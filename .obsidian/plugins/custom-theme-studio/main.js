/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/ace-builds/src-noconflict/ace.js
var require_ace = __commonJS({
  "node_modules/ace-builds/src-noconflict/ace.js"(exports, module2) {
    (function() {
      var ACE_NAMESPACE = "ace";
      var global2 = /* @__PURE__ */ function() {
        return this;
      }();
      if (!global2 && typeof window != "undefined") global2 = window;
      if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
        return;
      var define2 = function(module3, deps, payload) {
        if (typeof module3 !== "string") {
          if (define2.original)
            define2.original.apply(this, arguments);
          else {
            console.error("dropping module because define wasn't a string.");
            console.trace();
          }
          return;
        }
        if (arguments.length == 2)
          payload = deps;
        if (!define2.modules[module3]) {
          define2.payloads[module3] = payload;
          define2.modules[module3] = null;
        }
      };
      define2.modules = {};
      define2.payloads = {};
      var _require = function(parentId, module3, callback) {
        if (typeof module3 === "string") {
          var payload = lookup(parentId, module3);
          if (payload != void 0) {
            callback && callback();
            return payload;
          }
        } else if (Object.prototype.toString.call(module3) === "[object Array]") {
          var params = [];
          for (var i = 0, l = module3.length; i < l; ++i) {
            var dep = lookup(parentId, module3[i]);
            if (dep == void 0 && require3.original)
              return;
            params.push(dep);
          }
          return callback && callback.apply(null, params) || true;
        }
      };
      var require3 = function(module3, callback) {
        var packagedModule = _require("", module3, callback);
        if (packagedModule == void 0 && require3.original)
          return require3.original.apply(this, arguments);
        return packagedModule;
      };
      var normalizeModule = function(parentId, moduleName) {
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };
      var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module3 = define2.modules[moduleName];
        if (!module3) {
          module3 = define2.payloads[moduleName];
          if (typeof module3 === "function") {
            var exports2 = {};
            var mod = {
              id: moduleName,
              uri: "",
              exports: exports2,
              packaged: true
            };
            var req = function(module4, callback) {
              return _require(moduleName, module4, callback);
            };
            var returnValue = module3(req, exports2, mod);
            exports2 = returnValue || mod.exports;
            define2.modules[moduleName] = exports2;
            delete define2.payloads[moduleName];
          }
          module3 = define2.modules[moduleName] = exports2 || module3;
        }
        return module3;
      };
      function exportAce(ns2) {
        var root = global2;
        if (ns2) {
          if (!global2[ns2])
            global2[ns2] = {};
          root = global2[ns2];
        }
        if (!root.define || !root.define.packaged) {
          define2.original = root.define;
          root.define = define2;
          root.define.packaged = true;
        }
        if (!root.require || !root.require.packaged) {
          require3.original = root.require;
          root.require = require3;
          root.require.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(require3, exports2, module3) {
      function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
          value: val,
          enumerable: false,
          writable: true,
          configurable: true
        });
      }
      if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position) {
          position = position || 0;
          return this.lastIndexOf(searchString, position) === position;
        });
      }
      if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position) {
          var subjectString = this;
          if (position === void 0 || position > subjectString.length) {
            position = subjectString.length;
          }
          position -= searchString.length;
          var lastIndex = subjectString.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        });
      }
      if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
          var result = "";
          var string = this;
          while (count > 0) {
            if (count & 1)
              result += string;
            if (count >>= 1)
              string += string;
          }
          return result;
        });
      }
      if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position) {
          return this.indexOf(str, position) != -1;
        });
      }
      if (!Object.assign) {
        Object.assign = function(target) {
          if (target === void 0 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== void 0 && source !== null) {
              Object.keys(source).forEach(function(key) {
                output[key] = source[key];
              });
            }
          }
          return output;
        };
      }
      if (!Object.values) {
        Object.values = function(o) {
          return Object.keys(o).map(function(k2) {
            return o[k2];
          });
        };
      }
      if (!Array.prototype.find) {
        defineProp(Array.prototype, "find", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k2 = 0; k2 < len; k2++) {
            var kValue = this[k2];
            if (predicate.call(thisArg, kValue, k2, this)) {
              return kValue;
            }
          }
        });
      }
      if (!Array.prototype.findIndex) {
        defineProp(Array.prototype, "findIndex", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k2 = 0; k2 < len; k2++) {
            var kValue = this[k2];
            if (predicate.call(thisArg, kValue, k2, this)) {
              return k2;
            }
          }
        });
      }
      if (!Array.prototype.includes) {
        defineProp(Array.prototype, "includes", function(item, position) {
          return this.indexOf(item, position) != -1;
        });
      }
      if (!Array.prototype.fill) {
        defineProp(Array.prototype, "fill", function(value) {
          var O2 = this;
          var len = O2.length >>> 0;
          var start = arguments[1];
          var relativeStart = start >> 0;
          var k2 = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
          var end = arguments[2];
          var relativeEnd = end === void 0 ? len : end >> 0;
          var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
          while (k2 < final) {
            O2[k2] = value;
            k2++;
          }
          return O2;
        });
      }
      if (!Array.of) {
        defineProp(Array, "of", function() {
          return Array.prototype.slice.call(arguments);
        });
      }
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(require3, exports2, module3) {
      "use strict";
      require3("./es6-shim");
    });
    ace.define("ace/lib/deep_copy", ["require", "exports", "module"], function(require3, exports2, module3) {
      exports2.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
          return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]")
          return obj;
        copy = {};
        for (var key in obj)
          copy[key] = deepCopy(obj[key]);
        return copy;
      };
    });
    ace.define("ace/lib/lang", ["require", "exports", "module", "ace/lib/deep_copy"], function(require3, exports2, module3) {
      "use strict";
      exports2.last = function(a) {
        return a[a.length - 1];
      };
      exports2.stringReverse = function(string) {
        return string.split("").reverse().join("");
      };
      exports2.stringRepeat = function(string, count) {
        var result = "";
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports2.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, "");
      };
      exports2.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, "");
      };
      exports2.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports2.copyArray = function(array) {
        var copy = [];
        for (var i = 0, l = array.length; i < l; i++) {
          if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
          else
            copy[i] = array[i];
        }
        return copy;
      };
      exports2.deepCopy = require3("./deep_copy").deepCopy;
      exports2.arrayToMap = function(arr) {
        var map = {};
        for (var i = 0; i < arr.length; i++) {
          map[arr[i]] = 1;
        }
        return map;
      };
      exports2.createMap = function(props) {
        var map = /* @__PURE__ */ Object.create(null);
        for (var i in props) {
          map[i] = props[i];
        }
        return map;
      };
      exports2.arrayRemove = function(array, value) {
        for (var i = 0; i <= array.length; i++) {
          if (value === array[i]) {
            array.splice(i, 1);
          }
        }
      };
      exports2.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
      };
      exports2.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports2.getMatchOffsets = function(string, regExp) {
        var matches = [];
        string.replace(regExp, function(str) {
          matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches;
      };
      exports2.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var deferred = function(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function() {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function() {
          return timer;
        };
        return deferred;
      };
      exports2.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var _self = function(timeout) {
          if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
          this.cancel();
          fcn();
        };
        _self.cancel = function() {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function() {
          return timer;
        };
        return _self;
      };
      exports2.supportsLookbehind = function() {
        try {
          new RegExp("(?<=.)");
        } catch (e) {
          return false;
        }
        return true;
      };
      exports2.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
        return supportsUnicodeFlag && line.codePointAt(last) > 65535 ? 2 : 1;
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      exports2.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports2.getOS = function() {
        if (exports2.isMac) {
          return exports2.OS.MAC;
        } else if (exports2.isLinux) {
          return exports2.OS.LINUX;
        } else {
          return exports2.OS.WINDOWS;
        }
      };
      var _navigator = typeof navigator == "object" ? navigator : {};
      var os2 = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
      var ua = _navigator.userAgent || "";
      var appName = _navigator.appName || "";
      exports2.isWin = os2 == "win";
      exports2.isMac = os2 == "mac";
      exports2.isLinux = os2 == "linux";
      exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
      exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
      exports2.isGecko = exports2.isMozilla = ua.match(/ Gecko\/\d+/);
      exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";
      exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
      exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
      exports2.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports2.isChrome || void 0;
      exports2.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
      exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports2.isAndroid = ua.indexOf("Android") >= 0;
      exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
      exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];
      if (exports2.isIOS)
        exports2.isMac = true;
      exports2.isMobile = exports2.isIOS || exports2.isAndroid;
    });
    ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var useragent = require3("./useragent");
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports2.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
          var txt = document.createTextNode(arr);
          if (parent)
            parent.appendChild(txt);
          return txt;
        }
        if (!Array.isArray(arr)) {
          if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
          return arr;
        }
        if (typeof arr[0] != "string" || !arr[0]) {
          var els = [];
          for (var i = 0; i < arr.length; i++) {
            var ch = buildDom(arr[i], parent, refs);
            ch && els.push(ch);
          }
          return els;
        }
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options))
          childIndex = 2;
        for (var i = childIndex; i < arr.length; i++)
          buildDom(arr[i], el, refs);
        if (childIndex == 2) {
          Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
              el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
              el[n] = val;
            } else if (n === "ref") {
              if (refs)
                refs[val] = el;
            } else if (n === "style") {
              if (typeof val == "string")
                el.style.cssText = val;
            } else if (val != null) {
              el.setAttribute(n, val);
            }
          });
        }
        if (parent)
          parent.appendChild(el);
        return el;
      };
      exports2.getDocumentHead = function(doc) {
        if (!doc)
          doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports2.createElement = function(tag, ns2) {
        return document.createElementNS ? document.createElementNS(ns2 || XHTML_NS, tag) : document.createElement(tag);
      };
      exports2.removeChildren = function(element) {
        element.innerHTML = "";
      };
      exports2.createTextNode = function(textContent, element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createTextNode(textContent);
      };
      exports2.createFragment = function(element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createDocumentFragment();
      };
      exports2.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports2.addCssClass = function(el, name) {
        if (!exports2.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports2.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports2.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add)
          classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports2.setCssClass = function(node, className, include) {
        if (include) {
          exports2.addCssClass(node, className);
        } else {
          exports2.removeCssClass(node, className);
        }
      };
      exports2.hasCssString = function(id, doc) {
        var index = 0, sheets;
        doc = doc || document;
        if (sheets = doc.querySelectorAll("style")) {
          while (index < sheets.length) {
            if (sheets[index++].id === id) {
              return true;
            }
          }
        }
      };
      exports2.removeElementById = function(id, doc) {
        doc = doc || document;
        if (doc.getElementById(id)) {
          doc.getElementById(id).remove();
        }
      };
      var strictCSP;
      var cssCache = [];
      exports2.useStrictCSP = function(value) {
        strictCSP = value;
        if (value == false)
          insertPendingStyles();
        else if (!cssCache)
          cssCache = [];
      };
      function insertPendingStyles() {
        var cache = cssCache;
        cssCache = null;
        cache && cache.forEach(function(item) {
          importCssString(item[0], item[1]);
        });
      }
      function importCssString(cssText, id, target) {
        if (typeof document == "undefined")
          return;
        if (cssCache) {
          if (target) {
            insertPendingStyles();
          } else if (target === false) {
            return cssCache.push([cssText, id]);
          }
        }
        if (strictCSP)
          return;
        var container = target;
        if (!target || !target.getRootNode) {
          container = document;
        } else {
          container = target.getRootNode();
          if (!container || container == target)
            container = document;
        }
        var doc = container.ownerDocument || container;
        if (id && exports2.hasCssString(id, container))
          return null;
        if (id)
          cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        var style = exports2.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
          style.id = id;
        if (container == doc)
          container = exports2.getDocumentHead(doc);
        container.insertBefore(style, container.firstChild);
      }
      exports2.importCssString = importCssString;
      exports2.importCssStylsheet = function(uri, doc) {
        exports2.buildDom(["link", { rel: "stylesheet", href: uri }], exports2.getDocumentHead(doc));
      };
      exports2.scrollbarWidth = function(doc) {
        var inner = exports2.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports2.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = doc && doc.documentElement || document && document.documentElement;
        if (!body)
          return 0;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar === withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      exports2.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
      };
      exports2.setStyle = function(styles, property, value) {
        if (styles[property] !== value) {
          styles[property] = value;
        }
      };
      exports2.HAS_CSS_ANIMATION = false;
      exports2.HAS_CSS_TRANSFORMS = false;
      exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
      if (useragent.isChromeOS)
        exports2.HI_DPI = false;
      if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports2.HI_DPI && div.style.transform !== void 0)
          exports2.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
          exports2.HAS_CSS_ANIMATION = true;
        div = null;
      }
      if (exports2.HAS_CSS_TRANSFORMS) {
        exports2.translate = function(element, tx, ty) {
          element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
        };
      } else {
        exports2.translate = function(element, tx, ty) {
          element.style.top = Math.round(ty) + "px";
          element.style.left = Math.round(tx) + "px";
        };
      }
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("./dom");
      exports2.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports2.loadScript = function(path2, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement("script");
        s.src = path2;
        head.appendChild(s);
        s.onload = s.onreadystatechange = function(_2, isAbort) {
          if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
              callback();
          }
        };
      };
      exports2.qualifyURL = function(url) {
        var a = document.createElement("a");
        a.href = url;
        return a.href;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      exports2.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
      exports2.mixin = function(obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports2.implement = function(proto, mixin) {
        exports2.mixin(proto, mixin);
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var EventEmitter = {};
      var stopPropagation = function() {
        this.propagationStopped = true;
      };
      var preventDefault = function() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return;
        if (typeof e != "object" || !e)
          e = {};
        if (!e.type)
          e.type = eventName;
        if (!e.stopPropagation)
          e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
          e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](e, this);
          if (e.propagationStopped)
            break;
        }
        if (defaultHandler && !e.defaultPrevented)
          return defaultHandler(e, this);
      };
      EventEmitter._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
          return;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++)
          listeners[i](e, this);
      };
      EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.on(eventName, function newCallback() {
          _self.off(eventName, newCallback);
          callback.apply(null, arguments);
        });
        if (!callback) {
          return new Promise(function(resolve) {
            callback = resolve;
          });
        }
      };
      EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          handlers = this._defaultHandlers = { _disabled_: {} };
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
          listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;
        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function(eventName) {
        if (!eventName)
          this._eventRegistry = this._defaultHandlers = void 0;
        if (this._eventRegistry)
          this._eventRegistry[eventName] = void 0;
        if (this._defaultHandlers)
          this._defaultHandlers[eventName] = void 0;
      };
      exports2.EventEmitter = EventEmitter;
    });
    ace.define("ace/lib/report_error", ["require", "exports", "module"], function(require3, exports2, module3) {
      exports2.reportError = function reportError(msg, data) {
        var e = new Error(msg);
        e["data"] = data;
        if (typeof console == "object" && console.error)
          console.error(e);
        setTimeout(function() {
          throw e;
        });
      };
    });
    ace.define("ace/lib/default_english_messages", ["require", "exports", "module"], function(require3, exports2, module3) {
      var defaultEnglishMessages = {
        "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
        "autocomplete.popup.aria-label": "Autocomplete suggestions",
        "autocomplete.popup.item.aria-roledescription": "item",
        "autocomplete.loading": "Loading...",
        "editor.scroller.aria-roledescription": "editor",
        "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
        "editor.gutter.aria-roledescription": "editor gutter",
        "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
        "error-marker.good-state": "Looks good!",
        "prompt.recently-used": "Recently used",
        "prompt.other-commands": "Other commands",
        "prompt.no-matching-commands": "No matching commands",
        "search-box.find.placeholder": "Search for",
        "search-box.find-all.text": "All",
        "search-box.replace.placeholder": "Replace with",
        "search-box.replace-next.text": "Replace",
        "search-box.replace-all.text": "All",
        "search-box.toggle-replace.title": "Toggle Replace mode",
        "search-box.toggle-regexp.title": "RegExp Search",
        "search-box.toggle-case.title": "CaseSensitive Search",
        "search-box.toggle-whole-word.title": "Whole Word Search",
        "search-box.toggle-in-selection.title": "Search In Selection",
        "search-box.search-counter": "$0 of $1",
        "text-input.aria-roledescription": "editor",
        "text-input.aria-label": "Cursor at row $0",
        "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
        "gutter.code-folding.closed.title": "Unfold code",
        "gutter.code-folding.open.title": "Fold code",
        "gutter.annotation.aria-label.error": "Error, read annotations row $0",
        "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
        "gutter.annotation.aria-label.info": "Info, read annotations row $0",
        "inline-fold.closed.title": "Unfold code",
        "gutter-tooltip.aria-label.error.singular": "error",
        "gutter-tooltip.aria-label.error.plural": "errors",
        "gutter-tooltip.aria-label.warning.singular": "warning",
        "gutter-tooltip.aria-label.warning.plural": "warnings",
        "gutter-tooltip.aria-label.info.singular": "information message",
        "gutter-tooltip.aria-label.info.plural": "information messages",
        "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
        "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
        "gutter-tooltip.aria-label.security.singular": "security finding",
        "gutter-tooltip.aria-label.security.plural": "security findings",
        "gutter-tooltip.aria-label.hint.singular": "suggestion",
        "gutter-tooltip.aria-label.hint.plural": "suggestions",
        "editor.tooltip.disable-editing": "Editing is disabled"
      };
      exports2.defaultEnglishMessages = defaultEnglishMessages;
    });
    ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/report_error", "ace/lib/default_english_messages"], function(require3, exports2, module3) {
      "no use strict";
      var oop = require3("./oop");
      var EventEmitter = require3("./event_emitter").EventEmitter;
      var reportError = require3("./report_error").reportError;
      var defaultEnglishMessages = require3("./default_english_messages").defaultEnglishMessages;
      var optionsProvider = {
        setOptions: function(optList) {
          Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function(optionNames) {
          var result = {};
          if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
              return !options[key].hidden;
            });
          } else if (!Array.isArray(optionNames)) {
            optionNames = Object.keys(optionNames);
          }
          optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function(name, value) {
          if (this["$" + name] === value)
            return;
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet)
            this["$" + name] = value;
          if (opt && opt.set)
            opt.set.call(this, value);
        },
        getOption: function(name) {
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      function warn(message) {
        if (typeof console != "undefined" && console.warn)
          console.warn.apply(console, arguments);
      }
      var messages;
      var nlsPlaceholders;
      var AppConfig = (
        /** @class */
        function() {
          function AppConfig2() {
            this.$defaultOptions = {};
            messages = defaultEnglishMessages;
            nlsPlaceholders = "dollarSigns";
          }
          AppConfig2.prototype.defineOptions = function(obj, path2, options) {
            if (!obj.$options)
              this.$defaultOptions[path2] = obj.$options = {};
            Object.keys(options).forEach(function(key) {
              var opt = options[key];
              if (typeof opt == "string")
                opt = { forwardTo: opt };
              opt.name || (opt.name = key);
              obj.$options[opt.name] = opt;
              if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);
            return this;
          };
          AppConfig2.prototype.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
              var opt = obj.$options[key];
              if ("value" in opt)
                obj.setOption(key, opt.value);
            });
          };
          AppConfig2.prototype.setDefaultValue = function(path2, name, value) {
            if (!path2) {
              for (path2 in this.$defaultOptions)
                if (this.$defaultOptions[path2][name])
                  break;
              if (!this.$defaultOptions[path2][name])
                return false;
            }
            var opts = this.$defaultOptions[path2] || (this.$defaultOptions[path2] = {});
            if (opts[name]) {
              if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
              else
                opts[name].value = value;
            }
          };
          AppConfig2.prototype.setDefaultValues = function(path2, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
              this.setDefaultValue(path2, key, optionHash[key]);
            }, this);
          };
          AppConfig2.prototype.setMessages = function(value, options) {
            messages = value;
            if (options && options.placeholders) {
              nlsPlaceholders = options.placeholders;
            }
          };
          AppConfig2.prototype.nls = function(key, defaultString, params) {
            if (!messages[key]) {
              warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
              if (!messages[defaultString]) {
                warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
              }
            }
            var translated = messages[key] || messages[defaultString] || defaultString;
            if (params) {
              if (nlsPlaceholders === "dollarSigns") {
                translated = translated.replace(/\$(\$|[\d]+)/g, function(_2, dollarMatch) {
                  if (dollarMatch == "$")
                    return "$";
                  return params[dollarMatch];
                });
              }
              if (nlsPlaceholders === "curlyBrackets") {
                translated = translated.replace(/\{([^\}]+)\}/g, function(_2, curlyBracketMatch) {
                  return params[curlyBracketMatch];
                });
              }
            }
            return translated;
          };
          return AppConfig2;
        }()
      );
      AppConfig.prototype.warn = warn;
      AppConfig.prototype.reportError = reportError;
      oop.implement(AppConfig.prototype, EventEmitter);
      exports2.AppConfig = AppConfig;
    });
    ace.define("ace/theme/textmate-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate-css", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      exports2.isDark = false;
      exports2.cssClass = "ace-tm";
      exports2.cssText = require3("./textmate-css");
      exports2.$id = "ace/theme/textmate";
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config", "ace/theme/textmate"], function(require3, exports2, module3) {
      "no use strict";
      var lang = require3("./lib/lang");
      var net = require3("./lib/net");
      var dom = require3("./lib/dom");
      var AppConfig = require3("./lib/app_config").AppConfig;
      module3.exports = exports2 = new AppConfig();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false,
        useStrictCSP: null
      };
      exports2.get = function(key) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports2.set = function(key, value) {
        if (options.hasOwnProperty(key))
          options[key] = value;
        else if (this.setDefaultValue("", key, value) == false)
          throw new Error("Unknown config key: " + key);
        if (key == "useStrictCSP")
          dom.useStrictCSP(value);
      };
      exports2.all = function() {
        return lang.copyObject(options);
      };
      exports2.$modes = {};
      exports2.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
          return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re3 = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re3, "");
        }
        if ((!base || base == component) && parts.length > 1)
          base = parts[parts.length - 2];
        var path2 = options[component + "Path"];
        if (path2 == null) {
          path2 = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path2 && path2.slice(-1) != "/")
          path2 += "/";
        return path2 + component + sep + base + this.get("suffix");
      };
      exports2.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      var loader = function(moduleName, cb) {
        if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
          return cb(null, require3("./theme/textmate"));
        if (customLoader)
          return customLoader(moduleName, cb);
        console.error("loader is not configured");
      };
      var customLoader;
      exports2.setLoader = function(cb) {
        customLoader = cb;
      };
      exports2.dynamicModules = /* @__PURE__ */ Object.create(null);
      exports2.$loading = {};
      exports2.$loaded = {};
      exports2.loadModule = function(moduleId, onLoad) {
        var loadedModule;
        if (Array.isArray(moduleId)) {
          var moduleType = moduleId[0];
          var moduleName = moduleId[1];
        } else if (typeof moduleId == "string") {
          var moduleName = moduleId;
        }
        var load = function(module4) {
          if (module4 && !exports2.$loading[moduleName])
            return onLoad && onLoad(module4);
          if (!exports2.$loading[moduleName])
            exports2.$loading[moduleName] = [];
          exports2.$loading[moduleName].push(onLoad);
          if (exports2.$loading[moduleName].length > 1)
            return;
          var afterLoad = function() {
            loader(moduleName, function(err, module5) {
              if (module5)
                exports2.$loaded[moduleName] = module5;
              exports2._emit("load.module", { name: moduleName, module: module5 });
              var listeners = exports2.$loading[moduleName];
              exports2.$loading[moduleName] = null;
              listeners.forEach(function(onLoad2) {
                onLoad2 && onLoad2(module5);
              });
            });
          };
          if (!exports2.get("packaged"))
            return afterLoad();
          net.loadScript(exports2.moduleUrl(moduleName, moduleType), afterLoad);
          reportErrorIfPathIsNotConfigured();
        };
        if (exports2.dynamicModules[moduleName]) {
          exports2.dynamicModules[moduleName]().then(function(module4) {
            if (module4.default) {
              load(module4.default);
            } else {
              load(module4);
            }
          });
        } else {
          try {
            loadedModule = this.$require(moduleName);
          } catch (e) {
          }
          load(loadedModule || exports2.$loaded[moduleName]);
        }
      };
      exports2.$require = function(moduleName) {
        if (typeof module3["require"] == "function") {
          var req = "require";
          return module3[req](moduleName);
        }
      };
      exports2.setModuleLoader = function(moduleName, onLoad) {
        exports2.dynamicModules[moduleName] = onLoad;
      };
      var reportErrorIfPathIsNotConfigured = function() {
        if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
          console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
          reportErrorIfPathIsNotConfigured = function() {
          };
        }
      };
      exports2.version = "1.43.2";
    });
    ace.define("ace/loader_build", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      require3("./lib/fixoldbrowsers");
      var config = require3("./config");
      config.setLoader(function(moduleName, cb) {
        require3([moduleName], function(module4) {
          cb(null, module4);
        });
      });
      var global2 = /* @__PURE__ */ function() {
        return this || typeof window != "undefined" && window;
      }();
      module3.exports = function(ace4) {
        config.init = init;
        config.$require = require3;
        ace4.require = require3;
        if (typeof define === "function")
          ace4.define = define;
      };
      init(true);
      function init(packaged) {
        if (!global2 || !global2.document)
          return;
        config.set("packaged", packaged || require3.packaged || module3.packaged || global2.define && define.packaged);
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = document.currentScript || document._currentScript;
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        if (currentScript && currentScript.src) {
          scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
        }
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
          var script = scripts[i];
          var src = script.src || script.getAttribute("src");
          if (!src)
            continue;
          var attributes = script.attributes;
          for (var j3 = 0, l = attributes.length; j3 < l; j3++) {
            var attr = attributes[j3];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
          if (m)
            scriptUrl = m[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions)
          if (typeof scriptOptions[key] !== "undefined")
            config.set(key, scriptOptions[key]);
      }
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) {
          return m1.toUpperCase();
        });
      }
    });
    ace.define("ace/range", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var Range = (
        /** @class */
        function() {
          function Range2(startRow, startColumn, endRow, endColumn) {
            this.start = {
              row: startRow,
              column: startColumn
            };
            this.end = {
              row: endRow,
              column: endColumn
            };
          }
          Range2.prototype.isEqual = function(range) {
            return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
          };
          Range2.prototype.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
          };
          Range2.prototype.contains = function(row, column) {
            return this.compare(row, column) == 0;
          };
          Range2.prototype.compareRange = function(range) {
            var cmp, end = range.end, start = range.start;
            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
              cmp = this.compare(start.row, start.column);
              if (cmp == 1) {
                return 2;
              } else if (cmp == 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (cmp == -1) {
              return -2;
            } else {
              cmp = this.compare(start.row, start.column);
              if (cmp == -1) {
                return -1;
              } else if (cmp == 1) {
                return 42;
              } else {
                return 0;
              }
            }
          };
          Range2.prototype.comparePoint = function(p) {
            return this.compare(p.row, p.column);
          };
          Range2.prototype.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
          };
          Range2.prototype.intersects = function(range) {
            var cmp = this.compareRange(range);
            return cmp == -1 || cmp == 0 || cmp == 1;
          };
          Range2.prototype.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
          };
          Range2.prototype.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
          };
          Range2.prototype.setStart = function(row, column) {
            if (typeof row == "object") {
              this.start.column = row.column;
              this.start.row = row.row;
            } else {
              this.start.row = row;
              this.start.column = column;
            }
          };
          Range2.prototype.setEnd = function(row, column) {
            if (typeof row == "object") {
              this.end.column = row.column;
              this.end.row = row.row;
            } else {
              this.end.row = row;
              this.end.column = column;
            }
          };
          Range2.prototype.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.compare = function(row, column) {
            if (!this.isMultiLine()) {
              if (row === this.start.row) {
                return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
              }
            }
            if (row < this.start.row)
              return -1;
            if (row > this.end.row)
              return 1;
            if (this.start.row === row)
              return column >= this.start.column ? 0 : -1;
            if (this.end.row === row)
              return column <= this.end.column ? 0 : 1;
            return 0;
          };
          Range2.prototype.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
              var end = { row: lastRow + 1, column: 0 };
            else if (this.end.row < firstRow)
              var end = { row: firstRow, column: 0 };
            if (this.start.row > lastRow)
              var start = { row: lastRow + 1, column: 0 };
            else if (this.start.row < firstRow)
              var start = { row: firstRow, column: 0 };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.extend = function(row, column) {
            var cmp = this.compare(row, column);
            if (cmp == 0)
              return this;
            else if (cmp == -1)
              var start = { row, column };
            else
              var end = { row, column };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
          };
          Range2.prototype.isMultiLine = function() {
            return this.start.row !== this.end.row;
          };
          Range2.prototype.clone = function() {
            return Range2.fromPoints(this.start, this.end);
          };
          Range2.prototype.collapseRows = function() {
            if (this.end.column == 0)
              return new Range2(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
            else
              return new Range2(this.start.row, 0, this.end.row, 0);
          };
          Range2.prototype.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);
            return new Range2(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
          };
          Range2.prototype.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
          };
          return Range2;
        }()
      );
      Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports2.Range = Range;
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./oop");
      var Keys = {
        MODIFIER_KEYS: {
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          224: "Meta",
          91: "MetaLeft",
          92: "MetaRight",
          93: "ContextMenu"
        },
        KEY_MODS: {
          "ctrl": 1,
          "alt": 2,
          "option": 2,
          "shift": 4,
          "super": 8,
          "meta": 8,
          "command": 8,
          "cmd": 8,
          "control": 1
        },
        FUNCTION_KEYS: {
          8: "Backspace",
          9: "Tab",
          13: "Return",
          19: "Pause",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "Print",
          45: "Insert",
          46: "Delete",
          "-13": "NumpadEnter",
          144: "Numlock",
          145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
          32: " ",
          59: ";",
          61: "=",
          107: "+",
          109: "-",
          110: ".",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          111: "/",
          106: "*"
        }
      };
      var codeToKeyCode = {
        Command: 224,
        Backspace: 8,
        Tab: 9,
        Return: 13,
        Enter: 13,
        Pause: 19,
        Escape: 27,
        PageUp: 33,
        PageDown: 34,
        End: 35,
        Home: 36,
        Insert: 45,
        Delete: 46,
        ArrowLeft: 37,
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        Backquote: 192,
        Minus: 189,
        Equal: 187,
        BracketLeft: 219,
        Backslash: 220,
        BracketRight: 221,
        Semicolon: 186,
        Quote: 222,
        Comma: 188,
        Period: 190,
        Slash: 191,
        Space: 32,
        NumpadAdd: 107,
        NumpadDecimal: 110,
        NumpadSubtract: 109,
        NumpadDivide: 111,
        NumpadMultiply: 106
      };
      for (var i = 0; i < 10; i++) {
        codeToKeyCode["Digit" + i] = 48 + i;
        codeToKeyCode["Numpad" + i] = 96 + i;
        Keys.PRINTABLE_KEYS[48 + i] = "" + i;
        Keys.FUNCTION_KEYS[96 + i] = "Numpad" + i;
      }
      for (var i = 65; i < 91; i++) {
        var chr = String.fromCharCode(i + 32);
        codeToKeyCode["Key" + chr.toUpperCase()] = i;
        Keys.PRINTABLE_KEYS[i] = chr;
      }
      for (var i = 1; i < 13; i++) {
        codeToKeyCode["F" + i] = 111 + i;
        Keys.FUNCTION_KEYS[111 + i] = "F" + i;
      }
      var modifiers = {
        Shift: 16,
        Control: 17,
        Alt: 18,
        Meta: 224
      };
      for (var mod in modifiers) {
        codeToKeyCode[mod] = codeToKeyCode[mod + "Left"] = codeToKeyCode[mod + "Right"] = modifiers[mod];
      }
      exports2.$codeToKeyCode = codeToKeyCode;
      Keys.PRINTABLE_KEYS[173] = "-";
      for (var j3 in Keys.FUNCTION_KEYS) {
        var name = Keys.FUNCTION_KEYS[j3].toLowerCase();
        Keys[name] = parseInt(j3, 10);
      }
      for (var j3 in Keys.PRINTABLE_KEYS) {
        var name = Keys.PRINTABLE_KEYS[j3].toLowerCase();
        Keys[name] = parseInt(j3, 10);
      }
      oop.mixin(Keys, Keys.MODIFIER_KEYS);
      oop.mixin(Keys, Keys.PRINTABLE_KEYS);
      oop.mixin(Keys, Keys.FUNCTION_KEYS);
      Keys.enter = Keys["return"];
      Keys.escape = Keys.esc;
      Keys.del = Keys["delete"];
      (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i2 = Math.pow(2, mods.length); i2--; ) {
          Keys.KEY_MODS[i2] = mods.filter(function(x) {
            return i2 & Keys.KEY_MODS[x];
          }).join("-") + "-";
        }
      })();
      Keys.KEY_MODS[0] = "";
      Keys.KEY_MODS[-1] = "input-";
      oop.mixin(exports2, Keys);
      exports2.default = exports2;
      exports2.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
          keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var keys = require3("./keys");
      var useragent = require3("./useragent");
      var pressedKeys = null;
      var ts2 = 0;
      var activeListenerOptions;
      function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
          document.createComment("").addEventListener("test", function() {
          }, {
            get passive() {
              activeListenerOptions = { passive: false };
              return true;
            }
          });
        } catch (e) {
        }
      }
      function getListenerOptions() {
        if (activeListenerOptions == void 0)
          detectListenerOptionsSupport();
        return activeListenerOptions;
      }
      function EventListener(elem, type, callback) {
        this.elem = elem;
        this.type = type;
        this.callback = callback;
      }
      EventListener.prototype.destroy = function() {
        removeListener(this.elem, this.type, this.callback);
        this.elem = this.type = this.callback = void 0;
      };
      var addListener = exports2.addListener = function(elem, type, callback, destroyer) {
        elem.addEventListener(type, callback, getListenerOptions());
        if (destroyer)
          destroyer.$toDestroy.push(new EventListener(elem, type, callback));
      };
      var removeListener = exports2.removeListener = function(elem, type, callback) {
        elem.removeEventListener(type, callback, getListenerOptions());
      };
      exports2.stopEvent = function(e) {
        exports2.stopPropagation(e);
        exports2.preventDefault(e);
        return false;
      };
      exports2.stopPropagation = function(e) {
        if (e.stopPropagation)
          e.stopPropagation();
      };
      exports2.preventDefault = function(e) {
        if (e.preventDefault)
          e.preventDefault();
      };
      exports2.getButton = function(e) {
        if (e.type == "dblclick")
          return 0;
        if (e.type == "contextmenu" || useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey))
          return 2;
        return e.button;
      };
      exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
        var ownerDocument = el && el.ownerDocument || document;
        function onMouseUp(e) {
          eventHandler && eventHandler(e);
          releaseCaptureHandler && releaseCaptureHandler(e);
          removeListener(ownerDocument, "mousemove", eventHandler);
          removeListener(ownerDocument, "mouseup", onMouseUp);
          removeListener(ownerDocument, "dragstart", onMouseUp);
        }
        addListener(ownerDocument, "mousemove", eventHandler);
        addListener(ownerDocument, "mouseup", onMouseUp);
        addListener(ownerDocument, "dragstart", onMouseUp);
        return onMouseUp;
      };
      exports2.addMouseWheelListener = function(el, callback, destroyer) {
        addListener(el, "wheel", function(e) {
          var factor = 0.15;
          var deltaX = e.deltaX || 0;
          var deltaY = e.deltaY || 0;
          switch (e.deltaMode) {
            case e.DOM_DELTA_PIXEL:
              e.wheelX = deltaX * factor;
              e.wheelY = deltaY * factor;
              break;
            case e.DOM_DELTA_LINE:
              var linePixels = 15;
              e.wheelX = deltaX * linePixels;
              e.wheelY = deltaY * linePixels;
              break;
            case e.DOM_DELTA_PAGE:
              var pagePixels = 150;
              e.wheelX = deltaX * pagePixels;
              e.wheelY = deltaY * pagePixels;
              break;
          }
          callback(e);
        }, destroyer);
      };
      exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        function onMousedown(e) {
          if (exports2.getButton(e) !== 0) {
            clicks = 0;
          } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
              clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
              clicks = 1;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e.clientX;
              startY = e.clientY;
            }
          }
          e._clicks = clicks;
          eventHandler[callbackName]("mousedown", e);
          if (clicks > 4)
            clicks = 0;
          else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
        }
        if (!Array.isArray(elements))
          elements = [elements];
        elements.forEach(function(el) {
          addListener(el, "mousedown", onMousedown, destroyer);
        });
      };
      function getModifierHash(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
      }
      exports2.getModifierString = function(e) {
        return keys.KEY_MODS[getModifierHash(e)];
      };
      function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);
        if (!keyCode && e.code) {
          keyCode = keys.$codeToKeyCode[e.code] || keyCode;
        }
        if (!useragent.isMac && pressedKeys) {
          if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
            hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
              pressedKeys.altGr = 0;
            else
              return;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location2 = e.location;
            if (keyCode === 17 && location2 === 1) {
              if (pressedKeys[keyCode] == 1)
                ts2 = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location2 === 2) {
              var dt2 = e.timeStamp - ts2;
              if (dt2 < 50)
                pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          if (e.location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
              return;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e, hashId, keyCode);
          if (e.defaultPrevented)
            return;
          else
            hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e, hashId, keyCode);
      }
      exports2.addCommandKeyListener = function(el, callback, destroyer) {
        var lastDefaultPrevented = null;
        addListener(el, "keydown", function(e) {
          pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
          var result = normalizeCommandKeys(callback, e, e.keyCode);
          lastDefaultPrevented = e.defaultPrevented;
          return result;
        }, destroyer);
        addListener(el, "keypress", function(e) {
          if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
            exports2.stopEvent(e);
            lastDefaultPrevented = null;
          }
        }, destroyer);
        addListener(el, "keyup", function(e) {
          pressedKeys[e.keyCode] = null;
        }, destroyer);
        if (!pressedKeys) {
          resetPressedKeys();
          addListener(window, "focus", resetPressedKeys);
        }
      };
      function resetPressedKeys() {
        pressedKeys = /* @__PURE__ */ Object.create(null);
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports2.nextTick = function(callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId++;
          var listener = function(e) {
            if (e.data == messageName) {
              exports2.stopPropagation(e);
              removeListener(win, "message", listener);
              callback();
            }
          };
          addListener(win, "message", listener);
          win.postMessage(messageName, "*");
        };
      }
      exports2.$idleBlocked = false;
      exports2.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
          if (!exports2.$idleBlocked) {
            cb();
          } else {
            setTimeout(handler, 100);
          }
        }, timeout);
      };
      exports2.$idleBlockId = null;
      exports2.blockIdle = function(delay) {
        if (exports2.$idleBlockId)
          clearTimeout(exports2.$idleBlockId);
        exports2.$idleBlocked = true;
        exports2.$idleBlockId = setTimeout(function() {
          exports2.$idleBlocked = false;
        }, delay || 100);
      };
      exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window["mozRequestAnimationFrame"] || window["webkitRequestAnimationFrame"] || window["msRequestAnimationFrame"] || window["oRequestAnimationFrame"]);
      if (exports2.nextFrame)
        exports2.nextFrame = exports2.nextFrame.bind(window);
      else
        exports2.nextFrame = function(callback) {
          setTimeout(callback, 17);
        };
    });
    ace.define("ace/clipboard", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var $cancelT;
      module3.exports = {
        lineMode: false,
        pasteCancelled: function() {
          if ($cancelT && $cancelT > Date.now() - 50)
            return true;
          return $cancelT = false;
        },
        cancel: function() {
          $cancelT = Date.now();
        }
      };
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/config", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(require3, exports2, module3) {
      "use strict";
      var event = require3("../lib/event");
      var nls = require3("../config").nls;
      var useragent = require3("../lib/useragent");
      var dom = require3("../lib/dom");
      var lang = require3("../lib/lang");
      var clipboard = require3("../clipboard");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var HAS_FOCUS_ARGS = useragent.isChrome > 63;
      var MAX_LINE_LENGTH = 400;
      var KEYS = require3("../lib/keys");
      var MODS = KEYS.KEY_MODS;
      var isIOS = useragent.isIOS;
      var valueResetRegex = isIOS ? /\s/ : /\n/;
      var isMobile = useragent.isMobile;
      var TextInput = (
        /** @class */
        function() {
          function TextInput2(parentNode, host) {
            var _this = this;
            this.host = host;
            this.text = dom.createElement("textarea");
            this.text.className = "ace_text-input";
            this.text.setAttribute("wrap", "off");
            this.text.setAttribute("autocorrect", "off");
            this.text.setAttribute("autocapitalize", "off");
            this.text.setAttribute("spellcheck", "false");
            this.text.style.opacity = "0";
            parentNode.insertBefore(this.text, parentNode.firstChild);
            this.copied = false;
            this.pasted = false;
            this.inComposition = false;
            this.sendingText = false;
            this.tempStyle = "";
            if (!isMobile)
              this.text.style.fontSize = "1px";
            this.commandMode = false;
            this.ignoreFocusEvents = false;
            this.lastValue = "";
            this.lastSelectionStart = 0;
            this.lastSelectionEnd = 0;
            this.lastRestoreEnd = 0;
            this.rowStart = Number.MAX_SAFE_INTEGER;
            this.rowEnd = Number.MIN_SAFE_INTEGER;
            this.numberOfExtraLines = 0;
            try {
              this.$isFocused = document.activeElement === this.text;
            } catch (e) {
            }
            this.cancelComposition = this.cancelComposition.bind(this);
            this.setAriaOptions({ role: "textbox" });
            event.addListener(this.text, "blur", function(e) {
              if (_this.ignoreFocusEvents)
                return;
              host.onBlur(e);
              _this.$isFocused = false;
            }, host);
            event.addListener(this.text, "focus", function(e) {
              if (_this.ignoreFocusEvents)
                return;
              _this.$isFocused = true;
              if (useragent.isEdge) {
                try {
                  if (!document.hasFocus())
                    return;
                } catch (e2) {
                }
              }
              host.onFocus(e);
              if (useragent.isEdge)
                setTimeout(_this.resetSelection.bind(_this));
              else
                _this.resetSelection();
            }, host);
            this.$focusScroll = false;
            host.on("beforeEndOperation", function() {
              var curOp = host.curOp;
              var commandName = curOp && curOp.command && curOp.command.name;
              if (commandName == "insertstring")
                return;
              var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
              if (_this.inComposition && isUserAction) {
                _this.lastValue = _this.text.value = "";
                _this.onCompositionEnd();
              }
              _this.resetSelection();
            });
            host.on("changeSelection", this.setAriaLabel.bind(this));
            this.resetSelection = isIOS ? this.$resetSelectionIOS : this.$resetSelection;
            if (this.$isFocused)
              host.onFocus();
            this.inputHandler = null;
            this.afterContextMenu = false;
            event.addCommandKeyListener(this.text, function(e, hashId, keyCode) {
              if (_this.inComposition)
                return;
              return host.onCommandKey(e, hashId, keyCode);
            }, host);
            event.addListener(this.text, "select", this.onSelect.bind(this), host);
            event.addListener(this.text, "input", this.onInput.bind(this), host);
            event.addListener(this.text, "cut", this.onCut.bind(this), host);
            event.addListener(this.text, "copy", this.onCopy.bind(this), host);
            event.addListener(this.text, "paste", this.onPaste.bind(this), host);
            if (!("oncut" in this.text) || !("oncopy" in this.text) || !("onpaste" in this.text)) {
              event.addListener(parentNode, "keydown", function(e) {
                if (useragent.isMac && !e.metaKey || !e.ctrlKey)
                  return;
                switch (e.keyCode) {
                  case 67:
                    _this.onCopy(e);
                    break;
                  case 86:
                    _this.onPaste(e);
                    break;
                  case 88:
                    _this.onCut(e);
                    break;
                }
              }, host);
            }
            this.syncComposition = lang.delayedCall(this.onCompositionUpdate.bind(this), 50).schedule.bind(null, null);
            event.addListener(this.text, "compositionstart", this.onCompositionStart.bind(this), host);
            event.addListener(this.text, "compositionupdate", this.onCompositionUpdate.bind(this), host);
            event.addListener(this.text, "keyup", this.onKeyup.bind(this), host);
            event.addListener(this.text, "keydown", this.syncComposition.bind(this), host);
            event.addListener(this.text, "compositionend", this.onCompositionEnd.bind(this), host);
            this.closeTimeout;
            event.addListener(this.text, "mouseup", this.$onContextMenu.bind(this), host);
            event.addListener(this.text, "mousedown", function(e) {
              e.preventDefault();
              _this.onContextMenuClose();
            }, host);
            event.addListener(host.renderer.scroller, "contextmenu", this.$onContextMenu.bind(this), host);
            event.addListener(this.text, "contextmenu", this.$onContextMenu.bind(this), host);
            if (isIOS)
              this.addIosSelectionHandler(parentNode, host, this.text);
          }
          TextInput2.prototype.addIosSelectionHandler = function(parentNode, host, text) {
            var _this = this;
            var typingResetTimeout = null;
            var typing = false;
            text.addEventListener("keydown", function(e) {
              if (typingResetTimeout)
                clearTimeout(typingResetTimeout);
              typing = true;
            }, true);
            text.addEventListener("keyup", function(e) {
              typingResetTimeout = setTimeout(function() {
                typing = false;
              }, 100);
            }, true);
            var detectArrowKeys = function(e) {
              if (document.activeElement !== text)
                return;
              if (typing || _this.inComposition || host.$mouseHandler.isMousePressed)
                return;
              if (_this.copied) {
                return;
              }
              var selectionStart = text.selectionStart;
              var selectionEnd = text.selectionEnd;
              var key = null;
              var modifier = 0;
              if (selectionStart == 0) {
                key = KEYS.up;
              } else if (selectionStart == 1) {
                key = KEYS.home;
              } else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue[selectionEnd] == "\n") {
                key = KEYS.end;
              } else if (selectionStart < _this.lastSelectionStart && _this.lastValue[selectionStart - 1] == " ") {
                key = KEYS.left;
                modifier = MODS.option;
              } else if (selectionStart < _this.lastSelectionStart || selectionStart == _this.lastSelectionStart && _this.lastSelectionEnd != _this.lastSelectionStart && selectionStart == selectionEnd) {
                key = KEYS.left;
              } else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue.slice(0, selectionEnd).split("\n").length > 2) {
                key = KEYS.down;
              } else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue[selectionEnd - 1] == " ") {
                key = KEYS.right;
                modifier = MODS.option;
              } else if (selectionEnd > _this.lastSelectionEnd || selectionEnd == _this.lastSelectionEnd && _this.lastSelectionEnd != _this.lastSelectionStart && selectionStart == selectionEnd) {
                key = KEYS.right;
              }
              if (selectionStart !== selectionEnd)
                modifier |= MODS.shift;
              if (key) {
                var result = host.onCommandKey({}, modifier, key);
                if (!result && host.commands) {
                  key = KEYS.keyCodeToString(key);
                  var command = host.commands.findKeyCommand(modifier, key);
                  if (command)
                    host.execCommand(command);
                }
                _this.lastSelectionStart = selectionStart;
                _this.lastSelectionEnd = selectionEnd;
                _this.resetSelection("");
              }
            };
            document.addEventListener("selectionchange", detectArrowKeys);
            host.on("destroy", function() {
              document.removeEventListener("selectionchange", detectArrowKeys);
            });
          };
          TextInput2.prototype.onContextMenuClose = function() {
            var _this = this;
            clearTimeout(this.closeTimeout);
            this.closeTimeout = setTimeout(function() {
              if (_this.tempStyle) {
                _this.text.style.cssText = _this.tempStyle;
                _this.tempStyle = "";
              }
              _this.host.renderer.$isMousePressed = false;
              if (_this.host.renderer.$keepTextAreaAtCursor)
                _this.host.renderer.$moveTextAreaToCursor();
            }, 0);
          };
          TextInput2.prototype.$onContextMenu = function(e) {
            this.host.textInput.onContextMenu(e);
            this.onContextMenuClose();
          };
          TextInput2.prototype.onKeyup = function(e) {
            if (e.keyCode == 27 && this.text.value.length < this.text.selectionStart) {
              if (!this.inComposition)
                this.lastValue = this.text.value;
              this.lastSelectionStart = this.lastSelectionEnd = -1;
              this.resetSelection();
            }
            this.syncComposition();
          };
          TextInput2.prototype.cancelComposition = function() {
            this.ignoreFocusEvents = true;
            this.text.blur();
            this.text.focus();
            this.ignoreFocusEvents = false;
          };
          TextInput2.prototype.onCompositionStart = function(e) {
            if (this.inComposition || !this.host.onCompositionStart || this.host.$readOnly)
              return;
            this.inComposition = {};
            if (this.commandMode)
              return;
            if (e.data)
              this.inComposition.useTextareaForIME = false;
            setTimeout(this.onCompositionUpdate.bind(this), 0);
            this.host._signal("compositionStart");
            this.host.on("mousedown", this.cancelComposition);
            var range = this.host.getSelectionRange();
            range.end.row = range.start.row;
            range.end.column = range.start.column;
            this.inComposition.markerRange = range;
            this.inComposition.selectionStart = this.lastSelectionStart;
            this.host.onCompositionStart(this.inComposition);
            if (this.inComposition.useTextareaForIME) {
              this.lastValue = this.text.value = "";
              this.lastSelectionStart = 0;
              this.lastSelectionEnd = 0;
            } else {
              if (this.text.msGetInputContext)
                this.inComposition.context = this.text.msGetInputContext();
              if (this.text.getInputContext)
                this.inComposition.context = this.text.getInputContext();
            }
          };
          TextInput2.prototype.onCompositionUpdate = function() {
            if (!this.inComposition || !this.host.onCompositionUpdate || this.host.$readOnly)
              return;
            if (this.commandMode)
              return this.cancelComposition();
            if (this.inComposition.useTextareaForIME) {
              this.host.onCompositionUpdate(this.text.value);
            } else {
              var data = this.text.value;
              this.sendText(data);
              if (this.inComposition.markerRange) {
                if (this.inComposition.context) {
                  this.inComposition.markerRange.start.column = this.inComposition.selectionStart = this.inComposition.context.compositionStartOffset;
                }
                this.inComposition.markerRange.end.column = this.inComposition.markerRange.start.column + this.lastSelectionEnd - this.inComposition.selectionStart + this.lastRestoreEnd;
              }
            }
          };
          TextInput2.prototype.onCompositionEnd = function(e) {
            if (!this.host.onCompositionEnd || this.host.$readOnly)
              return;
            this.inComposition = false;
            this.host.onCompositionEnd();
            this.host.off("mousedown", this.cancelComposition);
            if (e)
              this.onInput();
          };
          TextInput2.prototype.onCut = function(e) {
            this.doCopy(e, true);
          };
          TextInput2.prototype.onCopy = function(e) {
            this.doCopy(e, false);
          };
          TextInput2.prototype.onPaste = function(e) {
            var data = this.handleClipboardData(e);
            if (clipboard.pasteCancelled())
              return;
            if (typeof data == "string") {
              if (data)
                this.host.onPaste(data, e);
              if (useragent.isIE)
                setTimeout(this.resetSelection);
              event.preventDefault(e);
            } else {
              this.text.value = "";
              this.pasted = true;
            }
          };
          TextInput2.prototype.doCopy = function(e, isCut) {
            var _this = this;
            var data = this.host.getCopyText();
            if (!data)
              return event.preventDefault(e);
            if (this.handleClipboardData(e, data)) {
              if (isIOS) {
                this.resetSelection(data);
                this.copied = data;
                setTimeout(function() {
                  _this.copied = false;
                }, 10);
              }
              isCut ? this.host.onCut() : this.host.onCopy();
              event.preventDefault(e);
            } else {
              this.copied = true;
              this.text.value = data;
              this.text.select();
              setTimeout(function() {
                _this.copied = false;
                _this.resetSelection();
                isCut ? _this.host.onCut() : _this.host.onCopy();
              });
            }
          };
          TextInput2.prototype.handleClipboardData = function(e, data, forceIEMime) {
            var clipboardData = e.clipboardData || window["clipboardData"];
            if (!clipboardData || BROKEN_SETDATA)
              return;
            var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
            try {
              if (data) {
                return clipboardData.setData(mime, data) !== false;
              } else {
                return clipboardData.getData(mime);
              }
            } catch (e2) {
              if (!forceIEMime)
                return this.handleClipboardData(e2, data, true);
            }
          };
          TextInput2.prototype.onInput = function(e) {
            if (this.inComposition)
              return this.onCompositionUpdate();
            if (e && e.inputType) {
              if (e.inputType == "historyUndo")
                return this.host.execCommand("undo");
              if (e.inputType == "historyRedo")
                return this.host.execCommand("redo");
            }
            var data = this.text.value;
            var inserted = this.sendText(data, true);
            if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && this.lastSelectionStart < 1 && this.lastSelectionStart == this.lastSelectionEnd) {
              this.resetSelection();
            }
          };
          TextInput2.prototype.sendText = function(value, fromInput) {
            if (this.afterContextMenu)
              this.afterContextMenu = false;
            if (this.pasted) {
              this.resetSelection();
              if (value)
                this.host.onPaste(value);
              this.pasted = false;
              return "";
            } else {
              var selectionStart = this.text.selectionStart;
              var selectionEnd = this.text.selectionEnd;
              var extendLeft = this.lastSelectionStart;
              var extendRight = this.lastValue.length - this.lastSelectionEnd;
              var inserted = value;
              var restoreStart = value.length - selectionStart;
              var restoreEnd = value.length - selectionEnd;
              var i = 0;
              while (extendLeft > 0 && this.lastValue[i] == value[i]) {
                i++;
                extendLeft--;
              }
              inserted = inserted.slice(i);
              i = 1;
              while (extendRight > 0 && this.lastValue.length - i > this.lastSelectionStart - 1 && this.lastValue[this.lastValue.length - i] == value[value.length - i]) {
                i++;
                extendRight--;
              }
              restoreStart -= i - 1;
              restoreEnd -= i - 1;
              var endIndex = inserted.length - i + 1;
              if (endIndex < 0) {
                extendLeft = -endIndex;
                endIndex = 0;
              }
              inserted = inserted.slice(0, endIndex);
              if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
                return "";
              this.sendingText = true;
              var shouldReset = false;
              if (useragent.isAndroid && inserted == ". ") {
                inserted = "  ";
                shouldReset = true;
              }
              if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || this.commandMode) {
                this.host.onTextInput(inserted);
              } else {
                this.host.onTextInput(inserted, {
                  extendLeft,
                  extendRight,
                  restoreStart,
                  restoreEnd
                });
              }
              this.sendingText = false;
              this.lastValue = value;
              this.lastSelectionStart = selectionStart;
              this.lastSelectionEnd = selectionEnd;
              this.lastRestoreEnd = restoreEnd;
              return shouldReset ? "\n" : inserted;
            }
          };
          TextInput2.prototype.onSelect = function(e) {
            var _this = this;
            if (this.inComposition)
              return;
            var isAllSelected = function(text) {
              return text.selectionStart === 0 && text.selectionEnd >= _this.lastValue.length && text.value === _this.lastValue && _this.lastValue && text.selectionEnd !== _this.lastSelectionEnd;
            };
            if (this.copied) {
              this.copied = false;
            } else if (isAllSelected(this.text)) {
              this.host.selectAll();
              this.resetSelection();
            } else if (isMobile && this.text.selectionStart != this.lastSelectionStart) {
              this.resetSelection();
            }
          };
          TextInput2.prototype.$resetSelectionIOS = function(value) {
            if (!this.$isFocused || this.copied && !value || this.sendingText)
              return;
            if (!value)
              value = "";
            var newValue = "\n ab" + value + "cde fg\n";
            if (newValue != this.text.value)
              this.text.value = this.lastValue = newValue;
            var selectionStart = 4;
            var selectionEnd = 4 + (value.length || (this.host.selection.isEmpty() ? 0 : 1));
            if (this.lastSelectionStart != selectionStart || this.lastSelectionEnd != selectionEnd) {
              this.text.setSelectionRange(selectionStart, selectionEnd);
            }
            this.lastSelectionStart = selectionStart;
            this.lastSelectionEnd = selectionEnd;
          };
          TextInput2.prototype.$resetSelection = function() {
            var _this = this;
            if (this.inComposition || this.sendingText)
              return;
            if (!this.$isFocused && !this.afterContextMenu)
              return;
            this.inComposition = true;
            var selectionStart = 0;
            var selectionEnd = 0;
            var line = "";
            var positionToSelection = function(row2, column) {
              var selection2 = column;
              for (var i2 = 1; i2 <= row2 - _this.rowStart && i2 < 2 * _this.numberOfExtraLines + 1; i2++) {
                selection2 += _this.host.session.getLine(row2 - i2).length + 1;
              }
              return selection2;
            };
            if (this.host.session) {
              var selection = this.host.selection;
              var range = selection.getRange();
              var row = selection.cursor.row;
              if (row === this.rowEnd + 1) {
                this.rowStart = this.rowEnd + 1;
                this.rowEnd = this.rowStart + 2 * this.numberOfExtraLines;
              } else if (row === this.rowStart - 1) {
                this.rowEnd = this.rowStart - 1;
                this.rowStart = this.rowEnd - 2 * this.numberOfExtraLines;
              } else if (row < this.rowStart - 1 || row > this.rowEnd + 1) {
                this.rowStart = row > this.numberOfExtraLines ? row - this.numberOfExtraLines : 0;
                this.rowEnd = row > this.numberOfExtraLines ? row + this.numberOfExtraLines : 2 * this.numberOfExtraLines;
              }
              var lines = [];
              for (var i = this.rowStart; i <= this.rowEnd; i++) {
                lines.push(this.host.session.getLine(i));
              }
              line = lines.join("\n");
              selectionStart = positionToSelection(range.start.row, range.start.column);
              selectionEnd = positionToSelection(range.end.row, range.end.column);
              if (range.start.row < this.rowStart) {
                var prevLine = this.host.session.getLine(this.rowStart - 1);
                selectionStart = range.start.row < this.rowStart - 1 ? 0 : selectionStart;
                selectionEnd += prevLine.length + 1;
                line = prevLine + "\n" + line;
              } else if (range.end.row > this.rowEnd) {
                var nextLine = this.host.session.getLine(this.rowEnd + 1);
                selectionEnd = range.end.row > this.rowEnd + 1 ? nextLine.length : range.end.column;
                selectionEnd += line.length + 1;
                line = line + "\n" + nextLine;
              } else if (isMobile && row > 0) {
                line = "\n" + line;
                selectionEnd += 1;
                selectionStart += 1;
              }
              if (line.length > MAX_LINE_LENGTH) {
                if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                  line = line.slice(0, MAX_LINE_LENGTH);
                } else {
                  line = "\n";
                  if (selectionStart == selectionEnd) {
                    selectionStart = selectionEnd = 0;
                  } else {
                    selectionStart = 0;
                    selectionEnd = 1;
                  }
                }
              }
              var newValue = line + "\n\n";
              if (newValue != this.lastValue) {
                this.text.value = this.lastValue = newValue;
                this.lastSelectionStart = this.lastSelectionEnd = newValue.length;
              }
            }
            if (this.afterContextMenu) {
              this.lastSelectionStart = this.text.selectionStart;
              this.lastSelectionEnd = this.text.selectionEnd;
            }
            if (this.lastSelectionEnd != selectionEnd || this.lastSelectionStart != selectionStart || this.text.selectionEnd != this.lastSelectionEnd) {
              try {
                this.text.setSelectionRange(selectionStart, selectionEnd);
                this.lastSelectionStart = selectionStart;
                this.lastSelectionEnd = selectionEnd;
              } catch (e) {
              }
            }
            this.inComposition = false;
          };
          TextInput2.prototype.setHost = function(newHost) {
            this.host = newHost;
          };
          TextInput2.prototype.setNumberOfExtraLines = function(number) {
            this.rowStart = Number.MAX_SAFE_INTEGER;
            this.rowEnd = Number.MIN_SAFE_INTEGER;
            if (number < 0) {
              this.numberOfExtraLines = 0;
              return;
            }
            this.numberOfExtraLines = number;
          };
          TextInput2.prototype.setAriaLabel = function() {
            var ariaLabel = "";
            if (this.host.$textInputAriaLabel) {
              ariaLabel += "".concat(this.host.$textInputAriaLabel, ", ");
            }
            if (this.host.session) {
              var row = this.host.session.selection.cursor.row;
              ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [row + 1]);
            }
            this.text.setAttribute("aria-label", ariaLabel);
          };
          TextInput2.prototype.setAriaOptions = function(options) {
            if (options.activeDescendant) {
              this.text.setAttribute("aria-haspopup", "true");
              this.text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
              this.text.setAttribute("aria-activedescendant", options.activeDescendant);
            } else {
              this.text.setAttribute("aria-haspopup", "false");
              this.text.setAttribute("aria-autocomplete", "both");
              this.text.removeAttribute("aria-activedescendant");
            }
            if (options.role) {
              this.text.setAttribute("role", options.role);
            }
            if (options.setLabel) {
              this.text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
              this.setAriaLabel();
            }
          };
          TextInput2.prototype.focus = function() {
            var _this = this;
            this.setAriaOptions({
              setLabel: this.host.renderer.enableKeyboardAccessibility
            });
            if (this.tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
              return this.text.focus({ preventScroll: true });
            var top = this.text.style.top;
            this.text.style.position = "fixed";
            this.text.style.top = "0px";
            try {
              var isTransformed = this.text.getBoundingClientRect().top != 0;
            } catch (e) {
              return;
            }
            var ancestors = [];
            if (isTransformed) {
              var t = this.text.parentElement;
              while (t && t.nodeType == 1) {
                ancestors.push(t);
                t.setAttribute("ace_nocontext", "true");
                if (!t.parentElement && t.getRootNode)
                  t = t.getRootNode()["host"];
                else
                  t = t.parentElement;
              }
            }
            this.text.focus({ preventScroll: true });
            if (isTransformed) {
              ancestors.forEach(function(p) {
                p.removeAttribute("ace_nocontext");
              });
            }
            setTimeout(function() {
              _this.text.style.position = "";
              if (_this.text.style.top == "0px")
                _this.text.style.top = top;
            }, 0);
          };
          TextInput2.prototype.blur = function() {
            this.text.blur();
          };
          TextInput2.prototype.isFocused = function() {
            return this.$isFocused;
          };
          TextInput2.prototype.setInputHandler = function(cb) {
            this.inputHandler = cb;
          };
          TextInput2.prototype.getInputHandler = function() {
            return this.inputHandler;
          };
          TextInput2.prototype.getElement = function() {
            return this.text;
          };
          TextInput2.prototype.setCommandMode = function(value) {
            this.commandMode = value;
            this.text.readOnly = false;
          };
          TextInput2.prototype.setReadOnly = function(readOnly) {
            if (!this.commandMode)
              this.text.readOnly = readOnly;
          };
          TextInput2.prototype.setCopyWithEmptySelection = function(value) {
          };
          TextInput2.prototype.onContextMenu = function(e) {
            this.afterContextMenu = true;
            this.resetSelection();
            this.host._emit("nativecontextmenu", {
              target: this.host,
              domEvent: e
            });
            this.moveToMouse(e, true);
          };
          TextInput2.prototype.moveToMouse = function(e, bringToFront) {
            var _this = this;
            if (!this.tempStyle)
              this.tempStyle = this.text.style.cssText;
            this.text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (this.lastSelectionStart + this.lastSelectionEnd) * this.host.renderer.characterWidth * 0.5 + "px;";
            var rect = this.host.container.getBoundingClientRect();
            var style = dom.computedStyle(this.host.container);
            var top = rect.top + (parseInt(style.borderTopWidth) || 0);
            var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
            var maxTop = rect.bottom - top - this.text.clientHeight - 2;
            var move = function(e2) {
              dom.translate(_this.text, e2.clientX - left - 2, Math.min(e2.clientY - top - 2, maxTop));
            };
            move(e);
            if (e.type != "mousedown")
              return;
            this.host.renderer.$isMousePressed = true;
            clearTimeout(this.closeTimeout);
            if (useragent.isWin)
              event.capture(this.host.container, move, this.onContextMenuClose.bind(this));
          };
          TextInput2.prototype.destroy = function() {
            if (this.text.parentElement)
              this.text.parentElement.removeChild(this.text);
          };
          return TextInput2;
        }()
      );
      exports2.TextInput = TextInput;
      exports2.$setUserAgentForTests = function(_isMobile, _isIOS) {
        isMobile = _isMobile;
        isIOS = _isIOS;
      };
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var useragent = require3("../lib/useragent");
      var DRAG_OFFSET = 0;
      var SCROLL_COOLDOWN_T = 550;
      var DefaultHandlers = (
        /** @class */
        function() {
          function DefaultHandlers2(mouseHandler) {
            mouseHandler.$clickSelection = null;
            var editor = mouseHandler.editor;
            editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
            editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
            editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
            editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
            editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
            var exports3 = [
              "select",
              "startSelect",
              "selectEnd",
              "selectAllEnd",
              "selectByWordsEnd",
              "selectByLinesEnd",
              "dragWait",
              "dragWaitEnd",
              "focusWait"
            ];
            exports3.forEach(function(x) {
              mouseHandler[x] = this[x];
            }, this);
            mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
            mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
          }
          DefaultHandlers2.prototype.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;
            var button = ev.getButton();
            if (button !== 0) {
              var selectionRange = editor.getSelectionRange();
              var selectionEmpty = selectionRange.isEmpty();
              if (selectionEmpty || button == 1)
                editor.selection.moveToPosition(pos);
              if (button == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                  ev.preventDefault();
              }
              return;
            }
            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
              editor.focus();
              if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
              }
            }
            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
          };
          DefaultHandlers2.prototype.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            if (!this.mousedownEvent)
              return;
            if (this.mousedownEvent.getShiftKey())
              editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
              editor.selection.moveToPosition(pos);
            if (!waitForClickSelection)
              this.select();
            editor.setStyle("ace_selecting");
            this.setState("select");
          };
          DefaultHandlers2.prototype.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
              var cmp = this.$clickSelection.comparePoint(cursor);
              if (cmp == -1) {
                anchor = this.$clickSelection.end;
              } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
              var cmpStart = this.$clickSelection.comparePoint(range.start);
              var cmpEnd = this.$clickSelection.comparePoint(range.end);
              if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                  cursor = range.start;
              } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                  cursor = range.end;
              } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
          };
          DefaultHandlers2.prototype.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();
            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
              this.startSelect(this.mousedownEvent.getDocumentPosition());
          };
          DefaultHandlers2.prototype.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;
            var range = session.getBracketRange(pos);
            if (range) {
              if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
              }
              this.setState("select");
            } else {
              range = editor.selection.getWordRange(pos.row, pos.column);
              this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
          };
          DefaultHandlers2.prototype.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
              this.$clickSelection = editor.selection.getLineRange(range.start.row);
              this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
              this.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            this.select();
          };
          DefaultHandlers2.prototype.onQuadClick = function(ev) {
            var editor = this.editor;
            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
          };
          DefaultHandlers2.prototype.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
              return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
              ev.wheelX = ev.wheelY;
              ev.wheelY = 0;
            }
            var editor = this.editor;
            if (!this.$lastScroll)
              this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            var prevScroll = this.$lastScroll;
            var t = ev.domEvent.timeStamp;
            var dt2 = t - prevScroll.t;
            var vx = dt2 ? ev.wheelX / dt2 : prevScroll.vx;
            var vy = dt2 ? ev.wheelY / dt2 : prevScroll.vy;
            if (dt2 < SCROLL_COOLDOWN_T) {
              vx = (vx + prevScroll.vx) / 2;
              vy = (vy + prevScroll.vy) / 2;
            }
            var direction = Math.abs(vx / vy);
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
              canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
              canScroll = true;
            if (canScroll) {
              prevScroll.allowed = t;
            } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
              var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
              if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t;
              } else {
                prevScroll.allowed = 0;
              }
            }
            prevScroll.t = t;
            prevScroll.vx = vx;
            prevScroll.vy = vy;
            if (canScroll) {
              editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
              return ev.stop();
            }
          };
          return DefaultHandlers2;
        }()
      );
      DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
      exports2.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
          var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
          var cmp = cursor.column - 4;
        else
          var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0)
          return { cursor: range.start, anchor: range.end };
        else
          return { cursor: range.end, anchor: range.start };
      }
    });
    ace.define("ace/lib/scroll", ["require", "exports", "module"], function(require3, exports2, module3) {
      exports2.preventParentScroll = function preventParentScroll(event) {
        event.stopPropagation();
        var target = event.currentTarget;
        var contentOverflows = target.scrollHeight > target.clientHeight;
        if (!contentOverflows) {
          event.preventDefault();
        }
      };
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/range", "ace/lib/scroll"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require3("./lib/dom");
      var event = require3("./lib/event");
      var Range = require3("./range").Range;
      var preventParentScroll = require3("./lib/scroll").preventParentScroll;
      var CLASSNAME = "ace_tooltip";
      var Tooltip = (
        /** @class */
        function() {
          function Tooltip2(parentNode) {
            this.isOpen = false;
            this.$element = null;
            this.$parentNode = parentNode;
          }
          Tooltip2.prototype.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = CLASSNAME;
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
          };
          Tooltip2.prototype.getElement = function() {
            return this.$element || this.$init();
          };
          Tooltip2.prototype.setText = function(text) {
            this.getElement().textContent = text;
          };
          Tooltip2.prototype.setHtml = function(html) {
            this.getElement().innerHTML = html;
          };
          Tooltip2.prototype.setPosition = function(x, y2) {
            this.getElement().style.left = x + "px";
            this.getElement().style.top = y2 + "px";
          };
          Tooltip2.prototype.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
          };
          Tooltip2.prototype.setTheme = function(theme) {
            this.$element.className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
          };
          Tooltip2.prototype.show = function(text, x, y2) {
            if (text != null)
              this.setText(text);
            if (x != null && y2 != null)
              this.setPosition(x, y2);
            if (!this.isOpen) {
              this.getElement().style.display = "block";
              this.isOpen = true;
            }
          };
          Tooltip2.prototype.hide = function(e) {
            if (this.isOpen) {
              this.getElement().style.display = "none";
              this.getElement().className = CLASSNAME;
              this.isOpen = false;
            }
          };
          Tooltip2.prototype.getHeight = function() {
            return this.getElement().offsetHeight;
          };
          Tooltip2.prototype.getWidth = function() {
            return this.getElement().offsetWidth;
          };
          Tooltip2.prototype.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
              this.$element.parentNode.removeChild(this.$element);
            }
          };
          return Tooltip2;
        }()
      );
      var PopupManager = (
        /** @class */
        function() {
          function PopupManager2() {
            this.popups = [];
          }
          PopupManager2.prototype.addPopup = function(popup) {
            this.popups.push(popup);
            this.updatePopups();
          };
          PopupManager2.prototype.removePopup = function(popup) {
            var index = this.popups.indexOf(popup);
            if (index !== -1) {
              this.popups.splice(index, 1);
              this.updatePopups();
            }
          };
          PopupManager2.prototype.updatePopups = function() {
            var e_1, _a2, e_2, _b;
            this.popups.sort(function(a, b2) {
              return b2.priority - a.priority;
            });
            var visiblepopups = [];
            try {
              for (var _c2 = __values(this.popups), _d = _c2.next(); !_d.done; _d = _c2.next()) {
                var popup = _d.value;
                var shouldDisplay = true;
                try {
                  for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {
                    var visiblePopup = visiblepopups_1_1.value;
                    if (this.doPopupsOverlap(visiblePopup, popup)) {
                      shouldDisplay = false;
                      break;
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
                if (shouldDisplay) {
                  visiblepopups.push(popup);
                } else {
                  popup.hide();
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_d && !_d.done && (_a2 = _c2.return)) _a2.call(_c2);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          };
          PopupManager2.prototype.doPopupsOverlap = function(popupA, popupB) {
            var rectA = popupA.getElement().getBoundingClientRect();
            var rectB = popupB.getElement().getBoundingClientRect();
            return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
          };
          return PopupManager2;
        }()
      );
      var popupManager = new PopupManager();
      exports2.popupManager = popupManager;
      exports2.Tooltip = Tooltip;
      var HoverTooltip = (
        /** @class */
        function(_super) {
          __extends(HoverTooltip2, _super);
          function HoverTooltip2(parentNode) {
            if (parentNode === void 0) {
              parentNode = document.body;
            }
            var _this = _super.call(this, parentNode) || this;
            _this.timeout = void 0;
            _this.lastT = 0;
            _this.idleTime = 350;
            _this.lastEvent = void 0;
            _this.onMouseOut = _this.onMouseOut.bind(_this);
            _this.onMouseMove = _this.onMouseMove.bind(_this);
            _this.waitForHover = _this.waitForHover.bind(_this);
            _this.hide = _this.hide.bind(_this);
            var el = _this.getElement();
            el.style.whiteSpace = "pre-wrap";
            el.style.pointerEvents = "auto";
            el.addEventListener("mouseout", _this.onMouseOut);
            el.tabIndex = -1;
            el.addEventListener("blur", function() {
              if (!el.contains(document.activeElement))
                this.hide();
            }.bind(_this));
            el.addEventListener("wheel", preventParentScroll);
            return _this;
          }
          HoverTooltip2.prototype.addToEditor = function(editor) {
            editor.on("mousemove", this.onMouseMove);
            editor.on("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
          };
          HoverTooltip2.prototype.removeFromEditor = function(editor) {
            editor.off("mousemove", this.onMouseMove);
            editor.off("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
          };
          HoverTooltip2.prototype.onMouseMove = function(e, editor) {
            this.lastEvent = e;
            this.lastT = Date.now();
            var isMousePressed = editor.$mouseHandler.isMousePressed;
            if (this.isOpen) {
              var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
              if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) {
                this.hide();
              }
            }
            if (this.timeout || isMousePressed)
              return;
            this.lastEvent = e;
            this.timeout = setTimeout(this.waitForHover, this.idleTime);
          };
          HoverTooltip2.prototype.waitForHover = function() {
            if (this.timeout)
              clearTimeout(this.timeout);
            var dt2 = Date.now() - this.lastT;
            if (this.idleTime - dt2 > 10) {
              this.timeout = setTimeout(this.waitForHover, this.idleTime - dt2);
              return;
            }
            this.timeout = null;
            if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
              this.$gatherData(this.lastEvent, this.lastEvent.editor);
            }
          };
          HoverTooltip2.prototype.isOutsideOfText = function(e) {
            var editor = e.editor;
            var docPos = e.getDocumentPosition();
            var line = editor.session.getLine(docPos.row);
            if (docPos.column == line.length) {
              var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
              var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
              if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) {
                return true;
              }
            }
            return false;
          };
          HoverTooltip2.prototype.setDataProvider = function(value) {
            this.$gatherData = value;
          };
          HoverTooltip2.prototype.showForRange = function(editor, range, domNode, startingEvent) {
            var MARGIN = 10;
            if (startingEvent && startingEvent != this.lastEvent)
              return;
            if (this.isOpen && document.activeElement == this.getElement())
              return;
            var renderer = editor.renderer;
            if (!this.isOpen) {
              popupManager.addPopup(this);
              this.$registerCloseEvents();
              this.setTheme(renderer.theme);
            }
            this.isOpen = true;
            this.addMarker(range, editor.session);
            this.range = Range.fromPoints(range.start, range.end);
            var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
            var rect = renderer.scroller.getBoundingClientRect();
            if (position.pageX < rect.left)
              position.pageX = rect.left;
            var element = this.getElement();
            element.innerHTML = "";
            element.appendChild(domNode);
            element.style.maxHeight = "";
            element.style.display = "block";
            var labelHeight = element.clientHeight;
            var labelWidth = element.clientWidth;
            var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
            var isAbove = true;
            if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
              isAbove = false;
            }
            element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
            element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
            element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
            element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
          };
          HoverTooltip2.prototype.addMarker = function(range, session) {
            if (this.marker) {
              this.$markerSession.removeMarker(this.marker);
            }
            this.$markerSession = session;
            this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
          };
          HoverTooltip2.prototype.hide = function(e) {
            if (!e && document.activeElement == this.getElement())
              return;
            if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target))
              return;
            this.lastEvent = null;
            if (this.timeout)
              clearTimeout(this.timeout);
            this.timeout = null;
            this.addMarker(null);
            if (this.isOpen) {
              this.$removeCloseEvents();
              this.getElement().style.display = "none";
              this.isOpen = false;
              popupManager.removePopup(this);
            }
          };
          HoverTooltip2.prototype.$registerCloseEvents = function() {
            window.addEventListener("keydown", this.hide, true);
            window.addEventListener("wheel", this.hide, true);
            window.addEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.$removeCloseEvents = function() {
            window.removeEventListener("keydown", this.hide, true);
            window.removeEventListener("wheel", this.hide, true);
            window.removeEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.onMouseOut = function(e) {
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
            this.lastEvent = null;
            if (!this.isOpen)
              return;
            if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))
              return;
            if (e && e.currentTarget.contains(e.relatedTarget))
              return;
            if (!e.relatedTarget.classList.contains("ace_content"))
              this.hide();
          };
          return HoverTooltip2;
        }(Tooltip)
      );
      exports2.HoverTooltip = HoverTooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/tooltip", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require3("../lib/dom");
      var event = require3("../lib/event");
      var Tooltip = require3("../tooltip").Tooltip;
      var nls = require3("../config").nls;
      var GUTTER_TOOLTIP_LEFT_OFFSET = 5;
      var GUTTER_TOOLTIP_TOP_OFFSET = 3;
      exports2.GUTTER_TOOLTIP_LEFT_OFFSET = GUTTER_TOOLTIP_LEFT_OFFSET;
      exports2.GUTTER_TOOLTIP_TOP_OFFSET = GUTTER_TOOLTIP_TOP_OFFSET;
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor, true);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
          if (!editor.isFocused() || e.getButton() != 0)
            return;
          var gutterRegion = gutter.getRegion(e);
          if (gutterRegion == "foldWidgets")
            return;
          var row = e.getDocumentPosition().row;
          var selection = editor.session.selection;
          if (e.getShiftKey())
            selection.selectTo(row, 0);
          else {
            if (e.domEvent.detail == 2) {
              editor.selectAll();
              return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e);
          return e.preventDefault();
        });
        var tooltipTimeout, mouseEvent;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var maxRow = editor.session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
              return hideTooltip();
          }
          tooltip.showTooltip(row);
          if (!tooltip.isOpen)
            return;
          editor.on("mousewheel", hideTooltip);
          editor.on("changeSession", hideTooltip);
          window.addEventListener("keydown", hideTooltip, true);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterRow = mouseEvent.getGutterRow();
            var gutterCell = gutter.$lines.get(gutterRow);
            if (gutterCell) {
              var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
              var rect = gutterElement.getBoundingClientRect();
              var style = tooltip.getElement().style;
              style.left = rect.right - GUTTER_TOOLTIP_LEFT_OFFSET + "px";
              style.top = rect.bottom - GUTTER_TOOLTIP_TOP_OFFSET + "px";
            } else {
              moveTooltip(mouseEvent);
            }
          }
        }
        function hideTooltip(e) {
          if (e && e.type === "keydown" && (e.ctrlKey || e.metaKey))
            return;
          if (e && e.type === "mouseout" && (!e.relatedTarget || tooltip.getElement().contains(e.relatedTarget)))
            return;
          if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltip.isOpen) {
            tooltip.hideTooltip();
            editor.off("mousewheel", hideTooltip);
            editor.off("changeSession", hideTooltip);
            window.removeEventListener("keydown", hideTooltip, true);
          }
        }
        function moveTooltip(e) {
          tooltip.setPosition(e.x, e.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
          var target = e.domEvent.target || e.domEvent.srcElement;
          if (dom.hasCssClass(target, "ace_fold-widget") || dom.hasCssClass(target, "ace_custom-widget"))
            return hideTooltip();
          if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);
          mouseEvent = e;
          if (tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
          }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
          mouseEvent = null;
          if (!tooltip.isOpen)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip(e);
          }, 50);
        }, editor);
      }
      exports2.GutterHandler = GutterHandler;
      var GutterTooltip = (
        /** @class */
        function(_super) {
          __extends(GutterTooltip2, _super);
          function GutterTooltip2(editor, isHover) {
            if (isHover === void 0) {
              isHover = false;
            }
            var _this = _super.call(this, editor.container) || this;
            _this.id = "gt" + ++GutterTooltip2.$uid;
            _this.editor = editor;
            _this.visibleTooltipRow;
            var el = _this.getElement();
            el.setAttribute("role", "tooltip");
            el.setAttribute("id", _this.id);
            el.style.pointerEvents = "auto";
            if (isHover) {
              _this.onMouseOut = _this.onMouseOut.bind(_this);
              el.addEventListener("mouseout", _this.onMouseOut);
            }
            return _this;
          }
          GutterTooltip2.prototype.onMouseOut = function(e) {
            if (!this.isOpen)
              return;
            if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))
              return;
            if (e && e.currentTarget.contains(e.relatedTarget))
              return;
            this.hideTooltip();
          };
          GutterTooltip2.prototype.setPosition = function(x, y2) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x += 15;
            y2 += 15;
            if (x + width > windowWidth) {
              x -= x + width - windowWidth;
            }
            if (y2 + height > windowHeight) {
              y2 -= 20 + height;
            }
            Tooltip.prototype.setPosition.call(this, x, y2);
          };
          Object.defineProperty(GutterTooltip2, "annotationLabels", {
            get: function() {
              return {
                error: {
                  singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
                  plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
                },
                security: {
                  singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
                  plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
                },
                warning: {
                  singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
                  plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
                },
                info: {
                  singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
                  plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
                },
                hint: {
                  singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                  plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
                }
              };
            },
            enumerable: false,
            configurable: true
          });
          GutterTooltip2.prototype.showTooltip = function(row) {
            var _a2;
            var gutter = this.editor.renderer.$gutterLayer;
            var annotationsInRow = gutter.$annotations[row];
            var annotation;
            if (annotationsInRow)
              annotation = {
                displayText: Array.from(annotationsInRow.displayText),
                type: Array.from(annotationsInRow.type)
              };
            else
              annotation = { displayText: [], type: [] };
            var fold = gutter.session.getFoldLine(row);
            if (fold && gutter.$showFoldedAnnotations) {
              var annotationsInFold = { error: [], security: [], warning: [], info: [], hint: [] };
              var severityRank = { error: 1, security: 2, warning: 3, info: 4, hint: 5 };
              var mostSevereAnnotationTypeInFold;
              for (var i = row + 1; i <= fold.end.row; i++) {
                if (!gutter.$annotations[i])
                  continue;
                for (var j3 = 0; j3 < gutter.$annotations[i].text.length; j3++) {
                  var annotationType = gutter.$annotations[i].type[j3];
                  annotationsInFold[annotationType].push(gutter.$annotations[i].text[j3]);
                  if (!mostSevereAnnotationTypeInFold || severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]) {
                    mostSevereAnnotationTypeInFold = annotationType;
                  }
                }
              }
              if (["error", "security", "warning"].includes(mostSevereAnnotationTypeInFold)) {
                var summaryFoldedAnnotations = "".concat(GutterTooltip2.annotationsToSummaryString(annotationsInFold), " in folded code.");
                annotation.displayText.push(summaryFoldedAnnotations);
                annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
              }
            }
            if (annotation.displayText.length === 0)
              return this.hideTooltip();
            var annotationMessages = { error: [], security: [], warning: [], info: [], hint: [] };
            var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            for (var i = 0; i < annotation.displayText.length; i++) {
              var lineElement = dom.createElement("span");
              var iconElement = dom.createElement("span");
              (_a2 = iconElement.classList).add.apply(_a2, ["ace_".concat(annotation.type[i]), iconClassName]);
              iconElement.setAttribute("aria-label", "".concat(GutterTooltip2.annotationLabels[annotation.type[i].replace("_fold", "")].singular));
              iconElement.setAttribute("role", "img");
              iconElement.appendChild(dom.createTextNode(" "));
              lineElement.appendChild(iconElement);
              lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));
              lineElement.appendChild(dom.createElement("br"));
              annotationMessages[annotation.type[i].replace("_fold", "")].push(lineElement);
            }
            var tooltipElement = this.getElement();
            dom.removeChildren(tooltipElement);
            annotationMessages.error.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.security.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.warning.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.info.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.hint.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            tooltipElement.setAttribute("aria-live", "polite");
            if (!this.isOpen) {
              this.setTheme(this.editor.renderer.theme);
              this.setClassName("ace_gutter-tooltip");
            }
            var annotationNode = this.$findLinkedAnnotationNode(row);
            if (annotationNode) {
              annotationNode.setAttribute("aria-describedby", this.id);
            }
            this.show();
            this.visibleTooltipRow = row;
            this.editor._signal("showGutterTooltip", this);
          };
          GutterTooltip2.prototype.$findLinkedAnnotationNode = function(row) {
            var cell = this.$findCellByRow(row);
            if (cell) {
              var element = cell.element;
              if (element.childNodes.length > 2) {
                return element.childNodes[2];
              }
            }
          };
          GutterTooltip2.prototype.$findCellByRow = function(row) {
            return this.editor.renderer.$gutterLayer.$lines.cells.find(function(el) {
              return el.row === row;
            });
          };
          GutterTooltip2.prototype.hideTooltip = function() {
            if (!this.isOpen) {
              return;
            }
            this.$element.removeAttribute("aria-live");
            this.hide();
            if (this.visibleTooltipRow != void 0) {
              var annotationNode = this.$findLinkedAnnotationNode(this.visibleTooltipRow);
              if (annotationNode) {
                annotationNode.removeAttribute("aria-describedby");
              }
            }
            this.visibleTooltipRow = void 0;
            this.editor._signal("hideGutterTooltip", this);
          };
          GutterTooltip2.annotationsToSummaryString = function(annotations) {
            var e_1, _a2;
            var summary = [];
            var annotationTypes = ["error", "security", "warning", "info", "hint"];
            try {
              for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {
                var annotationType = annotationTypes_1_1.value;
                if (!annotations[annotationType].length)
                  continue;
                var label = annotations[annotationType].length === 1 ? GutterTooltip2.annotationLabels[annotationType].singular : GutterTooltip2.annotationLabels[annotationType].plural;
                summary.push("".concat(annotations[annotationType].length, " ").concat(label));
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a2 = annotationTypes_1.return)) _a2.call(annotationTypes_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return summary.join(", ");
          };
          return GutterTooltip2;
        }(Tooltip)
      );
      GutterTooltip.$uid = 0;
      exports2.GutterTooltip = GutterTooltip;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var event = require3("../lib/event");
      var useragent = require3("../lib/useragent");
      var MouseEvent2 = (
        /** @class */
        function() {
          function MouseEvent3(domEvent, editor) {
            this.speed;
            this.wheelX;
            this.wheelY;
            this.domEvent = domEvent;
            this.editor = editor;
            this.x = this.clientX = domEvent.clientX;
            this.y = this.clientY = domEvent.clientY;
            this.$pos = null;
            this.$inSelection = null;
            this.propagationStopped = false;
            this.defaultPrevented = false;
          }
          MouseEvent3.prototype.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
          };
          MouseEvent3.prototype.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
          };
          MouseEvent3.prototype.stop = function() {
            this.stopPropagation();
            this.preventDefault();
          };
          MouseEvent3.prototype.getDocumentPosition = function() {
            if (this.$pos)
              return this.$pos;
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
          };
          MouseEvent3.prototype.getGutterRow = function() {
            var documentRow = this.getDocumentPosition().row;
            var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
            var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
            return screenRow - screenTopRow;
          };
          MouseEvent3.prototype.inSelection = function() {
            if (this.$inSelection !== null)
              return this.$inSelection;
            var editor = this.editor;
            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
              this.$inSelection = false;
            else {
              var pos = this.getDocumentPosition();
              this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
            return this.$inSelection;
          };
          MouseEvent3.prototype.getButton = function() {
            return event.getButton(this.domEvent);
          };
          MouseEvent3.prototype.getShiftKey = function() {
            return this.domEvent.shiftKey;
          };
          MouseEvent3.prototype.getAccelKey = function() {
            return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
          };
          return MouseEvent3;
        }()
      );
      exports2.MouseEvent = MouseEvent2;
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var event = require3("../lib/event");
      var useragent = require3("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var dragImage = dom.createElement("div");
        dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
        dragImage.textContent = "\xA0";
        var exports3 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports3.forEach(function(x2) {
          mouseHandler[x2] = this[x2];
        }, this);
        editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker, x, y2;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self2 = this;
            setTimeout(function() {
              self2.startSelect();
              self2.captureMouse(e);
            }, 0);
            return e.preventDefault();
          }
          range = editor.getSelectionRange();
          var dataTransfer = e.dataTransfer;
          dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
          editor.container.appendChild(dragImage);
          dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
          setTimeout(function() {
            editor.container.removeChild(dragImage);
          });
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function(e) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
              editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
          x = e.clientX;
          y2 = e.clientY;
          if (!dragSelectionMarker)
            addDragMarker();
          counter++;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragOver = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
          x = e.clientX;
          y2 = e.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragLeave = function(e) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
          }
        };
        this.onDrop = function(e) {
          if (!dragCursor)
            return;
          var dataTransfer = e.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData("Text");
            range = {
              start: dragCursor,
              end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = { x, y: y2 };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y2);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor.renderer.layerConfig.lineHeight;
          var characterWidth = editor.renderer.layerConfig.characterWidth;
          var editorRect = editor.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x - editorRect.left,
              right: editorRect.right - x
            },
            y: {
              top: y2 - editorRect.top,
              bottom: editorRect.bottom - y2
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = { row: cursor.row, column: cursor.column };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || hScroll && !vMovement) {
            if (!autoScrollStartTime)
              autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
              editor.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor.renderer.screenToTextCoordinates(x, y2);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor.selection.toOrientedRange();
          dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
          editor.clearSelection();
          if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor.selection.fromOrientedRange(range);
          if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
              if (onMouseMoveTimer != null && dragSelectionMarker)
                clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function(type) {
            return type == "text/plain" || type == "Text";
          });
        }
        function getDropEffect(e) {
          var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
          var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
          var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
          } catch (e2) {
          }
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
          else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          return dropEffect;
        }
      }
      (function() {
        this.dragWait = function() {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay())
            this.startDrag();
        };
        this.dragWaitEnd = function() {
          var target = this.editor.container;
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function(e) {
          this.editor.$resetCursorStyle();
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function() {
          this.cancelDrag = false;
          var editor = this.editor;
          var target = editor.container;
          target.draggable = true;
          editor.renderer.$cursorLayer.setBlinking(false);
          editor.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function(e) {
          var target = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
              target.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function(e) {
          if (!this.$dragEnabled)
            return;
          this.mousedownEvent = e;
          var editor = this.editor;
          var inSelection = e.inSelection();
          var button = e.getButton();
          var clickCount = e.domEvent.detail || 1;
          if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
              return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
              eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports2.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var MouseEvent2 = require3("./mouse_event").MouseEvent;
      var event = require3("../lib/event");
      var dom = require3("../lib/dom");
      exports2.addTouchListeners = function(el, editor) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        function createContextMenu() {
          var clipboard = window.navigator && window.navigator.clipboard;
          var isOpen = false;
          var updateMenu = function() {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(dom.buildDom(isOpen ? [
              "span",
              !selected && canExecuteCommand("selectall") && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
              selected && canExecuteCommand("copy") && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
              selected && canExecuteCommand("cut") && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
              clipboard && canExecuteCommand("paste") && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
              hasUndo && canExecuteCommand("undo") && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
              canExecuteCommand("find") && ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
              canExecuteCommand("openCommandPalette") && ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
            ] : ["span"]), contextMenu.firstChild);
          };
          var canExecuteCommand = function(cmd) {
            return editor.commands.canExecute(cmd, editor);
          };
          var handleClick = function(e) {
            var action = e.target.getAttribute("action");
            if (action == "more" || !isOpen) {
              isOpen = !isOpen;
              return updateMenu();
            }
            if (action == "paste") {
              clipboard.readText().then(function(text) {
                editor.execCommand(action, text);
              });
            } else if (action) {
              if (action == "cut" || action == "copy") {
                if (clipboard)
                  clipboard.writeText(editor.getCopyText());
                else
                  document.execCommand("copy");
              }
              editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPalette")
              editor.focus();
          };
          contextMenu = dom.buildDom([
            "div",
            {
              class: "ace_mobile-menu",
              ontouchstart: function(e) {
                mode = "menu";
                e.stopPropagation();
                e.preventDefault();
                editor.textInput.focus();
              },
              ontouchend: function(e) {
                e.stopPropagation();
                e.preventDefault();
                handleClick(e);
              },
              onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
          ], editor.container);
        }
        function showContextMenu() {
          if (!editor.getOption("enableMobileMenu")) {
            if (contextMenu) {
              hideContextMenu();
            }
            return;
          }
          if (!contextMenu)
            createContextMenu();
          var cursor = editor.selection.cursor;
          var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
          var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
          var scrollLeft = editor.renderer.scrollLeft;
          var rect = editor.container.getBoundingClientRect();
          contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
          if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
          } else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
          }
          contextMenu.style.display = "";
          contextMenu.firstChild.style.display = "none";
          editor.on("input", hideContextMenu);
        }
        function hideContextMenu(e) {
          if (contextMenu)
            contextMenu.style.display = "none";
          editor.off("input", hideContextMenu);
        }
        function handleLongTap() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          var range = editor.selection.getRange();
          var inSelection = range.contains(pos.row, pos.column);
          if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
          }
          mode = "wait";
          showContextMenu();
        }
        function switchToSelectionMode() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          editor.selection.moveToPosition(pos);
          var range = clickCount >= 2 ? editor.selection.getLineRange(pos.row) : editor.session.getBracketRange(pos);
          if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
          } else {
            editor.selection.selectWord();
          }
          mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e) {
          if (!pressed)
            return;
          var textarea = editor.textInput.getElement();
          textarea.focus();
        }, editor);
        event.addListener(el, "touchstart", function(e) {
          var touches = e.touches;
          if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
          }
          pressed = editor.$mouseHandler.isMousePressed = true;
          var h = editor.renderer.layerConfig.lineHeight;
          var w2 = editor.renderer.layerConfig.lineHeight;
          var t = e.timeStamp;
          lastT = t;
          var touchObj = touches[0];
          var x = touchObj.clientX;
          var y2 = touchObj.clientY;
          if (Math.abs(startX - x) + Math.abs(startY - y2) > h)
            touchStartT = -1;
          startX = e.clientX = x;
          startY = e.clientY = y2;
          vX = vY = 0;
          var ev = new MouseEvent2(e, editor);
          pos = ev.getDocumentPosition();
          if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e.preventDefault();
            e.button = 0;
            switchToSelectionMode();
          } else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function(x2, y3) {
              x2 = x2 / w2;
              y3 = y3 / h - 0.75;
              return x2 * x2 + y3 * y3;
            };
            if (e.clientX < rect.left) {
              mode = "zoom";
              return;
            }
            var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
            var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
            if (diff1 < 3.5 && diff2 < 3.5)
              mode = diff1 > diff2 ? "cursor" : "anchor";
            if (diff2 < 3.5)
              mode = "anchor";
            else if (diff1 < 3.5)
              mode = "cursor";
            else
              mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
          }
          touchStartT = t;
        }, editor);
        event.addListener(el, "touchend", function(e) {
          pressed = editor.$mouseHandler.isMousePressed = false;
          if (animationTimer)
            clearInterval(animationTimer);
          if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
          } else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
          } else if (mode == "scroll") {
            animate();
            hideContextMenu();
          } else {
            showContextMenu();
          }
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
        }, editor);
        event.addListener(el, "touchmove", function(e) {
          if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
          }
          var touches = e.touches;
          if (touches.length > 1 || mode == "zoom")
            return;
          var touchObj = touches[0];
          var wheelX = startX - touchObj.clientX;
          var wheelY = startY - touchObj.clientY;
          if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
              mode = "cursor";
            else
              return e.preventDefault();
          }
          startX = touchObj.clientX;
          startY = touchObj.clientY;
          e.clientX = touchObj.clientX;
          e.clientY = touchObj.clientY;
          var t = e.timeStamp;
          var dt2 = t - lastT;
          lastT = t;
          if (mode == "scroll") {
            var mouseEvent = new MouseEvent2(e, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY))
              wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX))
              wheelY = 0;
            if (dt2 != 0) {
              vX = wheelX / dt2;
              vY = wheelY / dt2;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
              vX = vY = 0;
            }
          } else {
            var ev = new MouseEvent2(e, editor);
            var pos2 = ev.getDocumentPosition();
            if (mode == "cursor")
              editor.selection.moveCursorToPosition(pos2);
            else if (mode == "anchor")
              editor.selection.setSelectionAnchor(pos2.row, pos2.column);
            editor.renderer.scrollCursorIntoView(pos2);
            e.preventDefault();
          }
        }, editor);
        function animate() {
          animationSteps += 60;
          animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
              clearInterval(animationTimer);
              animationTimer = null;
            }
            if (Math.abs(vX) < 0.01)
              vX = 0;
            if (Math.abs(vY) < 0.01)
              vY = 0;
            if (animationSteps < 20)
              vX = 0.9 * vX;
            if (animationSteps < 20)
              vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
              animationSteps = 0;
          }, 10);
        }
      };
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var event = require3("../lib/event");
      var useragent = require3("../lib/useragent");
      var DefaultHandlers = require3("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = require3("./default_gutter_handler").GutterHandler;
      var MouseEvent2 = require3("./mouse_event").MouseEvent;
      var DragdropHandler = require3("./dragdrop_handler").DragdropHandler;
      var addTouchListeners = require3("./touch_handler").addTouchListeners;
      var config = require3("../config");
      var MouseHandler = (
        /** @class */
        function() {
          function MouseHandler2(editor) {
            this.$dragDelay;
            this.$dragEnabled;
            this.$mouseMoved;
            this.mouseEvent;
            this.$focusTimeout;
            var _self = this;
            this.editor = editor;
            new DefaultHandlers(this);
            new DefaultGutterHandler(this);
            new DragdropHandler(this);
            var focusEditor = function(e) {
              var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
              if (windowBlurred)
                window.focus();
              editor.focus();
              setTimeout(function() {
                if (!editor.isFocused())
                  editor.focus();
              });
            };
            var mouseTarget = editor.renderer.getMouseEventTarget();
            event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
            event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
            event.addMultiMouseDownListener([
              mouseTarget,
              editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
              editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
              editor.textInput && editor.textInput.getElement()
            ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
            event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
            addTouchListeners(editor.container, editor);
            var gutterEl = editor.renderer.$gutter;
            event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
            event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
            event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
            event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
            event.addListener(mouseTarget, "mousedown", focusEditor, editor);
            event.addListener(gutterEl, "mousedown", focusEditor, editor);
            if (useragent.isIE && editor.renderer.scrollBarV) {
              event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
              event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
            }
            editor.on(
              "mousemove",
              function(e) {
                if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                  return;
                var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
                var range = editor.session.selection.getRange();
                var renderer = editor.renderer;
                if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                  renderer.setCursorStyle("default");
                } else {
                  renderer.setCursorStyle("");
                }
              },
              //@ts-expect-error TODO: seems mistyping - should be boolean
              editor
            );
          }
          MouseHandler2.prototype.onMouseEvent = function(name, e) {
            if (!this.editor.session)
              return;
            this.editor._emit(name, new MouseEvent2(e, this.editor));
          };
          MouseHandler2.prototype.onMouseMove = function(name, e) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
              return;
            this.editor._emit(name, new MouseEvent2(e, this.editor));
          };
          MouseHandler2.prototype.onMouseWheel = function(name, e) {
            var mouseEvent = new MouseEvent2(e, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e.wheelX;
            mouseEvent.wheelY = e.wheelY;
            this.editor._emit(name, mouseEvent);
          };
          MouseHandler2.prototype.setState = function(state) {
            this.state = state;
          };
          MouseHandler2.prototype.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;
            this.isMousePressed = true;
            var editor = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;
            var self2 = this;
            var continueCapture = true;
            var onMouseMove = function(e) {
              if (!e)
                return;
              if (useragent.isWebKit && !e.which && self2.releaseMouse)
                return self2.releaseMouse();
              self2.x = e.clientX;
              self2.y = e.clientY;
              mouseMoveHandler && mouseMoveHandler(e);
              self2.mouseEvent = new MouseEvent2(e, self2.editor);
              self2.$mouseMoved = true;
            };
            var onCaptureEnd = function(e) {
              editor.off("beforeEndOperation", onOperationEnd);
              continueCapture = false;
              if (editor.session)
                onCaptureUpdate();
              self2[self2.state + "End"] && self2[self2.state + "End"](e);
              self2.state = "";
              self2.isMousePressed = renderer.$isMousePressed = false;
              if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
              self2.$onCaptureMouseMove = self2.releaseMouse = null;
              e && self2.onMouseEvent("mouseup", e);
              editor.endOperation();
            };
            var onCaptureUpdate = function() {
              self2[self2.state] && self2[self2.state]();
              self2.$mouseMoved = false;
            };
            var onCaptureInterval = function() {
              if (continueCapture) {
                onCaptureUpdate();
                event.nextFrame(onCaptureInterval);
              }
            };
            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
              return setTimeout(function() {
                onCaptureEnd(ev);
              });
            }
            var onOperationEnd = function(e) {
              if (!self2.releaseMouse)
                return;
              if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self2[self2.state + "End"] && self2[self2.state + "End"]();
                self2.state = "";
                self2.releaseMouse();
              }
            };
            editor.on("beforeEndOperation", onOperationEnd);
            editor.startOperation({ command: { name: "mouse" } });
            self2.$onCaptureMouseMove = onMouseMove;
            self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            onCaptureInterval();
          };
          MouseHandler2.prototype.cancelContextMenu = function() {
            var stop = function(e) {
              if (e && e.domEvent && e.domEvent.type != "contextmenu")
                return;
              this.editor.off("nativecontextmenu", stop);
              if (e && e.domEvent)
                event.stopEvent(e.domEvent);
            }.bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
          };
          MouseHandler2.prototype.destroy = function() {
            if (this.releaseMouse)
              this.releaseMouse();
          };
          return MouseHandler2;
        }()
      );
      MouseHandler.prototype.releaseMouse = null;
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: { initialValue: 2 },
        dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
        dragEnabled: { initialValue: true },
        focusTimeout: { initialValue: 0 },
        tooltipFollowsMouse: { initialValue: true }
      });
      exports2.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var FoldHandler = (
        /** @class */
        /* @__PURE__ */ function() {
          function FoldHandler2(editor) {
            editor.on("click", function(e) {
              var position = e.getDocumentPosition();
              var session = editor.session;
              var fold = session.getFoldAt(position.row, position.column, 1);
              if (fold) {
                if (e.getAccelKey())
                  session.removeFold(fold);
                else
                  session.expandFold(fold);
                e.stop();
              }
              var target = e.domEvent && e.domEvent.target;
              if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                  session.setOption("wrap", !session.getUseWrapMode());
                  editor.renderer.scrollCursorIntoView();
                }
              }
            });
            editor.on("gutterclick", function(e) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
              if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                  editor.session.onFoldWidgetClick(row, e);
                if (!editor.isFocused())
                  editor.focus();
                e.stop();
              }
            });
            editor.on("gutterdblclick", function(e) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
              if (gutterRegion == "foldWidgets") {
                var row = e.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;
                if (range) {
                  row = range.start.row;
                  var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                  if (fold) {
                    session.removeFold(fold);
                  } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                  }
                }
                e.stop();
              }
            });
          }
          return FoldHandler2;
        }()
      );
      exports2.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require3, exports2, module3) {
      "use strict";
      var keyUtil = require3("../lib/keys");
      var event = require3("../lib/event");
      var KeyBinding = (
        /** @class */
        function() {
          function KeyBinding2(editor) {
            this.$editor = editor;
            this.$data = { editor };
            this.$handlers = [];
            this.setDefaultHandler(editor.commands);
          }
          KeyBinding2.prototype.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
          };
          KeyBinding2.prototype.setKeyboardHandler = function(kb) {
            var h = this.$handlers;
            if (h[h.length - 1] == kb)
              return;
            while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
              this.removeKeyboardHandler(h[h.length - 1]);
            this.addKeyboardHandler(kb, 1);
          };
          KeyBinding2.prototype.addKeyboardHandler = function(kb, pos) {
            if (!kb)
              return;
            if (typeof kb == "function" && !kb.handleKeyboard)
              kb.handleKeyboard = kb;
            var i = this.$handlers.indexOf(kb);
            if (i != -1)
              this.$handlers.splice(i, 1);
            if (pos == void 0)
              this.$handlers.push(kb);
            else
              this.$handlers.splice(pos, 0, kb);
            if (i == -1 && kb.attach)
              kb.attach(this.$editor);
          };
          KeyBinding2.prototype.removeKeyboardHandler = function(kb) {
            var i = this.$handlers.indexOf(kb);
            if (i == -1)
              return false;
            this.$handlers.splice(i, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
          };
          KeyBinding2.prototype.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
          };
          KeyBinding2.prototype.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h) {
              return h.getStatusText && h.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
          };
          KeyBinding2.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;
            for (var i = this.$handlers.length; i--; ) {
              toExecute = this.$handlers[i].handleKeyboard(
                this.$data,
                hashId,
                keyString,
                keyCode,
                e
              );
              if (!toExecute || !toExecute.command)
                continue;
              if (toExecute.command == "null") {
                success = true;
              } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
              }
              if (success && e && hashId != -1 && toExecute["passEvent"] != true && toExecute.command["passEvent"] != true) {
                event.stopEvent(e);
              }
              if (success)
                break;
            }
            if (!success && hashId == -1) {
              toExecute = { command: "insertstring" };
              success = commands.exec("insertstring", this.$editor, keyString);
            }
            if (success && this.$editor._signal)
              this.$editor._signal("keyboardActivity", toExecute);
            return success;
          };
          KeyBinding2.prototype.onCommandKey = function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
          };
          KeyBinding2.prototype.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
          };
          return KeyBinding2;
        }()
      );
      exports2.KeyBinding = KeyBinding;
    });
    ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var ArabicAlefBetIntervalsBegine = ["\u0621", "\u0641"];
      var ArabicAlefBetIntervalsEnd = ["\u063A", "\u064A"];
      var dir = 0, hiLevel = 0;
      var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
      var impTab_LTR = [
        [0, 3, 0, 1, 0, 0, 0],
        [0, 3, 0, 1, 2, 2, 0],
        [0, 3, 0, 17, 2, 0, 1],
        [0, 3, 5, 5, 4, 1, 0],
        [0, 3, 21, 21, 4, 0, 1],
        [0, 3, 5, 5, 4, 2, 0]
      ];
      var impTab_RTL = [
        [2, 0, 1, 1, 0, 1, 0],
        [2, 0, 1, 1, 0, 2, 0],
        [2, 0, 2, 1, 3, 2, 0],
        [2, 0, 2, 33, 3, 1, 1]
      ];
      var LTR = 0, RTL = 1;
      var L3 = 0;
      var R2 = 1;
      var EN = 2;
      var AN = 3;
      var ON = 4;
      var B2 = 5;
      var S3 = 6;
      var AL = 7;
      var WS = 8;
      var CS = 9;
      var ES = 10;
      var ET = 11;
      var NSM = 12;
      var LRE = 13;
      var RLE = 14;
      var PDF = 15;
      var LRO = 16;
      var RLO = 17;
      var BN = 18;
      var UnicodeTBL00 = [
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        S3,
        B2,
        S3,
        WS,
        B2,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B2,
        B2,
        B2,
        S3,
        WS,
        ON,
        ON,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ES,
        CS,
        ES,
        CS,
        CS,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        L3,
        ON,
        ON,
        ON,
        ON,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B2,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        CS,
        ON,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        L3,
        ON,
        ON,
        BN,
        ON,
        ON,
        ET,
        ET,
        EN,
        EN,
        ON,
        L3,
        ON,
        ON,
        ON,
        EN,
        L3,
        ON,
        ON,
        ON,
        ON,
        ON
      ];
      var UnicodeTBL20 = [
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        BN,
        BN,
        BN,
        L3,
        R2,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS,
        B2,
        LRE,
        RLE,
        PDF,
        LRO,
        RLO,
        CS,
        ET,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS
      ];
      function _computeLevels(chars, levels, len, charTypes) {
        var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
        if (!charTypes) {
          for (i = 0, charTypes = []; i < len; i++) {
            charTypes[i] = _getCharacterType(chars[i]);
          }
        }
        hiLevel = dir;
        lastArabic = false;
        hasUBAT_AL = false;
        hasUBAT_B = false;
        hasUBAT_S = false;
        for (ix = 0; ix < len; ix++) {
          prevState = newState;
          classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
          newState = impTab[prevState][newClass];
          action = newState & 240;
          newState &= 15;
          levels[ix] = newLevel = impTab[newState][5];
          if (action > 0) {
            if (action == 16) {
              for (i = condPos; i < ix; i++) {
                levels[i] = 1;
              }
              condPos = -1;
            } else {
              condPos = -1;
            }
          }
          cond = impTab[newState][6];
          if (cond) {
            if (condPos == -1) {
              condPos = ix;
            }
          } else {
            if (condPos > -1) {
              for (i = condPos; i < ix; i++) {
                levels[i] = newLevel;
              }
              condPos = -1;
            }
          }
          if (charTypes[ix] == B2) {
            levels[ix] = 0;
          }
          hiLevel |= newLevel;
        }
        if (hasUBAT_S) {
          for (i = 0; i < len; i++) {
            if (charTypes[i] == S3) {
              levels[i] = dir;
              for (var j3 = i - 1; j3 >= 0; j3--) {
                if (charTypes[j3] == WS) {
                  levels[j3] = dir;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
      function _invertLevel(lev, levels, _array) {
        if (hiLevel < lev) {
          return;
        }
        if (lev == 1 && dir == RTL && !hasUBAT_B) {
          _array.reverse();
          return;
        }
        var len = _array.length, start = 0, end, lo2, hi2, tmp;
        while (start < len) {
          if (levels[start] >= lev) {
            end = start + 1;
            while (end < len && levels[end] >= lev) {
              end++;
            }
            for (lo2 = start, hi2 = end - 1; lo2 < hi2; lo2++, hi2--) {
              tmp = _array[lo2];
              _array[lo2] = _array[hi2];
              _array[hi2] = tmp;
            }
            start = end;
          }
          start++;
        }
      }
      function _getCharClass(chars, types, classes, ix) {
        var cType = types[ix], wType, nType, len, i;
        switch (cType) {
          case L3:
          case R2:
            lastArabic = false;
          case ON:
          case AN:
            return cType;
          case EN:
            return lastArabic ? AN : EN;
          case AL:
            lastArabic = true;
            hasUBAT_AL = true;
            return R2;
          case WS:
            return ON;
          case CS:
            if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
              return ON;
            }
            if (lastArabic) {
              nType = AN;
            }
            return nType == wType ? nType : ON;
          case ES:
            wType = ix > 0 ? classes[ix - 1] : B2;
            if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
              return EN;
            }
            return ON;
          case ET:
            if (ix > 0 && classes[ix - 1] == EN) {
              return EN;
            }
            if (lastArabic) {
              return ON;
            }
            i = ix + 1;
            len = types.length;
            while (i < len && types[i] == ET) {
              i++;
            }
            if (i < len && types[i] == EN) {
              return EN;
            }
            return ON;
          case NSM:
            len = types.length;
            i = ix + 1;
            while (i < len && types[i] == NSM) {
              i++;
            }
            if (i < len) {
              var c = chars[ix], rtlCandidate = c >= 1425 && c <= 2303 || c == 64286;
              wType = types[i];
              if (rtlCandidate && (wType == R2 || wType == AL)) {
                return R2;
              }
            }
            if (ix < 1 || (wType = types[ix - 1]) == B2) {
              return ON;
            }
            return classes[ix - 1];
          case B2:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
          case S3:
            hasUBAT_S = true;
            return ON;
          case LRE:
          case RLE:
          case LRO:
          case RLO:
          case PDF:
            lastArabic = false;
          case BN:
            return ON;
        }
      }
      function _getCharacterType(ch) {
        var uc2 = ch.charCodeAt(0), hi2 = uc2 >> 8;
        if (hi2 == 0) {
          return uc2 > 191 ? L3 : UnicodeTBL00[uc2];
        } else if (hi2 == 5) {
          return /[\u0591-\u05f4]/.test(ch) ? R2 : L3;
        } else if (hi2 == 6) {
          if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
            return NSM;
          else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
            return AN;
          else if (uc2 == 1642)
            return ET;
          else if (/[\u06f0-\u06f9]/.test(ch))
            return EN;
          else
            return AL;
        } else if (hi2 == 32 && uc2 <= 8287) {
          return UnicodeTBL20[uc2 & 255];
        } else if (hi2 == 254) {
          return uc2 >= 65136 ? AL : ON;
        }
        return ON;
      }
      function _isArabicDiacritics(ch) {
        return ch >= "\u064B" && ch <= "\u0655";
      }
      exports2.L = L3;
      exports2.R = R2;
      exports2.EN = EN;
      exports2.ON_R = 3;
      exports2.AN = 4;
      exports2.R_H = 5;
      exports2.B = 6;
      exports2.RLE = 7;
      exports2.DOT = "\xB7";
      exports2.doBidiReorder = function(text, textCharTypes, isRtl) {
        if (text.length < 2)
          return {};
        var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
        dir = isRtl ? RTL : LTR;
        _computeLevels(chars, levels, chars.length, textCharTypes);
        for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
          ;
        _invertLevel(2, levels, logicalFromVisual);
        _invertLevel(1, levels, logicalFromVisual);
        for (var i = 0; i < logicalFromVisual.length - 1; i++) {
          if (textCharTypes[i] === AN) {
            levels[i] = exports2.AN;
          } else if (levels[i] === R2 && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
            levels[i] = exports2.ON_R;
          } else if (i > 0 && chars[i - 1] === "\u0644" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
            levels[i - 1] = levels[i] = exports2.R_H;
            i++;
          }
        }
        if (chars[chars.length - 1] === exports2.DOT)
          levels[chars.length - 1] = exports2.B;
        if (chars[0] === "\u202B")
          levels[0] = exports2.RLE;
        for (var i = 0; i < logicalFromVisual.length; i++) {
          bidiLevels[i] = levels[logicalFromVisual[i]];
        }
        return { "logicalFromVisual": logicalFromVisual, "bidiLevels": bidiLevels };
      };
      exports2.hasBidiCharacters = function(text, textCharTypes) {
        var ret = false;
        for (var i = 0; i < text.length; i++) {
          textCharTypes[i] = _getCharacterType(text.charAt(i));
          if (!ret && (textCharTypes[i] == R2 || textCharTypes[i] == AL || textCharTypes[i] == AN))
            ret = true;
        }
        return ret;
      };
      exports2.getVisualFromLogicalIdx = function(logIdx, rowMap) {
        for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
          if (rowMap.logicalFromVisual[i] == logIdx)
            return i;
        }
        return 0;
      };
    });
    ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(require3, exports2, module3) {
      "use strict";
      var bidiUtil = require3("./lib/bidiutil");
      var lang = require3("./lib/lang");
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
      var BidiHandler = (
        /** @class */
        function() {
          function BidiHandler2(session) {
            this.session = session;
            this.bidiMap = {};
            this.currentRow = null;
            this.bidiUtil = bidiUtil;
            this.charWidths = [];
            this.EOL = "\xAC";
            this.showInvisibles = true;
            this.isRtlDir = false;
            this.$isRtl = false;
            this.line = "";
            this.wrapIndent = 0;
            this.EOF = "\xB6";
            this.RLE = "\u202B";
            this.contentWidth = 0;
            this.fontMetrics = null;
            this.rtlLineOffset = 0;
            this.wrapOffset = 0;
            this.isMoveLeftOperation = false;
            this.seenBidi = bidiRE.test(session.getValue());
          }
          BidiHandler2.prototype.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
              return false;
            if (screenRow !== this.currentRow) {
              this.currentRow = screenRow;
              this.updateRowLine(docRow, splitIndex);
              this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
          };
          BidiHandler2.prototype.onChange = function(delta) {
            if (!this.seenBidi) {
              if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
              }
            } else {
              this.currentRow = null;
            }
          };
          BidiHandler2.prototype.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              if (index >= 0)
                docRow = this.session.$docRowCache[index];
            }
            return docRow;
          };
          BidiHandler2.prototype.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                  break;
                prevIndex = currentIndex;
                splitIndex++;
              }
            } else {
              splitIndex = this.currentRow;
            }
            return splitIndex;
          };
          BidiHandler2.prototype.updateRowLine = function(docRow, splitIndex) {
            if (docRow === void 0)
              docRow = this.getDocumentRow();
            var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
              var splits = this.session.$wrapData[docRow];
              if (splits) {
                if (splitIndex === void 0)
                  splitIndex = this.getSplitIndex();
                if (splitIndex > 0 && splits.length) {
                  this.wrapIndent = splits.indent;
                  this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                  this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
                } else {
                  this.line = this.line.substring(0, splits[splitIndex]);
                }
                if (splitIndex == splits.length) {
                  this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                }
              }
            } else {
              this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i) {
              if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                size = ch === "	" ? session.getScreenTabSize(i + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
              }
              return ch;
            });
            if (this.isRtlDir) {
              this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
              this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
          };
          BidiHandler2.prototype.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
              this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            } else {
              this.bidiMap = {};
            }
          };
          BidiHandler2.prototype.markAsDirty = function() {
            this.currentRow = null;
          };
          BidiHandler2.prototype.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width)
              return;
            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("\u05D4");
            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setEolChar = function(eolChar) {
            this.EOL = eolChar;
          };
          BidiHandler2.prototype.setContentWidth = function(width) {
            this.contentWidth = width;
          };
          BidiHandler2.prototype.isRtlLine = function(row) {
            if (this.$isRtl)
              return true;
            if (row != void 0)
              return this.session.getLine(row).charAt(0) == this.RLE;
            else
              return this.isRtlDir;
          };
          BidiHandler2.prototype.setRtlDirection = function(editor, isRtlDir) {
            var cursor = editor.getCursorPosition();
            for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
              if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
              else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({ column: 0, row }, editor.session.$bidiHandler.RLE);
            }
          };
          BidiHandler2.prototype.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
            var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
              visualIdx++;
            for (var i = 0; i < visualIdx; i++) {
              left += this.charWidths[levels[i]];
            }
            if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0)
              left += this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            if (this.isRtlDir)
              left += this.rtlLineOffset;
            return left;
          };
          BidiHandler2.prototype.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
            if (this.wrapIndent)
              offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
              logIdx = map.logicalFromVisual[visIdx];
              level = levels[visIdx];
              isSelected = logIdx >= selColMin && logIdx < selColMax;
              if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
              } else if (!isSelected && isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
              }
              offset += this.charWidths[level];
              isSelectedPrev = isSelected;
            }
            if (isSelected && visIdx === levels.length) {
              selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            if (this.isRtlDir) {
              for (var i = 0; i < selections.length; i++) {
                selections[i].left += this.rtlLineOffset;
              }
            }
            return selections;
          };
          BidiHandler2.prototype.offsetToCol = function(posX) {
            if (this.isRtlDir)
              posX -= this.rtlLineOffset;
            var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            while (posX > offset + charWidth / 2) {
              offset += charWidth;
              if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
              }
              charWidth = this.charWidths[levels[++visualIdx]];
            }
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
              if (posX < offset)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
            } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
              if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }
            if (logicalIdx === 0 && this.isRtlDir)
              logicalIdx++;
            return logicalIdx + this.wrapIndent;
          };
          return BidiHandler2;
        }()
      );
      exports2.BidiHandler = BidiHandler;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./lib/oop");
      var lang = require3("./lib/lang");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var Range = require3("./range").Range;
      var Selection = (
        /** @class */
        function() {
          function Selection2(session) {
            this.session = session;
            this.doc = session.getDocument();
            this.clearSelection();
            this.cursor = this.lead = this.doc.createAnchor(0, 0);
            this.anchor = this.doc.createAnchor(0, 0);
            this.$silent = false;
            var self2 = this;
            this.cursor.on("change", function(e) {
              self2.$cursorChanged = true;
              if (!self2.$silent)
                self2._emit("changeCursor");
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
              if (!self2.$keepDesiredColumnOnChange && e.old.column != e.value.column)
                self2.$desiredColumn = null;
            });
            this.anchor.on("change", function() {
              self2.$anchorChanged = true;
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
            });
          }
          Selection2.prototype.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
          };
          Selection2.prototype.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
          };
          Selection2.prototype.getCursor = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.setAnchor = function(row, column) {
            this.$isEmpty = false;
            this.anchor.setPosition(row, column);
          };
          Selection2.prototype.getAnchor = function() {
            if (this.$isEmpty)
              return this.getSelectionLead();
            return this.anchor.getPosition();
          };
          Selection2.prototype.getSelectionLead = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
          };
          Selection2.prototype.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            if (this.$isEmpty)
              return Range.fromPoints(lead, lead);
            return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
          };
          Selection2.prototype.clearSelection = function() {
            if (!this.$isEmpty) {
              this.$isEmpty = true;
              this._emit("changeSelection");
            }
          };
          Selection2.prototype.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
          };
          Selection2.prototype.setRange = function(range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
          };
          Selection2.prototype.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
            if (this.$silent)
              return;
            var wasEmpty = this.$isEmpty;
            var wasMultiselect = this.inMultiSelectMode;
            this.$silent = true;
            this.$cursorChanged = this.$anchorChanged = false;
            this.anchor.setPosition(anchorRow, anchorColumn);
            this.cursor.setPosition(cursorRow, cursorColumn);
            this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
            this.$silent = false;
            if (this.$cursorChanged)
              this._emit("changeCursor");
            if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
              this._emit("changeSelection");
          };
          Selection2.prototype.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty)
              this.setSelectionAnchor(lead.row, lead.column);
            mover.call(this);
          };
          Selection2.prototype.selectTo = function(row, column) {
            this.$moveSelection(function() {
              this.moveCursorTo(row, column);
            });
          };
          Selection2.prototype.selectToPosition = function(pos) {
            this.$moveSelection(function() {
              this.moveCursorToPosition(pos);
            });
          };
          Selection2.prototype.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
          };
          Selection2.prototype.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
          };
          Selection2.prototype.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
          };
          Selection2.prototype.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
          };
          Selection2.prototype.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
          };
          Selection2.prototype.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
          };
          Selection2.prototype.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
          };
          Selection2.prototype.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
          };
          Selection2.prototype.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
          };
          Selection2.prototype.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
          };
          Selection2.prototype.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
          };
          Selection2.prototype.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
              var cursor = row || this.lead;
              row = cursor.row;
              column = cursor.column;
            }
            return this.session.getWordRange(row, column);
          };
          Selection2.prototype.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
          };
          Selection2.prototype.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
          };
          Selection2.prototype.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;
            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
              rowStart = foldLine.start.row;
              rowEnd = foldLine.end.row;
            } else {
              rowEnd = rowStart;
            }
            if (excludeLastChar === true)
              return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else
              return new Range(rowStart, 0, rowEnd + 1, 0);
          };
          Selection2.prototype.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
          };
          Selection2.prototype.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
          };
          Selection2.prototype.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
          };
          Selection2.prototype.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;
            if (direction < 0) {
              start = cursor.column - tabSize;
              end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
          };
          Selection2.prototype.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
            } else if (cursor.column === 0) {
              if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
              }
            } else {
              var tabSize = this.session.getTabSize();
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
              } else {
                this.moveCursorBy(0, -1);
              }
            }
          };
          Selection2.prototype.moveCursorRight = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
              this.moveCursorTo(fold.end.row, fold.end.column);
            } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
              if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
              }
            } else {
              var tabSize = this.session.getTabSize();
              var cursor = this.lead;
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
              } else {
                this.moveCursorBy(0, 1);
              }
            }
          };
          Selection2.prototype.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
              firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
          };
          Selection2.prototype.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
              var line = this.session.getLine(lineEnd.row);
              if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                  lineEnd.column = textEnd;
              }
            }
            this.moveCursorTo(lineEnd.row, lineEnd.column);
          };
          Selection2.prototype.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
          };
          Selection2.prototype.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              this.moveCursorTo(fold.end.row, fold.end.column);
              return;
            }
            if (this.session.nonTokenRe.exec(rightOfCursor)) {
              column += this.session.nonTokenRe.lastIndex;
              this.session.nonTokenRe.lastIndex = 0;
              rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
              this.moveCursorTo(row, line.length);
              this.moveCursorRight();
              if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
              return;
            }
            if (this.session.tokenRe.exec(rightOfCursor)) {
              column += this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
              return;
            }
            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) {
              str = this.doc.getLine(row).substring(0, column);
            }
            var leftOfCursor = lang.stringReverse(str);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (this.session.nonTokenRe.exec(leftOfCursor)) {
              column -= this.session.nonTokenRe.lastIndex;
              leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
              this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
              this.moveCursorTo(row, 0);
              this.moveCursorLeft();
              if (row > 0)
                this.moveCursorWordLeft();
              return;
            }
            if (this.session.tokenRe.exec(leftOfCursor)) {
              column -= this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.$shortWordEndIndex = function(rightOfCursor) {
            var index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;
            tokenRe.lastIndex = 0;
            if (this.session.tokenRe.exec(rightOfCursor)) {
              index = this.session.tokenRe.lastIndex;
            } else {
              while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index++;
              if (index < 1) {
                tokenRe.lastIndex = 0;
                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                  tokenRe.lastIndex = 0;
                  index++;
                  if (whitespaceRe.test(ch)) {
                    if (index > 2) {
                      index--;
                      break;
                    } else {
                      while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                        index++;
                      if (index > 2)
                        break;
                    }
                  }
                }
              }
            }
            tokenRe.lastIndex = 0;
            return index;
          };
          Selection2.prototype.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold)
              return this.moveCursorTo(fold.end.row, fold.end.column);
            if (column == line.length) {
              var l = this.doc.getLength();
              do {
                row++;
                rightOfCursor = this.doc.getLine(row);
              } while (row < l && /^\s*$/.test(rightOfCursor));
              if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
              column = 0;
            }
            var index = this.$shortWordEndIndex(rightOfCursor);
            this.moveCursorTo(row, column + index);
          };
          Selection2.prototype.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1))
              return this.moveCursorTo(fold.start.row, fold.start.column);
            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
              do {
                row--;
                line = this.doc.getLine(row);
              } while (row > 0 && /^\s*$/.test(line));
              column = line.length;
              if (!/\s+$/.test(line))
                line = "";
            }
            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);
            return this.moveCursorTo(row, column - index);
          };
          Selection2.prototype.moveCursorWordRight = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordRight();
            else
              this.moveCursorShortWordRight();
          };
          Selection2.prototype.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordLeft();
            else
              this.moveCursorShortWordLeft();
          };
          Selection2.prototype.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
            var offsetX;
            if (chars === 0) {
              if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                  offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                  screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                  offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
              }
              if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
              else
                this.$desiredColumn = screenPos.column;
            }
            if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
              var widget = this.session.lineWidgets[this.lead.row];
              if (rows < 0)
                rows -= widget.rowsAbove || 0;
              else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
            }
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            }
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
          };
          Selection2.prototype.moveCursorToPosition = function(position) {
            this.moveCursorTo(position.row, position.column);
          };
          Selection2.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              row = fold.start.row;
              column = fold.start.column;
            }
            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
              if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
              else
                column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;
            if (!keepDesiredColumn)
              this.$desiredColumn = null;
          };
          Selection2.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
          };
          Selection2.prototype.detach = function() {
            this.lead.detach();
            this.anchor.detach();
          };
          Selection2.prototype.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
          };
          Selection2.prototype.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
              range.start.column = r.start.column;
              range.start.row = r.start.row;
              range.end.column = r.end.column;
              range.end.row = r.end.row;
            } else {
              range = r;
            }
            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
          };
          Selection2.prototype.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
              func(this);
              var end = this.getCursor();
              return Range.fromPoints(start, end);
            } catch (e) {
              return Range.fromPoints(start, start);
            } finally {
              this.moveCursorToPosition(start);
            }
          };
          Selection2.prototype.toJSON = function() {
            if (this.rangeCount) {
              var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
              });
            } else {
              var data = this.getRange();
              data.isBackwards = this.isBackwards();
            }
            return data;
          };
          Selection2.prototype.fromJSON = function(data) {
            if (data.start == void 0) {
              if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i = data.length; i--; ) {
                  var r = Range.fromPoints(data[i].start, data[i].end);
                  if (data[i].isBackwards)
                    r.cursor = r.start;
                  this.addRange(r, true);
                }
                return;
              } else {
                data = data[0];
              }
            }
            if (this.rangeList)
              this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
          };
          Selection2.prototype.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount)
              return false;
            if (!data.length || !this.ranges)
              return this.getRange().isEqual(data);
            for (var i = this.ranges.length; i--; ) {
              if (!this.ranges[i].isEqual(data[i]))
                return false;
            }
            return true;
          };
          return Selection2;
        }()
      );
      Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
      Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;
      Selection.prototype.setSelectionRange = Selection.prototype.setRange;
      oop.implement(Selection.prototype, EventEmitter);
      exports2.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module", "ace/lib/report_error"], function(require3, exports2, module3) {
      "use strict";
      var reportError = require3("./lib/report_error").reportError;
      var MAX_TOKEN_COUNT = 2e3;
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2(rules) {
            this.splitRegex;
            this.states = rules;
            this.regExps = {};
            this.matchMappings = {};
            for (var key in this.states) {
              var state = this.states[key];
              var ruleRegExps = [];
              var matchTotal = 0;
              var mapping = this.matchMappings[key] = { defaultToken: "text" };
              var flag = "g";
              var splitterRurles = [];
              for (var i = 0; i < state.length; i++) {
                var rule = state[i];
                if (rule.defaultToken)
                  mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive && flag.indexOf("i") === -1)
                  flag += "i";
                if (rule.unicode && flag.indexOf("u") === -1)
                  flag += "u";
                if (rule.regex == null)
                  continue;
                if (rule.regex instanceof RegExp)
                  rule.regex = rule.regex.toString().slice(1, -1);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                  if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                  } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                      rule,
                      groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                  } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                  }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                  if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                  else
                    rule.onMatch = rule.token;
                }
                if (matchcount > 1) {
                  if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                      return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                  } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                  }
                  if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule);
                }
                mapping[matchTotal] = i;
                matchTotal += matchcount;
                ruleRegExps.push(adjustedregex);
                if (!rule.onMatch)
                  rule.onMatch = null;
              }
              if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
              }
              splitterRurles.forEach(function(rule2) {
                rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
              }, this);
              this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
            }
          }
          Tokenizer2.prototype.$setMaxTokenCount = function(m) {
            MAX_TOKEN_COUNT = m | 0;
          };
          Tokenizer2.prototype.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
              return [{ type: types, value: str }];
            var tokens = [];
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i])
                tokens[tokens.length] = {
                  type: types[i],
                  value: values[i]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.$arrayTokens = function(str) {
            if (!str)
              return [];
            var values = this.splitRegex.exec(str);
            if (!values)
              return "text";
            var tokens = [];
            var types = this.tokenArray;
            for (var i = 0, l = types.length; i < l; i++) {
              if (values[i + 1])
                tokens[tokens.length] = {
                  type: types[i],
                  value: values[i + 1]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.removeCapturingGroups = function(src) {
            var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x, y2) {
              return y2 ? "(?:" : x;
            });
            return r;
          };
          Tokenizer2.prototype.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
              var stack = 0;
              var inChClass = false;
              var lastCapture = {};
              src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                  inChClass = square != "]";
                } else if (square) {
                  inChClass = true;
                } else if (parenClose) {
                  if (stack == lastCapture.stack) {
                    lastCapture.end = index + 1;
                    lastCapture.stack = -1;
                  }
                  stack--;
                } else if (parenOpen) {
                  stack++;
                  if (parenOpen.length != 1) {
                    lastCapture.stack = stack;
                    lastCapture.start = index;
                  }
                }
                return m;
              });
              if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^")
              src = "^" + src;
            if (src.charAt(src.length - 1) != "$")
              src += "$";
            return new RegExp(src, (flag || "").replace("g", ""));
          };
          Tokenizer2.prototype.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
              var stack = startState.slice(0);
              startState = stack[0];
              if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
              }
            } else
              var stack = [];
            var currentState = (
              /**@type{string}*/
              startState || "start"
            );
            var state = this.states[currentState];
            if (!state) {
              currentState = "start";
              state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re3 = this.regExps[currentState];
            re3.lastIndex = 0;
            var match, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;
            var token = { type: null, value: "" };
            while (match = re3.exec(line)) {
              var type = mapping.defaultToken;
              var rule = null;
              var value = match[0];
              var index = re3.lastIndex;
              if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                  token.value += skipped;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = { type, value: skipped };
                }
              }
              for (var i = 0; i < match.length - 2; i++) {
                if (match[i + 1] === void 0)
                  continue;
                rule = state[mapping[i]];
                if (rule.onMatch)
                  type = rule.onMatch(value, currentState, stack, line);
                else
                  type = rule.token;
                if (rule.next) {
                  if (typeof rule.next == "string") {
                    currentState = rule.next;
                  } else {
                    currentState = rule.next(currentState, stack);
                  }
                  state = this.states[currentState];
                  if (!state) {
                    this.reportError("state doesn't exist", currentState);
                    currentState = "start";
                    state = this.states[currentState];
                  }
                  mapping = this.matchMappings[currentState];
                  lastIndex = index;
                  re3 = this.regExps[currentState];
                  re3.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                  lastIndex = index;
                break;
              }
              if (value) {
                if (typeof type === "string") {
                  if ((!rule || rule.merge !== false) && token.type === type) {
                    token.value += value;
                  } else {
                    if (token.type)
                      tokens.push(token);
                    token = { type, value };
                  }
                } else if (type) {
                  if (token.type)
                    tokens.push(token);
                  token = { type: null, value: "" };
                  for (var i = 0; i < type.length; i++)
                    tokens.push(type[i]);
                }
              }
              if (lastIndex == line.length)
                break;
              lastIndex = index;
              if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                  this.reportError("infinite loop with in ace tokenizer", {
                    startState,
                    line
                  });
                }
                while (lastIndex < line.length) {
                  if (token.type)
                    tokens.push(token);
                  token = {
                    value: line.substring(lastIndex, lastIndex += 500),
                    type: "overflow"
                  };
                }
                currentState = "start";
                stack = [];
                break;
              }
            }
            if (token.type)
              tokens.push(token);
            if (stack.length > 1) {
              if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
            }
            return {
              tokens,
              state: stack.length ? stack : currentState
            };
          };
          return Tokenizer2;
        }()
      );
      Tokenizer.prototype.reportError = reportError;
      exports2.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/deep_copy"], function(require3, exports2, module3) {
      "use strict";
      var deepCopy = require3("../lib/deep_copy").deepCopy;
      var TextHighlightRules;
      TextHighlightRules = function() {
        this.$rules = {
          "start": [{
            token: "empty_line",
            regex: "^$"
          }, {
            defaultToken: "text"
          }]
        };
      };
      (function() {
        this.addRules = function(rules, prefix) {
          if (!prefix) {
            for (var key in rules)
              this.$rules[key] = rules[key];
            return;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next == "string") {
                  if (rule.next.indexOf(prefix) !== 0)
                    rule.next = prefix + rule.next;
                }
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                  rule.nextState = prefix + rule.nextState;
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function() {
          return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i = 0; i < states.length; i++)
              states[i] = prefix + states[i];
          } else {
            states = [];
            for (var key in embedRules)
              states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
              addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
          }
          if (!this.$embeds)
            this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
          return this.$embeds;
        };
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function() {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state["processed"] = true;
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              var toInsert = null;
              if (Array.isArray(rule)) {
                toInsert = rule;
                rule = {};
              }
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next)
                  rule.next = [];
                rule.next.push({
                  defaultToken: rule.token
                }, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string")
                    stateName = stateName[0] || "";
                  if (rules[stateName])
                    stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push)
                      rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              var includeName = typeof rule == "string" ? rule : rule.include;
              if (includeName) {
                if (includeName === "$self")
                  includeName = "start";
                if (Array.isArray(includeName))
                  toInsert = includeName.map(function(x) {
                    return rules[x];
                  });
                else
                  toInsert = rules[includeName];
              }
              if (toInsert) {
                var args = [i, 1].concat(toInsert);
                if (rule.noEscape)
                  args = args.filter(function(x) {
                    return !x.next;
                  });
                state.splice.apply(state, args);
                i--;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
          var keywords = /* @__PURE__ */ Object.create(null);
          this.$keywordList = [];
          Object.keys(map).forEach(function(className) {
            var a = map[className];
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; ) {
              var word = list[i];
              this.$keywordList.push(word);
              if (ignoreCase)
                word = word.toLowerCase();
              keywords[word] = className;
            }
          }, this);
          map = null;
          return ignoreCase ? function(value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function(value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function() {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports2.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var Behaviour;
      Behaviour = function() {
        this.$behaviours = {};
      };
      (function() {
        this.add = function(name, action, callback) {
          switch (void 0) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function(name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function(mode, filter) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
          } else {
            var behaviours = mode.getBehaviours(filter);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter) {
          if (!filter) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
              if (this.$behaviours[filter[i]]) {
                ret[filter[i]] = this.$behaviours[filter[i]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports2.Behaviour = Behaviour;
    });
    ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("./range").Range;
      var TokenIterator = (
        /** @class */
        function() {
          function TokenIterator2(session, initialRow, initialColumn) {
            this.$session = session;
            this.$row = initialRow;
            this.$rowTokens = session.getTokens(initialRow);
            var token = session.getTokenAt(initialRow, initialColumn);
            this.$tokenIndex = token ? token.index : -1;
          }
          TokenIterator2.prototype.stepBackward = function() {
            this.$tokenIndex -= 1;
            while (this.$tokenIndex < 0) {
              this.$row -= 1;
              if (this.$row < 0) {
                this.$row = 0;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
              this.$row += 1;
              if (!rowCount)
                rowCount = this.$session.getLength();
              if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentTokenRow = function() {
            return this.$row;
          };
          TokenIterator2.prototype.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== void 0)
              return column;
            column = 0;
            while (tokenIndex > 0) {
              tokenIndex -= 1;
              column += rowTokens[tokenIndex].value.length;
            }
            return column;
          };
          TokenIterator2.prototype.getCurrentTokenPosition = function() {
            return { row: this.$row, column: this.getCurrentTokenColumn() };
          };
          TokenIterator2.prototype.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
          };
          return TokenIterator2;
        }()
      );
      exports2.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../../lib/oop");
      var Behaviour = require3("../behaviour").Behaviour;
      var TokenIterator = require3("../../token_iterator").TokenIterator;
      var lang = require3("../../lib/lang");
      var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
      var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
      var context;
      var contextCache = {};
      var defaultQuotes = { '"': '"', "'": "'" };
      var initContext = function(editor) {
        var id = -1;
        if (editor.multiSelect) {
          id = editor.selection.index;
          if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = { rangeCount: editor.multiSelect.rangeCount };
        }
        if (contextCache[id])
          return context = contextCache[id];
        context = contextCache[id] = {
          autoInsertedBrackets: 0,
          autoInsertedRow: -1,
          autoInsertedLineEnd: "",
          maybeInsertedBrackets: 0,
          maybeInsertedRow: -1,
          maybeInsertedLineStart: "",
          maybeInsertedLineEnd: ""
        };
      };
      var getWrapped = function(selection, selected, opening, closing) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
          text: opening + selected + closing,
          selection: [
            0,
            selection.start.column + 1,
            rowDiff,
            selection.end.column + (rowDiff ? 0 : 1)
          ]
        };
      };
      var CstyleBehaviour;
      CstyleBehaviour = function(options) {
        options = options || {};
        this.add("braces", "insertion", function(state, action, editor, session, text) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (text == "{") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            var token = session.getTokenAt(cursor.row, cursor.column);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "{", "}");
            } else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
              var excludeTokens = [
                /tag\-(?:open|name)/,
                /attribute\-name/
              ];
              if (excludeTokens.some(function(el) {
                return el.test(token.type);
              }) || /(string)\.quasi/.test(token.type) && token.value[cursor.column - token.start - 1] !== "$")
                return;
              CstyleBehaviour.recordAutoInsert(editor, session, "}");
              return {
                text: "{}",
                selection: [1, 1]
              };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {
                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                  text: "{}",
                  selection: [1, 1]
                };
              } else {
                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                return {
                  text: "{",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "}") {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "}") {
              var matching = session.$findOpeningBracket("}", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
              closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === "}") {
              var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, "}");
              if (!openBracePos)
                return null;
              var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
              var next_indent = this.$getIndent(line);
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
              return;
            }
            var indent = next_indent + session.getTabString();
            return {
              text: "\n" + indent + "\n" + next_indent + closing,
              selection: [1, indent.length, 1, indent.length]
            };
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
        });
        this.add("braces", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "{") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == "}") {
              range.end.column++;
              return range;
            } else {
              context.maybeInsertedBrackets--;
            }
          }
        });
        this.add("parens", "insertion", function(state, action, editor, session, text) {
          if (text == "(") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "(", ")");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, ")");
              return {
                text: "()",
                selection: [1, 1]
              };
            }
          } else if (text == ")") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ")") {
              var matching = session.$findOpeningBracket(")", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("parens", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "(") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ")") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("brackets", "insertion", function(state, action, editor, session, text) {
          if (text == "[") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "[", "]");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, "]");
              return {
                text: "[]",
                selection: [1, 1]
              };
            }
          } else if (text == "]") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "]") {
              var matching = session.$findOpeningBracket("]", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("brackets", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "[") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == "]") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
              return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var leftChar = line.substring(cursor.column - 1, cursor.column);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              var token = session.getTokenAt(cursor.row, cursor.column);
              var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
              if (leftChar == "\\" && token && /escape/.test(token.type))
                return null;
              var stringBefore = token && /string|escape/.test(token.type);
              var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
              var pair;
              if (rightChar == quote) {
                pair = stringBefore !== stringAfter;
                if (pair && /string\.end/.test(rightToken.type))
                  pair = false;
              } else {
                if (stringBefore && !stringAfter)
                  return null;
                if (stringBefore && stringAfter)
                  return null;
                var wordRe = session.$mode.tokenRe;
                wordRe.lastIndex = 0;
                var isWordBefore = wordRe.test(leftChar);
                wordRe.lastIndex = 0;
                var isWordAfter = wordRe.test(rightChar);
                var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
                if (!shouldPairQuotes && isWordBefore || isWordAfter)
                  return null;
                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                  return null;
                var charBefore = line[cursor.column - 2];
                if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
                  return null;
                pair = true;
              }
              return {
                text: pair ? quote + quote : "",
                selection: [1, 1]
              };
            }
          }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
        if (options.closeDocComment !== false) {
          this.add("doc comment end", "insertion", function(state, action, editor, session, text) {
            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor.selection.isEmpty()) {
              var cursor = editor.getCursorPosition();
              if (cursor.column === 0) {
                return;
              }
              var line = session.doc.getLine(cursor.row);
              var nextLine = session.doc.getLine(cursor.row + 1);
              var tokens = session.getTokens(cursor.row);
              var index = 0;
              for (var i = 0; i < tokens.length; i++) {
                index += tokens[i].value.length;
                var currentToken = tokens[i];
                if (index >= cursor.column) {
                  if (index === cursor.column) {
                    if (!/\.doc/.test(currentToken.type)) {
                      return;
                    }
                    if (/\*\//.test(currentToken.value)) {
                      var nextToken = tokens[i + 1];
                      if (!nextToken || !/\.doc/.test(nextToken.type)) {
                        return;
                      }
                    }
                  }
                  var cursorPosInToken = cursor.column - (index - currentToken.value.length);
                  var closeDocPos = currentToken.value.indexOf("*/");
                  var openDocPos = currentToken.value.indexOf("/**", closeDocPos > -1 ? closeDocPos + 2 : 0);
                  if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {
                    return;
                  }
                  if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) {
                    return;
                  }
                  break;
                }
              }
              var indent = this.$getIndent(line);
              if (/\s*\*/.test(nextLine)) {
                if (/^\s*\*/.test(line)) {
                  return {
                    text: text + indent + "* ",
                    selection: [1, 2 + indent.length, 1, 2 + indent.length]
                  };
                } else {
                  return {
                    text: text + indent + " * ",
                    selection: [1, 3 + indent.length, 1, 3 + indent.length]
                  };
                }
              }
              if (/\/\*\*/.test(line.substring(0, cursor.column))) {
                return {
                  text: text + indent + " * " + text + " " + indent + "*/",
                  selection: [1, 4 + indent.length, 1, 4 + indent.length]
                };
              }
            }
          });
        }
      };
      CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
          if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
          var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
          if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour["$matchTokenType"] = function(token, types) {
        return types.indexOf(token.type || token) > -1;
      };
      CstyleBehaviour["recordAutoInsert"] = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0]))
          context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
      };
      CstyleBehaviour["recordMaybeInsert"] = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isMaybeInsertedClosing"](cursor, line))
          context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
      };
      CstyleBehaviour["isAutoInsertedClosing"] = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour["isMaybeInsertedClosing"] = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour["popAutoInsertedClosing"] = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
      };
      CstyleBehaviour["clearMaybeInsertedClosing"] = function() {
        if (context) {
          context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = -1;
        }
      };
      oop.inherits(CstyleBehaviour, Behaviour);
      exports2.CstyleBehaviour = CstyleBehaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
      var code = 0;
      var str = [];
      for (var i = 0; i < wordChars.length; i += 2) {
        str.push(code += wordChars[i]);
        if (wordChars[i + 1])
          str.push(45, code += wordChars[i + 1]);
      }
      exports2.wordChars = String.fromCharCode.apply(null, str);
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var config = require3("../config");
      var Tokenizer = require3("../tokenizer").Tokenizer;
      var TextHighlightRules = require3("./text_highlight_rules").TextHighlightRules;
      var CstyleBehaviour = require3("./behaviour/cstyle").CstyleBehaviour;
      var unicode = require3("../unicode");
      var lang = require3("../lib/lang");
      var TokenIterator = require3("../token_iterator").TokenIterator;
      var Range = require3("../range").Range;
      var Mode;
      Mode = function() {
        this.HighlightRules = TextHighlightRules;
      };
      (function() {
        this.$defaultBehaviour = new CstyleBehaviour();
        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
          var doc = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment)
              return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function(line, i) {
              if (testRemove(line, i))
                return;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
              }
            };
            var uncomment = function(line, i) {
              var m;
              if (m = line.match(regexpEnd))
                doc.removeInLine(i, line.length - m[0].length, line.length);
              if (m = line.match(regexpStart))
                doc.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function(line, row) {
              if (regexpStart.test(line))
                return true;
              var tokens = session.getTokens(row);
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i].type === "comment")
                  return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function(line, i) {
              var m = line.match(regexpStart);
              if (!m)
                return;
              var start = m[1].length, end = m[0].length;
              if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                end--;
              doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent))
                  doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
                else
                  doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
              }
            };
            var testRemove = function(line, i) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ")
                spaces++;
              if (spaces % tabSize != 0)
                return false;
              var spaces = 0;
              while (line.charAt(after++) == " ")
                spaces++;
              if (tabSize > 2)
                return spaces % tabSize != tabSize - 1;
              else
                return spaces % tabSize == 0;
            };
          }
          function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
              fun(doc.getLine(i), i);
          }
          var minEmptyLength = Infinity;
          iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent)
                minIndent = indent;
              if (shouldRemove && !testRemove(line, i))
                shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment)
            return;
          if (!comment.start && comment[0])
            comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          var sel = session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow, colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.start);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                startRange = new Range(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.end);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                endRange = new Range(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange)
              session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
          return false;
        };
        this.autoOutdent = function(state, doc, row) {
        };
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
          return null;
        };
        this.createModeDelegates = function(mapping) {
          this.$embeds = [];
          this.$modes = {};
          for (var i in mapping) {
            if (mapping[i]) {
              var Mode2 = mapping[i];
              var id = Mode2.prototype.$id;
              var mode = config.$modes[id];
              if (!mode)
                config.$modes[id] = mode = new Mode2();
              if (!config.$modes[i])
                config.$modes[i] = mode;
              this.$embeds.push(i);
              this.$modes[i] = mode;
            }
          }
          var delegations = [
            "toggleBlockComment",
            "toggleCommentLines",
            "getNextLineIndent",
            "checkOutdent",
            "autoOutdent",
            "transformAction",
            "getCompletions"
          ];
          var _loop_1 = function(i2) {
            (function(scope) {
              var functionName = delegations[i2];
              var defaultHandler = scope[functionName];
              scope[delegations[i2]] = function() {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            })(this_1);
          };
          var this_1 = this;
          for (var i = 0; i < delegations.length; i++) {
            _loop_1(i);
          }
        };
        this.$delegator = function(method, args, defaultHandler) {
          var state = args[0] || "start";
          if (typeof state != "string") {
            if (Array.isArray(state[2])) {
              var language = state[2][state[2].length - 1];
              var mode = this.$modes[language];
              if (mode)
                return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
          }
          for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]])
              continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
              args[0] = split[1];
              var mode = this.$modes[this.$embeds[i]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : void 0;
        };
        this.transformAction = function(state, action, editor, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function(append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer["rules"];
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0, l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token))
                    completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append)
            return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
          if (!this.$highlightRules)
            this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function(word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports2.Mode = Mode;
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("./lib/dom");
      var LineWidgets = (
        /** @class */
        function() {
          function LineWidgets2(session) {
            this.session = session;
            this.session.widgetManager = this;
            this.session.getRowLength = this.getRowLength;
            this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
            this.updateOnChange = this.updateOnChange.bind(this);
            this.renderWidgets = this.renderWidgets.bind(this);
            this.measureWidgets = this.measureWidgets.bind(this);
            this.session._changedWidgets = [];
            this.$onChangeEditor = this.$onChangeEditor.bind(this);
            this.session.on("change", this.updateOnChange);
            this.session.on("changeFold", this.updateOnFold);
            this.session.on("changeEditor", this.$onChangeEditor);
          }
          LineWidgets2.prototype.getRowLength = function(row) {
            var h;
            if (this.lineWidgets)
              h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else
              h = 0;
            if (!this["$useWrapMode"] || !this["$wrapData"][row]) {
              return 1 + h;
            } else {
              return this["$wrapData"][row].length + 1 + h;
            }
          };
          LineWidgets2.prototype.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w2) {
              if (w2 && w2.rowCount && !w2.hidden)
                screenRows += w2.rowCount;
            });
            return screenRows;
          };
          LineWidgets2.prototype.$onChangeEditor = function(e) {
            this.attach(e.editor);
          };
          LineWidgets2.prototype.attach = function(editor) {
            if (editor && editor.widgetManager && editor.widgetManager != this)
              editor.widgetManager.detach();
            if (this.editor == editor)
              return;
            this.detach();
            this.editor = editor;
            if (editor) {
              editor.widgetManager = this;
              editor.renderer.on("beforeRender", this.measureWidgets);
              editor.renderer.on("afterRender", this.renderWidgets);
            }
          };
          LineWidgets2.prototype.detach = function(e) {
            var editor = this.editor;
            if (!editor)
              return;
            this.editor = null;
            editor.widgetManager = null;
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w2) {
              if (w2 && w2.el && w2.el.parentNode) {
                w2._inDocument = false;
                w2.el.parentNode.removeChild(w2.el);
              }
            });
          };
          LineWidgets2.prototype.updateOnFold = function(e, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e.action)
              return;
            var fold = e.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e.action == "add";
            for (var i = start + 1; i < end; i++) {
              if (lineWidgets[i])
                lineWidgets[i].hidden = hide;
            }
            if (lineWidgets[end]) {
              if (hide) {
                if (!lineWidgets[start])
                  lineWidgets[start] = lineWidgets[end];
                else
                  lineWidgets[end].hidden = hide;
              } else {
                if (lineWidgets[start] == lineWidgets[end])
                  lineWidgets[start] = void 0;
                lineWidgets[end].hidden = hide;
              }
            }
          };
          LineWidgets2.prototype.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              var removed = lineWidgets.splice(startRow + 1, len);
              if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
              }
              removed.forEach(function(w2) {
                w2 && this.removeLineWidget(w2);
              }, this);
              this.$updateRows();
            } else {
              var args = new Array(len);
              if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                  startRow++;
              }
              args.unshift(startRow, 0);
              lineWidgets.splice.apply(lineWidgets, args);
              this.$updateRows();
            }
          };
          LineWidgets2.prototype.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var noWidgets = true;
            lineWidgets.forEach(function(w2, i) {
              if (w2) {
                noWidgets = false;
                w2.row = i;
                while (w2.$oldWidget) {
                  w2.$oldWidget.row = i;
                  w2 = w2.$oldWidget;
                }
              }
            });
            if (noWidgets)
              this.session.lineWidgets = null;
          };
          LineWidgets2.prototype.$registerLineWidget = function(w2) {
            if (!this.session.lineWidgets)
              this.session.lineWidgets = new Array(this.session.getLength());
            var old = this.session.lineWidgets[w2.row];
            if (old) {
              w2.$oldWidget = old;
              if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
              }
            }
            this.session.lineWidgets[w2.row] = w2;
            return w2;
          };
          LineWidgets2.prototype.addLineWidget = function(w2) {
            this.$registerLineWidget(w2);
            w2.session = this.session;
            if (!this.editor)
              return w2;
            var renderer = this.editor.renderer;
            if (w2.html && !w2.el) {
              w2.el = dom.createElement("div");
              w2.el.innerHTML = w2.html;
            }
            if (w2.text && !w2.el) {
              w2.el = dom.createElement("div");
              w2.el.textContent = w2.text;
            }
            if (w2.el) {
              dom.addCssClass(w2.el, "ace_lineWidgetContainer");
              if (w2.className) {
                dom.addCssClass(w2.el, w2.className);
              }
              w2.el.style.position = "absolute";
              w2.el.style.zIndex = "5";
              renderer.container.appendChild(w2.el);
              w2._inDocument = true;
              if (!w2.coverGutter) {
                w2.el.style.zIndex = "3";
              }
              if (w2.pixelHeight == null) {
                w2.pixelHeight = w2.el.offsetHeight;
              }
            }
            if (w2.rowCount == null) {
              w2.rowCount = w2.pixelHeight / renderer.layerConfig.lineHeight;
            }
            var fold = this.session.getFoldAt(w2.row, 0);
            w2.$fold = fold;
            if (fold) {
              var lineWidgets = this.session.lineWidgets;
              if (w2.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w2;
              else
                w2.hidden = true;
            }
            this.session._emit("changeFold", { data: { start: { row: w2.row } } });
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w2);
            return w2;
          };
          LineWidgets2.prototype.removeLineWidget = function(w2) {
            w2._inDocument = false;
            w2.session = null;
            if (w2.el && w2.el.parentNode)
              w2.el.parentNode.removeChild(w2.el);
            if (w2.editor && w2.editor.destroy)
              try {
                w2.editor.destroy();
              } catch (e) {
              }
            if (this.session.lineWidgets) {
              var w1 = this.session.lineWidgets[w2.row];
              if (w1 == w2) {
                this.session.lineWidgets[w2.row] = w2.$oldWidget;
                if (w2.$oldWidget)
                  this.onWidgetChanged(w2.$oldWidget);
              } else {
                while (w1) {
                  if (w1.$oldWidget == w2) {
                    w1.$oldWidget = w2.$oldWidget;
                    break;
                  }
                  w1 = w1.$oldWidget;
                }
              }
            }
            this.session._emit("changeFold", { data: { start: { row: w2.row } } });
            this.$updateRows();
          };
          LineWidgets2.prototype.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w2 = lineWidgets && lineWidgets[row];
            var list = [];
            while (w2) {
              list.push(w2);
              w2 = w2.$oldWidget;
            }
            return list;
          };
          LineWidgets2.prototype.onWidgetChanged = function(w2) {
            this.session._changedWidgets.push(w2);
            this.editor && this.editor.renderer.updateFull();
          };
          LineWidgets2.prototype.measureWidgets = function(e, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            if (!changedWidgets || !changedWidgets.length)
              return;
            var min2 = Infinity;
            for (var i = 0; i < changedWidgets.length; i++) {
              var w2 = changedWidgets[i];
              if (!w2 || !w2.el)
                continue;
              if (w2.session != this.session)
                continue;
              if (!w2._inDocument) {
                if (this.session.lineWidgets[w2.row] != w2)
                  continue;
                w2._inDocument = true;
                renderer.container.appendChild(w2.el);
              }
              w2.h = w2.el.offsetHeight;
              if (!w2.fixedWidth) {
                w2.w = w2.el.offsetWidth;
                w2.screenWidth = Math.ceil(w2.w / config.characterWidth);
              }
              var rowCount = w2.h / config.lineHeight;
              if (w2.coverLine) {
                rowCount -= this.session.getRowLineCount(w2.row);
                if (rowCount < 0)
                  rowCount = 0;
              }
              if (w2.rowCount != rowCount) {
                w2.rowCount = rowCount;
                if (w2.row < min2)
                  min2 = w2.row;
              }
            }
            if (min2 != Infinity) {
              this.session._emit("changeFold", { data: { start: { row: min2 } } });
              this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
          };
          LineWidgets2.prototype.renderWidgets = function(e, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            while (first > 0 && !lineWidgets[first])
              first--;
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;
            renderer.$cursorLayer.config = config;
            for (var i = first; i <= last; i++) {
              var w2 = lineWidgets[i];
              if (!w2 || !w2.el)
                continue;
              if (w2.hidden) {
                w2.el.style.top = -100 - (w2.pixelHeight || 0) + "px";
                continue;
              }
              if (!w2._inDocument) {
                w2._inDocument = true;
                renderer.container.appendChild(w2.el);
              }
              var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
              if (!w2.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w2.row);
              w2.el.style.top = top - config.offset + "px";
              var left = w2.coverGutter ? 0 : renderer.gutterWidth;
              if (!w2.fixedWidth)
                left -= renderer.scrollLeft;
              w2.el.style.left = left + "px";
              if (w2.fullWidth && w2.screenWidth) {
                w2.el.style.minWidth = config.width + 2 * config.padding + "px";
              }
              if (w2.fixedWidth) {
                w2.el.style.right = renderer.scrollBar.getWidth() + "px";
              } else {
                w2.el.style.right = "";
              }
            }
          };
          return LineWidgets2;
        }()
      );
      exports2.LineWidgets = LineWidgets;
    });
    ace.define("ace/apply_delta", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      function throwDeltaError(delta, errorText) {
        console.log("Invalid Delta:", delta);
        throw "Invalid Delta: " + errorText;
      }
      function positionInDocument(docLines, position) {
        return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
      }
      function validateDelta(docLines, delta) {
        if (delta.action != "insert" && delta.action != "remove")
          throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
        if (!(delta.lines instanceof Array))
          throwDeltaError(delta, "delta.lines must be an Array");
        if (!delta.start || !delta.end)
          throwDeltaError(delta, "delta.start/end must be an present");
        var start = delta.start;
        if (!positionInDocument(docLines, delta.start))
          throwDeltaError(delta, "delta.start must be contained in document");
        var end = delta.end;
        if (delta.action == "remove" && !positionInDocument(docLines, end))
          throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
        var numRangeRows = end.row - start.row;
        var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
        if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
          throwDeltaError(delta, "delta.range must match delta lines");
      }
      exports2.applyDelta = function(docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./lib/oop");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var Anchor = (
        /** @class */
        function() {
          function Anchor2(doc, row, column) {
            this.$onChange = this.onChange.bind(this);
            this.attach(doc);
            if (typeof row != "number")
              this.setPosition(row.row, row.column);
            else
              this.setPosition(row, column);
          }
          Anchor2.prototype.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
          };
          Anchor2.prototype.getDocument = function() {
            return this.document;
          };
          Anchor2.prototype.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
              return;
            if (delta.start.row > this.row)
              return;
            var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(point.row, point.column, true);
          };
          Anchor2.prototype.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
              pos = {
                row,
                column
              };
            } else {
              pos = this.$clipPositionToDocument(row, column);
            }
            if (this.row == pos.row && this.column == pos.column)
              return;
            var old = {
              row: this.row,
              column: this.column
            };
            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
              old,
              value: pos
            });
          };
          Anchor2.prototype.detach = function() {
            this.document.off("change", this.$onChange);
          };
          Anchor2.prototype.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
          };
          Anchor2.prototype.$clipPositionToDocument = function(row, column) {
            var pos = {};
            if (row >= this.document.getLength()) {
              pos.row = Math.max(0, this.document.getLength() - 1);
              pos.column = this.document.getLine(pos.row).length;
            } else if (row < 0) {
              pos.row = 0;
              pos.column = 0;
            } else {
              pos.row = row;
              pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }
            if (column < 0)
              pos.column = 0;
            return pos;
          };
          return Anchor2;
        }()
      );
      Anchor.prototype.$insertRight = false;
      oop.implement(Anchor.prototype, EventEmitter);
      function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
      }
      function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
          return {
            row: point.row,
            column: point.column
          };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
          return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
          };
        }
        return {
          row: deltaStart.row,
          column: deltaStart.column
        };
      }
      exports2.Anchor = Anchor;
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./lib/oop");
      var applyDelta = require3("./apply_delta").applyDelta;
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var Range = require3("./range").Range;
      var Anchor = require3("./anchor").Anchor;
      var Document = (
        /** @class */
        function() {
          function Document2(textOrLines) {
            this.$lines = [""];
            if (textOrLines.length === 0) {
              this.$lines = [""];
            } else if (Array.isArray(textOrLines)) {
              this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
            } else {
              this.insert({ row: 0, column: 0 }, textOrLines);
            }
          }
          Document2.prototype.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({ row: 0, column: 0 }, text || "");
          };
          Document2.prototype.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
          };
          Document2.prototype.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
          };
          Document2.prototype.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match ? match[1] : "\n";
            this._signal("changeNewLineMode");
          };
          Document2.prototype.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
          };
          Document2.prototype.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
              return;
            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
          };
          Document2.prototype.getNewLineMode = function() {
            return this.$newLineMode;
          };
          Document2.prototype.isNewLine = function(text) {
            return text == "\r\n" || text == "\r" || text == "\n";
          };
          Document2.prototype.getLine = function(row) {
            return this.$lines[row] || "";
          };
          Document2.prototype.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
          };
          Document2.prototype.getAllLines = function() {
            return this.getLines(0, this.getLength());
          };
          Document2.prototype.getLength = function() {
            return this.$lines.length;
          };
          Document2.prototype.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
          };
          Document2.prototype.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
              lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
              lines = this.getLines(range.start.row, range.end.row);
              lines[0] = (lines[0] || "").substring(range.start.column);
              var l = lines.length - 1;
              if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
          };
          Document2.prototype.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
          };
          Document2.prototype.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
          };
          Document2.prototype.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, ["", ""]);
          };
          Document2.prototype.insert = function(position, text) {
            if (this.getLength() <= 1)
              this.$detectNewLine(text);
            return this.insertMergedLines(position, this.$split(text));
          };
          Document2.prototype.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines: [text]
            }, true);
            return this.clonePos(end);
          };
          Document2.prototype.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === void 0) {
              row = length;
            } else if (row < 0) {
              row = 0;
            } else if (row >= length) {
              row = length - 1;
              column = void 0;
            }
            var line = this.getLine(row);
            if (column == void 0)
              column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return { row, column };
          };
          Document2.prototype.clonePos = function(pos) {
            return { row: pos.row, column: pos.column };
          };
          Document2.prototype.pos = function(row, column) {
            return { row, column };
          };
          Document2.prototype.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
              position.row = Math.max(0, length - 1);
              position.column = this.getLine(length - 1).length;
            } else {
              position.row = Math.max(0, position.row);
              position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
          };
          Document2.prototype.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
              lines = lines.concat([""]);
              column = 0;
            } else {
              lines = [""].concat(lines);
              row--;
              column = this.$lines[row].length;
            }
            this.insertMergedLines({ row, column }, lines);
          };
          Document2.prototype.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
              row: start.row + lines.length - 1,
              column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines
            });
            return this.clonePos(end);
          };
          Document2.prototype.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            });
            return this.clonePos(start);
          };
          Document2.prototype.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            }, true);
            return this.clonePos(start);
          };
          Document2.prototype.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine = lastRow < this.getLength() - 1;
            var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
            var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
            var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
            var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            this.applyDelta({
              start: range.start,
              end: range.end,
              action: "remove",
              lines: this.getLinesForRange(range)
            });
            return deletedLines;
          };
          Document2.prototype.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
              this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
              });
            }
          };
          Document2.prototype.replace = function(range, text) {
            if (!(range instanceof Range))
              range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
              return range.start;
            if (text == this.getTextRange(range))
              return range.end;
            this.remove(range);
            var end;
            if (text) {
              end = this.insert(range.start, text);
            } else {
              end = range.start;
            }
            return end;
          };
          Document2.prototype.applyDeltas = function(deltas) {
            for (var i = 0; i < deltas.length; i++) {
              this.applyDelta(deltas[i]);
            }
          };
          Document2.prototype.revertDeltas = function(deltas) {
            for (var i = deltas.length - 1; i >= 0; i--) {
              this.revertDelta(deltas[i]);
            }
          };
          Document2.prototype.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
              return;
            }
            if (isInsert && delta.lines.length > 2e4) {
              this.$splitAndapplyLargeDelta(delta, 2e4);
            } else {
              applyDelta(this.$lines, delta, doNotValidate);
              this._signal("change", delta);
            }
          };
          Document2.prototype.$safeApplyDelta = function(delta) {
            var docLength = this.$lines.length;
            if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
              this.applyDelta(delta);
            }
          };
          Document2.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row;
            var column = delta.start.column;
            for (var from = 0, to2 = 0; from < l; from = to2) {
              to2 += MAX - 1;
              var chunk = lines.slice(from, to2);
              chunk.push("");
              this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to2, column = 0),
                action: delta.action,
                lines: chunk
              }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
          };
          Document2.prototype.revertDelta = function(delta) {
            this.$safeApplyDelta({
              start: this.clonePos(delta.start),
              end: this.clonePos(delta.end),
              action: delta.action == "insert" ? "remove" : "insert",
              lines: delta.lines.slice()
            });
          };
          Document2.prototype.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i = startRow || 0, l = lines.length; i < l; i++) {
              index -= lines[i].length + newlineLength;
              if (index < 0)
                return { row: i, column: index + lines[i].length + newlineLength };
            }
            return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
          };
          Document2.prototype.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i = startRow || 0; i < row; ++i)
              index += lines[i].length + newlineLength;
            return index + pos.column;
          };
          Document2.prototype.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
          };
          return Document2;
        }()
      );
      Document.prototype.$autoNewLine = "";
      Document.prototype.$newLineMode = "auto";
      oop.implement(Document.prototype, EventEmitter);
      exports2.Document = Document;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./lib/oop");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = (
        /** @class */
        function() {
          function BackgroundTokenizer2(tokenizer, session) {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.tokenizer = tokenizer;
            var self2 = this;
            this.$worker = function() {
              if (!self2.running) {
                return;
              }
              var workerStart = /* @__PURE__ */ new Date();
              var currentLine = self2.currentLine;
              var endLine = -1;
              var doc = self2.doc;
              var startLine = currentLine;
              while (self2.lines[currentLine])
                currentLine++;
              var len = doc.getLength();
              var processedLines = 0;
              self2.running = false;
              while (currentLine < len) {
                self2.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                  currentLine++;
                } while (self2.lines[currentLine]);
                processedLines++;
                if (processedLines % 5 === 0 && /* @__PURE__ */ new Date() - workerStart > 20) {
                  self2.running = setTimeout(self2.$worker, 20);
                  break;
                }
              }
              self2.currentLine = currentLine;
              if (endLine == -1)
                endLine = currentLine;
              if (startLine <= endLine)
                self2.fireUpdateEvent(startLine, endLine);
            };
          }
          BackgroundTokenizer2.prototype.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];
            this.start(0);
          };
          BackgroundTokenizer2.prototype.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];
            this.stop();
          };
          BackgroundTokenizer2.prototype.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
              first: firstRow,
              last: lastRow
            };
            this._signal("update", { data });
          };
          BackgroundTokenizer2.prototype.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);
            this.stop();
            this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.scheduleStart = function() {
            if (!this.running)
              this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
              this.lines[startRow] = null;
            } else if (delta.action == "remove") {
              this.lines.splice(startRow, len + 1, null);
              this.states.splice(startRow, len + 1, null);
            } else {
              var args = Array(len + 1);
              args.unshift(startRow, 1);
              this.lines.splice.apply(this.lines, args);
              this.states.splice.apply(this.states, args);
            }
            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
            this.stop();
          };
          BackgroundTokenizer2.prototype.stop = function() {
            if (this.running)
              clearTimeout(this.running);
            this.running = false;
          };
          BackgroundTokenizer2.prototype.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
          };
          BackgroundTokenizer2.prototype.getState = function(row) {
            if (this.currentLine == row)
              this.$tokenizeRow(row);
            return this.states[row] || "start";
          };
          BackgroundTokenizer2.prototype.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];
            var data = this.tokenizer.getLineTokens(line, state, row);
            if (this.states[row] + "" !== data.state + "") {
              this.states[row] = data.state;
              this.lines[row + 1] = null;
              if (this.currentLine > row + 1)
                this.currentLine = row + 1;
            } else if (this.currentLine == row) {
              this.currentLine = row + 1;
            }
            return this.lines[row] = data.tokens;
          };
          BackgroundTokenizer2.prototype.cleanup = function() {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.removeAllListeners();
          };
          return BackgroundTokenizer2;
        }()
      );
      oop.implement(BackgroundTokenizer.prototype, EventEmitter);
      exports2.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var lang = require3("./lib/lang");
      var Range = require3("./range").Range;
      var SearchHighlight = (
        /** @class */
        function() {
          function SearchHighlight2(regExp, clazz, type) {
            if (type === void 0) {
              type = "text";
            }
            this.setRegexp(regExp);
            this.clazz = clazz;
            this.type = type;
            this.docLen = 0;
          }
          SearchHighlight2.prototype.setRegexp = function(regExp) {
            if (this.regExp + "" == regExp + "")
              return;
            this.regExp = regExp;
            this.cache = [];
          };
          SearchHighlight2.prototype.update = function(html, markerLayer, session, config) {
            if (!this.regExp)
              return;
            var start = config.firstRow;
            var end = config.lastRow;
            var renderedMarkerRanges = {};
            var _search = session.$editor && session.$editor.$search;
            var mtSearch = _search && _search.$isMultilineSearch(session.$editor.getLastSearchOptions());
            for (var i = start; i <= end; i++) {
              var ranges = this.cache[i];
              if (ranges == null || session.getValue().length != this.docLen) {
                if (mtSearch) {
                  ranges = [];
                  var match = _search.$multiLineForward(session, this.regExp, i, end);
                  if (match) {
                    var end_row = match.endRow <= end ? match.endRow - 1 : end;
                    if (end_row > i)
                      i = end_row;
                    ranges.push(new Range(match.startRow, match.startCol, match.endRow, match.endCol));
                  }
                  if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                } else {
                  ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                  if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                  ranges = ranges.map(function(match2) {
                    return new Range(i, match2.offset, i, match2.offset + match2.length);
                  });
                }
                this.cache[i] = ranges.length ? ranges : "";
              }
              if (ranges.length === 0)
                continue;
              for (var j3 = ranges.length; j3--; ) {
                var rangeToAddMarkerTo = ranges[j3].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString])
                  continue;
                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
              }
            }
            this.docLen = session.getValue().length;
          };
          return SearchHighlight2;
        }()
      );
      SearchHighlight.prototype.MAX_RANGES = 500;
      exports2.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var UndoManager = (
        /** @class */
        function() {
          function UndoManager2() {
            this.$keepRedoStack;
            this.$maxRev = 0;
            this.$fromUndo = false;
            this.$undoDepth = Infinity;
            this.reset();
          }
          UndoManager2.prototype.addSession = function(session) {
            this.$session = session;
          };
          UndoManager2.prototype.add = function(delta, allowMerge, session) {
            if (this.$fromUndo)
              return;
            if (delta == this.$lastDelta)
              return;
            if (!this.$keepRedoStack)
              this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
              this.lastDeltas = [];
              var undoStackLength = this.$undoStack.length;
              if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
              }
              this.$undoStack.push(this.lastDeltas);
              delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert")
              this.$lastDelta = delta;
            this.lastDeltas.push(delta);
          };
          UndoManager2.prototype.addSelection = function(selection, rev) {
            this.selections.push({
              value: selection,
              rev: rev || this.$rev
            });
          };
          UndoManager2.prototype.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
          };
          UndoManager2.prototype.markIgnored = function(from, to2) {
            if (to2 == null)
              to2 = this.$rev + 1;
            var stack = this.$undoStack;
            for (var i = stack.length; i--; ) {
              var delta = stack[i][0];
              if (delta.id <= from)
                break;
              if (delta.id < to2)
                delta.ignore = true;
            }
            this.lastDeltas = null;
          };
          UndoManager2.prototype.getSelection = function(rev, after) {
            var stack = this.selections;
            for (var i = stack.length; i--; ) {
              var selection = stack[i];
              if (selection.rev < rev) {
                if (after)
                  selection = stack[i + 1];
                return selection;
              }
            }
          };
          UndoManager2.prototype.getRevision = function() {
            return this.$rev;
          };
          UndoManager2.prototype.getDeltas = function(from, to2) {
            if (to2 == null)
              to2 = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for (var i = stack.length; i--; ) {
              var delta = stack[i][0];
              if (delta.id < to2 && !end)
                end = i + 1;
              if (delta.id <= from) {
                start = i + 1;
                break;
              }
            }
            return stack.slice(start, end);
          };
          UndoManager2.prototype.getChangedRanges = function(from, to2) {
            if (to2 == null)
              to2 = this.$rev + 1;
          };
          UndoManager2.prototype.getChangedLines = function(from, to2) {
            if (to2 == null)
              to2 = this.$rev + 1;
          };
          UndoManager2.prototype.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            if (!rearrangeUndoStack(stack, stack.length))
              return;
            if (!session)
              session = this.$session;
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
              this.$redoStack = [];
            this.$fromUndo = true;
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (deltaSet) {
              undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
              this.$redoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return undoSelectionRange;
          };
          UndoManager2.prototype.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            if (!session)
              session = this.$session;
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
              var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
              rebaseRedoStack(this.$redoStack, diff);
              this.$redoStackBaseRev = this.$rev;
              this.$redoStack.forEach(function(x) {
                x[0].id = ++this.$maxRev;
              }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            if (deltaSet) {
              redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
              this.$undoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return redoSelectionRange;
          };
          UndoManager2.prototype.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
          };
          UndoManager2.prototype.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
          };
          UndoManager2.prototype.canUndo = function() {
            return this.$undoStack.length > 0;
          };
          UndoManager2.prototype.canRedo = function() {
            return this.$redoStack.length > 0;
          };
          UndoManager2.prototype.bookmark = function(rev) {
            if (rev == void 0)
              rev = this.$rev;
            this.mark = rev;
          };
          UndoManager2.prototype.isAtBookmark = function() {
            return this.$rev === this.mark;
          };
          UndoManager2.prototype.toJSON = function() {
            return {
              $redoStack: this.$redoStack,
              $undoStack: this.$undoStack
            };
          };
          UndoManager2.prototype.fromJSON = function(json) {
            this.reset();
            this.$undoStack = json.$undoStack;
            this.$redoStack = json.$redoStack;
          };
          UndoManager2.prototype.$prettyPrint = function(delta) {
            if (delta)
              return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
          };
          return UndoManager2;
        }()
      );
      UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
      UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
      UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
      UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
      function rearrangeUndoStack(stack, pos) {
        for (var i = pos; i--; ) {
          var deltaSet = stack[i];
          if (deltaSet && !deltaSet[0].ignore) {
            while (i < pos - 1) {
              var swapped = swapGroups(stack[i], stack[i + 1]);
              stack[i] = swapped[0];
              stack[i + 1] = swapped[1];
              i++;
            }
            return true;
          }
        }
      }
      var Range = require3("./range").Range;
      var cmp = Range.comparePoints;
      var comparePoints = Range.comparePoints;
      function $updateMarkers(delta) {
        var isInsert = delta.action == "insert";
        var start = delta.start;
        var end = delta.end;
        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
        if (isInsert)
          end = start;
        for (var i in this.marks) {
          var point = this.marks[i];
          var cmp2 = comparePoints(point, start);
          if (cmp2 < 0) {
            continue;
          }
          if (cmp2 === 0) {
            if (isInsert) {
              if (point.bias == 1) {
                cmp2 = 1;
              } else {
                point.bias == -1;
                continue;
              }
            }
          }
          var cmp22 = isInsert ? cmp2 : comparePoints(point, end);
          if (cmp22 > 0) {
            point.row += rowShift;
            point.column += point.row == end.row ? colShift : 0;
            continue;
          }
          if (!isInsert && cmp22 <= 0) {
            point.row = start.row;
            point.column = start.column;
            if (cmp22 === 0)
              point.bias = 1;
          }
        }
      }
      function clonePos(pos) {
        return { row: pos.row, column: pos.column };
      }
      function cloneDelta(d) {
        return {
          start: clonePos(d.start),
          end: clonePos(d.end),
          action: d.action,
          lines: d.lines.slice()
        };
      }
      function stringifyDelta(d) {
        d = d || this;
        if (Array.isArray(d)) {
          return d.map(stringifyDelta).join("\n");
        }
        var type = "";
        if (d.action) {
          type = d.action == "insert" ? "+" : "-";
          type += "[" + d.lines + "]";
        } else if (d.value) {
          if (Array.isArray(d.value)) {
            type = d.value.map(stringifyRange).join("\n");
          } else {
            type = stringifyRange(d.value);
          }
        }
        if (d.start) {
          type += stringifyRange(d);
        }
        if (d.id || d.rev) {
          type += "	(" + (d.id || d.rev) + ")";
        }
        return type;
      }
      function stringifyRange(r) {
        return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
      }
      function swap(d1, d2) {
        var i1 = d1.action == "insert";
        var i2 = d2.action == "insert";
        if (i1 && i2) {
          if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
          } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, 1);
          } else {
            return null;
          }
        } else if (i1 && !i2) {
          if (cmp(d2.start, d1.end) >= 0) {
            shift(d2, d1, -1);
          } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
          } else {
            return null;
          }
        } else if (!i1 && i2) {
          if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, 1);
          } else if (cmp(d2.start, d1.start) <= 0) {
            shift(d1, d2, 1);
          } else {
            return null;
          }
        } else if (!i1 && !i2) {
          if (cmp(d2.start, d1.start) >= 0) {
            shift(d2, d1, 1);
          } else if (cmp(d2.end, d1.start) <= 0) {
            shift(d1, d2, -1);
          } else {
            return null;
          }
        }
        return [d2, d1];
      }
      function swapGroups(ds1, ds2) {
        for (var i = ds1.length; i--; ) {
          for (var j3 = 0; j3 < ds2.length; j3++) {
            if (!swap(ds1[i], ds2[j3])) {
              while (i < ds1.length) {
                while (j3--) {
                  swap(ds2[j3], ds1[i]);
                }
                j3 = ds2.length;
                i++;
              }
              return [ds1, ds2];
            }
          }
        }
        ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
        return [ds2, ds1];
      }
      function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        if (i1 && i2) {
          if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, c1, 1);
          }
        } else if (i1 && !i2) {
          if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
          } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, 1);
          }
        } else if (!i1 && i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, 1);
          } else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, 1);
          }
        } else if (!i1 && !i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
          } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
              before = d1;
              d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
              after = splitDelta(d1, c1.end);
            }
            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
              d1.lines = after.lines;
              d1.start = after.start;
              d1.end = after.end;
              after = d1;
            }
            return [c1, before, after].filter(Boolean);
          }
        }
        return [c1, d1];
      }
      function shift(d1, d2, dir) {
        shiftPos(d1.start, d2.start, d2.end, dir);
        shiftPos(d1.end, d2.start, d2.end, dir);
      }
      function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
          pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
      }
      function splitDelta(c, pos) {
        var lines = c.lines;
        var end = c.end;
        c.end = clonePos(pos);
        var rowsBefore = c.end.row - c.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        var col = rowsBefore ? pos.column : pos.column - c.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col);
        var rest = {
          start: clonePos(pos),
          end,
          lines: otherLines,
          action: c.action
        };
        return rest;
      }
      function moveDeltasByOne(redoStack, d) {
        d = cloneDelta(d);
        for (var j3 = redoStack.length; j3--; ) {
          var deltaSet = redoStack[j3];
          for (var i = 0; i < deltaSet.length; i++) {
            var x = deltaSet[i];
            var xformed = xform(x, d);
            d = xformed[0];
            if (xformed.length != 2) {
              if (xformed[2]) {
                deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                i++;
              } else if (!xformed[1]) {
                deltaSet.splice(i, 1);
                i--;
              }
            }
          }
          if (!deltaSet.length) {
            redoStack.splice(j3, 1);
          }
        }
        return redoStack;
      }
      function rebaseRedoStack(redoStack, deltaSets) {
        for (var i = 0; i < deltaSets.length; i++) {
          var deltas = deltaSets[i];
          for (var j3 = 0; j3 < deltas.length; j3++) {
            moveDeltasByOne(redoStack, deltas[j3]);
          }
        }
      }
      exports2.UndoManager = UndoManager;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("../range").Range;
      var FoldLine = (
        /** @class */
        function() {
          function FoldLine2(foldData, folds) {
            this.foldData = foldData;
            if (Array.isArray(folds)) {
              this.folds = folds;
            } else {
              folds = this.folds = [folds];
            }
            var last = folds[folds.length - 1];
            this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
            this.start = this.range.start;
            this.end = this.range.end;
            this.folds.forEach(function(fold) {
              fold.setFoldLine(this);
            }, this);
          }
          FoldLine2.prototype.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
              fold.start.row += shift;
              fold.end.row += shift;
            });
          };
          FoldLine2.prototype.addFold = function(fold) {
            if (fold.sameRow) {
              if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
              }
              this.folds.push(fold);
              this.folds.sort(function(a, b2) {
                return -a.range.compareEnd(b2.start.row, b2.start.column);
              });
              if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
              } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
              }
            } else if (fold.start.row == this.end.row) {
              this.folds.push(fold);
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
              this.folds.unshift(fold);
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            } else {
              throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold.foldLine = this;
          };
          FoldLine2.prototype.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
          };
          FoldLine2.prototype.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
            if (endRow == null) {
              endRow = this.end.row;
              endColumn = this.end.column;
            }
            for (var i = 0; i < folds.length; i++) {
              fold = folds[i];
              cmp = fold.range.compareStart(endRow, endColumn);
              if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
              }
              stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
              stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
              if (stop || cmp === 0) {
                return;
              }
              isNewRow = !fold.sameRow;
              lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
          };
          FoldLine2.prototype.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for (var i = 0; i < this.folds.length; i++) {
              fold = this.folds[i];
              cmp = fold.range.compareEnd(row, column);
              if (cmp == -1) {
                return {
                  fold,
                  kind: "after"
                };
              } else if (cmp === 0) {
                return {
                  fold,
                  kind: "inside"
                };
              }
            }
            return null;
          };
          FoldLine2.prototype.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column), fold, folds;
            if (ret) {
              fold = ret.fold;
              if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                window.console && window.console.log(row, column, fold);
              } else if (fold.start.row == row) {
                folds = this.folds;
                var i = folds.indexOf(fold);
                if (i === 0) {
                  this.start.column += len;
                }
                for (i; i < folds.length; i++) {
                  fold = folds[i];
                  fold.start.column += len;
                  if (!fold.sameRow) {
                    return;
                  }
                  fold.end.column += len;
                }
                this.end.column += len;
              }
            }
          };
          FoldLine2.prototype.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            if (!pos || pos.kind == "inside")
              return null;
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            var i = folds.indexOf(fold);
            var foldBefore = folds[i - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i, folds.length - i);
            var newFoldLine = new FoldLine2(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
          };
          FoldLine2.prototype.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i = 0; i < folds.length; i++) {
              this.addFold(folds[i]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
          };
          FoldLine2.prototype.toString = function() {
            var ret = [this.range.toString() + ": ["];
            this.folds.forEach(function(fold) {
              ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
          };
          FoldLine2.prototype.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;
            for (var i = 0; i < this.folds.length; i++) {
              var fold = this.folds[i];
              idx -= fold.start.column - lastFoldEndColumn;
              if (idx < 0) {
                return {
                  row: fold.start.row,
                  column: fold.start.column + idx
                };
              }
              idx -= fold.placeholder.length;
              if (idx < 0) {
                return fold.start;
              }
              lastFoldEndColumn = fold.end.column;
            }
            return {
              row: this.end.row,
              column: this.end.column + idx
            };
          };
          return FoldLine2;
        }()
      );
      exports2.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = (
        /** @class */
        function() {
          function RangeList2() {
            this.ranges = [];
            this.$bias = 1;
          }
          RangeList2.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;
            for (var i = startIndex || 0; i < list.length; i++) {
              var range = list[i];
              var cmpEnd = comparePoints(pos, range.end);
              if (cmpEnd > 0)
                continue;
              var cmpStart = comparePoints(pos, range.start);
              if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
              if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
                return i;
              return -i - 1;
            }
            return -i - 1;
          };
          RangeList2.prototype.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            else
              endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
          };
          RangeList2.prototype.addList = function(list) {
            var removed = [];
            for (var i = list.length; i--; ) {
              removed.push.apply(removed, this.add(list[i]));
            }
            return removed;
          };
          RangeList2.prototype.substractPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges.splice(i, 1);
          };
          RangeList2.prototype.merge = function() {
            var removed = [];
            var list = this.ranges;
            list = list.sort(function(a, b2) {
              return comparePoints(a.start, b2.start);
            });
            var next = list[0], range;
            for (var i = 1; i < list.length; i++) {
              range = next;
              next = list[i];
              var cmp = comparePoints(range.end, next.start);
              if (cmp < 0)
                continue;
              if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;
              if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
              }
              list.splice(i, 1);
              removed.push(next);
              next = range;
              i--;
            }
            this.ranges = list;
            return removed;
          };
          RangeList2.prototype.contains = function(row, column) {
            return this.pointIndex({ row, column }) >= 0;
          };
          RangeList2.prototype.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
          };
          RangeList2.prototype.rangeAtPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0)
              return this.ranges[i];
          };
          RangeList2.prototype.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
              return [];
            var startIndex = this.pointIndex({ row: startRow, column: 0 });
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            var clipped = [];
            for (var i = startIndex; i < endIndex; i++) {
              clipped.push(list[i]);
            }
            return clipped;
          };
          RangeList2.prototype.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
          };
          RangeList2.prototype.attach = function(session) {
            if (this.session)
              this.detach();
            this.session = session;
            this.onChange = this.$onChange.bind(this);
            this.session.on("change", this.onChange);
          };
          RangeList2.prototype.detach = function() {
            if (!this.session)
              return;
            this.session.removeListener("change", this.onChange);
            this.session = null;
          };
          RangeList2.prototype.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for (var i = 0, n = ranges.length; i < n; i++) {
              var r = ranges[i];
              if (r.end.row >= startRow)
                break;
            }
            if (delta.action == "insert") {
              var lineDif = endRow - startRow;
              var colDiff = -start.column + end.column;
              for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > startRow)
                  break;
                if (r.start.row == startRow && r.start.column >= start.column) {
                  if (r.start.column == start.column && this.$bias <= 0) {
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                  if (r.end.column == start.column && this.$bias < 0) {
                    continue;
                  }
                  if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                    if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                      r.end.column -= colDiff;
                  }
                  r.end.column += colDiff;
                  r.end.row += lineDif;
                }
              }
            } else {
              var lineDif = startRow - endRow;
              var colDiff = start.column - end.column;
              for (; i < n; i++) {
                var r = ranges[i];
                if (r.start.row > endRow)
                  break;
                if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                  r.end.row = startRow;
                  r.end.column = start.column;
                } else if (r.end.row == endRow) {
                  if (r.end.column <= end.column) {
                    if (lineDif || r.end.column > start.column) {
                      r.end.column = start.column;
                      r.end.row = start.row;
                    }
                  } else {
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                  }
                } else if (r.end.row > endRow) {
                  r.end.row += lineDif;
                }
                if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                  r.start.row = startRow;
                  r.start.column = start.column;
                } else if (r.start.row == endRow) {
                  if (r.start.column <= end.column) {
                    if (lineDif || r.start.column > start.column) {
                      r.start.column = start.column;
                      r.start.row = start.row;
                    }
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                } else if (r.start.row > endRow) {
                  r.start.row += lineDif;
                }
              }
            }
            if (lineDif != 0 && i < n) {
              for (; i < n; i++) {
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
              }
            }
          };
          return RangeList2;
        }()
      );
      RangeList.prototype.comparePoints = comparePoints;
      exports2.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var RangeList = require3("../range_list").RangeList;
      var Fold = (
        /** @class */
        function(_super) {
          __extends(Fold2, _super);
          function Fold2(range, placeholder) {
            var _this = _super.call(this) || this;
            _this.foldLine = null;
            _this.placeholder = placeholder;
            _this.range = range;
            _this.start = range.start;
            _this.end = range.end;
            _this.sameRow = range.start.row == range.end.row;
            _this.subFolds = _this.ranges = [];
            return _this;
          }
          Fold2.prototype.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
          };
          Fold2.prototype.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
              fold.setFoldLine(foldLine);
            });
          };
          Fold2.prototype.clone = function() {
            var range = this.range.clone();
            var fold = new Fold2(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
              fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
          };
          Fold2.prototype.addSubFold = function(fold) {
            if (this.range.isEqual(fold))
              return;
            consumeRange(fold, this.start);
            var row = fold.start.row, column = fold.start.column;
            for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
              cmp = this.subFolds[i].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            var afterStart = this.subFolds[i];
            var firstConsumed = 0;
            if (cmp == 0) {
              if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
              else
                firstConsumed = 1;
            }
            var row = fold.range.end.row, column = fold.range.end.column;
            for (var j3 = i, cmp = -1; j3 < this.subFolds.length; j3++) {
              cmp = this.subFolds[j3].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            if (cmp == 0)
              j3++;
            var consumedFolds = this.subFolds.splice(i, j3 - i, fold);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for (var k2 = firstConsumed; k2 < last; k2++) {
              fold.addSubFold(consumedFolds[k2]);
            }
            fold.setFoldLine(this.foldLine);
            return fold;
          };
          Fold2.prototype.restoreRange = function(range) {
            return restoreRange(range, this.start);
          };
          return Fold2;
        }(RangeList)
      );
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
          point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0)
          point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
      exports2.Fold = Fold;
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator", "ace/mouse/mouse_event"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("../range").Range;
      var FoldLine = require3("./fold_line").FoldLine;
      var Fold = require3("./fold").Fold;
      var TokenIterator = require3("../token_iterator").TokenIterator;
      var MouseEvent2 = require3("../mouse/mouse_event").MouseEvent;
      function Folding() {
        this.getFoldAt = function(row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine)
            return null;
          var folds = foldLine.folds;
          for (var i = 0; i < folds.length; i++) {
            var range = folds[i].range;
            if (range.contains(row, column)) {
              if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                continue;
              } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                continue;
              }
              return folds[i];
            }
          }
        };
        this.getFoldsInRange = function(range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i].folds;
            for (var j3 = 0; j3 < folds.length; j3++) {
              var fold = folds[j3];
              cmp = fold.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function() {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i = 0; i < foldLines.length; i++)
            for (var j3 = 0; j3 < foldLines[i].folds.length; j3++)
              folds.push(foldLines[i].folds[j3]);
          return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine)
            return null;
          var lastFold = {
            end: { column: 0 }
          };
          var str, fold;
          for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold;
          }
          if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
          if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
          else if (trim == 1)
            return str.substring(column - lastFold.end.column);
          else
            return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function(first, last) {
          var foldData = this.$foldData, rowCount = last - first + 1;
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first)
                  rowCount -= last - start;
                else
                  rowCount = 0;
              }
              break;
            } else if (end >= first) {
              if (start >= first)
                rowCount -= end - start;
              else
                rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function(a, b2) {
            return a.start.row - b2.start.row;
          });
          return foldLine;
        };
        this.addFold = function(placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold;
          if (placeholder instanceof Fold)
            fold = placeholder;
          else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold.range);
          var startRow = fold.start.row;
          var startColumn = fold.start.column;
          var endRow = fold.end.row;
          var endColumn = fold.end.column;
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);
          if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            if (!fold.collapseChildren) {
              folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
              });
            }
          }
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold);
              added = true;
              if (!fold.sameRow) {
                var foldLineNext = foldData[i + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
          if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
          else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "add" });
          return fold;
        };
        this.addFolds = function(folds) {
          folds.forEach(function(fold) {
            this.addFold(fold);
          }, this);
        };
        this.removeFold = function(fold) {
          var foldLine = fold.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
          } else {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode)
              this.$updateWrapData(startRow, endRow);
            else
              this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "remove" });
        };
        this.removeFolds = function(folds) {
          var cloneFolds = [];
          for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
          }
          cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function(fold) {
          this.removeFold(fold);
          fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
          }
          fold.subFolds = [];
        };
        this.expandFolds = function(folds) {
          folds.forEach(function(fold) {
            this.expandFold(fold);
          }, this);
        };
        this.unfold = function(location2, expandInner) {
          var range, folds;
          if (location2 == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null)
              expandInner = true;
          } else if (typeof location2 == "number") {
            range = new Range(location2, 0, location2, this.getLine(location2).length);
          } else if ("row" in location2) {
            range = Range.fromPoints(location2, location2);
          } else if (Array.isArray(location2)) {
            folds = [];
            location2.forEach(function(range2) {
              folds = folds.concat(this.unfold(range2));
            }, this);
            return folds;
          } else {
            range = location2;
          }
          folds = this.getFoldsInRangeList(range);
          var outermostFolds = folds;
          while (folds.length == 1 && Range.comparePoints(folds[0].start, range.start) < 0 && Range.comparePoints(folds[0].end, range.end) > 0) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
          }
          if (expandInner != false) {
            this.removeFolds(folds);
          } else {
            this.expandFolds(folds);
          }
          if (outermostFolds.length)
            return outermostFolds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null)
            startRow = foldLine.start.row;
          if (startColumn == null)
            startColumn = 0;
          if (endRow == null)
            endRow = foldLine.end.row;
          if (endColumn == null)
            endColumn = this.getLine(endRow).length;
          var doc = this.doc;
          var textLine = "";
          foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
              return;
            if (row == startRow) {
              if (column < startColumn)
                return;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function() {
          var fd = [];
          fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
              return fold.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function(tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
              this.expandFold(fold);
              return;
            } else if (tryToUnfold) {
              var foldLine = this.getFoldLine(cursor.row);
              if (foldLine)
                this.expandFolds(foldLine.folds);
              return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
              if (range.comparePoint(bracketPos) == 1)
                range.end = bracketPos;
              else
                range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return;
            } else if (folds.length == 1) {
              fold = folds[0];
            }
          }
          if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
          if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
              return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          var type = token && token.type;
          if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
              type += "|doc-start|\\.doc";
            var re3 = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re3.test(token.type));
              token = iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;
            iterator = new TokenIterator(this, row, column);
            var initState = this.getState(iterator.$row);
            if (dir != -1) {
              var lastRow = -1;
              do {
                token = iterator.stepForward();
                if (lastRow == -1) {
                  var state = this.getState(iterator.$row);
                  if (initState.toString() !== state.toString())
                    lastRow = iterator.$row;
                } else if (iterator.$row > lastRow) {
                  break;
                }
              } while (token && re3.test(token.type));
              token = iterator.stepBackward();
            } else
              token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            if (range.start.row == range.end.row && range.start.column > range.end.column)
              return;
            return range;
          }
        };
        this.foldAll = function(startRow, endRow, depth, test) {
          if (depth == void 0)
            depth = 1e5;
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets)
            return;
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
              foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
              continue;
            if (test && !test(row))
              continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              range.collapseChildren = depth;
              this.addFold("...", range);
            }
          }
        };
        this.foldToLevel = function(level) {
          this.foldAll();
          while (level-- > 0)
            this.unfold(null, false);
        };
        this.foldAllComments = function() {
          var session = this;
          this.foldAll(null, null, null, function(row) {
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              if (token.type == "text" && /^\s+$/.test(token.value))
                continue;
              if (/comment/.test(token.type))
                return true;
              return false;
            }
          });
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
          if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style)
            return;
          this.$foldStyle = style;
          if (style == "manual")
            this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
          if (this.$foldMode == foldMode)
            return;
          this.$foldMode = foldMode;
          this.off("change", this.$updateFoldWidgets);
          this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
          this._signal("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
          this.on("change", this.$updateFoldWidgets);
          this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || ignoreCurrent && fw[row])
            return {};
          var i = row - 1, firstRange;
          while (i >= 0) {
            var c = fw[i];
            if (c == null)
              c = fw[i] = this.getFoldWidget(i);
            if (c == "start") {
              var range = this.getFoldWidgetRange(i);
              if (!firstRange)
                firstRange = range;
              if (range && range.end.row >= row)
                break;
            }
            i--;
          }
          return {
            range: i !== -1 && range,
            firstRange
          };
        };
        this.onFoldWidgetClick = function(row, e) {
          if (e instanceof MouseEvent2)
            e = e.domEvent;
          var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = e.target || e.srcElement;
            if (el && /ace_fold-widget/.test(el.className))
              el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function(row, options) {
          if (!this.getFoldWidget)
            return;
          var type = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type === "end" ? -1 : 1;
          var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold) {
            if (options.children || options.all)
              this.removeFold(fold);
            else
              this.expandFold(fold);
            return fold;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
              this.removeFold(fold);
              return fold;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
          } else if (range) {
            if (options.all)
              range.collapseChildren = 1e4;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range)
            return;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
              this.removeFold(fold);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function(delta) {
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == "remove") {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
        this.tokenizerUpdateFoldWidgets = function(e) {
          var rows = e.data;
          if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
              this.foldWidgets.splice(rows.first, this.foldWidgets.length);
          }
        };
      }
      exports2.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var TokenIterator = require3("../token_iterator").TokenIterator;
      var Range = require3("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function(position, chr) {
          if (position.column == 0)
            return null;
          var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
          if (charBeforeCursor == "")
            return null;
          var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match)
            return null;
          if (match[1])
            return this.$findClosingBracket(match[1], position);
          else
            return this.$findOpeningBracket(match[2], position);
        };
        this.getBracketRange = function(pos) {
          var line = this.getLine(pos.row);
          var before = true, range;
          var chr = line.charAt(pos.column - 1);
          var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match) {
            chr = line.charAt(pos.column);
            pos = { row: pos.row, column: pos.column + 1 };
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match)
            return null;
          if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.getMatchingBracketRanges = function(pos, isBackwards) {
          var line = this.getLine(pos.row);
          var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
          var chr = !isBackwards && line.charAt(pos.column - 1);
          var match = chr && chr.match(bracketsRegExp);
          if (!match) {
            chr = (isBackwards === void 0 || isBackwards) && line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match = chr && chr.match(bracketsRegExp);
          }
          if (!match)
            return null;
          var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
          var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos) : this.$findOpeningBracket(match[2], pos);
          if (!bracketPos)
            return [startRange];
          var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
          return [startRange, endRange];
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{",
          "<": ">",
          ">": "<"
        };
        this.$findOpeningBracket = function(bracket, position, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function(bracket, position, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            valueIndex = 0;
          }
          return null;
        };
        this.getMatchingTags = function(pos) {
          var iterator = new TokenIterator(this, pos.row, pos.column);
          var token = this.$findTagName(iterator);
          if (!token)
            return;
          var prevToken = iterator.stepBackward();
          if (prevToken.value === "<") {
            return this.$findClosingTag(iterator, token);
          } else {
            return this.$findOpeningTag(iterator, token);
          }
        };
        this.$findTagName = function(iterator) {
          var token = iterator.getCurrentToken();
          var found = false;
          var backward = false;
          if (token && token.type.indexOf("tag-name") === -1) {
            do {
              if (backward)
                token = iterator.stepBackward();
              else
                token = iterator.stepForward();
              if (token) {
                if (token.value === "/>") {
                  backward = true;
                } else if (token.type.indexOf("tag-name") !== -1) {
                  found = true;
                }
              }
            } while (token && !found);
          }
          return token;
        };
        this.$findClosingTag = function(iterator, token) {
          var prevToken;
          var currentTag = token.value;
          var tag = token.value;
          var depth = 0;
          var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          token = iterator.stepForward();
          var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          var foundOpenTagEnd = false;
          do {
            prevToken = token;
            if (prevToken.type.indexOf("tag-close") !== -1 && !foundOpenTagEnd) {
              var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
              foundOpenTagEnd = true;
            }
            token = iterator.stepForward();
            if (token) {
              if (token.value === ">" && !foundOpenTagEnd) {
                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                foundOpenTagEnd = true;
              }
              if (token.type.indexOf("tag-name") !== -1) {
                currentTag = token.value;
                if (tag === currentTag) {
                  if (prevToken.value === "<") {
                    depth++;
                  } else if (prevToken.value === "</") {
                    depth--;
                    if (depth < 0) {
                      iterator.stepBackward();
                      var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                      token = iterator.stepForward();
                      var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                      if (token.type.indexOf("tag-close") === -1) {
                        token = iterator.stepForward();
                      }
                      if (token && token.value === ">") {
                        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      } else {
                        return;
                      }
                    }
                  }
                }
              } else if (tag === currentTag && token.value === "/>") {
                depth--;
                if (depth < 0) {
                  var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                  var closeTagName = closeTagStart;
                  var closeTagEnd = closeTagName;
                  var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                }
              }
            }
          } while (token && depth >= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
        this.$findOpeningTag = function(iterator, token) {
          var prevToken = iterator.getCurrentToken();
          var tag = token.value;
          var depth = 0;
          var startRow = iterator.getCurrentTokenRow();
          var startColumn = iterator.getCurrentTokenColumn();
          var endColumn = startColumn + 2;
          var closeTagStart = new Range(startRow, startColumn, startRow, endColumn);
          iterator.stepForward();
          var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          if (token.type.indexOf("tag-close") === -1) {
            token = iterator.stepForward();
          }
          if (!token || token.value !== ">")
            return;
          var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          iterator.stepBackward();
          iterator.stepBackward();
          do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;
            prevToken = iterator.stepBackward();
            if (token) {
              if (token.type.indexOf("tag-name") !== -1) {
                if (tag === token.value) {
                  if (prevToken.value === "<") {
                    depth++;
                    if (depth > 0) {
                      var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                      var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      do {
                        token = iterator.stepForward();
                      } while (token && token.value !== ">");
                      var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    }
                  } else if (prevToken.value === "</") {
                    depth--;
                  }
                }
              } else if (token.value === "/>") {
                var stepCount = 0;
                var tmpToken = prevToken;
                while (tmpToken) {
                  if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                    depth--;
                    break;
                  } else if (tmpToken.value === "<") {
                    break;
                  }
                  tmpToken = iterator.stepBackward();
                  stepCount++;
                }
                for (var i = 0; i < stepCount; i++) {
                  iterator.stepForward();
                }
              }
            }
          } while (prevToken && depth <= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
      }
      exports2.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/line_widgets", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/undomanager", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./lib/oop");
      var lang = require3("./lib/lang");
      var BidiHandler = require3("./bidihandler").BidiHandler;
      var config = require3("./config");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var Selection = require3("./selection").Selection;
      var TextMode = require3("./mode/text").Mode;
      var Range = require3("./range").Range;
      var LineWidgets = require3("./line_widgets").LineWidgets;
      var Document = require3("./document").Document;
      var BackgroundTokenizer = require3("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = require3("./search_highlight").SearchHighlight;
      var UndoManager = require3("./undomanager").UndoManager;
      var EditSession = (
        /** @class */
        function() {
          function EditSession2(text, mode) {
            this.doc;
            this.$breakpoints = [];
            this.$decorations = [];
            this.$frontMarkers = {};
            this.$backMarkers = {};
            this.$markerId = 1;
            this.$undoSelect = true;
            this.$editor = null;
            this.prevOp = {};
            this.$foldData = [];
            this.id = "session" + ++EditSession2.$uid;
            this.$foldData.toString = function() {
              return this.join("\n");
            };
            this.$gutterCustomWidgets = {};
            this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
            var _self = this;
            this.bgTokenizer.on("update", function(e) {
              _self._signal("tokenizerUpdate", e);
            });
            this.on("changeFold", this.onChangeFold.bind(this));
            this.$onChange = this.onChange.bind(this);
            if (typeof text != "object" || !text.getLine)
              text = new Document(
                /**@type{string}*/
                text
              );
            this.setDocument(text);
            this.selection = new Selection(this);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.selection.on("changeCursor", this.$onSelectionChange);
            this.$bidiHandler = new BidiHandler(this);
            config.resetOptions(this);
            this.setMode(mode);
            config._signal("session", this);
            this.destroyed = false;
            this.$initOperationListeners();
          }
          EditSession2.prototype.$initOperationListeners = function() {
            var _this = this;
            this.curOp = null;
            this.on("change", function() {
              if (!_this.curOp) {
                _this.startOperation();
                _this.curOp.selectionBefore = _this.$lastSel;
              }
              _this.curOp.docChanged = true;
            }, true);
            this.on("changeSelection", function() {
              if (!_this.curOp) {
                _this.startOperation();
                _this.curOp.selectionBefore = _this.$lastSel;
              }
              _this.curOp.selectionChanged = true;
            }, true);
            this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
          };
          EditSession2.prototype.startOperation = function(commandEvent) {
            if (this.curOp) {
              if (!commandEvent || this.curOp.command) {
                return;
              }
              this.prevOp = this.curOp;
            }
            if (!commandEvent) {
              commandEvent = {};
            }
            this.$operationResetTimer.schedule();
            this.curOp = {
              command: commandEvent.command || {},
              args: commandEvent.args
            };
            this.curOp.selectionBefore = this.selection.toJSON();
            this._signal("startOperation", commandEvent);
          };
          EditSession2.prototype.endOperation = function(e) {
            if (this.curOp) {
              if (e && e.returnValue === false) {
                this.curOp = null;
                this._signal("endOperation", e);
                return;
              }
              if (e == true && this.curOp.command && this.curOp.command.name == "mouse") {
                return;
              }
              var currentSelection = this.selection.toJSON();
              this.curOp.selectionAfter = currentSelection;
              this.$lastSel = this.selection.toJSON();
              this.getUndoManager().addSelection(currentSelection);
              this._signal("beforeEndOperation");
              this.prevOp = this.curOp;
              this.curOp = null;
              this._signal("endOperation", e);
            }
          };
          EditSession2.prototype.setDocument = function(doc) {
            if (this.doc)
              this.doc.off("change", this.$onChange);
            this.doc = doc;
            doc.on("change", this.$onChange, true);
            this.bgTokenizer.setDocument(this.getDocument());
            this.resetCaches();
          };
          EditSession2.prototype.getDocument = function() {
            return this.doc;
          };
          Object.defineProperty(EditSession2.prototype, "widgetManager", {
            get: function() {
              var widgetManager = new LineWidgets(this);
              this.widgetManager = widgetManager;
              if (this.$editor)
                widgetManager.attach(this.$editor);
              return widgetManager;
            },
            set: function(value) {
              Object.defineProperty(this, "widgetManager", {
                writable: true,
                enumerable: true,
                configurable: true,
                value
              });
            },
            enumerable: false,
            configurable: true
          });
          EditSession2.prototype.$resetRowCache = function(docRow) {
            if (!docRow) {
              this.$docRowCache = [];
              this.$screenRowCache = [];
              return;
            }
            var l = this.$docRowCache.length;
            var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i) {
              this.$docRowCache.splice(i, l);
              this.$screenRowCache.splice(i, l);
            }
          };
          EditSession2.prototype.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi2 = cacheArray.length - 1;
            while (low <= hi2) {
              var mid = low + hi2 >> 1;
              var c = cacheArray[mid];
              if (val > c)
                low = mid + 1;
              else if (val < c)
                hi2 = mid - 1;
              else
                return mid;
            }
            return low - 1;
          };
          EditSession2.prototype.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (!this.destroyed)
              this.bgTokenizer.start(0);
          };
          EditSession2.prototype.onChangeFold = function(e) {
            var fold = e.data;
            this.$resetRowCache(fold.start.row);
          };
          EditSession2.prototype.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);
            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
              if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                  action: "removeFolds",
                  folds: removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
              }
              this.$undoManager.add(delta, this.mergeUndoDeltas);
              this.mergeUndoDeltas = true;
              this.$informUndoManager.schedule();
            }
            this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
          };
          EditSession2.prototype.onSelectionChange = function() {
            this._signal("changeSelection");
          };
          EditSession2.prototype.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);
            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
          };
          EditSession2.fromJSON = function(session) {
            if (typeof session == "string")
              session = JSON.parse(session);
            var undoManager = new UndoManager();
            undoManager.$undoStack = session.history.undo;
            undoManager.$redoStack = session.history.redo;
            undoManager.mark = session.history.mark;
            undoManager.$rev = session.history.rev;
            var editSession = new EditSession2(session.value);
            session.folds.forEach(function(fold) {
              editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
            });
            editSession.setAnnotations(session.annotations);
            editSession.setBreakpoints(session.breakpoints);
            editSession.setMode(session.mode);
            editSession.setScrollLeft(session.scrollLeft);
            editSession.setScrollTop(session.scrollTop);
            editSession.setUndoManager(undoManager);
            editSession.selection.fromJSON(session.selection);
            return editSession;
          };
          EditSession2.prototype.toJSON = function() {
            return {
              annotations: this.$annotations,
              breakpoints: this.$breakpoints,
              folds: this.getAllFolds().map(function(fold) {
                return fold.range;
              }),
              history: this.getUndoManager(),
              mode: this.$mode.$id,
              scrollLeft: this.$scrollLeft,
              scrollTop: this.$scrollTop,
              selection: this.selection.toJSON(),
              value: this.doc.getValue()
            };
          };
          EditSession2.prototype.toString = function() {
            return this.doc.getValue();
          };
          EditSession2.prototype.getSelection = function() {
            return this.selection;
          };
          EditSession2.prototype.getState = function(row) {
            return this.bgTokenizer.getState(row);
          };
          EditSession2.prototype.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
          };
          EditSession2.prototype.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c = 0;
            if (column == null) {
              var i = tokens.length - 1;
              c = this.getLine(row).length;
            } else {
              for (var i = 0; i < tokens.length; i++) {
                c += tokens[i].value.length;
                if (c >= column)
                  break;
              }
            }
            token = tokens[i];
            if (!token)
              return null;
            token.index = i;
            token.start = c - token.value.length;
            return token;
          };
          EditSession2.prototype.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            if (this.$informUndoManager)
              this.$informUndoManager.cancel();
            if (undoManager) {
              var self2 = this;
              undoManager.addSession(this);
              this.$syncInformUndoManager = function() {
                self2.$informUndoManager.cancel();
                self2.mergeUndoDeltas = false;
              };
              this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else {
              this.$syncInformUndoManager = function() {
              };
            }
          };
          EditSession2.prototype.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
              this.$syncInformUndoManager();
          };
          EditSession2.prototype.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
          };
          EditSession2.prototype.getTabString = function() {
            if (this.getUseSoftTabs()) {
              return lang.stringRepeat(" ", this.getTabSize());
            } else {
              return "	";
            }
          };
          EditSession2.prototype.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
          };
          EditSession2.prototype.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          };
          EditSession2.prototype.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
          };
          EditSession2.prototype.getTabSize = function() {
            return this.$tabSize;
          };
          EditSession2.prototype.isTabStop = function(position) {
            return this.$useSoftTabs && position.column % this.$tabSize === 0;
          };
          EditSession2.prototype.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
          };
          EditSession2.prototype.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
          };
          EditSession2.prototype.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
          };
          EditSession2.prototype.getOverwrite = function() {
            return this.$overwrite;
          };
          EditSession2.prototype.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
          };
          EditSession2.prototype.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
              this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.removeGutterCustomWidget = function(row) {
            if (this.$editor) {
              this.$editor.renderer.$gutterLayer.$removeCustomWidget(row);
            }
          };
          EditSession2.prototype.addGutterCustomWidget = function(row, attributes) {
            if (this.$editor) {
              this.$editor.renderer.$gutterLayer.$addCustomWidget(row, attributes);
            }
          };
          EditSession2.prototype.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.getBreakpoints = function() {
            return this.$breakpoints;
          };
          EditSession2.prototype.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i = 0; i < rows.length; i++) {
              this.$breakpoints[rows[i]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.setBreakpoint = function(row, className) {
            if (className === void 0)
              className = "ace_breakpoint";
            if (className)
              this.$breakpoints[row] = className;
            else
              delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;
            var marker = {
              range,
              type: type || "line",
              renderer: typeof type == "function" ? type : null,
              clazz,
              inFront: !!inFront,
              id
            };
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return id;
          };
          EditSession2.prototype.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
              return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return marker;
          };
          EditSession2.prototype.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
              return;
            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete markers[markerId];
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          };
          EditSession2.prototype.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
          };
          EditSession2.prototype.highlight = function(re3) {
            if (!this.$searchHighlight) {
              var highlight = new SearchHighlight(null, "ace_selected-word", "text");
              this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re3);
          };
          EditSession2.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
              clazz = endRow;
              endRow = startRow;
            }
            if (!clazz)
              clazz = "ace_step";
            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
          };
          EditSession2.prototype.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
          };
          EditSession2.prototype.getAnnotations = function() {
            return this.$annotations || [];
          };
          EditSession2.prototype.clearAnnotations = function() {
            this.setAnnotations([]);
          };
          EditSession2.prototype.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r?\n)/m);
            if (match) {
              this.$autoNewLine = match[1];
            } else {
              this.$autoNewLine = "\n";
            }
          };
          EditSession2.prototype.getWordRange = function(row, column) {
            var line = this.getLine(row);
            var inToken = false;
            if (column > 0)
              inToken = !!line.charAt(column - 1).match(this.tokenRe);
            if (!inToken)
              inToken = !!line.charAt(column).match(this.tokenRe);
            if (inToken)
              var re3 = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
              var re3 = /\s/;
            else
              var re3 = this.nonTokenRe;
            var start = column;
            if (start > 0) {
              do {
                start--;
              } while (start >= 0 && line.charAt(start).match(re3));
              start++;
            }
            var end = column;
            while (end < line.length && line.charAt(end).match(re3)) {
              end++;
            }
            return new Range(row, start, row, end);
          };
          EditSession2.prototype.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);
            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
              wordRange.end.column += 1;
            }
            return wordRange;
          };
          EditSession2.prototype.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
          };
          EditSession2.prototype.getNewLineMode = function() {
            return this.doc.getNewLineMode();
          };
          EditSession2.prototype.setUseWorker = function(useWorker) {
            this.setOption("useWorker", useWorker);
          };
          EditSession2.prototype.getUseWorker = function() {
            return this.$useWorker;
          };
          EditSession2.prototype.onReloadTokenizer = function(e) {
            var rows = e.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e);
          };
          EditSession2.prototype.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
              if (mode.getTokenizer)
                return this.$onChangeMode(mode);
              var options = mode;
              var path2 = options.path;
            } else {
              path2 = /**@type{string}*/
              mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
              this.$modes["ace/mode/text"] = new TextMode();
            if (this.$modes[path2] && !options) {
              this.$onChangeMode(this.$modes[path2]);
              cb && cb();
              return;
            }
            this.$modeId = path2;
            config.loadModule(["mode", path2], function(m) {
              if (this.destroyed) {
                return;
              }
              if (this.$modeId !== path2)
                return cb && cb();
              if (this.$modes[path2] && !options) {
                this.$onChangeMode(this.$modes[path2]);
              } else if (m && m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                  this.$modes[path2] = m;
                  m.$id = path2;
                }
                this.$onChangeMode(m);
              }
              cb && cb();
            }.bind(this));
            if (!this.$mode)
              this.$onChangeMode(this.$modes["ace/mode/text"], true);
          };
          EditSession2.prototype.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
              this.$modeId = mode.$id;
            if (this.$mode === mode)
              return;
            var oldMode = this.$mode;
            this.$mode = mode;
            this.$stopWorker();
            if (this.$useWorker)
              this.$startWorker();
            var tokenizer = mode.getTokenizer();
            if (tokenizer.on !== void 0) {
              var onReloadTokenizer = this.onReloadTokenizer.bind(this);
              tokenizer.on("update", onReloadTokenizer);
            }
            this.bgTokenizer.setTokenizer(tokenizer);
            this.bgTokenizer.setDocument(this.getDocument());
            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;
            if (!$isPlaceholder) {
              if (mode.attachToSession)
                mode.attachToSession(this);
              this.$options.wrapMethod.set.call(this, this.$wrapMethod);
              this.$setFolding(mode.foldingRules);
              this.bgTokenizer.start(0);
              this._emit("changeMode", { oldMode, mode });
            }
          };
          EditSession2.prototype.$stopWorker = function() {
            if (this.$worker) {
              this.$worker.terminate();
              this.$worker = null;
            }
          };
          EditSession2.prototype.$startWorker = function() {
            try {
              this.$worker = this.$mode.createWorker(this);
            } catch (e) {
              config.warn("Could not load worker", e);
              this.$worker = null;
            }
          };
          EditSession2.prototype.getMode = function() {
            return this.$mode;
          };
          EditSession2.prototype.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
              return;
            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
          };
          EditSession2.prototype.getScrollTop = function() {
            return this.$scrollTop;
          };
          EditSession2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
              return;
            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
          };
          EditSession2.prototype.getScrollLeft = function() {
            return this.$scrollLeft;
          };
          EditSession2.prototype.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets)
              return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
          };
          EditSession2.prototype.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null)
              return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w2) {
              if (w2 && w2.screenWidth > width)
                width = w2.screenWidth;
            });
            return this.lineWidgetWidth = width;
          };
          EditSession2.prototype.$computeWidth = function(force) {
            if (this.$modified || force) {
              this.$modified = false;
              if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
              var lines = this.doc.getAllLines();
              var cache = this.$rowLengthCache;
              var longestScreenLine = 0;
              var foldIndex = 0;
              var foldLine = this.$foldData[foldIndex];
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              var len = lines.length;
              for (var i = 0; i < len; i++) {
                if (i > foldStart) {
                  i = foldLine.end.row + 1;
                  if (i >= len)
                    break;
                  foldLine = this.$foldData[foldIndex++];
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i] == null)
                  cache[i] = this.$getStringScreenWidth(lines[i])[0];
                if (cache[i] > longestScreenLine)
                  longestScreenLine = cache[i];
              }
              this.screenWidth = longestScreenLine;
            }
          };
          EditSession2.prototype.getLine = function(row) {
            return this.doc.getLine(row);
          };
          EditSession2.prototype.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
          };
          EditSession2.prototype.getLength = function() {
            return this.doc.getLength();
          };
          EditSession2.prototype.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
          };
          EditSession2.prototype.insert = function(position, text) {
            return this.doc.insert(position, text);
          };
          EditSession2.prototype.remove = function(range) {
            return this.doc.remove(range);
          };
          EditSession2.prototype.removeFullLines = function(firstRow, lastRow) {
            return this.doc.removeFullLines(firstRow, lastRow);
          };
          EditSession2.prototype.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i = deltas.length - 1; i != -1; i--) {
              var delta = deltas[i];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
              } else if (delta.folds) {
                this.addFolds(delta.folds);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i = 0; i < deltas.length; i++) {
              var delta = deltas[i];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
          };
          EditSession2.prototype.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta2) {
              return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
            }
            var range, point;
            for (var i = 0; i < deltas.length; i++) {
              var delta = deltas[i];
              if (!delta.start)
                continue;
              if (!range) {
                if (isInsert(delta)) {
                  range = Range.fromPoints(delta.start, delta.end);
                } else {
                  range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
              }
              if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                  range.setEnd(point);
                }
              } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range = Range.fromPoints(delta.start, delta.start);
                }
              }
            }
            return range;
          };
          EditSession2.prototype.replace = function(range, text) {
            return this.doc.replace(range, text);
          };
          EditSession2.prototype.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);
            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
              this.remove(fromRange);
              var rowDiff = fromRange.start.row - fromRange.end.row;
              var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
              if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                  toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                  toRange.end.column += collDiff;
              }
              if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
              }
            }
            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
              var oldStart = fromRange.start;
              var newStart = toRange.start;
              var rowDiff = newStart.row - oldStart.row;
              var collDiff = newStart.column - oldStart.column;
              this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row)
                  x.start.column += collDiff;
                if (x.end.row == oldStart.row)
                  x.end.column += collDiff;
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
              }));
            }
            return toRange;
          };
          EditSession2.prototype.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row = startRow; row <= endRow; row++)
              this.doc.insertInLine({ row, column: 0 }, indentString);
          };
          EditSession2.prototype.outdentRows = function(range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();
            for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
              var line = this.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              for (var j3 = 0; j3 < size; ++j3)
                if (line.charAt(j3) != " ")
                  break;
              if (j3 < size && line.charAt(j3) == "	") {
                deleteRange.start.column = j3;
                deleteRange.end.column = j3 + 1;
              } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j3;
              }
              this.remove(deleteRange);
            }
          };
          EditSession2.prototype.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
              var row = this.getRowFoldStart(firstRow + dir);
              if (row < 0)
                return 0;
              var diff = row - firstRow;
            } else if (dir > 0) {
              var row = this.getRowFoldEnd(lastRow + dir);
              if (row > this.doc.getLength() - 1)
                return 0;
              var diff = row - lastRow;
            } else {
              firstRow = this.$clipRowToDocument(firstRow);
              lastRow = this.$clipRowToDocument(lastRow);
              var diff = lastRow - firstRow + 1;
            }
            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x) {
              x = x.clone();
              x.start.row += diff;
              x.end.row += diff;
              return x;
            });
            var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow + diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
          };
          EditSession2.prototype.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
          };
          EditSession2.prototype.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
          };
          EditSession2.prototype.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
          };
          EditSession2.prototype.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength() - 1));
          };
          EditSession2.prototype.$clipColumnToRow = function(row, column) {
            if (column < 0)
              return 0;
            return Math.min(this.doc.getLine(row).length, column);
          };
          EditSession2.prototype.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);
            if (row < 0) {
              row = 0;
              column = 0;
            } else {
              var len = this.doc.getLength();
              if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
              } else {
                column = Math.min(this.doc.getLine(row).length, column);
              }
            }
            return {
              row,
              column
            };
          };
          EditSession2.prototype.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
              range.start.row = 0;
              range.start.column = 0;
            } else {
              range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
            }
            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
              range.end.row = len;
              range.end.column = this.doc.getLine(len).length;
            } else {
              range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
            }
            return range;
          };
          EditSession2.prototype.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
              this.$useWrapMode = useWrapMode;
              this.$modified = true;
              this.$resetRowCache(0);
              if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
              }
              this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.getUseWrapMode = function() {
            return this.$useWrapMode;
          };
          EditSession2.prototype.setWrapLimitRange = function(min2, max) {
            if (this.$wrapLimitRange.min !== min2 || this.$wrapLimitRange.max !== max) {
              this.$wrapLimitRange = { min: min2, max };
              this.$modified = true;
              this.$bidiHandler.markAsDirty();
              if (this.$useWrapMode)
                this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
              limits = { min: $printMargin, max: $printMargin };
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
              this.$wrapLimit = wrapLimit;
              this.$modified = true;
              if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
              }
              return true;
            }
            return false;
          };
          EditSession2.prototype.$constrainWrapLimit = function(wrapLimit, min2, max) {
            if (min2)
              wrapLimit = Math.max(min2, wrapLimit);
            if (max)
              wrapLimit = Math.min(max, wrapLimit);
            return wrapLimit;
          };
          EditSession2.prototype.getWrapLimit = function() {
            return this.$wrapLimit;
          };
          EditSession2.prototype.setWrapLimit = function(limit) {
            this.setWrapLimitRange(limit, limit);
          };
          EditSession2.prototype.getWrapLimitRange = function() {
            return {
              min: this.$wrapLimitRange.min,
              max: this.$wrapLimitRange.max
            };
          };
          EditSession2.prototype.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            this.$updating = true;
            if (len != 0) {
              if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                  foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                  foldLine.shiftRow(-len);
                  var foldLineBefore = this.getFoldLine(firstRow);
                  if (foldLineBefore && foldLineBefore !== foldLine) {
                    foldLineBefore.merge(foldLine);
                    foldLine = foldLineBefore;
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= end.row) {
                    foldLine.shiftRow(-len);
                  }
                }
                lastRow = firstRow;
              } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                  var cmp = foldLine.range.compareInside(start.row, start.column);
                  if (cmp == 0) {
                    foldLine = foldLine.split(start.row, start.column);
                    if (foldLine) {
                      foldLine.shiftRow(len);
                      foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                    }
                  } else if (cmp == -1) {
                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                    foldLine.shiftRow(len);
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= firstRow) {
                    foldLine.shiftRow(len);
                  }
                }
              }
            } else {
              len = Math.abs(delta.start.column - delta.end.column);
              if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
              }
              var foldLine = this.getFoldLine(firstRow);
              if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
              }
            }
            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
              console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;
            if (useWrapMode)
              this.$updateWrapData(firstRow, lastRow);
            else
              this.$updateRowLengthCache(firstRow, lastRow);
            return removedFolds;
          };
          EditSession2.prototype.$updateRowLengthCache = function(firstRow, lastRow) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
          };
          EditSession2.prototype.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;
            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
              foldLine = this.getFoldLine(row, foldLine);
              if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
              } else {
                tokens = [];
                foldLine.walk(function(placeholder, row2, column, lastColumn) {
                  var walkTokens;
                  if (placeholder != null) {
                    walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                    walkTokens[0] = PLACEHOLDER_START;
                    for (var i = 1; i < walkTokens.length; i++) {
                      walkTokens[i] = PLACEHOLDER_BODY;
                    }
                  } else {
                    walkTokens = this.$getDisplayTokens(lines[row2].substring(lastColumn, column), tokens.length);
                  }
                  tokens = tokens.concat(walkTokens);
                }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
              }
            }
          };
          EditSession2.prototype.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) {
              return [];
            }
            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;
            var isCode = this.$wrapAsCode;
            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
            function getWrapIndent() {
              var indentation = 0;
              if (maxIndent === 0)
                return indentation;
              if (indentedSoftWrap) {
                for (var i = 0; i < tokens.length; i++) {
                  var token = tokens[i];
                  if (token == SPACE)
                    indentation += 1;
                  else if (token == TAB)
                    indentation += tabSize;
                  else if (token == TAB_SPACE)
                    continue;
                  else
                    break;
                }
              }
              if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
              return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
              var len = screenPos - lastSplit;
              for (var i = lastSplit; i < screenPos; i++) {
                var ch = tokens[i];
                if (ch === 12 || ch === 2)
                  len -= 1;
              }
              if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
              }
              lastDocSplit += len;
              splits.push(lastDocSplit);
              lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
              var split = lastSplit + wrapLimit - indent;
              if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                addSplit(split);
                continue;
              }
              if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                for (split; split != lastSplit - 1; split--) {
                  if (tokens[split] == PLACEHOLDER_START) {
                    break;
                  }
                }
                if (split > lastSplit) {
                  addSplit(split);
                  continue;
                }
                split = lastSplit + wrapLimit;
                for (split; split < tokens.length; split++) {
                  if (tokens[split] != PLACEHOLDER_BODY) {
                    break;
                  }
                }
                if (split == tokens.length) {
                  break;
                }
                addSplit(split);
                continue;
              }
              var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
              while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
              }
              if (isCode) {
                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                  split--;
                }
                while (split > minSplit && tokens[split] == PUNCTUATION) {
                  split--;
                }
              } else {
                while (split > minSplit && tokens[split] < SPACE) {
                  split--;
                }
              }
              if (split > minSplit) {
                addSplit(++split);
                continue;
              }
              split = lastSplit + wrapLimit;
              if (tokens[split] == CHAR_EXT)
                split--;
              addSplit(split - indent);
            }
            return splits;
          };
          EditSession2.prototype.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;
            for (var i = 0; i < str.length; i++) {
              var c = str.charCodeAt(i);
              if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                  arr.push(TAB_SPACE);
                }
              } else if (c == 32) {
                arr.push(SPACE);
              } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                arr.push(PUNCTUATION);
              } else if (c >= 4352 && isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
              } else {
                arr.push(CHAR);
              }
            }
            return arr;
          };
          EditSession2.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
              return [0, 0];
            if (maxScreenColumn == null)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column < str.length; column++) {
              c = str.charCodeAt(column);
              if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else if (c >= 4352 && isFullWidth(c)) {
                screenColumn += 2;
              } else {
                screenColumn += 1;
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
          EditSession2.prototype.getRowLength = function(row) {
            var h = 1;
            if (this.lineWidgets)
              h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            if (!this.$useWrapMode || !this.$wrapData[row])
              return h;
            else
              return this.$wrapData[row].length + h;
          };
          EditSession2.prototype.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1;
            } else {
              return this.$wrapData[row].length + 1;
            }
          };
          EditSession2.prototype.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
              var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
              var splits = this.$wrapData[pos.row];
              return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
              return 0;
            }
          };
          EditSession2.prototype.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
          };
          EditSession2.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
          };
          EditSession2.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
          };
          EditSession2.prototype.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
              return void 0;
            } else {
              return this.$wrapData[row];
            }
          };
          EditSession2.prototype.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
          };
          EditSession2.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
          };
          EditSession2.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
          };
          EditSession2.prototype.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
              return { row: 0, column: 0 };
            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;
            var rowCache = this.$screenRowCache;
            var i = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var docRow = this.$docRowCache[i];
              var doCache = screenRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row <= screenRow) {
              rowLength = this.getRowLength(docRow);
              if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
              } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                  docRow = foldLine.end.row + 1;
                  foldLine = this.getNextFoldLine(docRow, foldLine);
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
              }
              if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
              }
            }
            if (foldLine && foldLine.start.row <= docRow) {
              line = this.getFoldDisplayLine(foldLine);
              docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
              return {
                row: maxRow,
                column: this.getLine(maxRow).length
              };
            } else {
              line = this.getLine(docRow);
              foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
              var splits = this.$wrapData[docRow];
              if (splits) {
                column = splits[splitIndex];
                if (splitIndex > 0 && splits.length) {
                  wrapIndent = splits.indent;
                  docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                  line = line.substring(docColumn);
                }
              }
            }
            if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
              screenColumn = this.$bidiHandler.offsetToCol(offsetX);
            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
              docColumn = column - 1;
            if (foldLine)
              return foldLine.idxToPosition(docColumn);
            return { row: docRow, column: docColumn };
          };
          EditSession2.prototype.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
              var pos = this.$clipPositionToDocument(
                /**@type{Point}*/
                docRow.row,
                /**@type{Point}*/
                docRow.column
              );
            else
              pos = this.$clipPositionToDocument(
                /**@type{number}*/
                docRow,
                docColumn
              );
            docRow = pos.row;
            docColumn = pos.column;
            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
              docRow = fold.start.row;
              docColumn = fold.start.column;
            }
            var rowEnd, row = 0;
            var rowCache = this.$docRowCache;
            var i = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i >= 0) {
              var row = rowCache[i];
              var screenRow = this.$screenRowCache[i];
              var doCache = docRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row < docRow) {
              if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                  break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              } else {
                rowEnd = row + 1;
              }
              screenRow += this.getRowLength(row);
              row = rowEnd;
              if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
              }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
              textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
              foldStartRow = foldLine.start.row;
            } else {
              textLine = this.getLine(docRow).substring(0, docColumn);
              foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
              var wrapRow = this.$wrapData[foldStartRow];
              if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                  screenRow++;
                  screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
              }
            }
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
              screenRow += this.lineWidgets[row].rowsAbove;
            return {
              row: screenRow,
              column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
          };
          EditSession2.prototype.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
          };
          EditSession2.prototype.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
          };
          EditSession2.prototype.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
              screenRows = this.getLength();
              var foldData = this.$foldData;
              for (var i = 0; i < foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
              }
            } else {
              var lastRow = this.$wrapData.length;
              var row = 0, i = 0;
              var fold = this.$foldData[i++];
              var foldStart = fold ? fold.start.row : Infinity;
              while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row > foldStart) {
                  row = fold.end.row + 1;
                  fold = this.$foldData[i++];
                  foldStart = fold ? fold.start.row : Infinity;
                }
              }
            }
            if (this.lineWidgets)
              screenRows += this.$getWidgetScreenLength();
            return screenRows;
          };
          EditSession2.prototype.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar)
              return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
              if (maxScreenColumn === 0)
                return [0, 0];
              if (!maxScreenColumn)
                maxScreenColumn = Infinity;
              screenColumn = screenColumn || 0;
              var c, column;
              for (column = 0; column < str.length; column++) {
                c = str.charAt(column);
                if (c === "	") {
                  screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                  screenColumn += fm.getCharacterWidth(c);
                }
                if (screenColumn > maxScreenColumn) {
                  break;
                }
              }
              return [screenColumn, column];
            };
          };
          EditSession2.prototype.getPrecedingCharacter = function() {
            var pos = this.selection.getCursor();
            if (pos.column === 0) {
              return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
            }
            var currentLine = this.getLine(pos.row);
            return currentLine[pos.column - 1];
          };
          EditSession2.prototype.destroy = function() {
            if (!this.destroyed) {
              this.bgTokenizer.setDocument(null);
              this.bgTokenizer.cleanup();
              this.destroyed = true;
            }
            this.endOperation();
            this.$stopWorker();
            this.removeAllListeners();
            if (this.doc) {
              this.doc.off("change", this.$onChange);
            }
            if (this.selection) {
              this.selection.off("changeCursor", this.$onSelectionChange);
              this.selection.off("changeSelection", this.$onSelectionChange);
            }
            this.selection.detach();
          };
          return EditSession2;
        }()
      );
      EditSession.$uid = 0;
      EditSession.prototype.$modes = config.$modes;
      EditSession.prototype.getValue = EditSession.prototype.toString;
      EditSession.prototype.$defaultUndoManager = {
        undo: function() {
        },
        redo: function() {
        },
        hasUndo: function() {
        },
        hasRedo: function() {
        },
        reset: function() {
        },
        add: function() {
        },
        addSelection: function() {
        },
        startNewGroup: function() {
        },
        addSession: function() {
        }
      };
      EditSession.prototype.$overwrite = false;
      EditSession.prototype.$mode = null;
      EditSession.prototype.$modeId = null;
      EditSession.prototype.$scrollTop = 0;
      EditSession.prototype.$scrollLeft = 0;
      EditSession.prototype.$wrapLimit = 80;
      EditSession.prototype.$useWrapMode = false;
      EditSession.prototype.$wrapLimitRange = {
        min: null,
        max: null
      };
      EditSession.prototype.lineWidgets = null;
      EditSession.prototype.isFullWidth = isFullWidth;
      oop.implement(EditSession.prototype, EventEmitter);
      var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
      function isFullWidth(c) {
        if (c < 4352)
          return false;
        return c >= 4352 && c <= 4447 || c >= 4515 && c <= 4519 || c >= 4602 && c <= 4607 || c >= 9001 && c <= 9002 || c >= 11904 && c <= 11929 || c >= 11931 && c <= 12019 || c >= 12032 && c <= 12245 || c >= 12272 && c <= 12283 || c >= 12288 && c <= 12350 || c >= 12353 && c <= 12438 || c >= 12441 && c <= 12543 || c >= 12549 && c <= 12589 || c >= 12593 && c <= 12686 || c >= 12688 && c <= 12730 || c >= 12736 && c <= 12771 || c >= 12784 && c <= 12830 || c >= 12832 && c <= 12871 || c >= 12880 && c <= 13054 || c >= 13056 && c <= 19903 || c >= 19968 && c <= 42124 || c >= 42128 && c <= 42182 || c >= 43360 && c <= 43388 || c >= 44032 && c <= 55203 || c >= 55216 && c <= 55238 || c >= 55243 && c <= 55291 || c >= 63744 && c <= 64255 || c >= 65040 && c <= 65049 || c >= 65072 && c <= 65106 || c >= 65108 && c <= 65126 || c >= 65128 && c <= 65131 || c >= 65281 && c <= 65376 || c >= 65504 && c <= 65510;
      }
      require3("./edit_session/folding").Folding.call(EditSession.prototype);
      require3("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function(value) {
            if (!value || value == "off")
              value = false;
            else if (value == "free")
              value = true;
            else if (value == "printMargin")
              value = -1;
            else if (typeof value == "string")
              value = parseInt(value, 10) || false;
            if (this.$wrap == value)
              return;
            this.$wrap = value;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
          },
          get: function() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1)
                return "printMargin";
              if (!this.getWrapLimitRange().min)
                return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
              }
            }
          },
          initialValue: "auto"
        },
        indentedSoftWrap: {
          set: function() {
            if (this.$useWrapMode) {
              this.$useWrapMode = false;
              this.setUseWrapMode(true);
            }
          },
          initialValue: true
        },
        firstLineNumber: {
          set: function() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
              this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: { initialValue: true },
        tabSize: {
          set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
              this.$modified = true;
              this.$rowLengthCache = [];
              this.$tabSize = tabSize;
              this._signal("changeTabSize");
            }
          },
          initialValue: 4,
          handlesSet: true
        },
        navigateWithinSoftTabs: { initialValue: false },
        foldStyle: {
          set: function(val) {
            this.setFoldStyle(val);
          },
          handlesSet: true
        },
        overwrite: {
          set: function(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function(val) {
            this.doc.setNewLineMode(val);
          },
          get: function() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function(val) {
            this.setMode(val);
          },
          get: function() {
            return this.$modeId;
          },
          handlesSet: true
        }
      });
      exports2.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var lang = require3("./lib/lang");
      var oop = require3("./lib/oop");
      var Range = require3("./range").Range;
      var Search = (
        /** @class */
        function() {
          function Search2() {
            this.$options = {};
          }
          Search2.prototype.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
          };
          Search2.prototype.getOptions = function() {
            return lang.copyObject(this.$options);
          };
          Search2.prototype.setOptions = function(options) {
            this.$options = options;
          };
          Search2.prototype.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
              return false;
            var firstRange = null;
            iterator.forEach(function(sr2, sc2, er3, ec2) {
              firstRange = new Range(sr2, sc2, er3, ec2);
              if (sc2 == ec2 && options.start && /**@type{Range}*/
              options.start.start && options.skipCurrent != false && firstRange.isEqual(
                /**@type{Range}*/
                options.start
              )) {
                firstRange = null;
                return false;
              }
              return true;
            });
            return firstRange;
          };
          Search2.prototype.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
              return [];
            this.$assembleRegExp(options);
            var range = options.range;
            var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
            var ranges = [];
            var re3 = options.re;
            if (options.$isMultiLine) {
              var len = re3.length;
              var maxRow = lines.length - len;
              var prevRange;
              outer: for (var row = re3.offset || 0; row <= maxRow; row++) {
                for (var j3 = 0; j3 < len; j3++)
                  if (lines[row + j3].search(re3[j3]) == -1)
                    continue outer;
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re3[0])[0].length;
                var endIndex = line.match(re3[len - 1])[0].length;
                if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                  continue;
                }
                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                if (len > 2)
                  row = row + len - 2;
              }
            } else {
              for (var matches, i = 0; i < lines.length; i++) {
                if (this.$isMultilineSearch(options)) {
                  var lng = lines.length - 1;
                  matches = this.$multiLineForward(session, re3, i, lng);
                  if (matches) {
                    var end_row = matches.endRow <= lng ? matches.endRow - 1 : lng;
                    if (end_row > i)
                      i = end_row;
                    ranges.push(new Range(matches.startRow, matches.startCol, matches.endRow, matches.endCol));
                  }
                } else {
                  matches = lang.getMatchOffsets(lines[i], re3);
                  for (var j3 = 0; j3 < matches.length; j3++) {
                    var match = matches[j3];
                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                  }
                }
              }
            }
            if (range) {
              var startColumn = range.start.column;
              var endColumn = range.end.column;
              var i = 0, j3 = ranges.length - 1;
              while (i < j3 && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
                i++;
              var endRow = range.end.row - range.start.row;
              while (i < j3 && ranges[j3].end.column > endColumn && ranges[j3].end.row == endRow)
                j3--;
              ranges = ranges.slice(i, j3 + 1);
              for (i = 0, j3 = ranges.length; i < j3; i++) {
                ranges[i].start.row += range.start.row;
                ranges[i].end.row += range.start.row;
              }
            }
            return ranges;
          };
          Search2.prototype.parseReplaceString = function(replaceString) {
            var CharCode = {
              DollarSign: 36,
              Ampersand: 38,
              Digit0: 48,
              Digit1: 49,
              Digit9: 57,
              Backslash: 92,
              n: 110,
              t: 116
            };
            var replacement = "";
            for (var i = 0, len = replaceString.length; i < len; i++) {
              var chCode = replaceString.charCodeAt(i);
              if (chCode === CharCode.Backslash) {
                i++;
                if (i >= len) {
                  replacement += "\\";
                  break;
                }
                var nextChCode = replaceString.charCodeAt(i);
                switch (nextChCode) {
                  case CharCode.Backslash:
                    replacement += "\\";
                    break;
                  case CharCode.n:
                    replacement += "\n";
                    break;
                  case CharCode.t:
                    replacement += "	";
                    break;
                }
                continue;
              }
              if (chCode === CharCode.DollarSign) {
                i++;
                if (i >= len) {
                  replacement += "$";
                  break;
                }
                var nextChCode_1 = replaceString.charCodeAt(i);
                if (nextChCode_1 === CharCode.DollarSign) {
                  replacement += "$$";
                  continue;
                }
                if (nextChCode_1 === CharCode.Digit0 || nextChCode_1 === CharCode.Ampersand) {
                  replacement += "$&";
                  continue;
                }
                if (CharCode.Digit1 <= nextChCode_1 && nextChCode_1 <= CharCode.Digit9) {
                  replacement += "$" + replaceString[i];
                  continue;
                }
              }
              replacement += replaceString[i];
            }
            return replacement || replaceString;
          };
          Search2.prototype.replace = function(input, replacement) {
            var options = this.$options;
            var re3 = this.$assembleRegExp(options);
            if (options.$isMultiLine)
              return replacement;
            if (!re3)
              return;
            var mtSearch = this.$isMultilineSearch(options);
            if (mtSearch)
              input = input.replace(/\r\n|\r|\n/g, "\n");
            var match = re3.exec(input);
            if (!match || !mtSearch && match[0].length != input.length)
              return null;
            replacement = options.regExp ? this.parseReplaceString(replacement) : replacement.replace(/\$/g, "$$$$");
            replacement = input.replace(re3, replacement);
            if (options.preserveCase) {
              replacement = replacement.split("");
              for (var i = Math.min(input.length, input.length); i--; ) {
                var ch = input[i];
                if (ch && ch.toLowerCase() != ch)
                  replacement[i] = replacement[i].toUpperCase();
                else
                  replacement[i] = replacement[i].toLowerCase();
              }
              replacement = replacement.join("");
            }
            return replacement;
          };
          Search2.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
              return options.re = options.needle;
            var needle = options.needle;
            if (!options.needle)
              return options.re = false;
            if (!options.regExp)
              needle = lang.escapeRegExp(needle);
            var modifier = options.caseSensitive ? "gm" : "gmi";
            try {
              new RegExp(needle, "u");
              options.$supportsUnicodeFlag = true;
              modifier += "u";
            } catch (e) {
              options.$supportsUnicodeFlag = false;
            }
            if (options.wholeWord)
              needle = addWordBoundary(needle, options);
            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
              return options.re = this.$assembleMultilineRegExp(needle, modifier);
            try {
              var re3 = new RegExp(needle, modifier);
            } catch (e) {
              re3 = false;
            }
            return options.re = re3;
          };
          Search2.prototype.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re3 = [];
            for (var i = 0; i < parts.length; i++)
              try {
                re3.push(new RegExp(parts[i], modifier));
              } catch (e) {
                return false;
              }
            return re3;
          };
          Search2.prototype.$isMultilineSearch = function(options) {
            return options.re && /\\r\\n|\\r|\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;
          };
          Search2.prototype.$multiLineForward = function(session, re3, start, last) {
            var line, chunk = chunkEnd(session, start);
            for (var row = start; row <= last; ) {
              for (var i = 0; i < chunk; i++) {
                if (row > last)
                  break;
                var next = session.getLine(row++);
                line = line == null ? next : line + "\n" + next;
              }
              var match = re3.exec(line);
              re3.lastIndex = 0;
              if (match) {
                var beforeMatch = line.slice(0, match.index).split("\n");
                var matchedText = match[0].split("\n");
                var startRow = start + beforeMatch.length - 1;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                return {
                  startRow,
                  startCol,
                  endRow,
                  endCol
                };
              }
            }
            return null;
          };
          Search2.prototype.$multiLineBackward = function(session, re3, endIndex, start, first) {
            var line, chunk = chunkEnd(session, start), endMargin = session.getLine(start).length - endIndex;
            for (var row = start; row >= first; ) {
              for (var i = 0; i < chunk && row >= first; i++) {
                var next = session.getLine(row--);
                line = line == null ? next : next + "\n" + line;
              }
              var match = multiLineBackwardMatch(line, re3, endMargin);
              if (match) {
                var beforeMatch = line.slice(0, match.index).split("\n");
                var matchedText = match[0].split("\n");
                var startRow = row + beforeMatch.length;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                return {
                  startRow,
                  startCol,
                  endRow,
                  endCol
                };
              }
            }
            return null;
          };
          Search2.prototype.$matchIterator = function(session, options) {
            var re3 = this.$assembleRegExp(options);
            if (!re3)
              return false;
            var mtSearch = this.$isMultilineSearch(options);
            var mtForward = this.$multiLineForward;
            var mtBackward = this.$multiLineBackward;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;
            var supportsUnicodeFlag = re3.unicode;
            var range = options.range;
            var start = options.start;
            if (!start)
              start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
            if (start.start)
              start = start[skipCurrent != backwards ? "end" : "start"];
            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            if (backwards) {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row--; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
              };
            } else {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row = row + 1; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
              };
            }
            if (options.$isMultiLine) {
              var len = re3.length;
              var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength())
                  return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re3[0]);
                if (!backwards && startIndex < offset || startIndex === -1)
                  return;
                for (var i = 1; i < len; i++) {
                  line = session.getLine(startRow + i);
                  if (line.search(re3[i]) == -1)
                    return;
                }
                var endIndex = line.match(re3[len - 1])[0].length;
                if (backwards && endIndex > offset)
                  return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                  return true;
              };
            } else if (backwards) {
              var forEachInLine = function(row, endIndex, callback) {
                if (mtSearch) {
                  var pos = mtBackward(session, re3, endIndex, row, firstRow);
                  if (!pos)
                    return false;
                  if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                    return true;
                } else {
                  var line = session.getLine(row);
                  var matches = [];
                  var m, last = 0;
                  re3.lastIndex = 0;
                  while (m = re3.exec(line)) {
                    var length = m[0].length;
                    last = m.index;
                    if (!length) {
                      if (last >= line.length)
                        break;
                      re3.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                    }
                    if (m.index + length > endIndex)
                      break;
                    matches.push(m.index, length);
                  }
                  for (var i = matches.length - 1; i >= 0; i -= 2) {
                    var column = matches[i - 1];
                    var length = matches[i];
                    if (callback(row, column, row, column + length))
                      return true;
                  }
                }
              };
            } else {
              var forEachInLine = function(row, startIndex, callback) {
                re3.lastIndex = startIndex;
                if (mtSearch) {
                  var pos = mtForward(session, re3, row, lastRow);
                  if (pos) {
                    var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;
                    if (end_row > row)
                      row = end_row;
                  }
                  if (!pos)
                    return false;
                  if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                    return true;
                } else {
                  var line = session.getLine(row);
                  var last;
                  var m;
                  while (m = re3.exec(line)) {
                    var length = m[0].length;
                    last = m.index;
                    if (callback(row, last, row, last + length))
                      return true;
                    if (!length) {
                      re3.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                      if (last >= line.length)
                        return false;
                    }
                  }
                }
              };
            }
            return { forEach };
          };
          return Search2;
        }()
      );
      function addWordBoundary(needle, options) {
        var supportsLookbehind = lang.supportsLookbehind();
        function wordBoundary(c, firstChar2) {
          if (firstChar2 === void 0) {
            firstChar2 = true;
          }
          var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
          if (wordRegExp.test(c) || options.regExp) {
            if (supportsLookbehind && options.$supportsUnicodeFlag) {
              if (firstChar2)
                return "(?<=^|[^\\p{L}\\p{N}_])";
              return "(?=[^\\p{L}\\p{N}_]|$)";
            }
            return "\\b";
          }
          return "";
        }
        var needleArray = Array.from(needle);
        var firstChar = needleArray[0];
        var lastChar = needleArray[needleArray.length - 1];
        return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
      }
      function multiLineBackwardMatch(line, re3, endMargin) {
        var match = null;
        var from = 0;
        while (from <= line.length) {
          re3.lastIndex = from;
          var newMatch = re3.exec(line);
          if (!newMatch)
            break;
          var end = newMatch.index + newMatch[0].length;
          if (end > line.length - endMargin)
            break;
          if (!match || end > match.index + match[0].length)
            match = newMatch;
          from = newMatch.index + 1;
        }
        return match;
      }
      function chunkEnd(session, start) {
        var base = 5e3, startPosition = { row: start, column: 0 }, startIndex = session.doc.positionToIndex(startPosition), targetIndex = startIndex + base, targetPosition = session.doc.indexToPosition(targetIndex), targetLine = targetPosition.row;
        return targetLine + 1;
      }
      exports2.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var keyUtil = require3("../lib/keys");
      var useragent = require3("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      var MultiHashHandler = (
        /** @class */
        function() {
          function MultiHashHandler2(config, platform) {
            this.$init(config, platform, false);
          }
          MultiHashHandler2.prototype.$init = function(config, platform, $singleCommand) {
            this.platform = platform || (useragent.isMac ? "mac" : "win");
            this.commands = {};
            this.commandKeyBinding = {};
            this.addCommands(config);
            this.$singleCommand = $singleCommand;
          };
          MultiHashHandler2.prototype.addCommand = function(command) {
            if (this.commands[command.name])
              this.removeCommand(command);
            this.commands[command.name] = command;
            if (command.bindKey)
              this._buildKeyHash(command);
          };
          MultiHashHandler2.prototype.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === "string" ? command : command.name);
            command = this.commands[name];
            if (!keepCommand)
              delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for (var keyId in ckb) {
              var cmdGroup = ckb[keyId];
              if (cmdGroup == command) {
                delete ckb[keyId];
              } else if (Array.isArray(cmdGroup)) {
                var i = cmdGroup.indexOf(command);
                if (i != -1) {
                  cmdGroup.splice(i, 1);
                  if (cmdGroup.length == 1)
                    ckb[keyId] = cmdGroup[0];
                }
              }
            }
          };
          MultiHashHandler2.prototype.bindKey = function(key, command, position) {
            if (typeof key == "object" && key) {
              if (position == void 0)
                position = key.position;
              key = key[this.platform];
            }
            if (!key)
              return;
            if (typeof command == "function")
              return this.addCommand({ exec: command, bindKey: key, name: command.name || /**@type{string}*/
              key });
            key.split("|").forEach(function(keyPart) {
              var chain = "";
              if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart2) {
                  var binding2 = this.parseKeys(keyPart2);
                  var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                  chain += (chain ? " " : "") + id2;
                  this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
              }
              var binding = this.parseKeys(keyPart);
              var id = KEY_MODS[binding.hashId] + binding.key;
              this._addCommandToBinding(chain + id, command, position);
            }, this);
          };
          MultiHashHandler2.prototype._addCommandToBinding = function(keyId, command, position) {
            var ckb = this.commandKeyBinding, i;
            if (!command) {
              delete ckb[keyId];
            } else if (!ckb[keyId] || this.$singleCommand) {
              ckb[keyId] = command;
            } else {
              if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
              } else if ((i = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i, 1);
              }
              if (typeof position != "number") {
                position = getPosition(command);
              }
              var commands = ckb[keyId];
              for (i = 0; i < commands.length; i++) {
                var other = commands[i];
                var otherPos = getPosition(other);
                if (otherPos > position)
                  break;
              }
              commands.splice(i, 0, command);
            }
          };
          MultiHashHandler2.prototype.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
              var command = commands[name];
              if (!command)
                return;
              if (typeof command === "string")
                return this.bindKey(command, name);
              if (typeof command === "function")
                command = { exec: command };
              if (typeof command !== "object")
                return;
              if (!command.name)
                command.name = name;
              this.addCommand(command);
            }, this);
          };
          MultiHashHandler2.prototype.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
              this.removeCommand(commands[name]);
            }, this);
          };
          MultiHashHandler2.prototype.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
              this.bindKey(key, keyList[key]);
            }, this);
          };
          MultiHashHandler2.prototype._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
          };
          MultiHashHandler2.prototype.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
              return x;
            });
            var key = parts.pop();
            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode])
              key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length)
              return { key, hashId: -1 };
            else if (parts.length == 1 && parts[0] == "shift")
              return { key: key.toUpperCase(), hashId: -1 };
            var hashId = 0;
            for (var i = parts.length; i--; ) {
              var modifier = keyUtil.KEY_MODS[parts[i]];
              if (modifier == null) {
                if (typeof console != "undefined")
                  console.error("invalid modifier " + parts[i] + " in " + keys);
                return false;
              }
              hashId |= modifier;
            }
            return { key, hashId };
          };
          MultiHashHandler2.prototype.findKeyCommand = function(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
          };
          MultiHashHandler2.prototype.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0)
              return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
              data.$keyChain += " " + key;
              command = this.commandKeyBinding[data.$keyChain] || command;
            }
            if (command) {
              if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return { command: "null" };
              }
            }
            if (data.$keyChain) {
              if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
              else if (hashId == -1 || keyCode > 0)
                data.$keyChain = "";
            }
            return { command };
          };
          MultiHashHandler2.prototype.getStatusText = function(editor, data) {
            return data.$keyChain || "";
          };
          return MultiHashHandler2;
        }()
      );
      function getPosition(command) {
        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
      }
      var HashHandler = (
        /** @class */
        function(_super) {
          __extends(HashHandler2, _super);
          function HashHandler2(config, platform) {
            var _this = _super.call(this, config, platform) || this;
            _this.$singleCommand = true;
            return _this;
          }
          return HashHandler2;
        }(MultiHashHandler)
      );
      HashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
      };
      MultiHashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
      };
      exports2.HashHandler = HashHandler;
      exports2.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var oop = require3("../lib/oop");
      var MultiHashHandler = require3("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var CommandManager = (
        /** @class */
        function(_super) {
          __extends(CommandManager2, _super);
          function CommandManager2(platform, commands) {
            var _this = _super.call(this, commands, platform) || this;
            _this.byName = _this.commands;
            _this.setDefaultHandler("exec", function(e) {
              if (!e.args) {
                return e.command.exec(e.editor, {}, e.event, true);
              }
              return e.command.exec(e.editor, e.args, e.event, false);
            });
            return _this;
          }
          CommandManager2.prototype.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
              for (var i = command.length; i--; ) {
                if (this.exec(command[i], editor, args))
                  return true;
              }
              return false;
            }
            if (typeof command === "string")
              command = this.commands[command];
            var e = { editor, command, args };
            if (!this.canExecute(command, editor)) {
              this._signal("commandUnavailable", e);
              return false;
            }
            e.returnValue = this._emit("exec", e);
            this._signal("afterExec", e);
            return e.returnValue === false ? false : true;
          };
          CommandManager2.prototype.canExecute = function(command, editor) {
            if (typeof command === "string")
              command = this.commands[command];
            if (!command)
              return false;
            if (editor && editor.$readOnly && !command.readOnly)
              return false;
            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
              return false;
            return true;
          };
          CommandManager2.prototype.toggleRecording = function(editor) {
            if (this.$inReplay)
              return;
            editor && editor._emit("changeStatus");
            if (this.recording) {
              this.macro.pop();
              this.off("exec", this.$addCommandToMacro);
              if (!this.macro.length)
                this.macro = this.oldMacro;
              return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
              this.$addCommandToMacro = function(e) {
                this.macro.push([e.command, e.args]);
              }.bind(this);
            }
            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
          };
          CommandManager2.prototype.replay = function(editor) {
            if (this.$inReplay || !this.macro)
              return;
            if (this.recording)
              return this.toggleRecording(editor);
            try {
              this.$inReplay = true;
              this.macro.forEach(function(x) {
                if (typeof x == "string")
                  this.exec(x, editor);
                else
                  this.exec(x[0], editor, x[1]);
              }, this);
            } finally {
              this.$inReplay = false;
            }
          };
          CommandManager2.prototype.trimMacro = function(m) {
            return m.map(function(x) {
              if (typeof x[0] != "string")
                x[0] = x[0].name;
              if (!x[1])
                x = x[0];
              return x;
            });
          };
          return CommandManager2;
        }(MultiHashHandler)
      );
      oop.implement(CommandManager.prototype, EventEmitter);
      exports2.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var lang = require3("../lib/lang");
      var config = require3("../config");
      var Range = require3("../range").Range;
      function bindKey(win, mac) {
        return { win, mac };
      }
      exports2.commands = [
        {
          name: "showSettingsMenu",
          description: "Show settings menu",
          bindKey: bindKey("Ctrl-,", "Command-,"),
          exec: function(editor) {
            config.loadModule("ace/ext/settings_menu", function(module4) {
              module4.init(editor);
              editor.showSettingsMenu();
            });
          },
          readOnly: true
        },
        {
          name: "goToNextError",
          description: "Go to next error",
          bindKey: bindKey("Alt-E", "F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module4) {
              module4.showErrorMarker(editor, 1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "goToPreviousError",
          description: "Go to previous error",
          bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module4) {
              module4.showErrorMarker(editor, -1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selectall",
          description: "Select all",
          bindKey: bindKey("Ctrl-A", "Command-A"),
          exec: function(editor) {
            editor.selectAll();
          },
          readOnly: true
        },
        {
          name: "centerselection",
          description: "Center selection",
          bindKey: bindKey(null, "Ctrl-L"),
          exec: function(editor) {
            editor.centerSelection();
          },
          readOnly: true
        },
        {
          name: "gotoline",
          description: "Go to line...",
          bindKey: bindKey("Ctrl-L", "Command-L"),
          exec: function(editor, line) {
            if (typeof line === "number" && !isNaN(line))
              editor.gotoLine(line);
            editor.prompt({ $type: "gotoLine" });
          },
          readOnly: true
        },
        {
          name: "fold",
          bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
          exec: function(editor) {
            editor.session.toggleFold(false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfold",
          bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
          exec: function(editor) {
            editor.session.toggleFold(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleFoldWidget",
          description: "Toggle fold widget",
          bindKey: bindKey("F2", "F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleParentFoldWidget",
          description: "Toggle parent fold widget",
          bindKey: bindKey("Alt-F2", "Alt-F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldall",
          description: "Fold all",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldAllComments",
          description: "Fold all comments",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAllComments();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldOther",
          description: "Fold other",
          bindKey: bindKey("Alt-0", "Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfoldall",
          description: "Unfold all",
          bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
          exec: function(editor) {
            editor.session.unfold();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findnext",
          description: "Find next",
          bindKey: bindKey("Ctrl-K", "Command-G"),
          exec: function(editor) {
            editor.findNext();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findprevious",
          description: "Find previous",
          bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
          exec: function(editor) {
            editor.findPrevious();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "selectOrFindNext",
          description: "Select or find next",
          bindKey: bindKey("Alt-K", "Ctrl-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findNext();
          },
          readOnly: true
        },
        {
          name: "selectOrFindPrevious",
          description: "Select or find previous",
          bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findPrevious();
          },
          readOnly: true
        },
        {
          name: "find",
          description: "Find",
          bindKey: bindKey("Ctrl-F", "Command-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {
              e.Search(editor);
            });
          },
          readOnly: true
        },
        {
          name: "overwrite",
          description: "Overwrite",
          bindKey: "Insert",
          exec: function(editor) {
            editor.toggleOverwrite();
          },
          readOnly: true
        },
        {
          name: "selecttostart",
          description: "Select to start",
          bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
          exec: function(editor) {
            editor.getSelection().selectFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotostart",
          description: "Go to start",
          bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
          exec: function(editor) {
            editor.navigateFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectup",
          description: "Select up",
          bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
          exec: function(editor) {
            editor.getSelection().selectUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golineup",
          description: "Go line up",
          bindKey: bindKey("Up", "Up|Ctrl-P"),
          exec: function(editor, args) {
            editor.navigateUp(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttoend",
          description: "Select to end",
          bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
          exec: function(editor) {
            editor.getSelection().selectFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotoend",
          description: "Go to end",
          bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
          exec: function(editor) {
            editor.navigateFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectdown",
          description: "Select down",
          bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
          exec: function(editor) {
            editor.getSelection().selectDown();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golinedown",
          description: "Go line down",
          bindKey: bindKey("Down", "Down|Ctrl-N"),
          exec: function(editor, args) {
            editor.navigateDown(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordleft",
          description: "Select word left",
          bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
          exec: function(editor) {
            editor.getSelection().selectWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordleft",
          description: "Go to word left",
          bindKey: bindKey("Ctrl-Left", "Option-Left"),
          exec: function(editor) {
            editor.navigateWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolinestart",
          description: "Select to line start",
          bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolinestart",
          description: "Go to line start",
          bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
          exec: function(editor) {
            editor.navigateLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectleft",
          description: "Select left",
          bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
          exec: function(editor) {
            editor.getSelection().selectLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoleft",
          description: "Go to left",
          bindKey: bindKey("Left", "Left|Ctrl-B"),
          exec: function(editor, args) {
            editor.navigateLeft(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordright",
          description: "Select word right",
          bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordright",
          description: "Go to word right",
          bindKey: bindKey("Ctrl-Right", "Option-Right"),
          exec: function(editor) {
            editor.navigateWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolineend",
          description: "Select to line end",
          bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolineend",
          description: "Go to line end",
          bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
          exec: function(editor) {
            editor.navigateLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectright",
          description: "Select right",
          bindKey: bindKey("Shift-Right", "Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoright",
          description: "Go to right",
          bindKey: bindKey("Right", "Right|Ctrl-F"),
          exec: function(editor, args) {
            editor.navigateRight(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectpagedown",
          description: "Select page down",
          bindKey: "Shift-PageDown",
          exec: function(editor) {
            editor.selectPageDown();
          },
          readOnly: true
        },
        {
          name: "pagedown",
          description: "Page down",
          bindKey: bindKey(null, "Option-PageDown"),
          exec: function(editor) {
            editor.scrollPageDown();
          },
          readOnly: true
        },
        {
          name: "gotopagedown",
          description: "Go to page down",
          bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
          exec: function(editor) {
            editor.gotoPageDown();
          },
          readOnly: true
        },
        {
          name: "selectpageup",
          description: "Select page up",
          bindKey: "Shift-PageUp",
          exec: function(editor) {
            editor.selectPageUp();
          },
          readOnly: true
        },
        {
          name: "pageup",
          description: "Page up",
          bindKey: bindKey(null, "Option-PageUp"),
          exec: function(editor) {
            editor.scrollPageUp();
          },
          readOnly: true
        },
        {
          name: "gotopageup",
          description: "Go to page up",
          bindKey: "PageUp",
          exec: function(editor) {
            editor.gotoPageUp();
          },
          readOnly: true
        },
        {
          name: "scrollup",
          description: "Scroll up",
          bindKey: bindKey("Ctrl-Up", null),
          exec: function(e) {
            e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "scrolldown",
          description: "Scroll down",
          bindKey: bindKey("Ctrl-Down", null),
          exec: function(e) {
            e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "selectlinestart",
          description: "Select line start",
          bindKey: "Shift-Home",
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectlineend",
          description: "Select line end",
          bindKey: "Shift-End",
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "togglerecording",
          description: "Toggle recording",
          bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
          exec: function(editor) {
            editor.commands.toggleRecording(editor);
          },
          readOnly: true
        },
        {
          name: "replaymacro",
          description: "Replay macro",
          bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
          exec: function(editor) {
            editor.commands.replay(editor);
          },
          readOnly: true
        },
        {
          name: "jumptomatching",
          description: "Jump to matching",
          bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
          exec: function(editor) {
            editor.jumpToMatching();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selecttomatching",
          description: "Select to matching",
          bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
          exec: function(editor) {
            editor.jumpToMatching(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "expandToMatching",
          description: "Expand to matching",
          bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
          exec: function(editor) {
            editor.jumpToMatching(true, true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "passKeysToBrowser",
          description: "Pass keys to browser",
          bindKey: bindKey(null, null),
          exec: function() {
          },
          passEvent: true,
          readOnly: true
        },
        {
          name: "copy",
          description: "Copy",
          exec: function(editor) {
          },
          readOnly: true
        },
        {
          name: "cut",
          description: "Cut",
          exec: function(editor) {
            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit("cut", range);
            if (!range.isEmpty())
              editor.session.remove(range);
            editor.clearSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "paste",
          description: "Paste",
          exec: function(editor, args) {
            editor.$handlePaste(args);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "removeline",
          description: "Remove line",
          bindKey: bindKey("Ctrl-D", "Command-D"),
          exec: function(editor) {
            editor.removeLines();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEachLine"
        },
        {
          name: "duplicateSelection",
          description: "Duplicate selection",
          bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
          exec: function(editor) {
            editor.duplicateSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "sortlines",
          description: "Sort lines",
          bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
          exec: function(editor) {
            editor.sortLines();
          },
          scrollIntoView: "selection",
          multiSelectAction: "forEachLine"
        },
        {
          name: "togglecomment",
          description: "Toggle comment",
          bindKey: bindKey("Ctrl-/", "Command-/"),
          exec: function(editor) {
            editor.toggleCommentLines();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "toggleBlockComment",
          description: "Toggle block comment",
          bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
          exec: function(editor) {
            editor.toggleBlockComment();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "modifyNumberUp",
          description: "Modify number up",
          bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
          exec: function(editor) {
            editor.modifyNumber(1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "modifyNumberDown",
          description: "Modify number down",
          bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
          exec: function(editor) {
            editor.modifyNumber(-1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "replace",
          description: "Replace",
          bindKey: bindKey("Ctrl-H", "Command-Option-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e) {
              e.Search(editor, true);
            });
          }
        },
        {
          name: "undo",
          description: "Undo",
          bindKey: bindKey("Ctrl-Z", "Command-Z"),
          exec: function(editor) {
            editor.undo();
          }
        },
        {
          name: "redo",
          description: "Redo",
          bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
          exec: function(editor) {
            editor.redo();
          }
        },
        {
          name: "copylinesup",
          description: "Copy lines up",
          bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
          exec: function(editor) {
            editor.copyLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesup",
          description: "Move lines up",
          bindKey: bindKey("Alt-Up", "Option-Up"),
          exec: function(editor) {
            editor.moveLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "copylinesdown",
          description: "Copy lines down",
          bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
          exec: function(editor) {
            editor.copyLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesdown",
          description: "Move lines down",
          bindKey: bindKey("Alt-Down", "Option-Down"),
          exec: function(editor) {
            editor.moveLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "del",
          description: "Delete",
          bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
          exec: function(editor) {
            editor.remove("right");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "backspace",
          description: "Backspace",
          bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
          exec: function(editor) {
            editor.remove("left");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "cut_or_delete",
          description: "Cut or delete",
          bindKey: bindKey("Shift-Delete", null),
          exec: function(editor) {
            if (editor.selection.isEmpty()) {
              editor.remove("left");
            } else {
              return false;
            }
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestart",
          description: "Remove to line start",
          bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
          exec: function(editor) {
            editor.removeToLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineend",
          description: "Remove to line end",
          bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
          exec: function(editor) {
            editor.removeToLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestarthard",
          description: "Remove to line start hard",
          bindKey: bindKey("Ctrl-Shift-Backspace", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineendhard",
          description: "Remove to line end hard",
          bindKey: bindKey("Ctrl-Shift-Delete", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordleft",
          description: "Remove word left",
          bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
          exec: function(editor) {
            editor.removeWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordright",
          description: "Remove word right",
          bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
          exec: function(editor) {
            editor.removeWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "outdent",
          description: "Outdent",
          bindKey: bindKey("Shift-Tab", "Shift-Tab"),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "indent",
          description: "Indent",
          bindKey: bindKey("Tab", "Tab"),
          exec: function(editor) {
            editor.indent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockoutdent",
          description: "Block outdent",
          bindKey: bindKey("Ctrl-[", "Ctrl-["),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockindent",
          description: "Block indent",
          bindKey: bindKey("Ctrl-]", "Ctrl-]"),
          exec: function(editor) {
            editor.blockIndent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "insertstring",
          description: "Insert string",
          exec: function(editor, str) {
            editor.insert(str);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "inserttext",
          description: "Insert text",
          exec: function(editor, args) {
            editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "splitline",
          description: "Split line",
          bindKey: bindKey(null, "Ctrl-O"),
          exec: function(editor) {
            editor.splitLine();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "transposeletters",
          description: "Transpose letters",
          bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
          exec: function(editor) {
            editor.transposeLetters();
          },
          multiSelectAction: function(editor) {
            editor.transposeSelections(1);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "touppercase",
          description: "To uppercase",
          bindKey: bindKey("Ctrl-U", "Ctrl-U"),
          exec: function(editor) {
            editor.toUpperCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "tolowercase",
          description: "To lowercase",
          bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
          exec: function(editor) {
            editor.toLowerCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "autoindent",
          description: "Auto Indent",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.autoIndent();
          },
          scrollIntoView: "animate"
        },
        {
          name: "expandtoline",
          description: "Expand to line",
          bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "openlink",
          bindKey: bindKey("Ctrl+F3", "F3"),
          exec: function(editor) {
            editor.openLink();
          }
        },
        {
          name: "joinlines",
          description: "Join lines",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);
            for (var i2 = selectionStart.row + 1; i2 <= selectionEnd.row + 1; i2++) {
              var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i2)));
              if (curLine.length !== 0) {
                curLine = " " + curLine;
              }
              insertLine += curLine;
            }
            if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
              insertLine += editor.session.doc.getNewLineCharacter();
            }
            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
            if (selectedCount > 0) {
              editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
              editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            } else {
              firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
              editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
          },
          multiSelectAction: "forEach",
          readOnly: true
        },
        {
          name: "invertSelection",
          description: "Invert selection",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
              ranges = [editor.selection.getRange()];
            }
            for (var i2 = 0; i2 < ranges.length; i2++) {
              if (i2 == ranges.length - 1) {
                if (!(ranges[i2].end.row === endRow && ranges[i2].end.column === endCol)) {
                  newRanges.push(new Range(ranges[i2].end.row, ranges[i2].end.column, endRow, endCol));
                }
              }
              if (i2 === 0) {
                if (!(ranges[i2].start.row === 0 && ranges[i2].start.column === 0)) {
                  newRanges.push(new Range(0, 0, ranges[i2].start.row, ranges[i2].start.column));
                }
              } else {
                newRanges.push(new Range(ranges[i2 - 1].end.row, ranges[i2 - 1].end.column, ranges[i2].start.row, ranges[i2].start.column));
              }
            }
            editor.exitMultiSelectMode();
            editor.clearSelection();
            for (var i2 = 0; i2 < newRanges.length; i2++) {
              editor.selection.addRange(newRanges[i2], false);
            }
          },
          readOnly: true,
          scrollIntoView: "none"
        },
        {
          name: "addLineAfter",
          description: "Add new line after the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert("\n");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "addLineBefore",
          description: "Add new line before the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert("\n");
            if (cursor.row === 0)
              editor.navigateUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "openCommandPallete",
          exec: function(editor) {
            console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
            editor.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "openCommandPalette",
          description: "Open command palette",
          bindKey: bindKey("F1", "F1"),
          exec: function(editor) {
            editor.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "modeSelect",
          description: "Change language mode...",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.prompt({ $type: "modes" });
          },
          readOnly: true
        }
      ];
      for (var i = 1; i < 9; i++) {
        exports2.commands.push({
          name: "foldToLevel" + i,
          description: "Fold To Level " + i,
          level: i,
          exec: function(editor) {
            editor.session.foldToLevel(this.level);
          },
          scrollIntoView: "center",
          readOnly: true
        });
      }
    });
    ace.define("ace/keyboard/gutter_handler", ["require", "exports", "module", "ace/lib/keys", "ace/mouse/default_gutter_handler"], function(require3, exports2, module3) {
      "use strict";
      var keys = require3("../lib/keys");
      var GutterTooltip = require3("../mouse/default_gutter_handler").GutterTooltip;
      var GutterKeyboardHandler = (
        /** @class */
        function() {
          function GutterKeyboardHandler2(editor) {
            this.editor = editor;
            this.gutterLayer = editor.renderer.$gutterLayer;
            this.element = editor.renderer.$gutter;
            this.lines = editor.renderer.$gutterLayer.$lines;
            this.activeRowIndex = null;
            this.activeLane = null;
            this.annotationTooltip = new GutterTooltip(this.editor);
          }
          GutterKeyboardHandler2.prototype.addListener = function() {
            this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.addEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.on("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.removeListener = function() {
            this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.off("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.$onGutterKeyDown = function(e) {
            if (this.annotationTooltip.isOpen) {
              e.preventDefault();
              if (e.keyCode === keys["escape"])
                this.annotationTooltip.hideTooltip();
              return;
            }
            if (e.target === this.element) {
              if (e.keyCode != keys["enter"]) {
                return;
              }
              e.preventDefault();
              var row = this.editor.getCursorPosition().row;
              if (!this.editor.isRowVisible(row))
                this.editor.scrollToLine(row, true, true);
              setTimeout(
                function() {
                  var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                  var nearestFoldLaneWidgetIndex = this.$findNearestFoldLaneWidget(index);
                  var nearestAnnotationIndex = this.$findNearestAnnotation(index);
                  if (nearestFoldLaneWidgetIndex === null && nearestAnnotationIndex === null)
                    return;
                  var futureActiveRowIndex = this.$findClosestNumber(nearestFoldLaneWidgetIndex, nearestAnnotationIndex, index);
                  if (futureActiveRowIndex === nearestFoldLaneWidgetIndex) {
                    this.activeLane = "fold";
                    this.activeRowIndex = nearestFoldLaneWidgetIndex;
                    if (this.$isCustomWidgetVisible(nearestFoldLaneWidgetIndex)) {
                      this.$focusCustomWidget(this.activeRowIndex);
                      return;
                    } else {
                      this.$focusFoldWidget(this.activeRowIndex);
                      return;
                    }
                  } else {
                    this.activeRowIndex = nearestAnnotationIndex;
                    this.activeLane = "annotation";
                    this.$focusAnnotation(this.activeRowIndex);
                    return;
                  }
                }.bind(this),
                10
              );
              return;
            }
            this.$handleGutterKeyboardInteraction(e);
            setTimeout(function() {
              this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e, this));
            }.bind(this), 10);
          };
          GutterKeyboardHandler2.prototype.$handleGutterKeyboardInteraction = function(e) {
            if (e.keyCode === keys["tab"]) {
              e.preventDefault();
              return;
            }
            if (e.keyCode === keys["escape"]) {
              e.preventDefault();
              this.$blurGutter();
              this.element.focus();
              this.lane = null;
              return;
            }
            if (e.keyCode === keys["up"]) {
              e.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetUp();
                  break;
                case "annotation":
                  this.$moveAnnotationUp();
                  break;
              }
              return;
            }
            if (e.keyCode === keys["down"]) {
              e.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetDown();
                  break;
                case "annotation":
                  this.$moveAnnotationDown();
                  break;
              }
              return;
            }
            if (e.keyCode === keys["left"]) {
              e.preventDefault();
              this.$switchLane("annotation");
              return;
            }
            if (e.keyCode === keys["right"]) {
              e.preventDefault();
              this.$switchLane("fold");
              return;
            }
            if (e.keyCode === keys["enter"] || e.keyCode === keys["space"]) {
              e.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  var row = this.$rowIndexToRow(this.activeRowIndex);
                  var customWidget = this.editor.session.$gutterCustomWidgets[row];
                  if (customWidget) {
                    if (customWidget.callbacks && customWidget.callbacks.onClick) {
                      customWidget.callbacks.onClick(e, row);
                    }
                  } else if (this.gutterLayer.session.foldWidgets[row] === "start") {
                    this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);
                    setTimeout(
                      function() {
                        if (this.$rowIndexToRow(this.activeRowIndex) !== row) {
                          this.$blurFoldWidget(this.activeRowIndex);
                          this.activeRowIndex = this.$rowToRowIndex(row);
                          this.$focusFoldWidget(this.activeRowIndex);
                        }
                      }.bind(this),
                      10
                    );
                    break;
                  } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end") {
                    break;
                  }
                  return;
                case "annotation":
                  var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
                  var rect = gutterElement.getBoundingClientRect();
                  var style = this.annotationTooltip.getElement().style;
                  style.left = rect.right + "px";
                  style.top = rect.bottom + "px";
                  this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                  break;
              }
              return;
            }
          };
          GutterKeyboardHandler2.prototype.$blurGutter = function() {
            if (this.activeRowIndex !== null) {
              switch (this.activeLane) {
                case "fold":
                  this.$blurFoldWidget(this.activeRowIndex);
                  this.$blurCustomWidget(this.activeRowIndex);
                  break;
                case "annotation":
                  this.$blurAnnotation(this.activeRowIndex);
                  break;
              }
            }
            if (this.annotationTooltip.isOpen)
              this.annotationTooltip.hideTooltip();
            return;
          };
          GutterKeyboardHandler2.prototype.$isFoldWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$isCustomWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = !!this.$getCustomWidget(index);
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$isAnnotationVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getAnnotation(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$getFoldWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[1];
          };
          GutterKeyboardHandler2.prototype.$getCustomWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[3];
          };
          GutterKeyboardHandler2.prototype.$getAnnotation = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[2];
          };
          GutterKeyboardHandler2.prototype.$findNearestFoldLaneWidget = function(index) {
            if (this.$isCustomWidgetVisible(index))
              return index;
            if (this.$isFoldWidgetVisible(index))
              return index;
            var i = 0;
            while (index - i > 0 || index + i < this.lines.getLength() - 1) {
              i++;
              if (index - i >= 0 && this.$isCustomWidgetVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isCustomWidgetVisible(index + i))
                return index + i;
              if (index - i >= 0 && this.$isFoldWidgetVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i))
                return index + i;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$findNearestAnnotation = function(index) {
            if (this.$isAnnotationVisible(index))
              return index;
            var i = 0;
            while (index - i > 0 || index + i < this.lines.getLength() - 1) {
              i++;
              if (index - i >= 0 && this.$isAnnotationVisible(index - i))
                return index - i;
              if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i))
                return index + i;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$focusFoldWidget = function(index) {
            if (index == null)
              return;
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
            foldWidget.focus();
          };
          GutterKeyboardHandler2.prototype.$focusCustomWidget = function(index) {
            if (index == null)
              return;
            var customWidget = this.$getCustomWidget(index);
            if (customWidget) {
              customWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
              customWidget.focus();
            }
          };
          GutterKeyboardHandler2.prototype.$focusAnnotation = function(index) {
            if (index == null)
              return;
            var annotation = this.$getAnnotation(index);
            annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
            annotation.focus();
          };
          GutterKeyboardHandler2.prototype.$blurFoldWidget = function(index) {
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
            foldWidget.blur();
          };
          GutterKeyboardHandler2.prototype.$blurCustomWidget = function(index) {
            var customWidget = this.$getCustomWidget(index);
            if (customWidget) {
              customWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
              customWidget.blur();
            }
          };
          GutterKeyboardHandler2.prototype.$blurAnnotation = function(index) {
            var annotation = this.$getAnnotation(index);
            annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
            annotation.blur();
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                if (this.$isFoldWidgetVisible(index)) {
                  this.$focusFoldWidget(this.activeRowIndex);
                } else {
                  this.$focusCustomWidget(this.activeRowIndex);
                }
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                if (this.$isFoldWidgetVisible(index)) {
                  this.$focusFoldWidget(this.activeRowIndex);
                } else {
                  this.$focusCustomWidget(this.activeRowIndex);
                }
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$findClosestNumber = function(num1, num2, target) {
            if (num1 === null)
              return num2;
            if (num2 === null)
              return num1;
            return Math.abs(target - num1) <= Math.abs(target - num2) ? num1 : num2;
          };
          GutterKeyboardHandler2.prototype.$switchLane = function(desinationLane) {
            switch (desinationLane) {
              case "annotation":
                if (this.activeLane === "annotation") {
                  break;
                }
                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
                if (annotationIndex == null) {
                  break;
                }
                this.activeLane = "annotation";
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                this.activeRowIndex = annotationIndex;
                this.$focusAnnotation(this.activeRowIndex);
                break;
              case "fold":
                if (this.activeLane === "fold") {
                  break;
                }
                var foldLaneWidgetIndex = this.$findNearestFoldLaneWidget(this.activeRowIndex);
                if (foldLaneWidgetIndex === null) {
                  break;
                }
                this.activeLane = "fold";
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = foldLaneWidgetIndex;
                if (this.$isCustomWidgetVisible(foldLaneWidgetIndex)) {
                  this.$focusCustomWidget(this.activeRowIndex);
                } else {
                  this.$focusFoldWidget(this.activeRowIndex);
                }
                break;
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$rowIndexToRow = function(index) {
            var cell = this.lines.get(index);
            if (cell)
              return cell.row;
            return null;
          };
          GutterKeyboardHandler2.prototype.$rowToRowIndex = function(row) {
            for (var i = 0; i < this.lines.getLength(); i++) {
              var cell = this.lines.get(i);
              if (cell.row == row)
                return i;
            }
            return null;
          };
          return GutterKeyboardHandler2;
        }()
      );
      exports2.GutterKeyboardHandler = GutterKeyboardHandler;
      var GutterKeyboardEvent = (
        /** @class */
        function() {
          function GutterKeyboardEvent2(domEvent, gutterKeyboardHandler) {
            this.gutterKeyboardHandler = gutterKeyboardHandler;
            this.domEvent = domEvent;
          }
          GutterKeyboardEvent2.prototype.getKey = function() {
            return keys.keyCodeToString(this.domEvent.keyCode);
          };
          GutterKeyboardEvent2.prototype.getRow = function() {
            return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
          };
          GutterKeyboardEvent2.prototype.isInAnnotationLane = function() {
            return this.gutterKeyboardHandler.activeLane === "annotation";
          };
          GutterKeyboardEvent2.prototype.isInFoldLane = function() {
            return this.gutterKeyboardHandler.activeLane === "fold";
          };
          return GutterKeyboardEvent2;
        }()
      );
      exports2.GutterKeyboardEvent = GutterKeyboardEvent;
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/keyboard/gutter_handler", "ace/config", "ace/clipboard", "ace/lib/keys", "ace/lib/event", "ace/tooltip"], function(require3, exports2, module3) {
      "use strict";
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var oop = require3("./lib/oop");
      var dom = require3("./lib/dom");
      var lang = require3("./lib/lang");
      var useragent = require3("./lib/useragent");
      var TextInput = require3("./keyboard/textinput").TextInput;
      var MouseHandler = require3("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = require3("./mouse/fold_handler").FoldHandler;
      var KeyBinding = require3("./keyboard/keybinding").KeyBinding;
      var EditSession = require3("./edit_session").EditSession;
      var Search = require3("./search").Search;
      var Range = require3("./range").Range;
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var CommandManager = require3("./commands/command_manager").CommandManager;
      var defaultCommands = require3("./commands/default_commands").commands;
      var config = require3("./config");
      var TokenIterator = require3("./token_iterator").TokenIterator;
      var GutterKeyboardHandler = require3("./keyboard/gutter_handler").GutterKeyboardHandler;
      var nls = require3("./config").nls;
      var clipboard = require3("./clipboard");
      var keys = require3("./lib/keys");
      var event = require3("./lib/event");
      var HoverTooltip = require3("./tooltip").HoverTooltip;
      var Editor = (
        /** @class */
        function() {
          function Editor2(renderer, session, options) {
            this.id = "editor" + ++Editor2.$uid;
            this.session;
            this.$toDestroy = [];
            var container = renderer.getContainerElement();
            this.container = container;
            this.renderer = renderer;
            this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
            if (typeof document == "object") {
              this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
              this.renderer.textarea = this.textInput.getElement();
              this.$mouseHandler = new MouseHandler(this);
              new FoldHandler(this);
            }
            this.keyBinding = new KeyBinding(this);
            this.$search = new Search().set({
              wrap: true
            });
            this.$historyTracker = this.$historyTracker.bind(this);
            this.commands.on("exec", this.$historyTracker);
            this.$initOperationListeners();
            this._$emitInputEvent = lang.delayedCall(function() {
              this._signal("input", {});
              if (this.session && !this.session.destroyed)
                this.session.bgTokenizer.scheduleStart();
            }.bind(this));
            this.on("change", function(_2, _self) {
              _self._$emitInputEvent.schedule(31);
            });
            this.setSession(session || options && options.session || new EditSession(""));
            config.resetOptions(this);
            if (options)
              this.setOptions(options);
            config._signal("editor", this);
          }
          Editor2.prototype.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);
          };
          Editor2.prototype.startOperation = function(commandEvent) {
            this.session.startOperation(commandEvent);
          };
          Editor2.prototype.endOperation = function(e) {
            this.session.endOperation(e);
          };
          Editor2.prototype.onStartOperation = function(commandEvent) {
            this.curOp = this.session.curOp;
            this.curOp.scrollTop = this.renderer.scrollTop;
            this.prevOp = this.session.prevOp;
            if (!commandEvent) {
              this.previousCommand = null;
            }
          };
          Editor2.prototype.onEndOperation = function(e) {
            if (this.curOp && this.session) {
              if (e && e.returnValue === false) {
                this.curOp = null;
                return;
              }
              this._signal("beforeEndOperation");
              if (!this.curOp)
                return;
              var command = this.curOp.command;
              var scrollIntoView = command && command.scrollIntoView;
              if (scrollIntoView) {
                switch (scrollIntoView) {
                  case "center-animate":
                    scrollIntoView = "animate";
                  case "center":
                    this.renderer.scrollCursorIntoView(null, 0.5);
                    break;
                  case "animate":
                  case "cursor":
                    this.renderer.scrollCursorIntoView();
                    break;
                  case "selectionPart":
                    var range = this.selection.getRange();
                    var config2 = this.renderer.layerConfig;
                    if (range.start.row >= config2.lastRow || range.end.row <= config2.firstRow) {
                      this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                    }
                    break;
                  default:
                    break;
                }
                if (scrollIntoView == "animate")
                  this.renderer.animateScrolling(this.curOp.scrollTop);
              }
              this.$lastSel = this.session.selection.toJSON();
              this.prevOp = this.curOp;
              this.curOp = null;
            }
          };
          Editor2.prototype.$historyTracker = function(e) {
            if (!this.$mergeUndoDeltas)
              return;
            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && e.command.name == prev.command.name;
            if (e.command.name == "insertstring") {
              var text = e.args;
              if (this.mergeNextCommand === void 0)
                this.mergeNextCommand = true;
              shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
              this.mergeNextCommand = true;
            } else {
              shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
            }
            if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
              shouldMerge = false;
            }
            if (shouldMerge)
              this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e.command.name) !== -1)
              this.sequenceStartTime = Date.now();
          };
          Editor2.prototype.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
              this.$keybindingId = keyboardHandler;
              var _self = this;
              config.loadModule(["keybinding", keyboardHandler], function(module4) {
                if (_self.$keybindingId == keyboardHandler)
                  _self.keyBinding.setKeyboardHandler(module4 && module4.handler);
                cb && cb();
              });
            } else {
              this.$keybindingId = null;
              this.keyBinding.setKeyboardHandler(keyboardHandler);
              cb && cb();
            }
          };
          Editor2.prototype.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
          };
          Editor2.prototype.setSession = function(session) {
            if (this.session == session)
              return;
            if (this.curOp)
              this.endOperation();
            this.curOp = {};
            var oldSession = this.session;
            if (oldSession) {
              this.session.off("change", this.$onDocumentChange);
              this.session.off("changeMode", this.$onChangeMode);
              this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
              this.session.off("changeTabSize", this.$onChangeTabSize);
              this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
              this.session.off("changeWrapMode", this.$onChangeWrapMode);
              this.session.off("changeFold", this.$onChangeFold);
              this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
              this.session.off("changeBackMarker", this.$onChangeBackMarker);
              this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
              this.session.off("changeAnnotation", this.$onChangeAnnotation);
              this.session.off("changeOverwrite", this.$onCursorChange);
              this.session.off("changeScrollTop", this.$onScrollTopChange);
              this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              this.session.off("startOperation", this.$onStartOperation);
              this.session.off("endOperation", this.$onEndOperation);
              var selection = this.session.getSelection();
              selection.off("changeCursor", this.$onCursorChange);
              selection.off("changeSelection", this.$onSelectionChange);
            }
            this.session = session;
            if (session) {
              this.$onDocumentChange = this.onDocumentChange.bind(this);
              session.on("change", this.$onDocumentChange);
              this.renderer.setSession(session);
              this.$onChangeMode = this.onChangeMode.bind(this);
              session.on("changeMode", this.$onChangeMode);
              this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
              session.on("tokenizerUpdate", this.$onTokenizerUpdate);
              this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
              session.on("changeTabSize", this.$onChangeTabSize);
              this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
              session.on("changeWrapLimit", this.$onChangeWrapLimit);
              this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
              session.on("changeWrapMode", this.$onChangeWrapMode);
              this.$onChangeFold = this.onChangeFold.bind(this);
              session.on("changeFold", this.$onChangeFold);
              this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
              this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
              this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
              this.session.on("changeBackMarker", this.$onChangeBackMarker);
              this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
              this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
              this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
              this.session.on("changeAnnotation", this.$onChangeAnnotation);
              this.$onCursorChange = this.onCursorChange.bind(this);
              this.session.on("changeOverwrite", this.$onCursorChange);
              this.$onScrollTopChange = this.onScrollTopChange.bind(this);
              this.session.on("changeScrollTop", this.$onScrollTopChange);
              this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
              this.session.on("changeScrollLeft", this.$onScrollLeftChange);
              this.selection = session.getSelection();
              this.selection.on("changeCursor", this.$onCursorChange);
              this.$onSelectionChange = this.onSelectionChange.bind(this);
              this.selection.on("changeSelection", this.$onSelectionChange);
              this.$onStartOperation = this.onStartOperation.bind(this);
              this.session.on("startOperation", this.$onStartOperation);
              this.$onEndOperation = this.onEndOperation.bind(this);
              this.session.on("endOperation", this.$onEndOperation);
              this.onChangeMode();
              this.onCursorChange();
              this.onScrollTopChange();
              this.onScrollLeftChange();
              this.onSelectionChange();
              this.onChangeFrontMarker();
              this.onChangeBackMarker();
              this.onChangeBreakpoint();
              this.onChangeAnnotation();
              this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
              this.renderer.updateFull();
            } else {
              this.selection = null;
              this.renderer.setSession(session);
            }
            this._signal("changeSession", {
              session,
              oldSession
            });
            this.curOp = null;
            oldSession && oldSession._signal("changeEditor", { oldEditor: this });
            if (oldSession)
              oldSession.$editor = null;
            session && session._signal("changeEditor", { editor: this });
            if (session)
              session.$editor = this;
            if (session && !session.destroyed)
              session.bgTokenizer.scheduleStart();
          };
          Editor2.prototype.getSession = function() {
            return this.session;
          };
          Editor2.prototype.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);
            if (!cursorPos)
              this.selectAll();
            else if (cursorPos == 1)
              this.navigateFileEnd();
            else if (cursorPos == -1)
              this.navigateFileStart();
            return val;
          };
          Editor2.prototype.getValue = function() {
            return this.session.getValue();
          };
          Editor2.prototype.getSelection = function() {
            return this.selection;
          };
          Editor2.prototype.resize = function(force) {
            this.renderer.onResize(force);
          };
          Editor2.prototype.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
          };
          Editor2.prototype.getTheme = function() {
            return this.renderer.getTheme();
          };
          Editor2.prototype.setStyle = function(style, incluude) {
            this.renderer.setStyle(style, incluude);
          };
          Editor2.prototype.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
          };
          Editor2.prototype.getFontSize = function() {
            return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
          };
          Editor2.prototype.setFontSize = function(size) {
            this.setOption("fontSize", size);
          };
          Editor2.prototype.$highlightBrackets = function() {
            if (this.$highlightPending) {
              return;
            }
            var self2 = this;
            this.$highlightPending = true;
            setTimeout(function() {
              self2.$highlightPending = false;
              var session = self2.session;
              if (!session || session.destroyed)
                return;
              if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                  session.removeMarker(id);
                });
                session.$bracketHighlight = null;
              }
              var pos = self2.getCursorPosition();
              var handler = self2.getKeyboardHandler();
              var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self2);
              var ranges = session.getMatchingBracketRanges(pos, isBackwards);
              if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                  var tagNamesRanges = session.getMatchingTags(pos);
                  if (tagNamesRanges) {
                    ranges = [
                      tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
                      tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
                    ];
                  }
                }
              }
              if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self2.session);
              if (!ranges) {
                if (self2.getHighlightIndentGuides())
                  self2.renderer.$textLayer.$highlightIndentGuide();
                return;
              }
              var markerType = "ace_bracket";
              if (!Array.isArray(ranges)) {
                ranges = [ranges];
              } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
              }
              if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                  ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                  ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
              }
              session.$bracketHighlight = {
                ranges,
                markerIds: ranges.map(function(range) {
                  return session.addMarker(range, markerType, "text");
                })
              };
              if (self2.getHighlightIndentGuides())
                self2.renderer.$textLayer.$highlightIndentGuide();
            }, 50);
          };
          Editor2.prototype.focus = function() {
            this.textInput.focus();
          };
          Editor2.prototype.isFocused = function() {
            return this.textInput.isFocused();
          };
          Editor2.prototype.blur = function() {
            this.textInput.blur();
          };
          Editor2.prototype.onFocus = function(e) {
            if (this.$isFocused)
              return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e);
          };
          Editor2.prototype.onBlur = function(e) {
            if (!this.$isFocused)
              return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e);
          };
          Editor2.prototype.$cursorChange = function() {
            this.renderer.updateCursor();
            this.$highlightBrackets();
            this.$updateHighlightActiveLine();
          };
          Editor2.prototype.onDocumentChange = function(delta) {
            var wrap = this.session.$useWrapMode;
            var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
            this.renderer.updateLines(delta.start.row, lastRow, wrap);
            this._signal("change", delta);
            this.$cursorChange();
          };
          Editor2.prototype.onTokenizerUpdate = function(e) {
            var rows = e.data;
            this.renderer.updateLines(rows.first, rows.last);
          };
          Editor2.prototype.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
          };
          Editor2.prototype.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
          };
          Editor2.prototype.onCursorChange = function() {
            this.$cursorChange();
            this._signal("changeSelection");
          };
          Editor2.prototype.$updateHighlightActiveLine = function() {
            var session = this.getSession();
            var highlight;
            if (this.$highlightActiveLine) {
              if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
              if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
              if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
            }
            if (session.$highlightLineMarker && !highlight) {
              session.removeMarker(session.$highlightLineMarker.id);
              session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
              var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
              range.id = session.addMarker(range, "ace_active-line", "screenLine");
              session.$highlightLineMarker = range;
            } else if (highlight) {
              session.$highlightLineMarker.start.row = highlight.row;
              session.$highlightLineMarker.end.row = highlight.row;
              session.$highlightLineMarker.start.column = highlight.column;
              session._signal("changeBackMarker");
            }
          };
          Editor2.prototype.onSelectionChange = function(e) {
            var session = this.session;
            if (session.$selectionMarker) {
              session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
              var range = this.selection.getRange();
              var style = this.getSelectionStyle();
              session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
              this.$updateHighlightActiveLine();
            }
            var re3 = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re3);
            this._signal("changeSelection");
          };
          Editor2.prototype.$getSelectionHighLightRegexp = function() {
            var session = this.session;
            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
              return;
            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5e3 || !/[\w\d]/.test(needle))
              return;
            var re3 = this.$search.$assembleRegExp({
              wholeWord: true,
              caseSensitive: true,
              needle
            });
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re3.test(wordWithBoundary))
              return;
            return re3;
          };
          Editor2.prototype.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
          };
          Editor2.prototype.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
          };
          Editor2.prototype.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
          };
          Editor2.prototype.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
          };
          Editor2.prototype.onChangeMode = function(e) {
            this.renderer.updateText();
            this._emit("changeMode", e);
          };
          Editor2.prototype.onChangeWrapLimit = function() {
            this.renderer.updateFull();
          };
          Editor2.prototype.onChangeWrapMode = function() {
            this.renderer.onResize(true);
          };
          Editor2.prototype.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
          };
          Editor2.prototype.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
          };
          Editor2.prototype.getCopyText = function() {
            var text = this.getSelectedText();
            var nl2 = this.session.doc.getNewLineCharacter();
            var copyLine = false;
            if (!text && this.$copyWithEmptySelection) {
              copyLine = true;
              var ranges = this.selection.getAllRanges();
              for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (i && ranges[i - 1].start.row == range.start.row)
                  continue;
                text += this.session.getLine(range.start.row) + nl2;
              }
            }
            var e = { text };
            this._signal("copy", e);
            clipboard.lineMode = copyLine ? e.text : false;
            return e.text;
          };
          Editor2.prototype.onCopy = function() {
            this.commands.exec("copy", this);
          };
          Editor2.prototype.onCut = function() {
            this.commands.exec("cut", this);
          };
          Editor2.prototype.onPaste = function(text, event2) {
            var e = { text, event: event2 };
            this.commands.exec("paste", this, e);
          };
          Editor2.prototype.$handlePaste = function(e) {
            if (typeof e == "string")
              e = { text: e };
            this._signal("paste", e);
            var text = e.text;
            var lineMode = text === clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
              if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
              else
                this.insert(text);
            } else if (lineMode) {
              this.selection.rangeList.ranges.forEach(function(range2) {
                session.insert({ row: range2.start.row, column: 0 }, text);
              });
            } else {
              var lines = text.split(/\r\n|\r|\n/);
              var ranges = this.selection.rangeList.ranges;
              var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
              if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);
              for (var i = ranges.length; i--; ) {
                var range = ranges[i];
                if (!range.isEmpty())
                  session.remove(range);
                session.insert(range.start, lines[i]);
              }
            }
          };
          Editor2.prototype.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
          };
          Editor2.prototype.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !pasted) {
              var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
              if (transform) {
                if (text !== transform.text) {
                  if (!this.inVirtualSelectionMode) {
                    this.session.mergeUndoDeltas = false;
                    this.mergeNextCommand = false;
                  }
                }
                text = transform.text;
              }
            }
            if (text == "	")
              text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
              var range = this.getSelectionRange();
              cursor = this.session.remove(range);
              this.clearSelection();
            } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
              var range = Range.fromPoints(cursor, cursor);
              range.end.column += text.length;
              this.session.remove(range);
            }
            if (text == "\n" || text == "\r\n") {
              var line = session.getLine(cursor.row);
              if (cursor.column > line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
              }
            }
            this.clearSelection();
            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);
            if (transform && transform.selection) {
              if (transform.selection.length == 2) {
                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
              } else {
                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
              }
            }
            if (this.$enableAutoIndent) {
              if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
              }
              if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
            }
          };
          Editor2.prototype.autoIndent = function() {
            var session = this.session;
            var mode = session.getMode();
            var ranges = this.selection.isEmpty() ? [new Range(0, 0, session.doc.getLength() - 1, 0)] : this.selection.getAllRanges();
            var prevLineState = "";
            var prevLine = "";
            var lineIndent = "";
            var tab = session.getTabString();
            for (var i = 0; i < ranges.length; i++) {
              var startRow = ranges[i].start.row;
              var endRow = ranges[i].end.row;
              for (var row = startRow; row <= endRow; row++) {
                if (row > 0) {
                  prevLineState = session.getState(row - 1);
                  prevLine = session.getLine(row - 1);
                  lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
                }
                var line = session.getLine(row);
                var currIndent = mode.$getIndent(line);
                if (lineIndent !== currIndent) {
                  if (currIndent.length > 0) {
                    var range = new Range(row, 0, row, currIndent.length);
                    session.remove(range);
                  }
                  if (lineIndent.length > 0) {
                    session.insert({ row, column: 0 }, lineIndent);
                  }
                }
                mode.autoOutdent(prevLineState, session, row);
              }
            }
          };
          Editor2.prototype.onTextInput = function(text, composition) {
            if (!composition)
              return this.keyBinding.onTextInput(text);
            this.startOperation({ command: { name: "insertstring" } });
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount)
              this.forEachSelection(applyComposition);
            else
              applyComposition();
            this.endOperation();
          };
          Editor2.prototype.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
              var r = this.selection.getRange();
              r.start.column -= composition.extendLeft;
              r.end.column += composition.extendRight;
              if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
              }
              this.selection.setRange(r);
              if (!text && !r.isEmpty())
                this.remove();
            }
            if (text || !this.selection.isEmpty())
              this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
              var r = this.selection.getRange();
              r.start.column -= composition.restoreStart;
              r.end.column -= composition.restoreEnd;
              this.selection.setRange(r);
            }
          };
          Editor2.prototype.onCommandKey = function(e, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e, hashId, keyCode);
          };
          Editor2.prototype.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
          };
          Editor2.prototype.getOverwrite = function() {
            return this.session.getOverwrite();
          };
          Editor2.prototype.toggleOverwrite = function() {
            this.session.toggleOverwrite();
          };
          Editor2.prototype.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
          };
          Editor2.prototype.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
          };
          Editor2.prototype.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
          };
          Editor2.prototype.getDragDelay = function() {
            return this.getOption("dragDelay");
          };
          Editor2.prototype.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
          };
          Editor2.prototype.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
          };
          Editor2.prototype.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
          };
          Editor2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          Editor2.prototype.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
          };
          Editor2.prototype.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
          };
          Editor2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.renderer.setAnimatedScroll(shouldAnimate);
          };
          Editor2.prototype.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
          };
          Editor2.prototype.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
          };
          Editor2.prototype.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
          };
          Editor2.prototype.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
          };
          Editor2.prototype.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
          };
          Editor2.prototype.setHighlightIndentGuides = function(highlight) {
            this.renderer.setHighlightIndentGuides(highlight);
          };
          Editor2.prototype.getHighlightIndentGuides = function() {
            return this.renderer.getHighlightIndentGuides();
          };
          Editor2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
          };
          Editor2.prototype.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
          };
          Editor2.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
          };
          Editor2.prototype.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
          };
          Editor2.prototype.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
          };
          Editor2.prototype.getReadOnly = function() {
            return this.getOption("readOnly");
          };
          Editor2.prototype.setBehavioursEnabled = function(enabled) {
            this.setOption("behavioursEnabled", enabled);
          };
          Editor2.prototype.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
          };
          Editor2.prototype.setWrapBehavioursEnabled = function(enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
          };
          Editor2.prototype.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
          };
          Editor2.prototype.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);
          };
          Editor2.prototype.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
          };
          Editor2.prototype.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
          };
          Editor2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          Editor2.prototype.remove = function(dir) {
            if (this.selection.isEmpty()) {
              if (dir == "left")
                this.selection.selectLeft();
              else
                this.selection.selectRight();
            }
            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
              var session = this.session;
              var state = session.getState(range.start.row);
              var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
              if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                  var line = session.getLine(range.end.row);
                  if (/^\s+$/.test(line)) {
                    range.end.column = line.length;
                  }
                }
              }
              if (new_range)
                range = new_range;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.removeWordRight = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordRight();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeWordLeft = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineStart = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineStart();
            if (this.selection.isEmpty())
              this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineEnd = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineEnd();
            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
              range.end.column = 0;
              range.end.row++;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.splitLine = function() {
            if (!this.selection.isEmpty()) {
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
            }
            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
          };
          Editor2.prototype.setGhostText = function(text, position) {
            this.renderer.setGhostText(text, position);
          };
          Editor2.prototype.removeGhostText = function() {
            this.renderer.removeGhostText();
          };
          Editor2.prototype.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
              return;
            }
            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
              return;
            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
              swap = line.charAt(column) + line.charAt(column - 1);
              range = new Range(cursor.row, column - 1, cursor.row, column + 1);
            } else {
              swap = line.charAt(column - 1) + line.charAt(column - 2);
              range = new Range(cursor.row, column - 2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
          };
          Editor2.prototype.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();
            if (range.start.row < range.end.row) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "	");
              return;
            } else if (range.start.column < range.end.column) {
              var text = session.getTextRange(range);
              if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "	");
                return;
              }
            }
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);
            if (this.session.getUseSoftTabs()) {
              var count = size - column % size;
              var indentString = lang.stringRepeat(" ", count);
            } else {
              var count = column % size;
              while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
              }
              this.selection.setSelectionRange(range);
              indentString = "	";
            }
            return this.insert(indentString);
          };
          Editor2.prototype.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "	");
          };
          Editor2.prototype.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
          };
          Editor2.prototype.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;
            var lines = [];
            for (var i = rows.first; i <= rows.last; i++)
              lines.push(session.getLine(i));
            lines.sort(function(a, b2) {
              if (a.toLowerCase() < b2.toLowerCase())
                return -1;
              if (a.toLowerCase() > b2.toLowerCase())
                return 1;
              return 0;
            });
            var deleteRange = new Range(0, 0, 0, 0);
            for (var i = rows.first; i <= rows.last; i++) {
              var line = session.getLine(i);
              deleteRange.start.row = i;
              deleteRange.end.row = i;
              deleteRange.end.column = line.length;
              session.replace(deleteRange, lines[i - rows.first]);
            }
          };
          Editor2.prototype.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
          };
          Editor2.prototype.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
          };
          Editor2.prototype.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;
            var s = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
              var m = _numberRx.exec(s);
              if (m.index <= column && m.index + m[0].length >= column) {
                var number = {
                  value: m[0],
                  start: m.index,
                  end: m.index + m[0].length
                };
                return number;
              }
            }
            return null;
          };
          Editor2.prototype.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column - 1, row, column);
            var c = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c)) && isFinite(c)) {
              var nr2 = this.getNumberAt(row, column);
              if (nr2) {
                var fp = nr2.value.indexOf(".") >= 0 ? nr2.start + nr2.value.indexOf(".") + 1 : nr2.end;
                var decimals = nr2.start + nr2.value.length - fp;
                var t = parseFloat(nr2.value);
                t *= Math.pow(10, decimals);
                if (fp !== nr2.end && column < fp) {
                  amount *= Math.pow(10, nr2.end - column - 1);
                } else {
                  amount *= Math.pow(10, nr2.end - column);
                }
                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);
                var replaceRange = new Range(row, nr2.start, row, nr2.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr2.start + 1, column + nnr.length - nr2.value.length));
              }
            } else {
              this.toggleWord();
            }
          };
          Editor2.prototype.toggleWord = function() {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0)
              delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) {
              wordParts.forEach(function(item2, i2) {
                itLength = curLength + item2.length;
                if (delta >= curLength && delta <= itLength) {
                  currentState = item2;
                  that.selection.clearSelection();
                  that.moveCursorTo(row, curLength + currWordStart);
                  that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
              });
            }
            var wordPairs = this.$toggleWordPairs;
            var reg;
            for (var i = 0; i < wordPairs.length; i++) {
              var item = wordPairs[i];
              for (var j3 = 0; j3 <= 1; j3++) {
                var negate = +!j3;
                var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item[j3]) + ")\\s?$", "i"));
                if (firstCondition) {
                  var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                  if (secondCondition) {
                    reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j3]), "i"), function(result) {
                      var res = item[negate];
                      if (result.toUpperCase() == result) {
                        res = res.toUpperCase();
                      } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                        res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                      }
                      return res;
                    });
                    this.insert(reg);
                    reg = "";
                  }
                }
              }
            }
          };
          Editor2.prototype.findLinkAt = function(row, column) {
            var e_1, _a2;
            var line = this.session.getLine(row);
            var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
            var columnPosition = column;
            if (columnPosition < 0)
              columnPosition = 0;
            var previousPosition = 0, currentPosition = 0, match;
            try {
              for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
                var item = wordParts_1_1.value;
                currentPosition = previousPosition + item.length;
                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                  if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                    match = item.replace(/[\s:.,'";}\]]+$/, "");
                    break;
                  }
                }
                previousPosition = currentPosition;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (wordParts_1_1 && !wordParts_1_1.done && (_a2 = wordParts_1.return)) _a2.call(wordParts_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return match;
          };
          Editor2.prototype.openLink = function() {
            var cursor = this.selection.getCursor();
            var url = this.findLinkAt(cursor.row, cursor.column);
            if (url)
              window.open(url, "_blank");
            return url != null;
          };
          Editor2.prototype.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
          };
          Editor2.prototype.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
              var row = range.start.row;
              doc.duplicateLines(row, row);
            } else {
              var point = reverse ? range.start : range.end;
              var endPoint = doc.insert(point, doc.getTextRange(range));
              range.start = point;
              range.end = endPoint;
              sel.setSelectionRange(range, reverse);
            }
          };
          Editor2.prototype.moveLinesDown = function() {
            this.$moveLines(1, false);
          };
          Editor2.prototype.moveLinesUp = function() {
            this.$moveLines(-1, false);
          };
          Editor2.prototype.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
          };
          Editor2.prototype.copyLinesUp = function() {
            this.$moveLines(-1, true);
          };
          Editor2.prototype.copyLinesDown = function() {
            this.$moveLines(1, true);
          };
          Editor2.prototype.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
              var range = selection.toOrientedRange();
              rows = this.$getSelectedRows(range);
              moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
              if (copy && dir == -1)
                moved = 0;
              range.moveBy(moved, 0);
              selection.fromOrientedRange(range);
            } else {
              var ranges = selection.rangeList.ranges;
              selection.rangeList.detach(this.session);
              this.inVirtualSelectionMode = true;
              var diff = 0;
              var totalDiff = 0;
              var l = ranges.length;
              for (var i = 0; i < l; i++) {
                var rangeIndex = i;
                ranges[i].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i]);
                var first = rows.first;
                var last = rows.last;
                while (++i < l) {
                  if (totalDiff)
                    ranges[i].moveBy(totalDiff, 0);
                  var subRows = this.$getSelectedRows(ranges[i]);
                  if (copy && subRows.first != last)
                    break;
                  else if (!copy && subRows.first > last + 1)
                    break;
                  last = subRows.last;
                }
                i--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1)
                  rangeIndex = i + 1;
                while (rangeIndex <= i) {
                  ranges[rangeIndex].moveBy(diff, 0);
                  rangeIndex++;
                }
                if (!copy)
                  diff = 0;
                totalDiff += diff;
              }
              selection.fromOrientedRange(selection.ranges[0]);
              selection.rangeList.attach(this.session);
              this.inVirtualSelectionMode = false;
            }
          };
          Editor2.prototype.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();
            return {
              first: this.session.getRowFoldStart(range.start.row),
              last: this.session.getRowFoldEnd(range.end.row)
            };
          };
          Editor2.prototype.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
          };
          Editor2.prototype.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
          };
          Editor2.prototype.onCompositionEnd = function() {
            this.renderer.hideComposition();
          };
          Editor2.prototype.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
          };
          Editor2.prototype.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
          };
          Editor2.prototype.isRowVisible = function(row) {
            return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
          };
          Editor2.prototype.isRowFullyVisible = function(row) {
            return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
          };
          Editor2.prototype.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          };
          Editor2.prototype.$moveByPage = function(dir, select) {
            var renderer = this.renderer;
            var config2 = this.renderer.layerConfig;
            var rows = dir * Math.floor(config2.height / config2.lineHeight);
            if (select === true) {
              this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
              });
            } else if (select === false) {
              this.selection.moveCursorBy(rows, 0);
              this.selection.clearSelection();
            }
            var scrollTop = renderer.scrollTop;
            renderer.scrollBy(0, rows * config2.lineHeight);
            if (select != null)
              renderer.scrollCursorIntoView(null, 0.5);
            renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.selectPageDown = function() {
            this.$moveByPage(1, true);
          };
          Editor2.prototype.selectPageUp = function() {
            this.$moveByPage(-1, true);
          };
          Editor2.prototype.gotoPageDown = function() {
            this.$moveByPage(1, false);
          };
          Editor2.prototype.gotoPageUp = function() {
            this.$moveByPage(-1, false);
          };
          Editor2.prototype.scrollPageDown = function() {
            this.$moveByPage(1);
          };
          Editor2.prototype.scrollPageUp = function() {
            this.$moveByPage(-1);
          };
          Editor2.prototype.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
          };
          Editor2.prototype.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
          };
          Editor2.prototype.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
              row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
              column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
          };
          Editor2.prototype.getCursorPosition = function() {
            return this.selection.getCursor();
          };
          Editor2.prototype.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
          };
          Editor2.prototype.getSelectionRange = function() {
            return this.selection.getRange();
          };
          Editor2.prototype.selectAll = function() {
            this.selection.selectAll();
          };
          Editor2.prototype.clearSelection = function() {
            this.selection.clearSelection();
          };
          Editor2.prototype.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
          };
          Editor2.prototype.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
          };
          Editor2.prototype.jumpToMatching = function(select, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var tokenCount = 0;
            if (prevToken && prevToken.type.indexOf("tag-name") !== -1) {
              prevToken = iterator.stepBackward();
            }
            var token = prevToken || iterator.stepForward();
            if (!token)
              return;
            var matchType;
            var found = false;
            var depth = {};
            var i = cursor.column - token.start;
            var bracketType;
            var brackets = {
              ")": "(",
              "(": "(",
              "]": "[",
              "[": "[",
              "{": "{",
              "}": "{"
            };
            do {
              if (token.value.match(/[{}()\[\]]/g)) {
                for (; i < token.value.length && !found; i++) {
                  if (!brackets[token.value[i]]) {
                    continue;
                  }
                  bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
                  if (isNaN(depth[bracketType])) {
                    depth[bracketType] = 0;
                  }
                  switch (token.value[i]) {
                    case "(":
                    case "[":
                    case "{":
                      depth[bracketType]++;
                      break;
                    case ")":
                    case "]":
                    case "}":
                      depth[bracketType]--;
                      if (depth[bracketType] === -1) {
                        matchType = "bracket";
                        found = true;
                      }
                      break;
                  }
                }
              } else if (token.type.indexOf("tag-name") !== -1) {
                if (isNaN(depth[token.value])) {
                  depth[token.value] = 0;
                }
                if (prevToken.value === "<" && tokenCount > 1) {
                  depth[token.value]++;
                } else if (prevToken.value === "</") {
                  depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                  matchType = "tag";
                  found = true;
                }
              }
              if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i = 0;
              }
            } while (token && !found);
            if (!matchType)
              return;
            var range, pos;
            if (matchType === "bracket") {
              range = this.session.getBracketRange(cursor);
              if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                  range = this.session.getBracketRange(pos);
              }
            } else if (matchType === "tag") {
              if (!token || token.type.indexOf("tag-name") === -1)
                return;
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
              if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                  if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                    range = tagsRanges.closeTag;
                    pos = range.start;
                  } else {
                    range = tagsRanges.openTag;
                    if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column)
                      pos = range.end;
                    else
                      pos = range.start;
                  }
                }
              }
              pos = pos || range.start;
            }
            pos = range && range.cursor || pos;
            if (pos) {
              if (select) {
                if (range && expand) {
                  this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                  this.clearSelection();
                } else {
                  this.selection.selectTo(pos.row, pos.column);
                }
              } else {
                this.selection.moveTo(pos.row, pos.column);
              }
            }
          };
          Editor2.prototype.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({ row: lineNumber - 1, column: column || 0 });
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);
            if (!this.isRowFullyVisible(lineNumber - 1))
              this.scrollToLine(lineNumber - 1, true, animate);
          };
          Editor2.prototype.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
          };
          Editor2.prototype.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
              var selectionStart = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
          };
          Editor2.prototype.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
              var selectionEnd = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
          };
          Editor2.prototype.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionStart = this.getSelectionRange().start;
              this.moveCursorToPosition(selectionStart);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorLeft();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionEnd = this.getSelectionRange().end;
              this.moveCursorToPosition(selectionEnd);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorRight();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
          };
          Editor2.prototype.replace = function(replacement, options) {
            if (options)
              this.$search.set(options);
            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
              return replaced;
            if (this.$tryReplace(range, replacement)) {
              replaced = 1;
            }
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
            return replaced;
          };
          Editor2.prototype.replaceAll = function(replacement, options) {
            if (options) {
              this.$search.set(options);
            }
            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
              return replaced;
            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for (var i = ranges.length - 1; i >= 0; --i) {
              if (this.$tryReplace(ranges[i], replacement)) {
                replaced++;
              }
            }
            this.selection.setSelectionRange(selection);
            return replaced;
          };
          Editor2.prototype.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
              range.end = this.session.replace(range, replacement);
              return range;
            } else {
              return null;
            }
          };
          Editor2.prototype.getLastSearchOptions = function() {
            return this.$search.getOptions();
          };
          Editor2.prototype.find = function(needle, options, animate) {
            if (!options)
              options = {};
            if (typeof needle == "string" || needle instanceof RegExp)
              options.needle = needle;
            else if (typeof needle == "object")
              oop.mixin(options, needle);
            var range = this.selection.getRange();
            if (options.needle == null) {
              needle = this.session.getTextRange(range) || this.$search.$options.needle;
              if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
              }
              this.$search.set({ needle });
            }
            this.$search.set(options);
            if (!options.start)
              this.$search.set({ start: range });
            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
              return newRange;
            if (newRange) {
              this.revealRange(newRange, animate);
              return newRange;
            }
            if (options.backwards)
              range.start = range.end;
            else
              range.end = range.start;
            this.selection.setRange(range);
          };
          Editor2.prototype.findNext = function(options, animate) {
            this.find({ skipCurrent: true, backwards: false }, options, animate);
          };
          Editor2.prototype.findPrevious = function(options, animate) {
            this.find(options, { skipCurrent: true, backwards: true }, animate);
          };
          Editor2.prototype.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);
            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
              this.renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.destroy = function() {
            this.destroyed = true;
            if (this.$toDestroy) {
              this.$toDestroy.forEach(function(el) {
                el.destroy();
              });
              this.$toDestroy = [];
            }
            if (this.$mouseHandler)
              this.$mouseHandler.destroy();
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session)
              this.session.destroy();
            if (this._$emitInputEvent)
              this._$emitInputEvent.cancel();
            this.removeAllListeners();
          };
          Editor2.prototype.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
              return;
            var rect;
            var self2 = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
              this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
              shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
              if (shouldScroll)
                rect = self2.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
              if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
                var renderer = self2.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config2 = renderer.layerConfig;
                var top = pos.top - config2.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                  shouldScroll = true;
                } else if (pos.top < config2.height && pos.top + rect.top + config2.lineHeight > window.innerHeight) {
                  shouldScroll = false;
                } else {
                  shouldScroll = null;
                }
                if (shouldScroll != null) {
                  scrollAnchor.style.top = top + "px";
                  scrollAnchor.style.left = pos.left + "px";
                  scrollAnchor.style.height = config2.lineHeight + "px";
                  scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(enable2) {
              if (enable2)
                return;
              delete this.setAutoScrollEditorIntoView;
              this.off("changeSelection", onChangeSelection);
              this.renderer.off("afterRender", onAfterRender);
              this.renderer.off("beforeRender", onBeforeRender);
            };
          };
          Editor2.prototype.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
              return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
          };
          Editor2.prototype.prompt = function(message, options, callback) {
            var editor = this;
            config.loadModule("ace/ext/prompt", function(module4) {
              module4.prompt(editor, message, options, callback);
            });
          };
          return Editor2;
        }()
      );
      Editor.$uid = 0;
      Editor.prototype.curOp = null;
      Editor.prototype.prevOp = {};
      Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
      Editor.prototype.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
      ];
      oop.implement(Editor.prototype, EventEmitter);
      config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", { data: style });
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function(readOnly) {
            var _this = this;
            this.textInput.setReadOnly(readOnly);
            if (this.destroyed)
              return;
            this.$resetCursorStyle();
            if (!this.$readOnlyCallback) {
              this.$readOnlyCallback = function(e) {
                var shouldShow = false;
                if (e && e.type == "keydown") {
                  if (e && e.key && !e.ctrlKey && !e.metaKey) {
                    if (e.key == " ")
                      e.preventDefault();
                    shouldShow = e.key.length == 1;
                  }
                  if (!shouldShow)
                    return;
                } else if (e && e.type !== "exec") {
                  shouldShow = true;
                }
                if (shouldShow) {
                  if (!_this.hoverTooltip) {
                    _this.hoverTooltip = new HoverTooltip();
                  }
                  var domNode = dom.createElement("div");
                  domNode.textContent = nls("editor.tooltip.disable-editing", "Editing is disabled");
                  if (!_this.hoverTooltip.isOpen) {
                    _this.hoverTooltip.showForRange(_this, _this.getSelectionRange(), domNode);
                  }
                } else if (_this.hoverTooltip && _this.hoverTooltip.isOpen) {
                  _this.hoverTooltip.hide();
                }
              };
            }
            var textArea = this.textInput.getElement();
            if (readOnly) {
              event.addListener(textArea, "keydown", this.$readOnlyCallback, this);
              this.commands.on("exec", this.$readOnlyCallback);
              this.commands.on("commandUnavailable", this.$readOnlyCallback);
            } else {
              event.removeListener(textArea, "keydown", this.$readOnlyCallback);
              this.commands.off("exec", this.$readOnlyCallback);
              this.commands.off("commandUnavailable", this.$readOnlyCallback);
              if (this.hoverTooltip) {
                this.hoverTooltip.destroy();
                this.hoverTooltip = null;
              }
            }
          },
          initialValue: false
        },
        copyWithEmptySelection: {
          set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
          },
          initialValue: false
        },
        cursorStyle: {
          set: function(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: { initialValue: true },
        wrapBehavioursEnabled: { initialValue: true },
        enableAutoIndent: { initialValue: true },
        autoScrollEditorIntoView: {
          set: function(val) {
            this.setAutoScrollEditorIntoView(val);
          }
        },
        keyboardHandler: {
          set: function(val) {
            this.setKeyboardHandler(val);
          },
          get: function() {
            return this.$keybindingId;
          },
          handlesSet: true
        },
        value: {
          set: function(val) {
            this.session.setValue(val);
          },
          get: function() {
            return this.getValue();
          },
          handlesSet: true,
          hidden: true
        },
        session: {
          set: function(val) {
            this.setSession(val);
          },
          get: function() {
            return this.session;
          },
          handlesSet: true,
          hidden: true
        },
        showLineNumbers: {
          set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          },
          initialValue: true
        },
        relativeLineNumbers: {
          set: function(value) {
            if (this.$showLineNumbers && value)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          }
        },
        placeholder: {
          set: function(message) {
            if (!this.$updatePlaceholder) {
              this.$updatePlaceholder = function() {
                var hasValue = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                if (hasValue && this.renderer.placeholderNode) {
                  this.renderer.off("afterRender", this.$updatePlaceholder);
                  dom.removeCssClass(this.container, "ace_hasPlaceholder");
                  this.renderer.placeholderNode.remove();
                  this.renderer.placeholderNode = null;
                } else if (!hasValue && !this.renderer.placeholderNode) {
                  this.renderer.on("afterRender", this.$updatePlaceholder);
                  dom.addCssClass(this.container, "ace_hasPlaceholder");
                  var el = dom.createElement("div");
                  el.className = "ace_placeholder";
                  el.textContent = this.$placeholder || "";
                  this.renderer.placeholderNode = el;
                  this.renderer.content.appendChild(this.renderer.placeholderNode);
                } else if (!hasValue && this.renderer.placeholderNode) {
                  this.renderer.placeholderNode.textContent = this.$placeholder || "";
                }
              }.bind(this);
              this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
          }
        },
        enableKeyboardAccessibility: {
          set: function(value) {
            var blurCommand = {
              name: "blurTextInput",
              description: "Set focus to the editor content div to allow tabbing through the page",
              bindKey: "Esc",
              exec: function(editor) {
                editor.blur();
                editor.renderer.scroller.focus();
              },
              readOnly: true
            };
            var focusOnEnterKeyup = function(e) {
              if (e.target == this.renderer.scroller && e.keyCode === keys["enter"]) {
                e.preventDefault();
                var row = this.getCursorPosition().row;
                if (!this.isRowVisible(row))
                  this.scrollToLine(row, true, true);
                this.focus();
              }
            };
            var gutterKeyboardHandler;
            if (value) {
              this.renderer.enableKeyboardAccessibility = true;
              this.renderer.keyboardFocusClassName = "ace_keyboard-focus";
              this.textInput.getElement().setAttribute("tabindex", -1);
              this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
              this.renderer.scroller.setAttribute("tabindex", 0);
              this.renderer.scroller.setAttribute("role", "group");
              this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
              this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.setAttribute("aria-label", nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit"));
              this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.addCommand(blurCommand);
              this.renderer.$gutter.setAttribute("tabindex", 0);
              this.renderer.$gutter.setAttribute("aria-hidden", false);
              this.renderer.$gutter.setAttribute("role", "group");
              this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
              this.renderer.$gutter.setAttribute("aria-label", nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit"));
              this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.content.setAttribute("aria-hidden", true);
              if (!gutterKeyboardHandler)
                gutterKeyboardHandler = new GutterKeyboardHandler(this);
              gutterKeyboardHandler.addListener();
              this.textInput.setAriaOptions({
                setLabel: true
              });
            } else {
              this.renderer.enableKeyboardAccessibility = false;
              this.textInput.getElement().setAttribute("tabindex", 0);
              this.textInput.setNumberOfExtraLines(0);
              this.renderer.scroller.setAttribute("tabindex", -1);
              this.renderer.scroller.removeAttribute("role");
              this.renderer.scroller.removeAttribute("aria-roledescription");
              this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.removeAttribute("aria-label");
              this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.removeCommand(blurCommand);
              this.renderer.content.removeAttribute("aria-hidden");
              this.renderer.$gutter.setAttribute("tabindex", -1);
              this.renderer.$gutter.setAttribute("aria-hidden", true);
              this.renderer.$gutter.removeAttribute("role");
              this.renderer.$gutter.removeAttribute("aria-roledescription");
              this.renderer.$gutter.removeAttribute("aria-label");
              this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);
              if (gutterKeyboardHandler)
                gutterKeyboardHandler.removeListener();
            }
          },
          initialValue: false
        },
        textInputAriaLabel: {
          set: function(val) {
            this.$textInputAriaLabel = val;
          },
          initialValue: ""
        },
        enableMobileMenu: {
          set: function(val) {
            this.$enableMobileMenu = val;
          },
          initialValue: true
        },
        customScrollbar: "renderer",
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        highlightIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",
        useResizeObserver: "renderer",
        useSvgGutterIcons: "renderer",
        showFoldedAnnotations: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      var relativeNumberRenderer = {
        getText: function(session, row) {
          return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "\xB7" : "")) + "";
        },
        getWidth: function(session, lastLineNumber, config2) {
          return Math.max(lastLineNumber.toString().length, (config2.lastRow + 1).toString().length, 2) * config2.characterWidth;
        },
        update: function(e, editor) {
          editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
        },
        attach: function(editor) {
          editor.renderer.$gutterLayer.$renderer = this;
          editor.on("changeSelection", this.update);
          this.update(null, editor);
        },
        detach: function(editor) {
          if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
          editor.off("changeSelection", this.update);
          this.update(null, editor);
        }
      };
      exports2.Editor = Editor;
    });
    ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var Lines = (
        /** @class */
        function() {
          function Lines2(element, canvasHeight) {
            this.element = element;
            this.canvasHeight = canvasHeight || 5e5;
            this.element.style.height = this.canvasHeight * 2 + "px";
            this.cells = [];
            this.cellCache = [];
            this.$offsetCoefficient = 0;
          }
          Lines2.prototype.moveContainer = function(config) {
            dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
          };
          Lines2.prototype.pageChanged = function(oldConfig, newConfig) {
            return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
          };
          Lines2.prototype.computeLineTop = function(row, config, session) {
            var screenTop = config.firstRowScreen * config.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
            return lineTop - screenPage * this.canvasHeight;
          };
          Lines2.prototype.computeLineHeight = function(row, config, session) {
            return config.lineHeight * session.getRowLineCount(row);
          };
          Lines2.prototype.getLength = function() {
            return this.cells.length;
          };
          Lines2.prototype.get = function(index) {
            return this.cells[index];
          };
          Lines2.prototype.shift = function() {
            this.$cacheCell(this.cells.shift());
          };
          Lines2.prototype.pop = function() {
            this.$cacheCell(this.cells.pop());
          };
          Lines2.prototype.push = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.push.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
              }
              this.element.appendChild(fragment);
            } else {
              this.cells.push(cell);
              this.element.appendChild(cell.element);
            }
          };
          Lines2.prototype.unshift = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.unshift.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i = 0; i < cell.length; i++) {
                fragment.appendChild(cell[i].element);
              }
              if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
              else
                this.element.appendChild(fragment);
            } else {
              this.cells.unshift(cell);
              this.element.insertAdjacentElement("afterbegin", cell.element);
            }
          };
          Lines2.prototype.last = function() {
            if (this.cells.length)
              return this.cells[this.cells.length - 1];
            else
              return null;
          };
          Lines2.prototype.$cacheCell = function(cell) {
            if (!cell)
              return;
            cell.element.remove();
            this.cellCache.push(cell);
          };
          Lines2.prototype.createCell = function(row, config, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
              var element = dom.createElement("div");
              if (initElement)
                initElement(element);
              this.element.appendChild(element);
              cell = {
                element,
                text: "",
                row
              };
            }
            cell.row = row;
            return cell;
          };
          return Lines2;
        }()
      );
      exports2.Lines = Lines;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var oop = require3("../lib/oop");
      var lang = require3("../lib/lang");
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var Lines = require3("./lines").Lines;
      var nls = require3("../config").nls;
      var Gutter = (
        /** @class */
        function() {
          function Gutter2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_gutter-layer";
            parentEl.appendChild(this.element);
            this.setShowFoldWidgets(this.$showFoldWidgets);
            this.gutterWidth = 0;
            this.$annotations = [];
            this.$updateAnnotations = this.$updateAnnotations.bind(this);
            this.$lines = new Lines(this.element);
            this.$lines.$offsetCoefficient = 1;
          }
          Gutter2.prototype.setSession = function(session) {
            if (this.session)
              this.session.off("change", this.$updateAnnotations);
            this.session = session;
            if (session)
              session.on("change", this.$updateAnnotations);
          };
          Gutter2.prototype.addGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
          };
          Gutter2.prototype.removeGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
          };
          Gutter2.prototype.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              var row = annotation.row;
              var rowInfo = this.$annotations[row];
              if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [], type: [], displayText: [] };
              var annoText = annotation.text;
              var displayAnnoText = annotation.text;
              var annoType = annotation.type;
              annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
              displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";
              if (rowInfo.text.indexOf(annoText) === -1) {
                rowInfo.text.push(annoText);
                rowInfo.type.push(annoType);
                rowInfo.displayText.push(displayAnnoText);
              }
              var className = annotation.className;
              if (className) {
                rowInfo.className = className;
              } else if (annoType === "error") {
                rowInfo.className = " ace_error";
              } else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_security";
              } else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_warning";
              } else if (annoType === "info" && !rowInfo.className) {
                rowInfo.className = " ace_info";
              } else if (annoType === "hint" && !rowInfo.className) {
                rowInfo.className = " ace_hint";
              }
            }
          };
          Gutter2.prototype.$updateAnnotations = function(delta) {
            if (!this.$annotations.length)
              return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) {
            } else if (delta.action == "remove") {
              this.$annotations.splice(firstRow, len + 1, null);
            } else {
              var args = new Array(len + 1);
              args.unshift(firstRow, 1);
              this.$annotations.splice.apply(this.$annotations, args);
            }
          };
          Gutter2.prototype.update = function(config) {
            this.config = config;
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              session.getLength() - 1
            );
            this.oldLastRow = lastRow;
            this.config = config;
            this.$lines.moveContainer(config);
            this.$updateCursorRow();
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;
            var cell = null;
            var index = -1;
            var row = firstRow;
            while (true) {
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
              }
              if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                  this.$lines.pop();
                break;
              }
              cell = this.$lines.get(++index);
              if (cell) {
                cell.row = row;
              } else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
              }
              this.$renderCell(cell, config, fold, row);
              row++;
            }
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$updateGutterWidth = function(config) {
            var session = this.session;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || session.$useWrapMode)
              lastLineText = session.getLength() + firstLineNumber - 1;
            var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
              this.gutterWidth = gutterWidth;
              this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
              this._signal("changeGutterWidth", gutterWidth);
            }
          };
          Gutter2.prototype.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
              return;
            var position = this.session.selection.getCursor();
            if (this.$cursorRow === position.row)
              return;
            this.$cursorRow = position.row;
          };
          Gutter2.prototype.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
              return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;
            if (this.$cursorCell && this.$cursorCell.row == row)
              return;
            if (this.$cursorCell)
              this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for (var i = 0; i < cells.length; i++) {
              var cell = cells[i];
              if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                  var fold = this.session.getFoldLine(this.$cursorRow);
                  if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                    cell = cells[i - 1];
                  else
                    break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
              }
            }
          };
          Gutter2.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              this.session.getLength() - 1
            );
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldLastRow > lastRow)
              for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (lastRow > oldLastRow) {
              this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
            }
            this.updateLineHighlight();
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$renderLines = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
              this.$renderCell(cell, config, foldLine, row);
              fragment.push(cell);
              row++;
            }
            return fragment;
          };
          Gutter2.prototype.$renderCell = function(cell, config, fold, row) {
            var element = cell.element;
            var session = this.session;
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];
            var annotationNode = element.childNodes[2];
            var customWidget = element.childNodes[3];
            var annotationIconNode = annotationNode.firstChild;
            var firstLineNumber = session.$firstLineNumber;
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
            var lineHeight = config.lineHeight + "px";
            var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
            var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            var rowText = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
            if (this.$highlightGutterLine) {
              if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                  if (this.$cursorCell)
                    this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                  this.$cursorCell = cell;
                }
              }
            }
            if (breakpoints[row])
              className += breakpoints[row];
            if (decorations[row])
              className += decorations[row];
            if (this.$annotations[row] && row !== foldStart)
              className += this.$annotations[row].className;
            if (foldWidgets) {
              var c = foldWidgets[row];
              if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c) {
              var foldClass = "ace_fold-widget ace_" + c;
              var isClosedFold = c == "start" && row == foldStart && row < fold.end.row;
              if (isClosedFold) {
                foldClass += " ace_closed";
                var foldAnnotationClass = "";
                var annotationInFold = false;
                for (var i = row + 1; i <= fold.end.row; i++) {
                  if (!this.$annotations[i])
                    continue;
                  if (this.$annotations[i].className === " ace_error") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_error_fold";
                    break;
                  }
                  if (this.$annotations[i].className === " ace_security") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_security_fold";
                  } else if (this.$annotations[i].className === " ace_warning" && foldAnnotationClass !== " ace_security_fold") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_warning_fold";
                  }
                }
                className += foldAnnotationClass;
              } else
                foldClass += " ace_open";
              if (foldWidget.className != foldClass)
                foldWidget.className = foldClass;
              dom.setStyle(foldWidget.style, "height", lineHeight);
              dom.setStyle(foldWidget.style, "display", "inline-block");
              foldWidget.setAttribute("role", "button");
              foldWidget.setAttribute("tabindex", "-1");
              var foldRange = session.getFoldWidgetRange(row);
              if (foldRange)
                foldWidget.setAttribute("aria-label", nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                  foldRange.start.row + 1,
                  foldRange.end.row + 1
                ]));
              else {
                if (fold)
                  foldWidget.setAttribute("aria-label", nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                    fold.start.row + 1,
                    fold.end.row + 1
                  ]));
                else
                  foldWidget.setAttribute("aria-label", nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [row + 1]));
              }
              if (isClosedFold) {
                foldWidget.setAttribute("aria-expanded", "false");
                foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
              } else {
                foldWidget.setAttribute("aria-expanded", "true");
                foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
              }
            } else {
              if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
                foldWidget.setAttribute("tabindex", "0");
                foldWidget.removeAttribute("role");
                foldWidget.removeAttribute("aria-label");
              }
            }
            var customWidgetAttributes = this.session.$gutterCustomWidgets[row];
            if (customWidgetAttributes) {
              this.$addCustomWidget(row, customWidgetAttributes, cell);
            } else if (customWidget) {
              this.$removeCustomWidget(row, cell);
            }
            if (annotationInFold && this.$showFoldedAnnotations) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              annotationIconNode.className += foldAnnotationClass;
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              var ariaLabel;
              switch (foldAnnotationClass) {
                case " ace_error_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                  break;
                case " ace_security_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                  break;
                case " ace_warning_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                  break;
              }
              annotationNode.setAttribute("aria-label", ariaLabel);
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else if (this.$annotations[row]) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              if (this.$useSvgGutterIcons)
                annotationIconNode.className += this.$annotations[row].className;
              else
                element.classList.add(this.$annotations[row].className.replace(" ", ""));
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              var ariaLabel;
              switch (this.$annotations[row].className) {
                case " ace_error":
                  ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                  break;
                case " ace_security":
                  ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                  break;
                case " ace_warning":
                  ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                  break;
                case " ace_info":
                  ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [rowText]);
                  break;
                case " ace_hint":
                  ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [rowText]);
                  break;
              }
              annotationNode.setAttribute("aria-label", ariaLabel);
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else {
              dom.setStyle(annotationNode.style, "display", "none");
              annotationNode.removeAttribute("aria-label");
              annotationNode.removeAttribute("role");
              annotationNode.setAttribute("tabindex", "0");
            }
            if (rowText !== textNode.data) {
              textNode.data = rowText;
            }
            if (element.className != className)
              element.className = className;
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
            cell.text = rowText;
            if (annotationNode.style.display === "none" && foldWidget.style.display === "none" && !customWidgetAttributes)
              cell.element.setAttribute("aria-hidden", true);
            else
              cell.element.setAttribute("aria-hidden", false);
            return cell;
          };
          Gutter2.prototype.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
          };
          Gutter2.prototype.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
              getWidth: function() {
                return 0;
              },
              getText: function() {
                return "";
              }
            };
          };
          Gutter2.prototype.getShowLineNumbers = function() {
            return this.$showLineNumbers;
          };
          Gutter2.prototype.setShowFoldWidgets = function(show) {
            if (show)
              dom.addCssClass(this.element, "ace_folding-enabled");
            else
              dom.removeCssClass(this.element, "ace_folding-enabled");
            this.$showFoldWidgets = show;
            this.$padding = null;
          };
          Gutter2.prototype.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
          };
          Gutter2.prototype.$hideFoldWidget = function(row, cell) {
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var foldWidget = rowCell.element.childNodes[1];
              if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
              }
            }
          };
          Gutter2.prototype.$showFoldWidget = function(row, cell) {
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var foldWidget = rowCell.element.childNodes[1];
              if (foldWidget && this.session.foldWidgets && this.session.foldWidgets[rowCell.row]) {
                dom.setStyle(foldWidget.style, "display", "inline-block");
              }
            }
          };
          Gutter2.prototype.$getGutterCell = function(row) {
            var cells = this.$lines.cells;
            var visibileRow = this.session.documentToScreenRow(row, 0);
            return cells[row - this.config.firstRowScreen - (row - visibileRow)];
          };
          Gutter2.prototype.$addCustomWidget = function(row, _a2, cell) {
            var className = _a2.className, label = _a2.label, title = _a2.title, callbacks = _a2.callbacks;
            this.session.$gutterCustomWidgets[row] = { className, label, title, callbacks };
            this.$hideFoldWidget(row, cell);
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var customWidget = rowCell.element.querySelector(".ace_custom-widget");
              if (customWidget) {
                customWidget.remove();
              }
              customWidget = dom.createElement("span");
              customWidget.className = "ace_custom-widget ".concat(className);
              customWidget.setAttribute("tabindex", "-1");
              customWidget.setAttribute("role", "button");
              customWidget.setAttribute("aria-label", label);
              customWidget.setAttribute("title", title);
              dom.setStyle(customWidget.style, "display", "inline-block");
              dom.setStyle(customWidget.style, "height", "inherit");
              if (callbacks && callbacks.onClick) {
                customWidget.addEventListener("click", function(e) {
                  callbacks.onClick(e, row);
                  e.stopPropagation();
                });
              }
              rowCell.element.appendChild(customWidget);
            }
          };
          Gutter2.prototype.$removeCustomWidget = function(row, cell) {
            delete this.session.$gutterCustomWidgets[row];
            this.$showFoldWidget(row, cell);
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
              var customWidget = rowCell.element.querySelector(".ace_custom-widget");
              if (customWidget) {
                rowCell.element.removeChild(customWidget);
              }
            }
          };
          Gutter2.prototype.$computePadding = function() {
            if (!this.element.firstChild)
              return { left: 0, right: 0 };
            var style = dom.computedStyle(
              /**@type{Element}*/
              this.element.firstChild
            );
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
            return this.$padding;
          };
          Gutter2.prototype.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
              return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
              return "foldWidgets";
          };
          return Gutter2;
        }()
      );
      Gutter.prototype.$fixedWidth = false;
      Gutter.prototype.$highlightGutterLine = true;
      Gutter.prototype.$renderer = "";
      Gutter.prototype.$showLineNumbers = true;
      Gutter.prototype.$showFoldWidgets = true;
      oop.implement(Gutter.prototype, EventEmitter);
      function onCreateCell(element) {
        var textNode = document.createTextNode("");
        element.appendChild(textNode);
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        var annotationNode = dom.createElement("span");
        element.appendChild(annotationNode);
        var annotationIconNode = dom.createElement("span");
        annotationNode.appendChild(annotationIconNode);
        return element;
      }
      exports2.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("../range").Range;
      var dom = require3("../lib/dom");
      var Marker = (
        /** @class */
        function() {
          function Marker2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_marker-layer";
            parentEl.appendChild(this.element);
          }
          Marker2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Marker2.prototype.setSession = function(session) {
            this.session = session;
          };
          Marker2.prototype.setMarkers = function(markers) {
            this.markers = markers;
          };
          Marker2.prototype.elt = function(className, css) {
            var x = this.i != -1 && this.element.childNodes[this.i];
            if (!x) {
              x = document.createElement("div");
              this.element.appendChild(x);
              this.i = -1;
            } else {
              this.i++;
            }
            x.style.cssText = css;
            x.className = className;
          };
          Marker2.prototype.update = function(config) {
            if (!config)
              return;
            this.config = config;
            this.i = 0;
            var html;
            for (var key in this.markers) {
              var marker = this.markers[key];
              if (!marker.range) {
                marker.update(html, this, this.session, config);
                continue;
              }
              var range = marker.range.clipRows(config.firstRow, config.lastRow);
              if (range.isEmpty())
                continue;
              range = range.toScreenRange(this.session);
              if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html, range, left, top, config);
              } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html, range, marker.clazz, config);
              } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html, range, marker.clazz, config);
              } else if (range.isMultiLine()) {
                if (marker.type == "text")
                  this.drawTextMarker(html, range, marker.clazz, config);
                else
                  this.drawMultiLineMarker(html, range, marker.clazz, config);
              } else {
                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
              }
            }
            if (this.i != -1) {
              while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
            }
          };
          Marker2.prototype.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
          };
          Marker2.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0;
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range(row, range.start.column, row, curr);
            for (; row <= end; row++) {
              lineRange.start.row = lineRange.end.row = row;
              lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
              lineRange.end.column = next;
              prev = curr;
              curr = next;
              next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
              this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
            }
          };
          Marker2.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height = config.lineHeight;
            var top = this.$getTop(range.start.row, config);
            var left = padding + range.start.column * config.characterWidth;
            extraStyle = extraStyle || "";
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
              var range1 = range.clone();
              range1.end.row = range1.start.row;
              range1.end.column = this.session.getLine(range1.start.row).length;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else {
              this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
              var range1 = range.clone();
              range1.start.row = range1.end.row;
              range1.start.column = 0;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
              top = this.$getTop(range.end.row, config);
              var width = range.end.column * config.characterWidth;
              this.elt(clazz + " ace_br12", "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0)
              return;
            top = this.$getTop(range.start.row + 1, config);
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
            this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row))
              return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            this.elt(clazz, "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
            selections.forEach(function(selection) {
              this.elt(clazz, "height:" + height + "px;width:" + (selection.width + (extraLength || 0)) + "px;top:" + top + "px;left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
            }, this);
          };
          Marker2.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row)
              height += this.$getTop(range.end.row, config) - top;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          Marker2.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          return Marker2;
        }()
      );
      Marker.prototype.$padding = 0;
      function getBorderClass(tl, tr3, br2, bl2) {
        return (tl ? 1 : 0) | (tr3 ? 2 : 0) | (br2 ? 4 : 0) | (bl2 ? 8 : 0);
      }
      exports2.Marker = Marker;
    });
    ace.define("ace/layer/text_util", ["require", "exports", "module"], function(require3, exports2, module3) {
      var textTokens = /* @__PURE__ */ new Set(["text", "rparen", "lparen"]);
      exports2.isTextToken = function(tokenType) {
        return textTokens.has(tokenType);
      };
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter", "ace/config", "ace/layer/text_util"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../lib/oop");
      var dom = require3("../lib/dom");
      var lang = require3("../lib/lang");
      var Lines = require3("./lines").Lines;
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var nls = require3("../config").nls;
      var isTextToken = require3("./text_util").isTextToken;
      var Text = (
        /** @class */
        function() {
          function Text2(parentEl) {
            this.dom = dom;
            this.element = this.dom.createElement("div");
            this.element.className = "ace_layer ace_text-layer";
            parentEl.appendChild(this.element);
            this.$updateEolChar = this.$updateEolChar.bind(this);
            this.$lines = new Lines(this.element);
          }
          Text2.prototype.$updateEolChar = function() {
            var doc = this.session.doc;
            var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
              this.EOL_CHAR = EOL_CHAR;
              return true;
            }
          };
          Text2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
          };
          Text2.prototype.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
          };
          Text2.prototype.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
          };
          Text2.prototype.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on(
              "changeCharacterSize",
              function(e) {
                this._signal("changeCharacterSize", e);
              }.bind(this)
            );
            this.$pollSizeChanges();
          };
          Text2.prototype.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
          };
          Text2.prototype.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          };
          Text2.prototype.setSession = function(session) {
            this.session = session;
            if (session)
              this.$computeTabString();
          };
          Text2.prototype.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
              return false;
            this.showInvisibles = showInvisibles;
            if (typeof showInvisibles == "string") {
              this.showSpaces = /tab/i.test(showInvisibles);
              this.showTabs = /space/i.test(showInvisibles);
              this.showEOL = /eol/i.test(showInvisibles);
            } else {
              this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
            }
            this.$computeTabString();
            return true;
          };
          Text2.prototype.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
              return false;
            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
          };
          Text2.prototype.setHighlightIndentGuides = function(highlight) {
            if (this.$highlightIndentGuides === highlight)
              return false;
            this.$highlightIndentGuides = highlight;
            return highlight;
          };
          Text2.prototype.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i = 1; i < tabSize + 1; i++) {
              if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                tabStr.push(span);
              } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
              }
            }
            if (this.displayIndentGuides) {
              this.$indentGuideRe = /\s\S| \t|\t |\s$/;
              var className = "ace_indent-guide";
              var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
              var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
              var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
              var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
              var span = this.dom.createElement("span");
              span.className = className + spaceClass;
              span.textContent = spaceContent;
              this.$tabStrings[" "] = span;
              var span = this.dom.createElement("span");
              span.className = className + tabClass;
              span.textContent = tabContent;
              this.$tabStrings["	"] = span;
            }
          };
          Text2.prototype.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
              return this.update(config);
            }
            this.config = config;
            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);
            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;
            for (var row = config.firstRow; row < first; row++) {
              var foldLine = this.session.getFoldLine(row);
              if (foldLine) {
                if (foldLine.containsRow(first)) {
                  first = foldLine.start.row;
                  break;
                } else {
                  row = foldLine.end.row;
                }
              }
              lineElementsIdx++;
            }
            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > last)
                break;
              var lineElement = lineElements[lineElementsIdx++];
              if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                if (heightChanged)
                  lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
                var height = config.lineHeight * this.session.getRowLength(row) + "px";
                if (lineElement.style.height != height) {
                  heightChanged = true;
                  lineElement.style.height = height;
                }
              }
              row++;
            }
            if (heightChanged) {
              while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
              }
            }
          };
          Text2.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = config.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (!oldConfig || oldConfig.lastRow < config.firstRow)
              return this.update(config);
            if (config.lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldConfig.lastRow > config.lastRow)
              for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (config.lastRow > oldConfig.lastRow) {
              this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
            }
            this.$highlightIndentGuide();
          };
          Text2.prototype.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var line = this.$lines.createCell(row, config, this.session);
              var lineEl = line.element;
              this.dom.removeChildren(lineEl);
              dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
              dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
              this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
              if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
              } else {
                lineEl.className = "ace_line";
              }
              fragment.push(line);
              row++;
            }
            return fragment;
          };
          Text2.prototype.update = function(config) {
            this.$lines.moveContainer(config);
            this.config = config;
            var firstRow = config.firstRow;
            var lastRow = config.lastRow;
            var lines = this.$lines;
            while (lines.getLength())
              lines.pop();
            lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
          };
          Text2.prototype.$renderToken = function(parent, screenColumn, token, value) {
            var self2 = this;
            var re3 = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            var valueFragment = this.dom.createFragment(this.element);
            var m;
            var i = 0;
            while (m = re3.exec(value)) {
              var tab = m[1];
              var simpleSpace = m[2];
              var controlCharacter = m[3];
              var cjkSpace = m[4];
              var cjk = m[5];
              if (!self2.showSpaces && simpleSpace)
                continue;
              var before = i != m.index ? value.slice(i, m.index) : "";
              i = m.index + m[0].length;
              if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
              }
              if (tab) {
                var tabSize = self2.session.getScreenTabSize(screenColumn + m.index);
                var text = self2.$tabStrings[tabSize].cloneNode(true);
                text["charCount"] = 1;
                valueFragment.appendChild(text);
                screenColumn += tabSize - 1;
              } else if (simpleSpace) {
                if (self2.showSpaces) {
                  var span = this.dom.createElement("span");
                  span.className = "ace_invisible ace_invisible_space";
                  span.textContent = lang.stringRepeat(self2.SPACE_CHAR, simpleSpace.length);
                  valueFragment.appendChild(span);
                } else {
                  valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
                }
              } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self2.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
              } else if (cjkSpace) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = self2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self2.showSpaces ? self2.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
              } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
              }
            }
            valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
            if (!isTextToken(token.type)) {
              var classes = "ace_" + token.type.replace(/\./g, " ace_");
              var span = this.dom.createElement("span");
              if (token.type == "fold") {
                span.style.width = token.value.length * this.config.characterWidth + "px";
                span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
              }
              span.className = classes;
              span.appendChild(valueFragment);
              parent.appendChild(span);
            } else {
              parent.appendChild(valueFragment);
            }
            return screenColumn + value.length;
          };
          Text2.prototype.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
              return value;
            if (value[0] == " ") {
              cols -= cols % this.tabSize;
              var count = cols / this.tabSize;
              for (var i = 0; i < count; i++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            } else if (value[0] == "	") {
              for (var i = 0; i < cols; i++) {
                parent.appendChild(this.$tabStrings["	"].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            }
            this.$highlightIndentGuide();
            return value;
          };
          Text2.prototype.$highlightIndentGuide = function() {
            if (!this.$highlightIndentGuides || !this.displayIndentGuides)
              return;
            this.$highlightIndentGuideMarker = {
              indentLevel: void 0,
              start: void 0,
              end: void 0,
              dir: void 0
            };
            var lines = this.session.doc.$lines;
            if (!lines)
              return;
            var cursor = this.session.selection.getCursor();
            var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
            var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
            this.$highlightIndentGuideMarker = {
              indentLevel: elementIndentLevel,
              start: cursor.row
            };
            var bracketHighlight = this.session.$bracketHighlight;
            if (bracketHighlight) {
              var ranges = this.session.$bracketHighlight.ranges;
              for (var i = 0; i < ranges.length; i++) {
                if (cursor.row !== ranges[i].start.row) {
                  this.$highlightIndentGuideMarker.end = ranges[i].start.row + 1;
                  if (cursor.row > ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.dir = -1;
                  } else {
                    this.$highlightIndentGuideMarker.dir = 1;
                  }
                  break;
                }
              }
            }
            if (!this.$highlightIndentGuideMarker.end) {
              if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i = cursor.row + 1; i < lines.length; i++) {
                  var line = lines[i];
                  var currentIndent = /^\s*/.exec(line)[0].length;
                  if (line !== "") {
                    this.$highlightIndentGuideMarker.end = i;
                    if (currentIndent <= initialIndent)
                      break;
                  }
                }
              }
            }
            this.$renderHighlightIndentGuide();
          };
          Text2.prototype.$clearActiveIndentGuide = function() {
            var activeIndentGuides = this.element.querySelectorAll(".ace_indent-guide-active");
            for (var i = 0; i < activeIndentGuides.length; i++) {
              activeIndentGuides[i].classList.remove("ace_indent-guide-active");
            }
          };
          Text2.prototype.$setIndentGuideActive = function(cell, indentLevel) {
            var line = this.session.doc.getLine(cell.row);
            if (line !== "") {
              var element = cell.element;
              if (cell.element.classList && cell.element.classList.contains("ace_line_group")) {
                if (cell.element.childNodes.length > 0) {
                  element = cell.element.childNodes[0];
                } else {
                  return;
                }
              }
              var childNodes = element.childNodes;
              if (childNodes) {
                var node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide"))
                  node.classList.add("ace_indent-guide-active");
              }
            }
          };
          Text2.prototype.$renderHighlightIndentGuide = function() {
            if (!this.$lines)
              return;
            var cells = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
            if (indentLevel !== 0) {
              if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i = 0; i < cells.length; i++) {
                  var cell = cells[i];
                  if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                    if (cell.row >= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              } else {
                for (var i = cells.length - 1; i >= 0; i--) {
                  var cell = cells[i];
                  if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                    if (cell.row < this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              }
            }
          };
          Text2.prototype.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            return lineEl;
          };
          Text2.prototype.$renderWrappedLine = function(parent, tokens, splits) {
            var chars = 0;
            var split = 0;
            var splitChars = splits[0];
            var screenColumn = 0;
            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              var value = token.value;
              if (i == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                  continue;
                chars -= value.length;
              }
              if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
              } else {
                while (chars + value.length >= splitChars) {
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                  value = value.substring(splitChars - chars);
                  chars = splitChars;
                  lineEl = this.$createLineElement();
                  parent.appendChild(lineEl);
                  var text = this.dom.createTextNode(lang.stringRepeat("\xA0", splits.indent), this.element);
                  text["charCount"] = 0;
                  lineEl.appendChild(text);
                  split++;
                  screenColumn = 0;
                  splitChars = splits[split] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                  chars += value.length;
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                }
              }
            }
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
              this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
          };
          Text2.prototype.$renderSimpleLine = function(parent, tokens) {
            var screenColumn = 0;
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              var value = token.value;
              if (i == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                  continue;
              }
              if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
              screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
          };
          Text2.prototype.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            parent.appendChild(overflowEl);
          };
          Text2.prototype.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false)
              foldLine = this.session.getFoldLine(row);
            if (foldLine)
              var tokens = this.$getFoldLineTokens(row, foldLine);
            else
              var tokens = this.session.getTokens(row);
            var lastLineEl = parent;
            if (tokens.length) {
              var splits = this.session.getRowSplitData(row);
              if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
              } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                  lastLineEl = this.$createLineElement();
                  parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
              }
            } else if (this.$useLineGroups()) {
              lastLineEl = this.$createLineElement();
              parent.appendChild(lastLineEl);
            }
            if (this.showEOL && lastLineEl) {
              if (foldLine)
                row = foldLine.end.row;
              var invisibleEl = this.dom.createElement("span");
              invisibleEl.className = "ace_invisible ace_invisible_eol";
              invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
              lastLineEl.appendChild(invisibleEl);
            }
          };
          Text2.prototype.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];
            function addTokens(tokens2, from, to2) {
              var idx = 0, col = 0;
              while (col + tokens2[idx].value.length < from) {
                col += tokens2[idx].value.length;
                idx++;
                if (idx == tokens2.length)
                  return;
              }
              if (col != from) {
                var value = tokens2[idx].value.substring(from - col);
                if (value.length > to2 - from)
                  value = value.substring(0, to2 - from);
                renderTokens.push({
                  type: tokens2[idx].type,
                  value
                });
                col = from + value.length;
                idx += 1;
              }
              while (col < to2 && idx < tokens2.length) {
                var value = tokens2[idx].value;
                if (value.length + col > to2) {
                  renderTokens.push({
                    type: tokens2[idx].type,
                    value: value.substring(0, to2 - col)
                  });
                } else
                  renderTokens.push(tokens2[idx]);
                col += value.length;
                idx += 1;
              }
            }
            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
              if (placeholder != null) {
                renderTokens.push({
                  type: "fold",
                  value: placeholder
                });
              } else {
                if (isNewRow)
                  tokens = session.getTokens(row2);
                if (tokens.length)
                  addTokens(tokens, lastColumn, column);
              }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
            return renderTokens;
          };
          Text2.prototype.$useLineGroups = function() {
            return this.session.getUseWrapMode();
          };
          return Text2;
        }()
      );
      Text.prototype.EOF_CHAR = "\xB6";
      Text.prototype.EOL_CHAR_LF = "\xAC";
      Text.prototype.EOL_CHAR_CRLF = "\xA4";
      Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
      Text.prototype.TAB_CHAR = "\u2014";
      Text.prototype.SPACE_CHAR = "\xB7";
      Text.prototype.$padding = 0;
      Text.prototype.MAX_LINE_LENGTH = 1e4;
      Text.prototype.showInvisibles = false;
      Text.prototype.showSpaces = false;
      Text.prototype.showTabs = false;
      Text.prototype.showEOL = false;
      Text.prototype.displayIndentGuides = true;
      Text.prototype.$highlightIndentGuides = true;
      Text.prototype.$tabStrings = [];
      Text.prototype.destroy = {};
      Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;
      oop.implement(Text.prototype, EventEmitter);
      exports2.Text = Text;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var Cursor = (
        /** @class */
        function() {
          function Cursor2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_cursor-layer";
            parentEl.appendChild(this.element);
            this.isVisible = false;
            this.isBlinking = true;
            this.blinkInterval = 1e3;
            this.smoothBlinking = false;
            this.cursors = [];
            this.cursor = this.addCursor();
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.$updateCursors = this.$updateOpacity.bind(this);
          }
          Cursor2.prototype.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
          };
          Cursor2.prototype.$startCssAnimation = function() {
            var cursors = this.cursors;
            for (var i = cursors.length; i--; )
              cursors[i].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = true;
            setTimeout(function() {
              if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
              }
            }.bind(this));
          };
          Cursor2.prototype.$stopCssAnimation = function() {
            this.$isAnimating = false;
            dom.removeCssClass(this.element, "ace_animate-blinking");
          };
          Cursor2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Cursor2.prototype.setSession = function(session) {
            this.session = session;
          };
          Cursor2.prototype.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
              this.isBlinking = blinking;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
              this.blinkInterval = blinkInterval;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
              this.smoothBlinking = smoothBlinking;
              dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
              this.$updateCursors(true);
              this.restartTimer();
            }
          };
          Cursor2.prototype.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
          };
          Cursor2.prototype.removeCursor = function() {
            if (this.cursors.length > 1) {
              var el = this.cursors.pop();
              el.parentNode.removeChild(el);
              return el;
            }
          };
          Cursor2.prototype.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = false;
              dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            update(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
              this.$stopCssAnimation();
              return;
            }
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = true;
              setTimeout(function() {
                if (this.$isSmoothBlinking) {
                  dom.addCssClass(this.element, "ace_smooth-blinking");
                }
              }.bind(this));
            }
            if (dom.HAS_CSS_ANIMATION) {
              this.$startCssAnimation();
            } else {
              var blink = (
                /**@this{Cursor}*/
                function() {
                  this.timeoutId = setTimeout(function() {
                    update(false);
                  }, 0.6 * this.blinkInterval);
                }.bind(this)
              );
              this.intervalId = setInterval(function() {
                update(true);
                blink();
              }, this.blinkInterval);
              blink();
            }
          };
          Cursor2.prototype.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session)
              return { left: 0, top: 0 };
            if (!position)
              position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return { left: cursorLeft, top: cursorTop };
          };
          Cursor2.prototype.isCursorInView = function(pixelPos, config) {
            return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
          };
          Cursor2.prototype.update = function(config) {
            this.config = config;
            var selections = this.session.$selectionMarkers;
            var i = 0, cursorIndex = 0;
            if (selections === void 0 || selections.length === 0) {
              selections = [{ cursor: null }];
            }
            for (var i = 0, n = selections.length; i < n; i++) {
              var pixelPos = this.getPixelPosition(selections[i].cursor, true);
              if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                continue;
              }
              var element = this.cursors[cursorIndex++] || this.addCursor();
              var style = element.style;
              if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                  dom.setStyle(style, "display", "none");
                } else {
                  dom.setStyle(style, "display", "block");
                  dom.translate(element, pixelPos.left, pixelPos.top);
                  dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                  dom.setStyle(style, "height", config.lineHeight + "px");
                }
              } else {
                this.drawCursor(element, pixelPos, config, selections[i], this.session);
              }
            }
            while (this.cursors.length > cursorIndex)
              this.removeCursor();
            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
          };
          Cursor2.prototype.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
              this.overwrite = overwrite;
              if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
              else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
          };
          Cursor2.prototype.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
          };
          return Cursor2;
        }()
      );
      Cursor.prototype.$padding = 0;
      Cursor.prototype.drawCursor = null;
      exports2.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var oop = require3("./lib/oop");
      var dom = require3("./lib/dom");
      var event = require3("./lib/event");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var MAX_SCROLL_H = 32768;
      var Scrollbar = (
        /** @class */
        function() {
          function Scrollbar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "ace_scrollbar-inner";
            this.inner.textContent = "\xA0";
            this.element.appendChild(this.inner);
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addListener(this.element, "scroll", this.onScroll.bind(this));
            event.addListener(this.element, "mousedown", event.preventDefault);
          }
          Scrollbar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return Scrollbar2;
        }()
      );
      oop.implement(Scrollbar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollTop = this.element.scrollTop;
              if (this.coeff != 1) {
                var h = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
              }
              this._emit("scroll", { data: this.scrollTop });
            }
            this.skipEvent = false;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.element.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
              this.coeff = MAX_SCROLL_H / height;
              height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
              this.coeff = 1;
            }
            this.inner.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
              this.skipEvent = true;
              this.scrollTop = scrollTop;
              this.element.scrollTop = scrollTop * this.coeff;
            }
          };
          return VScrollBar2;
        }(Scrollbar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.height = renderer.$scrollbarWidth;
            _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
            return _this;
          }
          HScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollLeft = this.element.scrollLeft;
              this._emit("scroll", { data: this.scrollLeft });
            }
            this.skipEvent = false;
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.element.style.width = width + "px";
          };
          HScrollBar2.prototype.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
              this.skipEvent = true;
              this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
          };
          return HScrollBar2;
        }(Scrollbar)
      );
      exports2.ScrollBar = VScrollBar;
      exports2.ScrollBarV = VScrollBar;
      exports2.ScrollBarH = HScrollBar;
      exports2.VScrollBar = VScrollBar;
      exports2.HScrollBar = HScrollBar;
    });
    ace.define("ace/scrollbar_custom", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var oop = require3("./lib/oop");
      var dom = require3("./lib/dom");
      var event = require3("./lib/event");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
      var ScrollBar = (
        /** @class */
        function() {
          function ScrollBar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_sb" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "";
            this.element.appendChild(this.inner);
            this.VScrollWidth = 12;
            this.HScrollHeight = 12;
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
          }
          ScrollBar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return ScrollBar2;
        }()
      );
      oop.implement(ScrollBar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            _this.parent = parent;
            _this.width = _this.VScrollWidth;
            _this.renderer = renderer;
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onMouseDown = function(eType, e) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e) !== 0 || e.detail === 2) {
              return;
            }
            if (e.target === this.inner) {
              var self2 = this;
              var mousePageY = e.clientY;
              var onMouseMove = function(e2) {
                mousePageY = e2.clientY;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startY = e.clientY;
              var startTop = this.thumbTop;
              var onScrollInterval = function() {
                if (mousePageY === void 0)
                  return;
                var scrollTop = self2.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self2.scrollTop)
                  return;
                self2._emit("scroll", { data: scrollTop });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e);
            }
            var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
            return event.preventDefault(e);
          };
          VScrollBar2.prototype.getHeight = function() {
            return this.height;
          };
          VScrollBar2.prototype.scrollTopFromThumbTop = function(thumbTop) {
            var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
            scrollTop = scrollTop >> 0;
            if (scrollTop < 0) {
              scrollTop = 0;
            } else if (scrollTop > this.pageHeight - this.viewHeight) {
              scrollTop = this.pageHeight - this.viewHeight;
            }
            return scrollTop;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.height = Math.max(0, height);
            this.slideHeight = this.height;
            this.viewHeight = this.height;
            this.setScrollHeight(this.pageHeight, true);
          };
          VScrollBar2.prototype.setScrollHeight = function(height, force) {
            if (this.pageHeight === height && !force)
              return;
            this.pageHeight = height;
            this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
            if (this.thumbHeight > this.slideHeight)
              this.thumbHeight = this.slideHeight;
            if (this.thumbHeight < 15)
              this.thumbHeight = 15;
            this.inner.style.height = this.thumbHeight + "px";
            if (this.scrollTop > this.pageHeight - this.viewHeight) {
              this.scrollTop = this.pageHeight - this.viewHeight;
              if (this.scrollTop < 0)
                this.scrollTop = 0;
              this._emit("scroll", { data: this.scrollTop });
            }
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            this.scrollTop = scrollTop;
            if (scrollTop < 0)
              scrollTop = 0;
            this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
            this.inner.style.top = this.thumbTop + "px";
          };
          return VScrollBar2;
        }(ScrollBar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.scrollWidth = 0;
            _this.height = _this.HScrollHeight;
            _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
            _this.renderer = renderer;
            return _this;
          }
          HScrollBar2.prototype.onMouseDown = function(eType, e) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e) !== 0 || e.detail === 2) {
              return;
            }
            if (e.target === this.inner) {
              var self2 = this;
              var mousePageX = e.clientX;
              var onMouseMove = function(e2) {
                mousePageX = e2.clientX;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startX = e.clientX;
              var startLeft = this.thumbLeft;
              var onScrollInterval = function() {
                if (mousePageX === void 0)
                  return;
                var scrollLeft = self2.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self2.scrollLeft)
                  return;
                self2._emit("scroll", { data: scrollLeft });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e);
            }
            var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
            return event.preventDefault(e);
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.scrollLeftFromThumbLeft = function(thumbLeft) {
            var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
            scrollLeft = scrollLeft >> 0;
            if (scrollLeft < 0) {
              scrollLeft = 0;
            } else if (scrollLeft > this.pageWidth - this.viewWidth) {
              scrollLeft = this.pageWidth - this.viewWidth;
            }
            return scrollLeft;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.width = Math.max(0, width);
            this.element.style.width = this.width + "px";
            this.slideWidth = this.width;
            this.viewWidth = this.width;
            this.setScrollWidth(this.pageWidth, true);
          };
          HScrollBar2.prototype.setScrollWidth = function(width, force) {
            if (this.pageWidth === width && !force)
              return;
            this.pageWidth = width;
            this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
            if (this.thumbWidth > this.slideWidth)
              this.thumbWidth = this.slideWidth;
            if (this.thumbWidth < 15)
              this.thumbWidth = 15;
            this.inner.style.width = this.thumbWidth + "px";
            if (this.scrollLeft > this.pageWidth - this.viewWidth) {
              this.scrollLeft = this.pageWidth - this.viewWidth;
              if (this.scrollLeft < 0)
                this.scrollLeft = 0;
              this._emit("scroll", { data: this.scrollLeft });
            }
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            this.scrollLeft = scrollLeft;
            if (scrollLeft < 0)
              scrollLeft = 0;
            this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
            this.inner.style.left = this.thumbLeft + "px";
          };
          return HScrollBar2;
        }(ScrollBar)
      );
      HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
      exports2.ScrollBar = VScrollBar;
      exports2.ScrollBarV = VScrollBar;
      exports2.ScrollBarH = HScrollBar;
      exports2.VScrollBar = VScrollBar;
      exports2.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require3, exports2, module3) {
      "use strict";
      var event = require3("./lib/event");
      var RenderLoop = (
        /** @class */
        function() {
          function RenderLoop2(onRender, win) {
            this.onRender = onRender;
            this.pending = false;
            this.changes = 0;
            this.$recursionLimit = 2;
            this.window = win || window;
            var _self = this;
            this._flush = function(ts2) {
              _self.pending = false;
              var changes = _self.changes;
              if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
              }
              if (_self.changes) {
                if (_self.$recursionLimit-- < 0)
                  return;
                _self.schedule();
              } else {
                _self.$recursionLimit = 2;
              }
            };
          }
          RenderLoop2.prototype.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
              event.nextFrame(this._flush);
              this.pending = true;
            }
          };
          RenderLoop2.prototype.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
          };
          return RenderLoop2;
        }()
      );
      exports2.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(require3, exports2, module3) {
      var oop = require3("../lib/oop");
      var dom = require3("../lib/dom");
      var lang = require3("../lib/lang");
      var event = require3("../lib/event");
      var useragent = require3("../lib/useragent");
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 512;
      var USE_OBSERVER = typeof ResizeObserver == "function";
      var L3 = 200;
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(parentEl) {
            this.el = dom.createElement("div");
            this.$setMeasureNodeStyles(this.el.style, true);
            this.$main = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$main.style);
            this.$measureNode = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$measureNode.style);
            this.el.appendChild(this.$main);
            this.el.appendChild(this.$measureNode);
            parentEl.appendChild(this.el);
            this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
            this.$characterSize = { width: 0, height: 0 };
            if (USE_OBSERVER)
              this.$addObserver();
            else
              this.checkForSizeChanges();
          }
          FontMetrics2.prototype.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";
            if (useragent.isIE < 8) {
              style["font-family"] = "inherit";
            } else {
              style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
          };
          FontMetrics2.prototype.checkForSizeChanges = function(size) {
            if (size === void 0)
              size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
              this.$measureNode.style.fontWeight = "bold";
              var boldSize = this.$measureSizes();
              this.$measureNode.style.fontWeight = "";
              this.$characterSize = size;
              this.charSizes = /* @__PURE__ */ Object.create(null);
              this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
              this._emit("changeCharacterSize", { data: size });
            }
          };
          FontMetrics2.prototype.$addObserver = function() {
            var self2 = this;
            this.$observer = new window.ResizeObserver(function(e) {
              self2.checkForSizeChanges();
            });
            this.$observer.observe(this.$measureNode);
          };
          FontMetrics2.prototype.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
              return this.$pollSizeChangesTimer;
            var self2 = this;
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
              self2.checkForSizeChanges();
              event.onIdle(cb, 500);
            }, 500);
          };
          FontMetrics2.prototype.setPolling = function(val) {
            if (val) {
              this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
              clearInterval(this.$pollSizeChangesTimer);
              this.$pollSizeChangesTimer = 0;
            }
          };
          FontMetrics2.prototype.$measureSizes = function(node) {
            var size = {
              height: (node || this.$measureNode).clientHeight,
              width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0)
              return null;
            return size;
          };
          FontMetrics2.prototype.$measureCharWidth = function(ch) {
            this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
          };
          FontMetrics2.prototype.getCharacterWidth = function(ch) {
            var w2 = this.charSizes[ch];
            if (w2 === void 0) {
              w2 = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w2;
          };
          FontMetrics2.prototype.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer)
              this.$observer.disconnect();
            if (this.el && this.el.parentNode)
              this.el.parentNode.removeChild(this.el);
          };
          FontMetrics2.prototype.$getZoom = function(element) {
            if (!element || !element.parentElement)
              return 1;
            return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
          };
          FontMetrics2.prototype.$initTransformMeasureNodes = function() {
            var t = function(t2, l) {
              return ["div", {
                style: "position: absolute;top:" + t2 + "px;left:" + l + "px;"
              }];
            };
            this.els = dom.buildDom([t(0, 0), t(L3, 0), t(0, L3), t(L3, L3)], this.el);
          };
          FontMetrics2.prototype.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
              var zoom = this.$getZoom(this.el);
              clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
              var det = l1[1] * l2[0] - l1[0] * l2[1];
              return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
              ];
            }
            function sub(a2, b3) {
              return [a2[0] - b3[0], a2[1] - b3[1]];
            }
            function add(a2, b3) {
              return [a2[0] + b3[0], a2[1] + b3[1]];
            }
            function mul(a2, b3) {
              return [a2 * b3[0], a2 * b3[1]];
            }
            if (!this.els)
              this.$initTransformMeasureNodes();
            function p(el) {
              var r = el.getBoundingClientRect();
              return [r.left, r.top];
            }
            var a = p(this.els[0]);
            var b2 = p(this.els[1]);
            var c = p(this.els[2]);
            var d = p(this.els[3]);
            var h = solve(sub(d, b2), sub(d, c), sub(add(b2, c), add(d, a)));
            var m1 = mul(1 + h[0], sub(b2, a));
            var m2 = mul(1 + h[1], sub(c, a));
            if (elPos) {
              var x = elPos;
              var k2 = h[0] * x[0] / L3 + h[1] * x[1] / L3 + 1;
              var ut2 = add(mul(x[0], m1), mul(x[1], m2));
              return add(mul(1 / k2 / L3, ut2), a);
            }
            var u = sub(clientPos, a);
            var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
            return mul(L3, f);
          };
          return FontMetrics2;
        }()
      );
      FontMetrics.prototype.$characterSize = { width: 0, height: 0 };
      oop.implement(FontMetrics.prototype, EventEmitter);
      exports2.FontMetrics = FontMetrics;
    });
    ace.define("ace/css/editor-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    forced-color-adjust: none;
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}
.ace_invisible {
    font-variant-ligatures: none;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_security {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}
.ace_icon_svg.ace_hint {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");
    background-color: silver;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_security_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(33em, 66vw);
    overscroll-behavior: contain;
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget, .ace_custom-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
    pointer-events: auto;
}

.ace_custom-widget {
    background: none;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    position: relative;
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
    z-index: 1;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
}

.ace_ghost_text_container > div {
    white-space: pre;
}

.ghost_text_line_wrapped::after {
    content: "\u21A9";
    position: absolute;
}

.ace_lineWidgetContainer.ace_ghost_text {
    margin: 0px 4px
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}

.ace_hidden_token {
    display: none;
}`;
    });
    ace.define("ace/layer/decorators", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var oop = require3("../lib/oop");
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var Decorator = (
        /** @class */
        function() {
          function Decorator2(scrollbarV, renderer) {
            this.renderer = renderer;
            this.pixelRatio = 1;
            this.maxHeight = renderer.layerConfig.maxHeight;
            this.lineHeight = renderer.layerConfig.lineHeight;
            this.minDecorationHeight = 2 * this.pixelRatio | 0;
            this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
            this.colors = {};
            this.colors.dark = {
              "error": "rgba(255, 18, 18, 1)",
              "warning": "rgba(18, 136, 18, 1)",
              "info": "rgba(18, 18, 136, 1)"
            };
            this.colors.light = {
              "error": "rgb(255,51,51)",
              "warning": "rgb(32,133,72)",
              "info": "rgb(35,68,138)"
            };
            this.setScrollBarV(scrollbarV);
          }
          Decorator2.prototype.$createCanvas = function() {
            this.canvas = dom.createElement("canvas");
            this.canvas.style.top = "0px";
            this.canvas.style.right = "0px";
            this.canvas.style.zIndex = "7";
            this.canvas.style.position = "absolute";
          };
          Decorator2.prototype.setScrollBarV = function(scrollbarV) {
            this.$createCanvas();
            this.scrollbarV = scrollbarV;
            scrollbarV.element.appendChild(this.canvas);
            this.setDimensions();
          };
          Decorator2.prototype.$updateDecorators = function(config) {
            if (typeof this.canvas.getContext !== "function") {
              return;
            }
            var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
            this.setDimensions(config);
            var ctx = this.canvas.getContext("2d");
            function compare(a, b2) {
              if (a.priority < b2.priority)
                return -1;
              if (a.priority > b2.priority)
                return 1;
              return 0;
            }
            var annotations = this.renderer.session.$annotations;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (annotations) {
              var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
              };
              annotations.forEach(function(item) {
                item["priority"] = priorities[item.type] || null;
              });
              annotations = annotations.sort(compare);
              for (var i = 0; i < annotations.length; i++) {
                var row = annotations[i].row;
                var offset1 = this.getVerticalOffsetForRow(row);
                var offset2 = offset1 + this.lineHeight;
                var y1 = Math.round(this.heightRatio * offset1);
                var y2 = Math.round(this.heightRatio * offset2);
                var ycenter = Math.round((y1 + y2) / 2);
                var halfHeight = y2 - ycenter;
                if (halfHeight < this.halfMinDecorationHeight) {
                  halfHeight = this.halfMinDecorationHeight;
                }
                if (ycenter - halfHeight < 0) {
                  ycenter = halfHeight;
                }
                if (ycenter + halfHeight > this.canvasHeight) {
                  ycenter = this.canvasHeight - halfHeight;
                }
                var from = ycenter - halfHeight;
                var to2 = ycenter + halfHeight;
                var zoneHeight = to2 - from;
                ctx.fillStyle = colors[annotations[i].type] || null;
                ctx.fillRect(0, from, Math.round(this.oneZoneWidth - 1), zoneHeight);
              }
            }
            var cursor = this.renderer.session.selection.getCursor();
            if (cursor) {
              var currentY = Math.round(this.getVerticalOffsetForRow(cursor.row) * this.heightRatio);
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(0, currentY, this.canvasWidth, 2);
            }
          };
          Decorator2.prototype.getVerticalOffsetForRow = function(row) {
            row = row | 0;
            var offset = this.renderer.session.documentToScreenRow(row, 0) * this.lineHeight;
            return offset;
          };
          Decorator2.prototype.setDimensions = function(config) {
            config = config || this.renderer.layerConfig;
            this.maxHeight = config.maxHeight;
            this.lineHeight = config.lineHeight;
            this.canvasHeight = config.height;
            this.canvasWidth = this.scrollbarV.width || this.canvasWidth;
            this.setZoneWidth();
            this.canvas.width = this.canvasWidth;
            this.canvas.height = this.canvasHeight;
            if (this.maxHeight < this.canvasHeight) {
              this.heightRatio = 1;
            } else {
              this.heightRatio = this.canvasHeight / this.maxHeight;
            }
          };
          Decorator2.prototype.setZoneWidth = function() {
            this.oneZoneWidth = this.canvasWidth;
          };
          Decorator2.prototype.destroy = function() {
            this.canvas.parentNode.removeChild(this.canvas);
          };
          return Decorator2;
        }()
      );
      oop.implement(Decorator.prototype, EventEmitter);
      exports2.Decorator = Decorator;
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/scrollbar_custom", "ace/scrollbar_custom", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/css/editor-css", "ace/layer/decorators", "ace/lib/useragent", "ace/layer/text_util"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./lib/oop");
      var dom = require3("./lib/dom");
      var lang = require3("./lib/lang");
      var config = require3("./config");
      var GutterLayer = require3("./layer/gutter").Gutter;
      var MarkerLayer = require3("./layer/marker").Marker;
      var TextLayer = require3("./layer/text").Text;
      var CursorLayer = require3("./layer/cursor").Cursor;
      var HScrollBar = require3("./scrollbar").HScrollBar;
      var VScrollBar = require3("./scrollbar").VScrollBar;
      var HScrollBarCustom = require3("./scrollbar_custom").HScrollBar;
      var VScrollBarCustom = require3("./scrollbar_custom").VScrollBar;
      var RenderLoop = require3("./renderloop").RenderLoop;
      var FontMetrics = require3("./layer/font_metrics").FontMetrics;
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var editorCss = require3("./css/editor-css");
      var Decorator = require3("./layer/decorators").Decorator;
      var useragent = require3("./lib/useragent");
      var isTextToken = require3("./layer/text_util").isTextToken;
      dom.importCssString(editorCss, "ace_editor.css", false);
      var VirtualRenderer = (
        /** @class */
        function() {
          function VirtualRenderer2(container, theme) {
            var _self = this;
            this.container = container || dom.createElement("div");
            dom.addCssClass(this.container, "ace_editor");
            if (dom.HI_DPI)
              dom.addCssClass(this.container, "ace_hidpi");
            this.setTheme(theme);
            if (config.get("useStrictCSP") == null)
              config.set("useStrictCSP", false);
            this.$gutter = dom.createElement("div");
            this.$gutter.className = "ace_gutter";
            this.container.appendChild(this.$gutter);
            this.$gutter.setAttribute("aria-hidden", "true");
            this.scroller = dom.createElement("div");
            this.scroller.className = "ace_scroller";
            this.container.appendChild(this.scroller);
            this.content = dom.createElement("div");
            this.content.className = "ace_content";
            this.scroller.appendChild(this.content);
            this.$gutterLayer = new GutterLayer(this.$gutter);
            this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
            this.$markerBack = new MarkerLayer(this.content);
            var textLayer = this.$textLayer = new TextLayer(this.content);
            this.canvas = textLayer.element;
            this.$markerFront = new MarkerLayer(this.content);
            this.$cursorLayer = new CursorLayer(this.content);
            this.$horizScroll = false;
            this.$vScroll = false;
            this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.on("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.on("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            this.scrollTop = 0;
            this.scrollLeft = 0;
            this.cursorPos = {
              row: 0,
              column: 0
            };
            this.$fontMetrics = new FontMetrics(this.container);
            this.$textLayer.$setFontMetrics(this.$fontMetrics);
            this.$textLayer.on("changeCharacterSize", function(e) {
              _self.updateCharacterSize();
              _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
              _self._signal("changeCharacterSize", e);
            });
            this.$size = {
              width: 0,
              height: 0,
              scrollerHeight: 0,
              scrollerWidth: 0,
              $dirty: true
            };
            this.layerConfig = {
              width: 1,
              padding: 0,
              firstRow: 0,
              firstRowScreen: 0,
              lastRow: 0,
              lineHeight: 0,
              characterWidth: 0,
              minHeight: 1,
              maxHeight: 1,
              offset: 0,
              height: 1,
              gutterOffset: 1
            };
            this.scrollMargin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.margin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.$keepTextAreaAtCursor = !useragent.isIOS;
            this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
            this.$loop.schedule(this.CHANGE_FULL);
            this.updateCharacterSize();
            this.setPadding(4);
            this.$addResizeObserver();
            config.resetOptions(this);
            config._signal("renderer", this);
          }
          VirtualRenderer2.prototype.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
              this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
              this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }
            this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
          };
          VirtualRenderer2.prototype.setSession = function(session) {
            if (this.session)
              this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
              session.setScrollTop(-this.scrollMargin.top);
            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
              return;
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          };
          VirtualRenderer2.prototype.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === void 0)
              lastRow = Infinity;
            if (!this.$changedLines) {
              this.$changedLines = {
                firstRow,
                lastRow
              };
            } else {
              if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;
              if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
              if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
              else
                return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
              return;
            this.$loop.schedule(this.CHANGE_LINES);
          };
          VirtualRenderer2.prototype.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          };
          VirtualRenderer2.prototype.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
          };
          VirtualRenderer2.prototype.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
          };
          VirtualRenderer2.prototype.updateFull = function(force) {
            if (force)
              this.$renderChanges(this.CHANGE_FULL, true);
            else
              this.$loop.schedule(this.CHANGE_FULL);
          };
          VirtualRenderer2.prototype.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
          };
          VirtualRenderer2.prototype.$updateSizeAsync = function() {
            if (this.$loop.pending)
              this.$size.$dirty = true;
            else
              this.onResize();
          };
          VirtualRenderer2.prototype.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
              return;
            else if (this.resizing > 0)
              this.resizing++;
            else
              this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
              height = el.clientHeight || el.scrollHeight;
            if (!height && this.$maxLines && this.lineHeight > 1) {
              if (!el.style.height || el.style.height == "0px") {
                el.style.height = "1px";
                height = el.clientHeight || el.scrollHeight;
              }
            }
            if (!width)
              width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);
            if (this.$resizeTimer)
              this.$resizeTimer.cancel();
            if (!this.$size.scrollerHeight || !width && !height)
              return this.resizing = 0;
            if (force)
              this.$gutterLayer.$padding = null;
            if (force)
              this.$renderChanges(changes | this.$changes, true);
            else
              this.$loop.schedule(changes | this.$changes);
            if (this.resizing)
              this.resizing = 0;
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            if (this.$customScrollbar) {
              this.$updateCustomScrollbar(true);
            }
          };
          VirtualRenderer2.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= this.$extraHeight || 0;
            var changes = 0;
            var size = this.$size;
            var oldSize = {
              width: size.width,
              height: size.height,
              scrollerHeight: size.scrollerHeight,
              scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
              size.height = height;
              changes |= this.CHANGE_SIZE;
              size.scrollerHeight = size.height;
              if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
              this.scrollBarV.setHeight(size.scrollerHeight);
              this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
              changes = changes | this.CHANGE_SCROLL;
            }
            if (width && (force || size.width != width)) {
              changes |= this.CHANGE_SIZE;
              size.width = width;
              if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
              this.gutterWidth = gutterWidth;
              dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
              dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
              size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
              dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
              var right = this.scrollBarV.getWidth() + "px";
              dom.setStyle(this.scrollBarH.element.style, "right", right);
              dom.setStyle(this.scroller.style, "right", right);
              dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
              this.scrollBarH.setWidth(size.scrollerWidth);
              if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
              }
            }
            size.$dirty = !width || !height;
            if (changes)
              this._signal("resize", oldSize);
            return changes;
          };
          VirtualRenderer2.prototype.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth)
              this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else {
              this.$computeLayerConfig();
            }
          };
          VirtualRenderer2.prototype.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
          };
          VirtualRenderer2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.setOption("animatedScroll", shouldAnimate);
          };
          VirtualRenderer2.prototype.getAnimatedScroll = function() {
            return this.$animatedScroll;
          };
          VirtualRenderer2.prototype.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
          };
          VirtualRenderer2.prototype.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
          };
          VirtualRenderer2.prototype.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
          };
          VirtualRenderer2.prototype.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
          };
          VirtualRenderer2.prototype.getHighlightIndentGuides = function() {
            return this.getOption("highlightIndentGuides");
          };
          VirtualRenderer2.prototype.setHighlightIndentGuides = function(highlight) {
            this.setOption("highlightIndentGuides", highlight);
          };
          VirtualRenderer2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
          };
          VirtualRenderer2.prototype.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
          };
          VirtualRenderer2.prototype.setPrintMarginColumn = function(printMarginColumn) {
            this.setOption("printMarginColumn", printMarginColumn);
          };
          VirtualRenderer2.prototype.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
          };
          VirtualRenderer2.prototype.getShowGutter = function() {
            return this.getOption("showGutter");
          };
          VirtualRenderer2.prototype.setShowGutter = function(show) {
            return this.setOption("showGutter", show);
          };
          VirtualRenderer2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          VirtualRenderer2.prototype.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
          };
          VirtualRenderer2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          VirtualRenderer2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          VirtualRenderer2.prototype.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
              return;
            if (!this.$printMarginEl) {
              var containerEl = dom.createElement("div");
              containerEl.className = "ace_layer ace_print-margin-layer";
              this.$printMarginEl = dom.createElement("div");
              this.$printMarginEl.className = "ace_print-margin";
              containerEl.appendChild(this.$printMarginEl);
              this.content.insertBefore(containerEl, this.content.firstChild);
            }
            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            if (this.session && this.session.$wrap == -1)
              this.adjustWrapLimit();
          };
          VirtualRenderer2.prototype.getContainerElement = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.getMouseEventTarget = function() {
            return this.scroller;
          };
          VirtualRenderer2.prototype.getTextAreaContainer = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed)
              return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
              dom.translate(this.textarea, -100, 0);
              return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos)
              return;
            if (composition && composition.markerRange)
              pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            var config2 = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config2.offset;
            var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
            if (posTop < 0 || posTop > config2.height - h) {
              dom.translate(this.textarea, 0, 0);
              return;
            }
            var w2 = 1;
            var maxTop = this.$size.height - h;
            if (!composition) {
              posTop += this.lineHeight;
            } else {
              if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w2 = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
              } else {
                posTop += this.lineHeight + 2;
              }
            }
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w2)
              posLeft = this.$size.scrollerWidth - w2;
            posLeft += this.gutterWidth + this.margin.left;
            dom.setStyle(style, "height", h + "px");
            dom.setStyle(style, "width", w2 + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w2), Math.min(posTop, maxTop));
          };
          VirtualRenderer2.prototype.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
          };
          VirtualRenderer2.prototype.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          };
          VirtualRenderer2.prototype.getLastFullyVisibleRow = function() {
            var config2 = this.layerConfig;
            var lastRow = config2.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config2.lineHeight;
            if (top - this.session.getScrollTop() > config2.height - config2.lineHeight)
              return lastRow - 1;
            return lastRow;
          };
          VirtualRenderer2.prototype.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
          };
          VirtualRenderer2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
          };
          VirtualRenderer2.prototype.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
              this.session.setScrollTop(-sm.top);
            this.updateFull();
          };
          VirtualRenderer2.prototype.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
          };
          VirtualRenderer2.prototype.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
              scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
              if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
              }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          };
          VirtualRenderer2.prototype.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          };
          VirtualRenderer2.prototype.freeze = function() {
            this.$frozen = true;
          };
          VirtualRenderer2.prototype.unfreeze = function() {
            this.$frozen = false;
          };
          VirtualRenderer2.prototype.$renderChanges = function(changes, force) {
            if (this.$changes) {
              changes |= this.$changes;
              this.$changes = 0;
            }
            if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
              this.$changes |= changes;
              return;
            }
            if (this.$size.$dirty) {
              this.$changes |= changes;
              return this.onResize(true);
            }
            if (!this.lineHeight) {
              this.$textLayer.checkForSizeChanges();
            }
            this._signal("beforeRender", changes);
            if (this.session && this.session.$bidiHandler)
              this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var config2 = this.layerConfig;
            if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
              changes |= this.$computeLayerConfig() | this.$loop.clear();
              if (config2.firstRow != this.layerConfig.firstRow && config2.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st3 = this.scrollTop + (config2.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                if (st3 > 0) {
                  this.scrollTop = st3;
                  changes = changes | this.CHANGE_SCROLL;
                  changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
              }
              config2 = this.layerConfig;
              this.$updateScrollBarV();
              if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              var width = config2.width + 2 * this.$padding + "px";
              var height = config2.minHeight + "px";
              dom.setStyle(this.content.style, "width", width);
              dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
              if (this.enableKeyboardAccessibility)
                this.scroller.className += this.keyboardFocusClassName;
            }
            if (changes & this.CHANGE_FULL) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_SCROLL) {
              this.$changedLines = null;
              if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config2);
              else
                this.$textLayer.scrollLines(config2);
              if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                  this.$gutterLayer.update(config2);
                else
                  this.$gutterLayer.scrollLines(config2);
              }
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_TEXT) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_LINES) {
              if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_CURSOR) {
              if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            }
            if (changes & this.CHANGE_CURSOR) {
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
              this.$markerFront.update(config2);
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
              this.$markerBack.update(config2);
            }
            this._signal("afterRender", changes);
          };
          VirtualRenderer2.prototype.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
              desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
              desiredHeight = this.$maxPixelHeight;
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
              if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
              }
              var w2 = this.container.clientWidth;
              this.container.style.height = desiredHeight + "px";
              this.$updateCachedSize(true, this.$gutterWidth, w2, desiredHeight);
              this.desiredHeight = desiredHeight;
              this._signal("autosize");
            }
          };
          VirtualRenderer2.prototype.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;
            var longestLine = this.$getLongestLine();
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
              this.$horizScroll = horizScroll;
              this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll;
            if (this.$maxLines && this.lineHeight > 1) {
              this.$autosize();
              hideScrollbars = size.height <= 2 * this.lineHeight;
            }
            var minHeight = size.scrollerHeight + this.lineHeight;
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            maxHeight += scrollPastEnd;
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
              firstRow = foldLine.start.row;
            }
            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;
            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
            offset = this.scrollTop - firstRowScreen * lineHeight;
            if (offset < 0 && firstRowScreen > 0) {
              firstRowScreen = Math.max(0, firstRowScreen + Math.floor(offset / lineHeight));
              offset = this.scrollTop - firstRowScreen * lineHeight;
            }
            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged)
              changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
              changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
              this._signal("scrollbarVisibilityChanged");
              if (vScrollChanged)
                longestLine = this.$getLongestLine();
            }
            this.layerConfig = {
              width: longestLine,
              padding: this.$padding,
              firstRow,
              firstRowScreen,
              lastRow,
              lineHeight,
              characterWidth: this.characterWidth,
              minHeight,
              maxHeight,
              offset,
              gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
              height: this.$size.scrollerHeight
            };
            if (this.session.$bidiHandler)
              this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
            return changes;
          };
          VirtualRenderer2.prototype.$updateLines = function() {
            if (!this.$changedLines)
              return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;
            var layerConfig = this.layerConfig;
            if (firstRow > layerConfig.lastRow + 1) {
              return;
            }
            if (lastRow < layerConfig.firstRow) {
              return;
            }
            if (lastRow === Infinity) {
              if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
              this.$textLayer.update(layerConfig);
              return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
          };
          VirtualRenderer2.prototype.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
              charCount += 1;
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
              charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
          };
          VirtualRenderer2.prototype.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          };
          VirtualRenderer2.prototype.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
          };
          VirtualRenderer2.prototype.addGutterDecoration = function(row, className) {
            this.$gutterLayer.addGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.removeGutterDecoration = function(row, className) {
            this.$gutterLayer.removeGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.updateBreakpoints = function(rows) {
            this._rows = rows;
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
          };
          VirtualRenderer2.prototype.hideCursor = function() {
            this.$cursorLayer.hideCursor();
          };
          VirtualRenderer2.prototype.showCursor = function() {
            this.$cursorLayer.showCursor();
          };
          VirtualRenderer2.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
          };
          VirtualRenderer2.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
              return;
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var newLeft = pos.left;
            var newTop = pos.top;
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            if (this.$scrollAnimation) {
              this.$stopAnimation = true;
            }
            var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            if (currentTop + topMargin > newTop) {
              if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
              if (newTop === 0)
                newTop = -this.scrollMargin.top;
              this.session.setScrollTop(newTop);
            } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
              if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
              this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }
            var currentLeft = this.scrollLeft;
            var twoCharsWidth = 2 * this.layerConfig.characterWidth;
            if (newLeft - twoCharsWidth < currentLeft) {
              newLeft -= twoCharsWidth;
              if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
              }
              this.session.setScrollLeft(newLeft);
            } else {
              newLeft += twoCharsWidth;
              if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
              } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
              }
            }
          };
          VirtualRenderer2.prototype.getScrollTop = function() {
            return this.session.getScrollTop();
          };
          VirtualRenderer2.prototype.getScrollLeft = function() {
            return this.session.getScrollLeft();
          };
          VirtualRenderer2.prototype.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
          };
          VirtualRenderer2.prototype.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          };
          VirtualRenderer2.prototype.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
          };
          VirtualRenderer2.prototype.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
              cursor = { row: cursor, column: 0 };
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h * (alignment || 0);
            this.session.setScrollTop(offset);
            return offset;
          };
          VirtualRenderer2.prototype.$calcSteps = function(fromValue, toValue) {
            var i = 0;
            var l = this.STEPS;
            var steps = [];
            var func = function(t, x_min, dx) {
              return dx * (Math.pow(t - 1, 3) + 1) + x_min;
            };
            for (i = 0; i < l; ++i)
              steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
            return steps;
          };
          VirtualRenderer2.prototype.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
            var offset = pos.top;
            if (center)
              offset -= this.$size.scrollerHeight / 2;
            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
              this.animateScrolling(initialScroll, callback);
          };
          VirtualRenderer2.prototype.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
              return;
            var _self = this;
            if (fromValue == toValue)
              return;
            if (this.$scrollAnimation) {
              var oldSteps = this.$scrollAnimation.steps;
              if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                  return;
              }
            }
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = { from: fromValue, to: toValue, steps };
            clearInterval(this.$timer);
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            function endAnimation() {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              _self.$stopAnimation = false;
              callback && callback();
            }
            this.$timer = setInterval(function() {
              if (_self.$stopAnimation) {
                endAnimation();
                return;
              }
              if (!_self.session)
                return clearInterval(_self.$timer);
              if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
              } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
              } else {
                endAnimation();
              }
            }, 10);
          };
          VirtualRenderer2.prototype.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
              this.$loop.schedule(this.CHANGE_SCROLL);
              this.scrollTop = scrollTop;
            }
          };
          VirtualRenderer2.prototype.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
              this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
          };
          VirtualRenderer2.prototype.scrollTo = function(x, y2) {
            this.session.setScrollTop(y2);
            this.session.setScrollLeft(x);
          };
          VirtualRenderer2.prototype.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
          };
          VirtualRenderer2.prototype.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
              return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
              return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
              return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
              return true;
          };
          VirtualRenderer2.prototype.pixelToScreenCoordinates = function(x, y2) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x, y2]);
              x = p[1] - this.gutterWidth - this.margin.left;
              y2 = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y2 + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            return { row, column: col, side: offset - col > 0 ? 1 : -1, offsetX };
          };
          VirtualRenderer2.prototype.screenToTextCoordinates = function(x, y2) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x, y2]);
              x = p[1] - this.gutterWidth - this.margin.left;
              y2 = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            var row = Math.floor((y2 + this.scrollTop - canvasPos.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
          };
          VirtualRenderer2.prototype.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);
            var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
            var y2 = pos.row * this.lineHeight;
            return {
              pageX: canvasPos.left + x - this.scrollLeft,
              pageY: canvasPos.top + y2 - this.scrollTop
            };
          };
          VirtualRenderer2.prototype.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) {
              composition.cssText = this.textarea.style.cssText;
            }
            if (composition.useTextareaForIME == void 0)
              composition.useTextareaForIME = this.$useTextareaForIME;
            if (this.$useTextareaForIME) {
              dom.addCssClass(this.textarea, "ace_composition");
              this.textarea.style.cssText = "";
              this.$moveTextAreaToCursor();
              this.$cursorLayer.element.style.display = "none";
            } else {
              composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
            }
          };
          VirtualRenderer2.prototype.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
          };
          VirtualRenderer2.prototype.hideComposition = function() {
            if (!this.$composition)
              return;
            if (this.$composition.markerId)
              this.session.removeMarker(this.$composition.markerId);
            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            var cursor = this.session.selection.cursor;
            this.removeExtraToken(cursor.row, cursor.column);
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
          };
          VirtualRenderer2.prototype.setGhostText = function(text, position) {
            var cursor = this.session.selection.cursor;
            var insertPosition = position || { row: cursor.row, column: cursor.column };
            this.removeGhostText();
            var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
            this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);
            this.$ghostText = {
              text,
              position: {
                row: insertPosition.row,
                column: insertPosition.column
              }
            };
            var widgetDiv = dom.createElement("div");
            if (textChunks.length > 1) {
              var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);
              var lastLineDiv;
              textChunks.slice(1).forEach(function(el2) {
                var chunkDiv = dom.createElement("div");
                var chunkSpan = dom.createElement("span");
                chunkSpan.className = "ace_ghost_text";
                if (el2.wrapped)
                  chunkDiv.className = "ghost_text_line_wrapped";
                if (el2.text.length === 0)
                  el2.text = " ";
                chunkSpan.appendChild(dom.createTextNode(el2.text));
                chunkDiv.appendChild(chunkSpan);
                widgetDiv.appendChild(chunkDiv);
                lastLineDiv = chunkDiv;
              });
              hiddenTokens.forEach(function(token) {
                var element = dom.createElement("span");
                if (!isTextToken(token.type))
                  element.className = "ace_" + token.type.replace(/\./g, " ace_");
                element.appendChild(dom.createTextNode(token.value));
                lastLineDiv.appendChild(element);
              });
              this.$ghostTextWidget = {
                el: widgetDiv,
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text_container"
              };
              this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
              var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
              var el = this.container;
              var height = el.getBoundingClientRect().height;
              var ghostTextHeight = textChunks.length * this.lineHeight;
              var fitsY = ghostTextHeight < height - pixelPosition.top;
              if (fitsY)
                return;
              if (ghostTextHeight < height) {
                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
              } else {
                this.scrollToRow(insertPosition.row);
              }
            }
          };
          VirtualRenderer2.prototype.$calculateWrappedTextChunks = function(text, position) {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth) - 2;
            limit = limit <= 0 ? 60 : limit;
            var textLines = text.split(/\r?\n/);
            var textChunks = [];
            for (var i = 0; i < textLines.length; i++) {
              var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);
              var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);
              if (wrapSplits.length > 0) {
                var start = 0;
                wrapSplits.push(textLines[i].length);
                for (var j3 = 0; j3 < wrapSplits.length; j3++) {
                  var textSlice = textLines[i].slice(start, wrapSplits[j3]);
                  textChunks.push({ text: textSlice, wrapped: true });
                  start = wrapSplits[j3];
                }
              } else {
                textChunks.push({ text: textLines[i], wrapped: false });
              }
            }
            return textChunks;
          };
          VirtualRenderer2.prototype.removeGhostText = function() {
            if (!this.$ghostText)
              return;
            var position = this.$ghostText.position;
            this.removeExtraToken(position.row, position.column);
            if (this.$ghostTextWidget) {
              this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
              this.$ghostTextWidget = null;
            }
            this.$ghostText = null;
          };
          VirtualRenderer2.prototype.addToken = function(text, type, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = { type, value: text };
            var tokens = session.getTokens(row);
            if (column == null || !tokens.length) {
              tokens.push(newToken);
            } else {
              var l = 0;
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                l += token.value.length;
                if (column <= l) {
                  var diff = token.value.length - (l - column);
                  var before = token.value.slice(0, diff);
                  var after = token.value.slice(diff);
                  tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                  break;
                }
              }
            }
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.hideTokensAfterPosition = function(row, column) {
            var tokens = this.session.getTokens(row);
            var l = 0;
            var hasPassedCursor = false;
            var hiddenTokens = [];
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              l += token.value.length;
              if (token.type === "ghost_text")
                continue;
              if (hasPassedCursor) {
                hiddenTokens.push({ type: token.type, value: token.value });
                token.type = "hidden_token";
                continue;
              }
              if (l === column) {
                hasPassedCursor = true;
              }
            }
            this.updateLines(row, row);
            return hiddenTokens;
          };
          VirtualRenderer2.prototype.removeExtraToken = function(row, column) {
            this.session.bgTokenizer.lines[row] = null;
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent("themeChange", { theme });
            if (!theme || typeof theme == "string") {
              var moduleName = theme || this.$options.theme.initialValue;
              config.loadModule(["theme", moduleName], afterLoad);
            } else {
              afterLoad(theme);
            }
            function afterLoad(module4) {
              if (_self.$themeId != theme)
                return cb && cb();
              if (!module4 || !module4.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
              if (module4.$id)
                _self.$themeId = module4.$id;
              dom.importCssString(module4.cssText, module4.cssClass, _self.container);
              if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
              var padding = "padding" in module4 ? module4.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
              if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
              _self.$theme = module4.cssClass;
              _self.theme = module4;
              dom.addCssClass(_self.container, module4.cssClass);
              dom.setCssClass(_self.container, "ace_dark", module4.isDark);
              if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
              }
              _self._dispatchEvent("themeLoaded", { theme: module4 });
              cb && cb();
              if (useragent.isSafari && _self.scroller) {
                _self.scroller.style.background = "red";
                _self.scroller.style.background = "";
              }
            }
          };
          VirtualRenderer2.prototype.getTheme = function() {
            return this.$themeId;
          };
          VirtualRenderer2.prototype.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
          };
          VirtualRenderer2.prototype.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
          };
          VirtualRenderer2.prototype.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
          };
          VirtualRenderer2.prototype.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
          };
          VirtualRenderer2.prototype.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
          };
          VirtualRenderer2.prototype.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
            this.removeAllListeners();
            this.container.textContent = "";
            this.setOption("useResizeObserver", false);
          };
          VirtualRenderer2.prototype.$updateCustomScrollbar = function(val) {
            var _self = this;
            this.$horizScroll = this.$vScroll = null;
            this.scrollBarV.element.remove();
            this.scrollBarH.element.remove();
            if (val === true) {
              this.scrollBarV = new VScrollBarCustom(this.container, this);
              this.scrollBarH = new HScrollBarCustom(this.container, this);
              this.scrollBarV.setHeight(this.$size.scrollerHeight);
              this.scrollBarH.setWidth(this.$size.scrollerWidth);
              this.scrollBarV.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
              });
              if (!this.$scrollDecorator) {
                this.$scrollDecorator = new Decorator(this.scrollBarV, this);
                this.$scrollDecorator.$updateDecorators();
              } else {
                this.$scrollDecorator.setScrollBarV(this.scrollBarV);
                this.$scrollDecorator.$updateDecorators();
              }
            } else {
              this.scrollBarV = new VScrollBar(this.container, this);
              this.scrollBarH = new HScrollBar(this.container, this);
              this.scrollBarV.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
              });
            }
          };
          VirtualRenderer2.prototype.$addResizeObserver = function() {
            if (!window.ResizeObserver || this.$resizeObserver)
              return;
            var self2 = this;
            this.$resizeTimer = lang.delayedCall(function() {
              if (!self2.destroyed)
                self2.onResize();
            }, 50);
            this.$resizeObserver = new window.ResizeObserver(function(e) {
              var w2 = e[0].contentRect.width;
              var h = e[0].contentRect.height;
              if (Math.abs(self2.$size.width - w2) > 1 || Math.abs(self2.$size.height - h) > 1) {
                self2.$resizeTimer.delay();
              } else {
                self2.$resizeTimer.cancel();
              }
            });
            this.$resizeObserver.observe(this.container);
          };
          return VirtualRenderer2;
        }()
      );
      VirtualRenderer.prototype.CHANGE_CURSOR = 1;
      VirtualRenderer.prototype.CHANGE_MARKER = 2;
      VirtualRenderer.prototype.CHANGE_GUTTER = 4;
      VirtualRenderer.prototype.CHANGE_SCROLL = 8;
      VirtualRenderer.prototype.CHANGE_LINES = 16;
      VirtualRenderer.prototype.CHANGE_TEXT = 32;
      VirtualRenderer.prototype.CHANGE_SIZE = 64;
      VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
      VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
      VirtualRenderer.prototype.CHANGE_FULL = 512;
      VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
      VirtualRenderer.prototype.$changes = 0;
      VirtualRenderer.prototype.$padding = null;
      VirtualRenderer.prototype.$frozen = false;
      VirtualRenderer.prototype.STEPS = 8;
      oop.implement(VirtualRenderer.prototype, EventEmitter);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
        useResizeObserver: {
          set: function(value) {
            if (!value && this.$resizeObserver) {
              this.$resizeObserver.disconnect();
              this.$resizeTimer.cancel();
              this.$resizeTimer = this.$resizeObserver = null;
            } else if (value && !this.$resizeObserver) {
              this.$addResizeObserver();
            }
          }
        },
        animatedScroll: { initialValue: false },
        showInvisibles: {
          set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function(val) {
            if (typeof val == "number")
              this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        useSvgGutterIcons: {
          set: function(value) {
            this.$gutterLayer.$useSvgGutterIcons = value;
          },
          initialValue: false
        },
        showFoldedAnnotations: {
          set: function(value) {
            this.$gutterLayer.$showFoldedAnnotations = value;
          },
          initialValue: false
        },
        fadeFoldWidgets: {
          set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
              this.$textLayer.$highlightIndentGuide();
            } else {
              this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        hScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function(size) {
            if (typeof size == "number")
              size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {
          set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }
        },
        maxLines: {
          set: function(val) {
            this.updateFull();
          }
        },
        minLines: {
          set: function(val) {
            if (!(this.$minLines < 562949953421311))
              this.$minLines = 0;
            this.updateFull();
          }
        },
        maxPixelHeight: {
          set: function(val) {
            this.updateFull();
          },
          initialValue: 0
        },
        scrollPastEnd: {
          set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
              return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {
          set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }
        },
        customScrollbar: {
          set: function(val) {
            this.$updateCustomScrollbar(val);
          },
          initialValue: false
        },
        theme: {
          set: function(val) {
            this.setTheme(val);
          },
          get: function() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        },
        hasCssTransforms: {},
        useTextareaForIME: {
          initialValue: !useragent.isMobile && !useragent.isIE
        }
      });
      exports2.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../lib/oop");
      var net = require3("../lib/net");
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var config = require3("../config");
      function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
          return new Blob([script], { "type": "application/javascript" });
        } catch (e) {
          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
          var blobBuilder = new BlobBuilder();
          blobBuilder.append(script);
          return blobBuilder.getBlob("application/javascript");
        }
      }
      function createWorker(workerUrl) {
        if (typeof Worker == "undefined")
          return { postMessage: function() {
          }, terminate: function() {
          } };
        if (config.get("loadWorkerFromBlob")) {
          var blob = $workerBlob(workerUrl);
          var URL2 = window.URL || window.webkitURL;
          var blobURL = URL2.createObjectURL(blob);
          return new Worker(blobURL);
        }
        return new Worker(workerUrl);
      }
      var WorkerClient = function(worker) {
        if (!worker.postMessage)
          worker = this.$createWorkerFromOldConfig.apply(this, arguments);
        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
          if (require3.nameToUrl && !require3.toUrl)
            require3.toUrl = require3.nameToUrl;
          if (config.get("packaged") || !require3.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod, "worker");
          } else {
            var normalizePath2 = this.$normalizePath;
            workerUrl = workerUrl || normalizePath2(require3.toUrl("ace/worker/worker.js", null, "_"));
            var tlns = {};
            topLevelNamespaces.forEach(function(ns2) {
              tlns[ns2] = normalizePath2(require3.toUrl(ns2, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
          }
          this.$worker = createWorker(workerUrl);
          if (importScripts) {
            this.send("importScripts", importScripts);
          }
          this.$worker.postMessage({
            init: true,
            tlns,
            module: mod,
            classname
          });
          return this.$worker;
        };
        this.onMessage = function(e) {
          var msg = e.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, { data: msg.data });
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function(err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path2) {
          return net.qualifyURL(path2);
        };
        this.terminate = function() {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker.onerror = function(e) {
            e.preventDefault();
          };
          this.$worker = null;
          if (this.$doc)
            this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function(cmd, args) {
          this.$worker.postMessage({ command: cmd, args });
        };
        this.call = function(cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function(event, data) {
          try {
            if (data.data && data.data.err)
              data.data.err = { message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code };
            this.$worker && this.$worker.postMessage({ event, data: { data: data.data } });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function(doc) {
          if (this.$doc)
            this.terminate();
          this.$doc = doc;
          this.call("setValue", [doc.getValue()]);
          doc.on("change", this.changeListener, true);
        };
        this.changeListener = function(delta) {
          if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
          }
          if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
          else
            this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function() {
          var q3 = this.deltaQueue;
          if (!q3) return;
          this.deltaQueue = null;
          if (q3.length > 50 && q3.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else
            this.emit("change", { data: q3 });
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var messageBuffer = [];
        var workerClient = new WorkerClient({
          messageBuffer,
          terminate: function() {
          },
          postMessage: function(e) {
            messageBuffer.push(e);
            if (!main) return;
            if (emitSync)
              setTimeout(processNext);
            else
              processNext();
          }
        });
        workerClient.setEmitSync = function(val) {
          emitSync = val;
        };
        var processNext = function() {
          var msg = messageBuffer.shift();
          if (msg.command)
            main[msg.command].apply(main, msg.args);
          else if (msg.event)
            sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
          workerClient.onMessage({ data: msg });
        };
        sender.callback = function(data, callbackId) {
          this.postMessage({ type: "call", id: callbackId, data });
        };
        sender.emit = function(name, data) {
          this.postMessage({ type: "event", name, data });
        };
        config.loadModule(["worker", mod], function(Main) {
          main = new Main[classname](sender);
          while (messageBuffer.length)
            processNext();
        });
        return workerClient;
      };
      exports2.UIWorkerClient = UIWorkerClient;
      exports2.WorkerClient = WorkerClient;
      exports2.createWorker = createWorker;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("./range").Range;
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var oop = require3("./lib/oop");
      var PlaceHolder = (
        /** @class */
        function() {
          function PlaceHolder2(session, length, pos, others, mainClass, othersClass) {
            var _self = this;
            this.length = length;
            this.session = session;
            this.doc = session.getDocument();
            this.mainClass = mainClass;
            this.othersClass = othersClass;
            this.$onUpdate = this.onUpdate.bind(this);
            this.doc.on("change", this.$onUpdate, true);
            this.$others = others;
            this.$onCursorChange = function() {
              setTimeout(function() {
                _self.onCursorChange();
              });
            };
            this.$pos = pos;
            var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || { length: -1 };
            this.$undoStackDepth = undoStack.length;
            this.setup();
            session.selection.on("changeCursor", this.$onCursorChange);
          }
          PlaceHolder2.prototype.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
              session.selection.toSingleRange();
            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
              var anchor = doc.createAnchor(other.row, other.column);
              anchor.$insertRight = true;
              anchor.detach();
              _self.others.push(anchor);
            });
            session.setUndoSelect(false);
          };
          PlaceHolder2.prototype.showOtherMarkers = function() {
            if (this.othersActive)
              return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
              anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            });
          };
          PlaceHolder2.prototype.hideOtherMarkers = function() {
            if (!this.othersActive)
              return;
            this.othersActive = false;
            for (var i = 0; i < this.others.length; i++) {
              this.session.removeMarker(this.others[i].markerId);
            }
          };
          PlaceHolder2.prototype.onUpdate = function(delta) {
            if (this.$updating)
              return this.updateAnchors(delta);
            var range = delta;
            if (range.start.row !== range.end.row)
              return;
            if (range.start.row !== this.pos.row)
              return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            this.updateAnchors(delta);
            if (inMainRange)
              this.length += lengthDiff;
            if (inMainRange && !this.session.$fromUndo) {
              if (delta.action === "insert") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.insertMergedLines(newPos, delta.lines);
                }
              } else if (delta.action === "remove") {
                for (var i = this.others.length - 1; i >= 0; i--) {
                  var otherPos = this.others[i];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
              }
            }
            this.$updating = false;
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i = this.others.length; i--; )
              this.others[i].onChange(delta);
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateMarkers = function() {
            if (this.$updating)
              return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
              session.removeMarker(pos.markerId);
              pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i = this.others.length; i--; )
              updateMarker(this.others[i], this.othersClass);
          };
          PlaceHolder2.prototype.onCursorChange = function(event) {
            if (this.$updating || !this.session)
              return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
              this.showOtherMarkers();
              this._emit("cursorEnter", event);
            } else {
              this.hideOtherMarkers();
              this._emit("cursorLeave", event);
            }
          };
          PlaceHolder2.prototype.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.off("change", this.$onUpdate);
            this.session.selection.off("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
          };
          PlaceHolder2.prototype.cancel = function() {
            if (this.$undoStackDepth === -1)
              return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
            for (var i = 0; i < undosRequired; i++) {
              undoManager.undo(this.session, true);
            }
            if (this.selectionBefore)
              this.session.selection.fromJSON(this.selectionBefore);
          };
          return PlaceHolder2;
        }()
      );
      oop.implement(PlaceHolder.prototype, EventEmitter);
      exports2.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require3, exports2, module3) {
      var event = require3("../lib/event");
      var useragent = require3("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        if (ctrl && useragent.isMac)
          button = ev.button;
        if (e.editor.inMultiSelectMode && button == 2) {
          e.editor.textInput.onContextMenu(e.domEvent);
          return;
        }
        if (!ctrl && !alt && !accel) {
          if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
          return;
        }
        if (button !== 0)
          return;
        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
        var mouseX = e.x, mouseY = e.y;
        var onMouseSelection = function(e2) {
          mouseX = e2.clientX;
          mouseY = e2.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
          else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
              return;
          } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection)
            return;
          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
          }
          editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
              selection.substractPoint(tmpSel.cursor);
            else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e.stop();
          editor.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
              return;
            screenCursor = newCursor;
            editor.selection.moveToPosition(cursor2);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
              rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
          };
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
          }
          if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
          else
            selection.moveToPosition(pos);
          screenCursor = { row: -1, column: -1 };
          var onMouseSelectionEnd = function(e2) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
              rectSel = [selection.toOrientedRange()];
            if (initialRange) {
              editor.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
              selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function() {
            onSelectionInterval();
          }, 20);
          return e.preventDefault();
        }
      }
      exports2.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require3, exports2, module3) {
      exports2.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function(editor) {
          editor.selectMoreLines(-1);
        },
        bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function(editor) {
          editor.selectMoreLines(1);
        },
        bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function(editor) {
          editor.selectMore(-1);
        },
        bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function(editor) {
          editor.selectMore(1);
        },
        bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function(editor) {
          editor.selectMore(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function(editor) {
          editor.selectMore(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split selection into lines",
        exec: function(editor) {
          if (editor.multiSelect.rangeCount > 1)
            editor.multiSelect.joinSelections();
          else
            editor.multiSelect.splitIntoLines();
        },
        bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
        readOnly: true
      }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) {
          editor.multiSelect.splitIntoLines();
        },
        readOnly: true
      }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function(editor) {
          editor.alignCursors();
        },
        bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
        scrollIntoView: "cursor"
      }, {
        name: "findAll",
        description: "Find all",
        exec: function(editor) {
          editor.findAll();
        },
        bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
        scrollIntoView: "cursor",
        readOnly: true
      }];
      exports2.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function(editor) {
          editor.exitMultiSelectMode();
        },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor) {
          return editor && editor.inMultiSelectMode;
        }
      }];
      var HashHandler = require3("../keyboard/hash_handler").HashHandler;
      exports2.keyboardHandler = new HashHandler(exports2.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      var RangeList = require3("./range_list").RangeList;
      var Range = require3("./range").Range;
      var Selection = require3("./selection").Selection;
      var onMouseDown = require3("./mouse/multi_select_handler").onMouseDown;
      var event = require3("./lib/event");
      var lang = require3("./lib/lang");
      var commands = require3("./commands/multi_select_commands");
      exports2.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = require3("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = require3("./edit_session").EditSession;
      (function() {
        this.getSelectionMarkers = function() {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
          if (!range)
            return;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor)
            range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length)
            this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length)
            this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function() {
          var removed = this.rangeList.merge();
          if (removed.length)
            this.$onRemoveRange(removed);
        };
        this.$onAddRange = function(range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", { range });
        };
        this.$onRemoveRange = function(removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", { ranges: removed });
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
          if (this.rangeList)
            return;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function() {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function() {
          var ranges = this.ranges.length ? this.ranges : [this.getRange()];
          var newRanges = [];
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
              newRanges.push(range.clone());
            } else {
              newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
              while (++row < endRow)
                newRanges.push(this.getLineRange(row, true));
              newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i == 0 && !this.isBackwards())
              newRanges = newRanges.reverse();
          }
          this.toSingleRange();
          for (var i = newRanges.length; i--; )
            this.addRange(newRanges[i]);
        };
        this.joinSelections = function() {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0)
            startColumn = 0;
          if (startRow < 0)
            startRow = 0;
          if (startRow == endRow)
            includeEmptyLines = true;
          var docEnd;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd))
                break;
              docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards)
            rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
              end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty())
                start++;
            }
            for (var i = end; i >= start; i--) {
              if (rectSel[i].isEmpty())
                rectSel.splice(i, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = require3("./editor").Editor;
      (function() {
        this.updateSelectionMarkers = function() {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
          if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
          if (!range.marker)
            return;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
              continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
              markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e) {
          this.addSelectionMarker(e.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e) {
          this.removeSelectionMarkers(e.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e) {
          if (this.inMultiSelectMode)
            return;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e) {
          if (this.session.multiSelect.inVirtualMode)
            return;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e) {
          var command = e.command;
          var editor = e.editor;
          if (!editor.multiSelect)
            return;
          if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
          } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
          } else {
            result = command.multiSelectAction(editor, e.args || {});
          }
          return result;
        };
        this.forEachSelection = function(cmd, args, options) {
          if (this.inVirtualSelectionMode)
            return;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i = ranges.length; i--; ) {
            if ($byLines) {
              while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== void 0)
              result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function() {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
              buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl2 = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl2);
            if (text.length == (buf.length - 1) * nl2.length)
              text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function(e, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
              return;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
              this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
              this.multiSelect.mergeOverlappingRanges();
          }
        };
        this.findAll = function(needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == void 0) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length)
            return 0;
          var selection = this.multiSelect;
          if (!additive)
            selection.toSingleRange(ranges[0]);
          for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
          if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
          return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip)
              var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove)
            this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
              var tmp_1 = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp_1.start.row;
              range.start.column = tmp_1.start.column;
              range.end.row = tmp_1.end.row;
              range.end.column = tmp_1.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0)
            words.unshift(words.pop());
          else
            words.push(words.shift());
          for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
          sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
              return;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip)
            this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr2 = range.start.row, lr2 = range.end.row;
            var guessRange = fr2 == lr2;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr2);
              } while (/[=:]/.test(line) && ++lr2 < max);
              do {
                line = this.session.getLine(fr2);
              } while (/[=:]/.test(line) && --fr2 > 0);
              if (fr2 < 0)
                fr2 = 0;
              if (lr2 >= max)
                lr2 = max - 1;
            }
            var lines = this.session.removeFullLines(fr2, lr2);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({ row: fr2, column: 0 }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function(r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
              var p = r.cursor;
              var line2 = session.getLine(p.row);
              var spaceOffset = line2.substr(p.column).search(/\S/g);
              if (spaceOffset == -1)
                spaceOffset = 0;
              if (p.column > maxCol)
                maxCol = p.column;
              if (spaceOffset < minSpace)
                minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function(r, i) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d = spaceOffsets[i] - minSpace;
              if (l > d)
                session.insert(p, lang.stringRepeat(" ", l - d));
              else
                session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function(lines, forceLeft) {
          var isLeftAligned = true, isRightAligned = true;
          var startW, textW, endW;
          return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
              return [line];
            if (startW == null) {
              startW = m[1].length;
              textW = m[2].length;
              endW = m[3].length;
              return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
              isRightAligned = false;
            if (startW != m[1].length)
              isLeftAligned = false;
            if (startW > m[1].length)
              startW = m[1].length;
            if (textW < m[2].length)
              textW = m[2].length;
            if (endW > m[3].length)
              endW = m[3].length;
            return m;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports2.onSessionChange = function(e) {
        var session = e.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
          else
            this.$onSingleSelect();
        }
      };
      function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
          return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports2.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
        if (!editor.textInput)
          return;
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e) {
          var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
          if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
              editor.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        }, editor);
        event.addListener(el, "keyup", reset, editor);
        event.addListener(el, "blur", reset, editor);
        function reset(e) {
          if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports2.MultiSelect = MultiSelect;
      require3("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
          set: function(val) {
            MultiSelect(this);
            if (val) {
              this.on("mousedown", onMouseDown);
            } else {
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        },
        enableBlockSelect: {
          set: function(val) {
            this.$blockSelectEnabled = val;
          },
          value: true
        }
      });
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("../../range").Range;
      var FoldMode = exports2.FoldMode = function() {
      };
      (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line))
            return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
            return "end";
          return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function(session, row, column) {
          var re3 = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re3);
          if (startLevel == -1)
            return;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re3);
            if (level == -1)
              continue;
            if (level <= startLevel) {
              var token = session.getTokenAt(row, 0);
              if (!token || token.type !== "string")
                break;
            }
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
          var start = { row, column: column + 1 };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end)
            return;
          var fw = session.foldWidgets[end.row];
          if (fw == null)
            fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
          var end = { row, column };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start)
            return;
          start.column++;
          end.column--;
          return Range.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var Range = require3("../range").Range;
      var nls = require3("../config").nls;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = first + last >> 1;
          var c = comparator(needle, array[mid]);
          if (c > 0)
            first = mid + 1;
          else if (c < 0)
            last = mid - 1;
          else
            return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
          return;
        var i = binarySearch(annotations, { row, column: -1 }, Range.comparePoints);
        if (i < 0)
          i = -i - 1;
        if (i >= annotations.length)
          i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0)
          i = annotations.length - 1;
        var annotation = annotations[i];
        if (!annotation || !dir)
          return;
        if (annotation.row === row) {
          do {
            annotation = annotations[i += dir];
          } while (annotation && annotation.row === row);
          if (!annotation)
            return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports2.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w3) {
          return w3.type == "errorMarker";
        })[0];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return;
        } else {
          gutterAnno = {
            displayText: [nls("error-marker.good-state", "Looks good!")],
            className: "ace_ok"
          };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w2 = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div"),
          type: "errorMarker"
        };
        var el = w2.el.appendChild(dom.createElement("div"));
        var arrow = w2.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w2.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        gutterAnno.displayText.forEach(function(annoTextLine, i) {
          el.appendChild(dom.createTextNode(annoTextLine));
          if (i < gutterAnno.displayText.length - 1) {
            el.appendChild(dom.createElement("br"));
          }
        });
        el.appendChild(dom.createElement("div"));
        var kb = function(_2, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w2.destroy();
            return { command: "null" };
          }
        };
        w2.destroy = function() {
          if (editor.$mouseHandler.isMousePressed)
            return;
          editor.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w2);
          editor.off("changeSelection", w2.destroy);
          editor.off("changeSession", w2.destroy);
          editor.off("mouseup", w2.destroy);
          editor.off("change", w2.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w2.destroy);
        editor.on("changeSession", w2.destroy);
        editor.on("mouseup", w2.destroy);
        editor.on("change", w2.destroy);
        editor.session.widgetManager.addLineWidget(w2);
        w2.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w2.el.offsetHeight });
      };
      dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config", "ace/loader_build"], function(require3, exports2, module3) {
      "use strict";
      require3("./loader_build")(exports2);
      var dom = require3("./lib/dom");
      var Range = require3("./range").Range;
      var Editor = require3("./editor").Editor;
      var EditSession = require3("./edit_session").EditSession;
      var UndoManager = require3("./undomanager").UndoManager;
      var Renderer = require3("./virtual_renderer").VirtualRenderer;
      require3("./worker/worker_client");
      require3("./keyboard/hash_handler");
      require3("./placeholder");
      require3("./multi_select");
      require3("./mode/folding/fold_mode");
      require3("./theme/textmate");
      require3("./ext/error_marker");
      exports2.config = require3("./config");
      exports2.edit = function(el, options) {
        if (typeof el == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el)
            throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor)
          return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
          value = el.textContent;
          el.innerHTML = "";
        }
        var doc = exports2.createEditSession(value);
        var editor = new Editor(new Renderer(el), doc, options);
        var env = {
          document: doc,
          editor,
          onResize: editor.resize.bind(editor, null)
        };
        if (oldNode)
          env.textarea = oldNode;
        editor.on("destroy", function() {
          env.editor.container.env = null;
        });
        editor.container.env = editor.env = env;
        return editor;
      };
      exports2.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
      };
      exports2.Range = Range;
      exports2.Editor = Editor;
      exports2.EditSession = EditSession;
      exports2.UndoManager = UndoManager;
      exports2.VirtualRenderer = Renderer;
      var version = exports2.config.version;
      exports2.version = version;
    });
    (function() {
      ace.require(["ace/ace"], function(a) {
        if (a) {
          a.config.init(true);
          a.define = ace.define;
        }
        var global2 = /* @__PURE__ */ function() {
          return this;
        }();
        if (!global2 && typeof window != "undefined") global2 = window;
        if (!global2 && typeof self != "undefined") global2 = self;
        if (!global2.ace)
          global2.ace = a;
        for (var key in a) if (a.hasOwnProperty(key))
          global2.ace[key] = a[key];
        global2.ace["default"] = global2.ace;
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = global2.ace;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/mode-css.js
var require_mode_css = __commonJS({
  "node_modules/ace-builds/src-noconflict/mode-css.js"(exports, module2) {
    ace.define("ace/mode/css_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/mode/text_highlight_rules"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../lib/oop");
      var lang = require3("../lib/lang");
      var TextHighlightRules = require3("./text_highlight_rules").TextHighlightRules;
      var supportType = exports2.supportType = "align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration|animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|border|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|bottom|box-shadow|box-sizing|caption-side|clear|clip|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|cursor|direction|display|empty-cells|filter|flex|flex-basis|flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|font|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|hanging-punctuation|height|justify-content|left|letter-spacing|line-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|max-height|max-width|max-zoom|min-height|min-width|min-zoom|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|order|outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-x|overflow-y|padding|padding-bottom|padding-left|padding-right|padding-top|page-break-after|page-break-before|page-break-inside|perspective|perspective-origin|position|quotes|resize|right|tab-size|table-layout|text-align|text-align-last|text-decoration|text-decoration-color|text-decoration-line|text-decoration-style|text-indent|text-justify|text-overflow|text-shadow|text-transform|top|transform|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function|unicode-bidi|user-select|user-zoom|vertical-align|visibility|white-space|width|word-break|word-spacing|word-wrap|z-index";
      var supportFunction = exports2.supportFunction = "rgb|rgba|url|attr|counter|counters";
      var supportConstant = exports2.supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|flex-end|flex-start|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero|zoom";
      var supportConstantColor = exports2.supportConstantColor = "aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen";
      var supportConstantFonts = exports2.supportConstantFonts = "arial|century|comic|courier|cursive|fantasy|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";
      var numRe = exports2.numRe = "\\-?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+))";
      var pseudoElements = exports2.pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";
      var pseudoClasses = exports2.pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";
      var CssHighlightRules = function() {
        var keywordMapper = this.createKeywordMapper({
          "support.function": supportFunction,
          "support.constant": supportConstant,
          "support.type": supportType,
          "support.constant.color": supportConstantColor,
          "support.constant.fonts": supportConstantFonts
        }, "text", true);
        this.$rules = {
          "start": [{
            include: ["strings", "url", "comments"]
          }, {
            token: "paren.lparen",
            regex: "\\{",
            next: "ruleset"
          }, {
            token: "paren.rparen",
            regex: "\\}"
          }, {
            token: "string",
            regex: "@(?!viewport)",
            next: "media"
          }, {
            token: "keyword",
            regex: "#[a-z0-9-_]+"
          }, {
            token: "keyword",
            regex: "%"
          }, {
            token: "variable",
            regex: "\\.[a-z0-9-_]+"
          }, {
            token: "string",
            regex: ":[a-z0-9-_]+"
          }, {
            token: "constant.numeric",
            regex: numRe
          }, {
            token: "constant",
            regex: "[a-z0-9-_]+"
          }, {
            caseInsensitive: true
          }],
          "media": [{
            include: ["strings", "url", "comments"]
          }, {
            token: "paren.lparen",
            regex: "\\{",
            next: "start"
          }, {
            token: "paren.rparen",
            regex: "\\}",
            next: "start"
          }, {
            token: "string",
            regex: ";",
            next: "start"
          }, {
            token: "keyword",
            regex: "(?:media|supports|document|charset|import|namespace|media|supports|document|page|font|keyframes|viewport|counter-style|font-feature-values|swash|ornaments|annotation|stylistic|styleset|character-variant)"
          }],
          "comments": [{
            token: "comment",
            // multi line comment
            regex: "\\/\\*",
            push: [{
              token: "comment",
              regex: "\\*\\/",
              next: "pop"
            }, {
              defaultToken: "comment"
            }]
          }],
          "ruleset": [{
            regex: "-(webkit|ms|moz|o)-",
            token: "text"
          }, {
            token: "punctuation.operator",
            regex: "[:;]"
          }, {
            token: "paren.rparen",
            regex: "\\}",
            next: "start"
          }, {
            include: ["strings", "url", "comments"]
          }, {
            token: ["constant.numeric", "keyword"],
            regex: "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vmax|vmin|vm|vw|%)"
          }, {
            token: "constant.numeric",
            regex: numRe
          }, {
            token: "constant.numeric",
            // hex6 color
            regex: "#[a-f0-9]{6}"
          }, {
            token: "constant.numeric",
            // hex3 color
            regex: "#[a-f0-9]{3}"
          }, {
            token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
            regex: pseudoElements
          }, {
            token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
            regex: pseudoClasses
          }, {
            include: "url"
          }, {
            token: keywordMapper,
            regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
          }, {
            token: "paren.lparen",
            regex: "\\{"
          }, {
            caseInsensitive: true
          }],
          url: [{
            token: "support.function",
            regex: "(?:url(:?-prefix)?|domain|regexp)\\(",
            push: [{
              token: "support.function",
              regex: "\\)",
              next: "pop"
            }, {
              defaultToken: "string"
            }]
          }],
          strings: [{
            token: "string.start",
            regex: "'",
            push: [{
              token: "string.end",
              regex: "'|$",
              next: "pop"
            }, {
              include: "escapes"
            }, {
              token: "constant.language.escape",
              regex: /\\$/,
              consumeLineEnd: true
            }, {
              defaultToken: "string"
            }]
          }, {
            token: "string.start",
            regex: '"',
            push: [{
              token: "string.end",
              regex: '"|$',
              next: "pop"
            }, {
              include: "escapes"
            }, {
              token: "constant.language.escape",
              regex: /\\$/,
              consumeLineEnd: true
            }, {
              defaultToken: "string"
            }]
          }],
          escapes: [{
            token: "constant.language.escape",
            regex: /\\([a-fA-F\d]{1,6}|[^a-fA-F\d])/
          }]
        };
        this.normalizeRules();
      };
      oop.inherits(CssHighlightRules, TextHighlightRules);
      exports2.CssHighlightRules = CssHighlightRules;
    });
    ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("../range").Range;
      var MatchingBraceOutdent = function() {
      };
      (function() {
        this.checkOutdent = function(line, input) {
          if (!/^\s+$/.test(line))
            return false;
          return /^\s*\}/.test(input);
        };
        this.autoOutdent = function(doc, row) {
          var line = doc.getLine(row);
          var match = line.match(/^(\s*\})/);
          if (!match)
            return 0;
          var column = match[1].length;
          var openBracePos = doc.findMatchingBracket({ row, column });
          if (!openBracePos || openBracePos.row == row)
            return 0;
          var indent = this.$getIndent(doc.getLine(openBracePos.row));
          doc.replace(new Range(row, 0, row, column - 1), indent);
        };
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
      }).call(MatchingBraceOutdent.prototype);
      exports2.MatchingBraceOutdent = MatchingBraceOutdent;
    });
    ace.define("ace/mode/css_completions", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var propertyMap = {
        "background": { "#$0": 1 },
        "background-color": { "#$0": 1, "transparent": 1, "fixed": 1 },
        "background-image": { "url('/$0')": 1 },
        "background-repeat": { "repeat": 1, "repeat-x": 1, "repeat-y": 1, "no-repeat": 1, "inherit": 1 },
        "background-position": { "bottom": 2, "center": 2, "left": 2, "right": 2, "top": 2, "inherit": 2 },
        "background-attachment": { "scroll": 1, "fixed": 1 },
        "background-size": { "cover": 1, "contain": 1 },
        "background-clip": { "border-box": 1, "padding-box": 1, "content-box": 1 },
        "background-origin": { "border-box": 1, "padding-box": 1, "content-box": 1 },
        "border": { "solid $0": 1, "dashed $0": 1, "dotted $0": 1, "#$0": 1 },
        "border-color": { "#$0": 1 },
        "border-style": { "solid": 2, "dashed": 2, "dotted": 2, "double": 2, "groove": 2, "hidden": 2, "inherit": 2, "inset": 2, "none": 2, "outset": 2, "ridged": 2 },
        "border-collapse": { "collapse": 1, "separate": 1 },
        "bottom": { "px": 1, "em": 1, "%": 1 },
        "clear": { "left": 1, "right": 1, "both": 1, "none": 1 },
        "color": { "#$0": 1, "rgb(#$00,0,0)": 1 },
        "cursor": { "default": 1, "pointer": 1, "move": 1, "text": 1, "wait": 1, "help": 1, "progress": 1, "n-resize": 1, "ne-resize": 1, "e-resize": 1, "se-resize": 1, "s-resize": 1, "sw-resize": 1, "w-resize": 1, "nw-resize": 1 },
        "display": { "none": 1, "block": 1, "inline": 1, "inline-block": 1, "table-cell": 1 },
        "empty-cells": { "show": 1, "hide": 1 },
        "float": { "left": 1, "right": 1, "none": 1 },
        "font-family": { "Arial": 2, "Comic Sans MS": 2, "Consolas": 2, "Courier New": 2, "Courier": 2, "Georgia": 2, "Monospace": 2, "Sans-Serif": 2, "Segoe UI": 2, "Tahoma": 2, "Times New Roman": 2, "Trebuchet MS": 2, "Verdana": 1 },
        "font-size": { "px": 1, "em": 1, "%": 1 },
        "font-weight": { "bold": 1, "normal": 1 },
        "font-style": { "italic": 1, "normal": 1 },
        "font-variant": { "normal": 1, "small-caps": 1 },
        "height": { "px": 1, "em": 1, "%": 1 },
        "left": { "px": 1, "em": 1, "%": 1 },
        "letter-spacing": { "normal": 1 },
        "line-height": { "normal": 1 },
        "list-style-type": { "none": 1, "disc": 1, "circle": 1, "square": 1, "decimal": 1, "decimal-leading-zero": 1, "lower-roman": 1, "upper-roman": 1, "lower-greek": 1, "lower-latin": 1, "upper-latin": 1, "georgian": 1, "lower-alpha": 1, "upper-alpha": 1 },
        "margin": { "px": 1, "em": 1, "%": 1 },
        "margin-right": { "px": 1, "em": 1, "%": 1 },
        "margin-left": { "px": 1, "em": 1, "%": 1 },
        "margin-top": { "px": 1, "em": 1, "%": 1 },
        "margin-bottom": { "px": 1, "em": 1, "%": 1 },
        "max-height": { "px": 1, "em": 1, "%": 1 },
        "max-width": { "px": 1, "em": 1, "%": 1 },
        "min-height": { "px": 1, "em": 1, "%": 1 },
        "min-width": { "px": 1, "em": 1, "%": 1 },
        "overflow": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
        "overflow-x": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
        "overflow-y": { "hidden": 1, "visible": 1, "auto": 1, "scroll": 1 },
        "padding": { "px": 1, "em": 1, "%": 1 },
        "padding-top": { "px": 1, "em": 1, "%": 1 },
        "padding-right": { "px": 1, "em": 1, "%": 1 },
        "padding-bottom": { "px": 1, "em": 1, "%": 1 },
        "padding-left": { "px": 1, "em": 1, "%": 1 },
        "page-break-after": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
        "page-break-before": { "auto": 1, "always": 1, "avoid": 1, "left": 1, "right": 1 },
        "position": { "absolute": 1, "relative": 1, "fixed": 1, "static": 1 },
        "right": { "px": 1, "em": 1, "%": 1 },
        "table-layout": { "fixed": 1, "auto": 1 },
        "text-decoration": { "none": 1, "underline": 1, "line-through": 1, "blink": 1 },
        "text-align": { "left": 1, "right": 1, "center": 1, "justify": 1 },
        "text-transform": { "capitalize": 1, "uppercase": 1, "lowercase": 1, "none": 1 },
        "top": { "px": 1, "em": 1, "%": 1 },
        "vertical-align": { "top": 1, "bottom": 1 },
        "visibility": { "hidden": 1, "visible": 1 },
        "white-space": { "nowrap": 1, "normal": 1, "pre": 1, "pre-line": 1, "pre-wrap": 1 },
        "width": { "px": 1, "em": 1, "%": 1 },
        "word-spacing": { "normal": 1 },
        "filter": { "alpha(opacity=$0100)": 1 },
        "text-shadow": { "$02px 2px 2px #777": 1 },
        "text-overflow": { "ellipsis-word": 1, "clip": 1, "ellipsis": 1 },
        "-moz-border-radius": 1,
        "-moz-border-radius-topright": 1,
        "-moz-border-radius-bottomright": 1,
        "-moz-border-radius-topleft": 1,
        "-moz-border-radius-bottomleft": 1,
        "-webkit-border-radius": 1,
        "-webkit-border-top-right-radius": 1,
        "-webkit-border-top-left-radius": 1,
        "-webkit-border-bottom-right-radius": 1,
        "-webkit-border-bottom-left-radius": 1,
        "-moz-box-shadow": 1,
        "-webkit-box-shadow": 1,
        "transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
        "-moz-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 },
        "-webkit-transform": { "rotate($00deg)": 1, "skew($00deg)": 1 }
      };
      var CssCompletions = function() {
      };
      (function() {
        this.completionsDefined = false;
        this.defineCompletions = function() {
          if (document) {
            var style = document.createElement("c").style;
            for (var i in style) {
              if (typeof style[i] !== "string")
                continue;
              var name = i.replace(/[A-Z]/g, function(x) {
                return "-" + x.toLowerCase();
              });
              if (!propertyMap.hasOwnProperty(name))
                propertyMap[name] = 1;
            }
          }
          this.completionsDefined = true;
        };
        this.getCompletions = function(state, session, pos, prefix) {
          if (!this.completionsDefined) {
            this.defineCompletions();
          }
          if (state === "ruleset" || session.$mode.$id == "ace/mode/scss") {
            var line = session.getLine(pos.row).substr(0, pos.column);
            var inParens = /\([^)]*$/.test(line);
            if (inParens) {
              line = line.substr(line.lastIndexOf("(") + 1);
            }
            if (/:[^;]+$/.test(line)) {
              /([\w\-]+):[^:]*$/.test(line);
              return this.getPropertyValueCompletions(state, session, pos, prefix);
            } else {
              return this.getPropertyCompletions(state, session, pos, prefix, inParens);
            }
          }
          return [];
        };
        this.getPropertyCompletions = function(state, session, pos, prefix, skipSemicolon) {
          skipSemicolon = skipSemicolon || false;
          var properties = Object.keys(propertyMap);
          return properties.map(function(property) {
            return {
              caption: property,
              snippet: property + ": $0" + (skipSemicolon ? "" : ";"),
              meta: "property",
              score: 1e6
            };
          });
        };
        this.getPropertyValueCompletions = function(state, session, pos, prefix) {
          var line = session.getLine(pos.row).substr(0, pos.column);
          var property = (/([\w\-]+):[^:]*$/.exec(line) || {})[1];
          if (!property)
            return [];
          var values = [];
          if (property in propertyMap && typeof propertyMap[property] === "object") {
            values = Object.keys(propertyMap[property]);
          }
          return values.map(function(value) {
            return {
              caption: value,
              snippet: value,
              meta: "property value",
              score: 1e6
            };
          });
        };
      }).call(CssCompletions.prototype);
      exports2.CssCompletions = CssCompletions;
    });
    ace.define("ace/mode/behaviour/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/mode/behaviour/cstyle", "ace/token_iterator"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../../lib/oop");
      var Behaviour = require3("../behaviour").Behaviour;
      var CstyleBehaviour = require3("./cstyle").CstyleBehaviour;
      var TokenIterator = require3("../../token_iterator").TokenIterator;
      var CssBehaviour = function() {
        this.inherit(CstyleBehaviour);
        this.add("colon", "insertion", function(state, action, editor, session, text) {
          if (text === ":" && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
              token = iterator.stepBackward();
            }
            if (token && token.type === "support.type") {
              var line = session.doc.getLine(cursor.row);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              if (rightChar === ":") {
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
              if (/^(\s+[^;]|\s*$)/.test(line.substring(cursor.column))) {
                return {
                  text: ":;",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("colon", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected === ":") {
            var cursor = editor.getCursorPosition();
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            if (token && token.value.match(/\s+/)) {
              token = iterator.stepBackward();
            }
            if (token && token.type === "support.type") {
              var line = session.doc.getLine(range.start.row);
              var rightChar = line.substring(range.end.column, range.end.column + 1);
              if (rightChar === ";") {
                range.end.column++;
                return range;
              }
            }
          }
        });
        this.add("semicolon", "insertion", function(state, action, editor, session, text) {
          if (text === ";" && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === ";") {
              return {
                text: "",
                selection: [1, 1]
              };
            }
          }
        });
        this.add("!important", "insertion", function(state, action, editor, session, text) {
          if (text === "!" && editor.selection.isEmpty()) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            if (/^\s*(;|}|$)/.test(line.substring(cursor.column))) {
              return {
                text: "!important",
                selection: [10, 10]
              };
            }
          }
        });
      };
      oop.inherits(CssBehaviour, CstyleBehaviour);
      exports2.CssBehaviour = CssBehaviour;
    });
    ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../../lib/oop");
      var Range = require3("../../range").Range;
      var BaseFoldMode = require3("./fold_mode").FoldMode;
      var FoldMode = exports2.FoldMode = function(commentRegex) {
        if (commentRegex) {
          this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
          this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
        }
      };
      oop.inherits(FoldMode, BaseFoldMode);
      (function() {
        this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
        this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
        this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
        this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
        this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
        this._getFoldWidgetBase = this.getFoldWidget;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.singleLineBlockCommentRe.test(line)) {
            if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
              return "";
          }
          var fw = this._getFoldWidgetBase(session, foldStyle, row);
          if (!fw && this.startRegionRe.test(line))
            return "start";
          return fw;
        };
        this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
          var line = session.getLine(row);
          if (this.startRegionRe.test(line))
            return this.getCommentRegionBlock(session, line, row);
          var match = line.match(this.foldingStartMarker);
          if (match) {
            var i = match.index;
            if (match[1])
              return this.openingBracketBlock(session, match[1], row, i);
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            if (range && !range.isMultiLine()) {
              if (forceMultiline) {
                range = this.getSectionRange(session, row);
              } else if (foldStyle != "all")
                range = null;
            }
            return range;
          }
          if (foldStyle === "markbegin")
            return;
          var match = line.match(this.foldingStopMarker);
          if (match) {
            var i = match.index + match[0].length;
            if (match[1])
              return this.closingBracketBlock(session, match[1], row, i);
            return session.getCommentFoldRange(row, i, -1);
          }
        };
        this.getSectionRange = function(session, row) {
          var line = session.getLine(row);
          var startIndent = line.search(/\S/);
          var startRow = row;
          var startColumn = line.length;
          row = row + 1;
          var endRow = row;
          var maxRow = session.getLength();
          while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
              continue;
            if (startIndent > indent)
              break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            if (subRange) {
              if (subRange.start.row <= startRow) {
                break;
              } else if (subRange.isMultiLine()) {
                row = subRange.end.row;
              } else if (startIndent == indent) {
                break;
              }
            }
            endRow = row;
          }
          return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
        };
        this.getCommentRegionBlock = function(session, line, row) {
          var startColumn = line.search(/\s*$/);
          var maxRow = session.getLength();
          var startRow = row;
          var re3 = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
          var depth = 1;
          while (++row < maxRow) {
            line = session.getLine(row);
            var m = re3.exec(line);
            if (!m)
              continue;
            if (m[1])
              depth--;
            else
              depth++;
            if (!depth)
              break;
          }
          var endRow = row;
          if (endRow > startRow) {
            return new Range(startRow, startColumn, endRow, line.length);
          }
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/mode/css", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/css_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/css_completions", "ace/mode/behaviour/css", "ace/mode/folding/cstyle"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../lib/oop");
      var TextMode = require3("./text").Mode;
      var CssHighlightRules = require3("./css_highlight_rules").CssHighlightRules;
      var MatchingBraceOutdent = require3("./matching_brace_outdent").MatchingBraceOutdent;
      var WorkerClient = require3("../worker/worker_client").WorkerClient;
      var CssCompletions = require3("./css_completions").CssCompletions;
      var CssBehaviour = require3("./behaviour/css").CssBehaviour;
      var CStyleFoldMode = require3("./folding/cstyle").FoldMode;
      var Mode = function() {
        this.HighlightRules = CssHighlightRules;
        this.$outdent = new MatchingBraceOutdent();
        this.$behaviour = new CssBehaviour();
        this.$completer = new CssCompletions();
        this.foldingRules = new CStyleFoldMode();
      };
      oop.inherits(Mode, TextMode);
      (function() {
        this.foldingRules = "cStyle";
        this.blockComment = { start: "/*", end: "*/" };
        this.getNextLineIndent = function(state, line, tab) {
          var indent = this.$getIndent(line);
          var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
          if (tokens.length && tokens[tokens.length - 1].type == "comment") {
            return indent;
          }
          var match = line.match(/^.*\{\s*$/);
          if (match) {
            indent += tab;
          }
          return indent;
        };
        this.checkOutdent = function(state, line, input) {
          return this.$outdent.checkOutdent(line, input);
        };
        this.autoOutdent = function(state, doc, row) {
          this.$outdent.autoOutdent(doc, row);
        };
        this.getCompletions = function(state, session, pos, prefix) {
          return this.$completer.getCompletions(state, session, pos, prefix);
        };
        this.createWorker = function(session) {
          var worker = new WorkerClient(["ace"], "ace/mode/css_worker", "Worker");
          worker.attachToDocument(session.getDocument());
          worker.on("annotate", function(e) {
            session.setAnnotations(e.data);
          });
          worker.on("terminate", function() {
            session.clearAnnotations();
          });
          return worker;
        };
        this.$id = "ace/mode/css";
        this.snippetFileId = "ace/snippets/css";
      }).call(Mode.prototype);
      exports2.Mode = Mode;
    });
    (function() {
      ace.require(["ace/mode/css"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/snippets/css.js
var require_css = __commonJS({
  "node_modules/ace-builds/src-noconflict/snippets/css.js"(exports, module2) {
    ace.define("ace/snippets/css.snippets", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = "snippet .\n	${1} {\n		${2}\n	}\nsnippet !\n	 !important\nsnippet bdi:m+\n	-moz-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};\nsnippet bdi:m\n	-moz-border-image: ${1};\nsnippet bdrz:m\n	-moz-border-radius: ${1};\nsnippet bxsh:m+\n	-moz-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};\nsnippet bxsh:m\n	-moz-box-shadow: ${1};\nsnippet bdi:w+\n	-webkit-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};\nsnippet bdi:w\n	-webkit-border-image: ${1};\nsnippet bdrz:w\n	-webkit-border-radius: ${1};\nsnippet bxsh:w+\n	-webkit-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};\nsnippet bxsh:w\n	-webkit-box-shadow: ${1};\nsnippet @f\n	@font-face {\n		font-family: ${1};\n		src: url(${2});\n	}\nsnippet @i\n	@import url(${1});\nsnippet @m\n	@media ${1:print} {\n		${2}\n	}\nsnippet bg+\n	background: #${1:FFF} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\nsnippet bga\n	background-attachment: ${1};\nsnippet bga:f\n	background-attachment: fixed;\nsnippet bga:s\n	background-attachment: scroll;\nsnippet bgbk\n	background-break: ${1};\nsnippet bgbk:bb\n	background-break: bounding-box;\nsnippet bgbk:c\n	background-break: continuous;\nsnippet bgbk:eb\n	background-break: each-box;\nsnippet bgcp\n	background-clip: ${1};\nsnippet bgcp:bb\n	background-clip: border-box;\nsnippet bgcp:cb\n	background-clip: content-box;\nsnippet bgcp:nc\n	background-clip: no-clip;\nsnippet bgcp:pb\n	background-clip: padding-box;\nsnippet bgc\n	background-color: #${1:FFF};\nsnippet bgc:t\n	background-color: transparent;\nsnippet bgi\n	background-image: url(${1});\nsnippet bgi:n\n	background-image: none;\nsnippet bgo\n	background-origin: ${1};\nsnippet bgo:bb\n	background-origin: border-box;\nsnippet bgo:cb\n	background-origin: content-box;\nsnippet bgo:pb\n	background-origin: padding-box;\nsnippet bgpx\n	background-position-x: ${1};\nsnippet bgpy\n	background-position-y: ${1};\nsnippet bgp\n	background-position: ${1:0} ${2:0};\nsnippet bgr\n	background-repeat: ${1};\nsnippet bgr:n\n	background-repeat: no-repeat;\nsnippet bgr:x\n	background-repeat: repeat-x;\nsnippet bgr:y\n	background-repeat: repeat-y;\nsnippet bgr:r\n	background-repeat: repeat;\nsnippet bgz\n	background-size: ${1};\nsnippet bgz:a\n	background-size: auto;\nsnippet bgz:ct\n	background-size: contain;\nsnippet bgz:cv\n	background-size: cover;\nsnippet bg\n	background: ${1};\nsnippet bg:ie\n	filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${2:crop}');\nsnippet bg:n\n	background: none;\nsnippet bd+\n	border: ${1:1px} ${2:solid} #${3:000};\nsnippet bdb+\n	border-bottom: ${1:1px} ${2:solid} #${3:000};\nsnippet bdbc\n	border-bottom-color: #${1:000};\nsnippet bdbi\n	border-bottom-image: url(${1});\nsnippet bdbi:n\n	border-bottom-image: none;\nsnippet bdbli\n	border-bottom-left-image: url(${1});\nsnippet bdbli:c\n	border-bottom-left-image: continue;\nsnippet bdbli:n\n	border-bottom-left-image: none;\nsnippet bdblrz\n	border-bottom-left-radius: ${1};\nsnippet bdbri\n	border-bottom-right-image: url(${1});\nsnippet bdbri:c\n	border-bottom-right-image: continue;\nsnippet bdbri:n\n	border-bottom-right-image: none;\nsnippet bdbrrz\n	border-bottom-right-radius: ${1};\nsnippet bdbs\n	border-bottom-style: ${1};\nsnippet bdbs:n\n	border-bottom-style: none;\nsnippet bdbw\n	border-bottom-width: ${1};\nsnippet bdb\n	border-bottom: ${1};\nsnippet bdb:n\n	border-bottom: none;\nsnippet bdbk\n	border-break: ${1};\nsnippet bdbk:c\n	border-break: close;\nsnippet bdcl\n	border-collapse: ${1};\nsnippet bdcl:c\n	border-collapse: collapse;\nsnippet bdcl:s\n	border-collapse: separate;\nsnippet bdc\n	border-color: #${1:000};\nsnippet bdci\n	border-corner-image: url(${1});\nsnippet bdci:c\n	border-corner-image: continue;\nsnippet bdci:n\n	border-corner-image: none;\nsnippet bdf\n	border-fit: ${1};\nsnippet bdf:c\n	border-fit: clip;\nsnippet bdf:of\n	border-fit: overwrite;\nsnippet bdf:ow\n	border-fit: overwrite;\nsnippet bdf:r\n	border-fit: repeat;\nsnippet bdf:sc\n	border-fit: scale;\nsnippet bdf:sp\n	border-fit: space;\nsnippet bdf:st\n	border-fit: stretch;\nsnippet bdi\n	border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};\nsnippet bdi:n\n	border-image: none;\nsnippet bdl+\n	border-left: ${1:1px} ${2:solid} #${3:000};\nsnippet bdlc\n	border-left-color: #${1:000};\nsnippet bdli\n	border-left-image: url(${1});\nsnippet bdli:n\n	border-left-image: none;\nsnippet bdls\n	border-left-style: ${1};\nsnippet bdls:n\n	border-left-style: none;\nsnippet bdlw\n	border-left-width: ${1};\nsnippet bdl\n	border-left: ${1};\nsnippet bdl:n\n	border-left: none;\nsnippet bdlt\n	border-length: ${1};\nsnippet bdlt:a\n	border-length: auto;\nsnippet bdrz\n	border-radius: ${1};\nsnippet bdr+\n	border-right: ${1:1px} ${2:solid} #${3:000};\nsnippet bdrc\n	border-right-color: #${1:000};\nsnippet bdri\n	border-right-image: url(${1});\nsnippet bdri:n\n	border-right-image: none;\nsnippet bdrs\n	border-right-style: ${1};\nsnippet bdrs:n\n	border-right-style: none;\nsnippet bdrw\n	border-right-width: ${1};\nsnippet bdr\n	border-right: ${1};\nsnippet bdr:n\n	border-right: none;\nsnippet bdsp\n	border-spacing: ${1};\nsnippet bds\n	border-style: ${1};\nsnippet bds:ds\n	border-style: dashed;\nsnippet bds:dtds\n	border-style: dot-dash;\nsnippet bds:dtdtds\n	border-style: dot-dot-dash;\nsnippet bds:dt\n	border-style: dotted;\nsnippet bds:db\n	border-style: double;\nsnippet bds:g\n	border-style: groove;\nsnippet bds:h\n	border-style: hidden;\nsnippet bds:i\n	border-style: inset;\nsnippet bds:n\n	border-style: none;\nsnippet bds:o\n	border-style: outset;\nsnippet bds:r\n	border-style: ridge;\nsnippet bds:s\n	border-style: solid;\nsnippet bds:w\n	border-style: wave;\nsnippet bdt+\n	border-top: ${1:1px} ${2:solid} #${3:000};\nsnippet bdtc\n	border-top-color: #${1:000};\nsnippet bdti\n	border-top-image: url(${1});\nsnippet bdti:n\n	border-top-image: none;\nsnippet bdtli\n	border-top-left-image: url(${1});\nsnippet bdtli:c\n	border-corner-image: continue;\nsnippet bdtli:n\n	border-corner-image: none;\nsnippet bdtlrz\n	border-top-left-radius: ${1};\nsnippet bdtri\n	border-top-right-image: url(${1});\nsnippet bdtri:c\n	border-top-right-image: continue;\nsnippet bdtri:n\n	border-top-right-image: none;\nsnippet bdtrrz\n	border-top-right-radius: ${1};\nsnippet bdts\n	border-top-style: ${1};\nsnippet bdts:n\n	border-top-style: none;\nsnippet bdtw\n	border-top-width: ${1};\nsnippet bdt\n	border-top: ${1};\nsnippet bdt:n\n	border-top: none;\nsnippet bdw\n	border-width: ${1};\nsnippet bd\n	border: ${1};\nsnippet bd:n\n	border: none;\nsnippet b\n	bottom: ${1};\nsnippet b:a\n	bottom: auto;\nsnippet bxsh+\n	box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};\nsnippet bxsh\n	box-shadow: ${1};\nsnippet bxsh:n\n	box-shadow: none;\nsnippet bxz\n	box-sizing: ${1};\nsnippet bxz:bb\n	box-sizing: border-box;\nsnippet bxz:cb\n	box-sizing: content-box;\nsnippet cps\n	caption-side: ${1};\nsnippet cps:b\n	caption-side: bottom;\nsnippet cps:t\n	caption-side: top;\nsnippet cl\n	clear: ${1};\nsnippet cl:b\n	clear: both;\nsnippet cl:l\n	clear: left;\nsnippet cl:n\n	clear: none;\nsnippet cl:r\n	clear: right;\nsnippet cp\n	clip: ${1};\nsnippet cp:a\n	clip: auto;\nsnippet cp:r\n	clip: rect(${1:0} ${2:0} ${3:0} ${4:0});\nsnippet c\n	color: #${1:000};\nsnippet ct\n	content: ${1};\nsnippet ct:a\n	content: attr(${1});\nsnippet ct:cq\n	content: close-quote;\nsnippet ct:c\n	content: counter(${1});\nsnippet ct:cs\n	content: counters(${1});\nsnippet ct:ncq\n	content: no-close-quote;\nsnippet ct:noq\n	content: no-open-quote;\nsnippet ct:n\n	content: normal;\nsnippet ct:oq\n	content: open-quote;\nsnippet coi\n	counter-increment: ${1};\nsnippet cor\n	counter-reset: ${1};\nsnippet cur\n	cursor: ${1};\nsnippet cur:a\n	cursor: auto;\nsnippet cur:c\n	cursor: crosshair;\nsnippet cur:d\n	cursor: default;\nsnippet cur:ha\n	cursor: hand;\nsnippet cur:he\n	cursor: help;\nsnippet cur:m\n	cursor: move;\nsnippet cur:p\n	cursor: pointer;\nsnippet cur:t\n	cursor: text;\nsnippet d\n	display: ${1};\nsnippet d:mib\n	display: -moz-inline-box;\nsnippet d:mis\n	display: -moz-inline-stack;\nsnippet d:b\n	display: block;\nsnippet d:cp\n	display: compact;\nsnippet d:ib\n	display: inline-block;\nsnippet d:itb\n	display: inline-table;\nsnippet d:i\n	display: inline;\nsnippet d:li\n	display: list-item;\nsnippet d:n\n	display: none;\nsnippet d:ri\n	display: run-in;\nsnippet d:tbcp\n	display: table-caption;\nsnippet d:tbc\n	display: table-cell;\nsnippet d:tbclg\n	display: table-column-group;\nsnippet d:tbcl\n	display: table-column;\nsnippet d:tbfg\n	display: table-footer-group;\nsnippet d:tbhg\n	display: table-header-group;\nsnippet d:tbrg\n	display: table-row-group;\nsnippet d:tbr\n	display: table-row;\nsnippet d:tb\n	display: table;\nsnippet ec\n	empty-cells: ${1};\nsnippet ec:h\n	empty-cells: hide;\nsnippet ec:s\n	empty-cells: show;\nsnippet exp\n	expression()\nsnippet fl\n	float: ${1};\nsnippet fl:l\n	float: left;\nsnippet fl:n\n	float: none;\nsnippet fl:r\n	float: right;\nsnippet f+\n	font: ${1:1em} ${2:Arial},${3:sans-serif};\nsnippet fef\n	font-effect: ${1};\nsnippet fef:eb\n	font-effect: emboss;\nsnippet fef:eg\n	font-effect: engrave;\nsnippet fef:n\n	font-effect: none;\nsnippet fef:o\n	font-effect: outline;\nsnippet femp\n	font-emphasize-position: ${1};\nsnippet femp:a\n	font-emphasize-position: after;\nsnippet femp:b\n	font-emphasize-position: before;\nsnippet fems\n	font-emphasize-style: ${1};\nsnippet fems:ac\n	font-emphasize-style: accent;\nsnippet fems:c\n	font-emphasize-style: circle;\nsnippet fems:ds\n	font-emphasize-style: disc;\nsnippet fems:dt\n	font-emphasize-style: dot;\nsnippet fems:n\n	font-emphasize-style: none;\nsnippet fem\n	font-emphasize: ${1};\nsnippet ff\n	font-family: ${1};\nsnippet ff:c\n	font-family: ${1:'Monotype Corsiva','Comic Sans MS'},cursive;\nsnippet ff:f\n	font-family: ${1:Capitals,Impact},fantasy;\nsnippet ff:m\n	font-family: ${1:Monaco,'Courier New'},monospace;\nsnippet ff:ss\n	font-family: ${1:Helvetica,Arial},sans-serif;\nsnippet ff:s\n	font-family: ${1:Georgia,'Times New Roman'},serif;\nsnippet fza\n	font-size-adjust: ${1};\nsnippet fza:n\n	font-size-adjust: none;\nsnippet fz\n	font-size: ${1};\nsnippet fsm\n	font-smooth: ${1};\nsnippet fsm:aw\n	font-smooth: always;\nsnippet fsm:a\n	font-smooth: auto;\nsnippet fsm:n\n	font-smooth: never;\nsnippet fst\n	font-stretch: ${1};\nsnippet fst:c\n	font-stretch: condensed;\nsnippet fst:e\n	font-stretch: expanded;\nsnippet fst:ec\n	font-stretch: extra-condensed;\nsnippet fst:ee\n	font-stretch: extra-expanded;\nsnippet fst:n\n	font-stretch: normal;\nsnippet fst:sc\n	font-stretch: semi-condensed;\nsnippet fst:se\n	font-stretch: semi-expanded;\nsnippet fst:uc\n	font-stretch: ultra-condensed;\nsnippet fst:ue\n	font-stretch: ultra-expanded;\nsnippet fs\n	font-style: ${1};\nsnippet fs:i\n	font-style: italic;\nsnippet fs:n\n	font-style: normal;\nsnippet fs:o\n	font-style: oblique;\nsnippet fv\n	font-variant: ${1};\nsnippet fv:n\n	font-variant: normal;\nsnippet fv:sc\n	font-variant: small-caps;\nsnippet fw\n	font-weight: ${1};\nsnippet fw:b\n	font-weight: bold;\nsnippet fw:br\n	font-weight: bolder;\nsnippet fw:lr\n	font-weight: lighter;\nsnippet fw:n\n	font-weight: normal;\nsnippet f\n	font: ${1};\nsnippet h\n	height: ${1};\nsnippet h:a\n	height: auto;\nsnippet l\n	left: ${1};\nsnippet l:a\n	left: auto;\nsnippet lts\n	letter-spacing: ${1};\nsnippet lh\n	line-height: ${1};\nsnippet lisi\n	list-style-image: url(${1});\nsnippet lisi:n\n	list-style-image: none;\nsnippet lisp\n	list-style-position: ${1};\nsnippet lisp:i\n	list-style-position: inside;\nsnippet lisp:o\n	list-style-position: outside;\nsnippet list\n	list-style-type: ${1};\nsnippet list:c\n	list-style-type: circle;\nsnippet list:dclz\n	list-style-type: decimal-leading-zero;\nsnippet list:dc\n	list-style-type: decimal;\nsnippet list:d\n	list-style-type: disc;\nsnippet list:lr\n	list-style-type: lower-roman;\nsnippet list:n\n	list-style-type: none;\nsnippet list:s\n	list-style-type: square;\nsnippet list:ur\n	list-style-type: upper-roman;\nsnippet lis\n	list-style: ${1};\nsnippet lis:n\n	list-style: none;\nsnippet mb\n	margin-bottom: ${1};\nsnippet mb:a\n	margin-bottom: auto;\nsnippet ml\n	margin-left: ${1};\nsnippet ml:a\n	margin-left: auto;\nsnippet mr\n	margin-right: ${1};\nsnippet mr:a\n	margin-right: auto;\nsnippet mt\n	margin-top: ${1};\nsnippet mt:a\n	margin-top: auto;\nsnippet m\n	margin: ${1};\nsnippet m:4\n	margin: ${1:0} ${2:0} ${3:0} ${4:0};\nsnippet m:3\n	margin: ${1:0} ${2:0} ${3:0};\nsnippet m:2\n	margin: ${1:0} ${2:0};\nsnippet m:0\n	margin: 0;\nsnippet m:a\n	margin: auto;\nsnippet mah\n	max-height: ${1};\nsnippet mah:n\n	max-height: none;\nsnippet maw\n	max-width: ${1};\nsnippet maw:n\n	max-width: none;\nsnippet mih\n	min-height: ${1};\nsnippet miw\n	min-width: ${1};\nsnippet op\n	opacity: ${1};\nsnippet op:ie\n	filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=${1:100});\nsnippet op:ms\n	-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${1:100})';\nsnippet orp\n	orphans: ${1};\nsnippet o+\n	outline: ${1:1px} ${2:solid} #${3:000};\nsnippet oc\n	outline-color: ${1:#000};\nsnippet oc:i\n	outline-color: invert;\nsnippet oo\n	outline-offset: ${1};\nsnippet os\n	outline-style: ${1};\nsnippet ow\n	outline-width: ${1};\nsnippet o\n	outline: ${1};\nsnippet o:n\n	outline: none;\nsnippet ovs\n	overflow-style: ${1};\nsnippet ovs:a\n	overflow-style: auto;\nsnippet ovs:mq\n	overflow-style: marquee;\nsnippet ovs:mv\n	overflow-style: move;\nsnippet ovs:p\n	overflow-style: panner;\nsnippet ovs:s\n	overflow-style: scrollbar;\nsnippet ovx\n	overflow-x: ${1};\nsnippet ovx:a\n	overflow-x: auto;\nsnippet ovx:h\n	overflow-x: hidden;\nsnippet ovx:s\n	overflow-x: scroll;\nsnippet ovx:v\n	overflow-x: visible;\nsnippet ovy\n	overflow-y: ${1};\nsnippet ovy:a\n	overflow-y: auto;\nsnippet ovy:h\n	overflow-y: hidden;\nsnippet ovy:s\n	overflow-y: scroll;\nsnippet ovy:v\n	overflow-y: visible;\nsnippet ov\n	overflow: ${1};\nsnippet ov:a\n	overflow: auto;\nsnippet ov:h\n	overflow: hidden;\nsnippet ov:s\n	overflow: scroll;\nsnippet ov:v\n	overflow: visible;\nsnippet pb\n	padding-bottom: ${1};\nsnippet pl\n	padding-left: ${1};\nsnippet pr\n	padding-right: ${1};\nsnippet pt\n	padding-top: ${1};\nsnippet p\n	padding: ${1};\nsnippet p:4\n	padding: ${1:0} ${2:0} ${3:0} ${4:0};\nsnippet p:3\n	padding: ${1:0} ${2:0} ${3:0};\nsnippet p:2\n	padding: ${1:0} ${2:0};\nsnippet p:0\n	padding: 0;\nsnippet pgba\n	page-break-after: ${1};\nsnippet pgba:aw\n	page-break-after: always;\nsnippet pgba:a\n	page-break-after: auto;\nsnippet pgba:l\n	page-break-after: left;\nsnippet pgba:r\n	page-break-after: right;\nsnippet pgbb\n	page-break-before: ${1};\nsnippet pgbb:aw\n	page-break-before: always;\nsnippet pgbb:a\n	page-break-before: auto;\nsnippet pgbb:l\n	page-break-before: left;\nsnippet pgbb:r\n	page-break-before: right;\nsnippet pgbi\n	page-break-inside: ${1};\nsnippet pgbi:a\n	page-break-inside: auto;\nsnippet pgbi:av\n	page-break-inside: avoid;\nsnippet pos\n	position: ${1};\nsnippet pos:a\n	position: absolute;\nsnippet pos:f\n	position: fixed;\nsnippet pos:r\n	position: relative;\nsnippet pos:s\n	position: static;\nsnippet q\n	quotes: ${1};\nsnippet q:en\n	quotes: '\\201C' '\\201D' '\\2018' '\\2019';\nsnippet q:n\n	quotes: none;\nsnippet q:ru\n	quotes: '\\00AB' '\\00BB' '\\201E' '\\201C';\nsnippet rz\n	resize: ${1};\nsnippet rz:b\n	resize: both;\nsnippet rz:h\n	resize: horizontal;\nsnippet rz:n\n	resize: none;\nsnippet rz:v\n	resize: vertical;\nsnippet r\n	right: ${1};\nsnippet r:a\n	right: auto;\nsnippet tbl\n	table-layout: ${1};\nsnippet tbl:a\n	table-layout: auto;\nsnippet tbl:f\n	table-layout: fixed;\nsnippet tal\n	text-align-last: ${1};\nsnippet tal:a\n	text-align-last: auto;\nsnippet tal:c\n	text-align-last: center;\nsnippet tal:l\n	text-align-last: left;\nsnippet tal:r\n	text-align-last: right;\nsnippet ta\n	text-align: ${1};\nsnippet ta:c\n	text-align: center;\nsnippet ta:l\n	text-align: left;\nsnippet ta:r\n	text-align: right;\nsnippet td\n	text-decoration: ${1};\nsnippet td:l\n	text-decoration: line-through;\nsnippet td:n\n	text-decoration: none;\nsnippet td:o\n	text-decoration: overline;\nsnippet td:u\n	text-decoration: underline;\nsnippet te\n	text-emphasis: ${1};\nsnippet te:ac\n	text-emphasis: accent;\nsnippet te:a\n	text-emphasis: after;\nsnippet te:b\n	text-emphasis: before;\nsnippet te:c\n	text-emphasis: circle;\nsnippet te:ds\n	text-emphasis: disc;\nsnippet te:dt\n	text-emphasis: dot;\nsnippet te:n\n	text-emphasis: none;\nsnippet th\n	text-height: ${1};\nsnippet th:a\n	text-height: auto;\nsnippet th:f\n	text-height: font-size;\nsnippet th:m\n	text-height: max-size;\nsnippet th:t\n	text-height: text-size;\nsnippet ti\n	text-indent: ${1};\nsnippet ti:-\n	text-indent: -9999px;\nsnippet tj\n	text-justify: ${1};\nsnippet tj:a\n	text-justify: auto;\nsnippet tj:d\n	text-justify: distribute;\nsnippet tj:ic\n	text-justify: inter-cluster;\nsnippet tj:ii\n	text-justify: inter-ideograph;\nsnippet tj:iw\n	text-justify: inter-word;\nsnippet tj:k\n	text-justify: kashida;\nsnippet tj:t\n	text-justify: tibetan;\nsnippet to+\n	text-outline: ${1:0} ${2:0} #${3:000};\nsnippet to\n	text-outline: ${1};\nsnippet to:n\n	text-outline: none;\nsnippet tr\n	text-replace: ${1};\nsnippet tr:n\n	text-replace: none;\nsnippet tsh+\n	text-shadow: ${1:0} ${2:0} ${3:0} #${4:000};\nsnippet tsh\n	text-shadow: ${1};\nsnippet tsh:n\n	text-shadow: none;\nsnippet tt\n	text-transform: ${1};\nsnippet tt:c\n	text-transform: capitalize;\nsnippet tt:l\n	text-transform: lowercase;\nsnippet tt:n\n	text-transform: none;\nsnippet tt:u\n	text-transform: uppercase;\nsnippet tw\n	text-wrap: ${1};\nsnippet tw:no\n	text-wrap: none;\nsnippet tw:n\n	text-wrap: normal;\nsnippet tw:s\n	text-wrap: suppress;\nsnippet tw:u\n	text-wrap: unrestricted;\nsnippet t\n	top: ${1};\nsnippet t:a\n	top: auto;\nsnippet va\n	vertical-align: ${1};\nsnippet va:bl\n	vertical-align: baseline;\nsnippet va:b\n	vertical-align: bottom;\nsnippet va:m\n	vertical-align: middle;\nsnippet va:sub\n	vertical-align: sub;\nsnippet va:sup\n	vertical-align: super;\nsnippet va:tb\n	vertical-align: text-bottom;\nsnippet va:tt\n	vertical-align: text-top;\nsnippet va:t\n	vertical-align: top;\nsnippet v\n	visibility: ${1};\nsnippet v:c\n	visibility: collapse;\nsnippet v:h\n	visibility: hidden;\nsnippet v:v\n	visibility: visible;\nsnippet whsc\n	white-space-collapse: ${1};\nsnippet whsc:ba\n	white-space-collapse: break-all;\nsnippet whsc:bs\n	white-space-collapse: break-strict;\nsnippet whsc:k\n	white-space-collapse: keep-all;\nsnippet whsc:l\n	white-space-collapse: loose;\nsnippet whsc:n\n	white-space-collapse: normal;\nsnippet whs\n	white-space: ${1};\nsnippet whs:n\n	white-space: normal;\nsnippet whs:nw\n	white-space: nowrap;\nsnippet whs:pl\n	white-space: pre-line;\nsnippet whs:pw\n	white-space: pre-wrap;\nsnippet whs:p\n	white-space: pre;\nsnippet wid\n	widows: ${1};\nsnippet w\n	width: ${1};\nsnippet w:a\n	width: auto;\nsnippet wob\n	word-break: ${1};\nsnippet wob:ba\n	word-break: break-all;\nsnippet wob:bs\n	word-break: break-strict;\nsnippet wob:k\n	word-break: keep-all;\nsnippet wob:l\n	word-break: loose;\nsnippet wob:n\n	word-break: normal;\nsnippet wos\n	word-spacing: ${1};\nsnippet wow\n	word-wrap: ${1};\nsnippet wow:no\n	word-wrap: none;\nsnippet wow:n\n	word-wrap: normal;\nsnippet wow:s\n	word-wrap: suppress;\nsnippet wow:u\n	word-wrap: unrestricted;\nsnippet z\n	z-index: ${1};\nsnippet z:a\n	z-index: auto;\nsnippet zoo\n	zoom: 1;\n";
    });
    ace.define("ace/snippets/css", ["require", "exports", "module", "ace/snippets/css.snippets"], function(require3, exports2, module3) {
      "use strict";
      exports2.snippetText = require3("./css.snippets");
      exports2.scope = "css";
    });
    (function() {
      ace.require(["ace/snippets/css"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-command_bar.js
var require_ext_command_bar = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-command_bar.js"(exports, module2) {
    ace.define("ace/ext/command_bar", ["require", "exports", "module", "ace/tooltip", "ace/lib/event_emitter", "ace/lib/lang", "ace/lib/dom", "ace/lib/oop", "ace/lib/useragent"], function(require3, exports2, module3) {
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var Tooltip = require3("../tooltip").Tooltip;
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var lang = require3("../lib/lang");
      var dom = require3("../lib/dom");
      var oop = require3("../lib/oop");
      var useragent = require3("../lib/useragent");
      var BUTTON_CLASS_NAME = "command_bar_tooltip_button";
      var VALUE_CLASS_NAME = "command_bar_button_value";
      var CAPTION_CLASS_NAME = "command_bar_button_caption";
      var KEYBINDING_CLASS_NAME = "command_bar_keybinding";
      var TOOLTIP_CLASS_NAME = "command_bar_tooltip";
      var MORE_OPTIONS_BUTTON_ID = "MoreOptionsButton";
      var defaultDelay = 100;
      var defaultMaxElements = 4;
      var minPosition = function(posA, posB) {
        if (posB.row > posA.row) {
          return posA;
        } else if (posB.row === posA.row && posB.column > posA.column) {
          return posA;
        }
        return posB;
      };
      var keyDisplayMap = {
        "Ctrl": { mac: "^" },
        "Option": { mac: "\u2325" },
        "Command": { mac: "\u2318" },
        "Cmd": { mac: "\u2318" },
        "Shift": "\u21E7",
        "Left": "\u2190",
        "Right": "\u2192",
        "Up": "\u2191",
        "Down": "\u2193"
      };
      var CommandBarTooltip = (
        /** @class */
        function() {
          function CommandBarTooltip2(parentNode, options) {
            var e_1, _a2;
            options = options || {};
            this.parentNode = parentNode;
            this.tooltip = new Tooltip(this.parentNode);
            this.moreOptions = new Tooltip(this.parentNode);
            this.maxElementsOnTooltip = options.maxElementsOnTooltip || defaultMaxElements;
            this.$alwaysShow = options.alwaysShow || false;
            this.eventListeners = {};
            this.elements = {};
            this.commands = {};
            this.tooltipEl = dom.buildDom(["div", { class: TOOLTIP_CLASS_NAME }], this.tooltip.getElement());
            this.moreOptionsEl = dom.buildDom(["div", { class: TOOLTIP_CLASS_NAME + " tooltip_more_options" }], this.moreOptions.getElement());
            this.$showTooltipTimer = lang.delayedCall(this.$showTooltip.bind(this), options.showDelay || defaultDelay);
            this.$hideTooltipTimer = lang.delayedCall(this.$hideTooltip.bind(this), options.hideDelay || defaultDelay);
            this.$tooltipEnter = this.$tooltipEnter.bind(this);
            this.$onMouseMove = this.$onMouseMove.bind(this);
            this.$onChangeScroll = this.$onChangeScroll.bind(this);
            this.$onEditorChangeSession = this.$onEditorChangeSession.bind(this);
            this.$scheduleTooltipForHide = this.$scheduleTooltipForHide.bind(this);
            this.$preventMouseEvent = this.$preventMouseEvent.bind(this);
            try {
              for (var _b = __values(["mousedown", "mouseup", "click"]), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
                var event = _c2.value;
                this.tooltip.getElement().addEventListener(event, this.$preventMouseEvent);
                this.moreOptions.getElement().addEventListener(event, this.$preventMouseEvent);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a2 = _b.return)) _a2.call(_b);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
          CommandBarTooltip2.prototype.registerCommand = function(id, command) {
            var registerForMainTooltip = Object.keys(this.commands).length < this.maxElementsOnTooltip;
            if (!registerForMainTooltip && !this.elements[MORE_OPTIONS_BUTTON_ID]) {
              this.$createCommand(MORE_OPTIONS_BUTTON_ID, {
                name: "\xB7\xB7\xB7",
                exec: function() {
                  this.$shouldHideMoreOptions = false;
                  this.$setMoreOptionsVisibility(!this.isMoreOptionsShown());
                }.bind(this),
                type: "checkbox",
                getValue: function() {
                  return this.isMoreOptionsShown();
                }.bind(this),
                enabled: true
              }, true);
            }
            this.$createCommand(id, command, registerForMainTooltip);
            if (this.isShown()) {
              this.updatePosition();
            }
          };
          CommandBarTooltip2.prototype.isShown = function() {
            return !!this.tooltip && this.tooltip.isOpen;
          };
          CommandBarTooltip2.prototype.isMoreOptionsShown = function() {
            return !!this.moreOptions && this.moreOptions.isOpen;
          };
          CommandBarTooltip2.prototype.getAlwaysShow = function() {
            return this.$alwaysShow;
          };
          CommandBarTooltip2.prototype.setAlwaysShow = function(alwaysShow) {
            this.$alwaysShow = alwaysShow;
            this.$updateOnHoverHandlers(!this.$alwaysShow);
            this._signal("alwaysShow", this.$alwaysShow);
          };
          CommandBarTooltip2.prototype.attach = function(editor) {
            if (!editor || this.isShown() && this.editor === editor) {
              return;
            }
            this.detach();
            this.editor = editor;
            this.editor.on("changeSession", this.$onEditorChangeSession);
            if (this.editor.session) {
              this.editor.session.on("changeScrollLeft", this.$onChangeScroll);
              this.editor.session.on("changeScrollTop", this.$onChangeScroll);
            }
            if (this.getAlwaysShow()) {
              this.$showTooltip();
            } else {
              this.$updateOnHoverHandlers(true);
            }
          };
          CommandBarTooltip2.prototype.updatePosition = function() {
            if (!this.editor) {
              return;
            }
            var renderer = this.editor.renderer;
            var ranges;
            if (this.editor.selection.getAllRanges) {
              ranges = this.editor.selection.getAllRanges();
            } else {
              ranges = [this.editor.getSelectionRange()];
            }
            if (!ranges.length) {
              return;
            }
            var minPos = minPosition(ranges[0].start, ranges[0].end);
            for (var i = 0, range; range = ranges[i]; i++) {
              minPos = minPosition(minPos, minPosition(range.start, range.end));
            }
            var pos = renderer.$cursorLayer.getPixelPosition(minPos, true);
            var tooltipEl = this.tooltip.getElement();
            var screenWidth = window.innerWidth;
            var screenHeight = window.innerHeight;
            var rect = this.editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left + renderer.gutterWidth - renderer.scrollLeft;
            var cursorVisible = pos.top >= rect.top && pos.top <= rect.bottom && pos.left >= rect.left + renderer.gutterWidth && pos.left <= rect.right;
            if (!cursorVisible && this.isShown()) {
              this.$hideTooltip();
              return;
            } else if (cursorVisible && !this.isShown() && this.getAlwaysShow()) {
              this.$showTooltip();
              return;
            }
            var top = pos.top - tooltipEl.offsetHeight;
            var left = Math.min(screenWidth - tooltipEl.offsetWidth, pos.left);
            var tooltipFits = top >= 0 && top + tooltipEl.offsetHeight <= screenHeight && left >= 0 && left + tooltipEl.offsetWidth <= screenWidth;
            if (!tooltipFits) {
              this.$hideTooltip();
              return;
            }
            this.tooltip.setPosition(left, top);
            if (this.isMoreOptionsShown()) {
              top = top + tooltipEl.offsetHeight;
              left = this.elements[MORE_OPTIONS_BUTTON_ID].getBoundingClientRect().left;
              var moreOptionsEl = this.moreOptions.getElement();
              var screenHeight = window.innerHeight;
              if (top + moreOptionsEl.offsetHeight > screenHeight) {
                top -= tooltipEl.offsetHeight + moreOptionsEl.offsetHeight;
              }
              if (left + moreOptionsEl.offsetWidth > screenWidth) {
                left = screenWidth - moreOptionsEl.offsetWidth;
              }
              this.moreOptions.setPosition(left, top);
            }
          };
          CommandBarTooltip2.prototype.update = function() {
            Object.keys(this.elements).forEach(this.$updateElement.bind(this));
          };
          CommandBarTooltip2.prototype.detach = function() {
            this.tooltip.hide();
            this.moreOptions.hide();
            this.$updateOnHoverHandlers(false);
            if (this.editor) {
              this.editor.off("changeSession", this.$onEditorChangeSession);
              if (this.editor.session) {
                this.editor.session.off("changeScrollLeft", this.$onChangeScroll);
                this.editor.session.off("changeScrollTop", this.$onChangeScroll);
              }
            }
            this.$mouseInTooltip = false;
            this.editor = null;
          };
          CommandBarTooltip2.prototype.destroy = function() {
            if (this.tooltip && this.moreOptions) {
              this.detach();
              this.tooltip.destroy();
              this.moreOptions.destroy();
            }
            this.eventListeners = {};
            this.commands = {};
            this.elements = {};
            this.tooltip = this.moreOptions = this.parentNode = null;
          };
          CommandBarTooltip2.prototype.$createCommand = function(id, command, forMainTooltip) {
            var parentEl = forMainTooltip ? this.tooltipEl : this.moreOptionsEl;
            var keyParts = [];
            var bindKey = command.bindKey;
            if (bindKey) {
              if (typeof bindKey === "object") {
                bindKey = useragent.isMac ? bindKey.mac : bindKey.win;
              }
              bindKey = bindKey.split("|")[0];
              keyParts = bindKey.split("-");
              keyParts = keyParts.map(function(key) {
                if (keyDisplayMap[key]) {
                  if (typeof keyDisplayMap[key] === "string") {
                    return keyDisplayMap[key];
                  } else if (useragent.isMac && keyDisplayMap[key].mac) {
                    return keyDisplayMap[key].mac;
                  }
                }
                return key;
              });
            }
            var buttonNode;
            if (forMainTooltip && command.iconCssClass) {
              buttonNode = [
                "div",
                {
                  class: ["ace_icon_svg", command.iconCssClass].join(" "),
                  "aria-label": command.name + " (" + command.bindKey + ")"
                }
              ];
            } else {
              buttonNode = [
                ["div", { class: VALUE_CLASS_NAME }],
                ["div", { class: CAPTION_CLASS_NAME }, command.name]
              ];
              if (keyParts.length) {
                buttonNode.push([
                  "div",
                  { class: KEYBINDING_CLASS_NAME },
                  keyParts.map(function(keyPart) {
                    return ["div", keyPart];
                  })
                ]);
              }
            }
            dom.buildDom(["div", { class: [BUTTON_CLASS_NAME, command.cssClass || ""].join(" "), ref: id }, buttonNode], parentEl, this.elements);
            this.commands[id] = command;
            var eventListener = function(e) {
              if (this.editor) {
                this.editor.focus();
              }
              this.$shouldHideMoreOptions = this.isMoreOptionsShown();
              if (!this.elements[id].disabled && command.exec) {
                command.exec(this.editor);
              }
              if (this.$shouldHideMoreOptions) {
                this.$setMoreOptionsVisibility(false);
              }
              this.update();
              e.preventDefault();
            }.bind(this);
            this.eventListeners[id] = eventListener;
            this.elements[id].addEventListener("click", eventListener.bind(this));
            this.$updateElement(id);
          };
          CommandBarTooltip2.prototype.$setMoreOptionsVisibility = function(visible) {
            if (visible) {
              this.moreOptions.setTheme(this.editor.renderer.theme);
              this.moreOptions.setClassName(TOOLTIP_CLASS_NAME + "_wrapper");
              this.moreOptions.show();
              this.update();
              this.updatePosition();
            } else {
              this.moreOptions.hide();
            }
          };
          CommandBarTooltip2.prototype.$onEditorChangeSession = function(e) {
            if (e.oldSession) {
              e.oldSession.off("changeScrollTop", this.$onChangeScroll);
              e.oldSession.off("changeScrollLeft", this.$onChangeScroll);
            }
            this.detach();
          };
          CommandBarTooltip2.prototype.$onChangeScroll = function() {
            if (this.editor.renderer && (this.isShown() || this.getAlwaysShow())) {
              this.editor.renderer.once("afterRender", this.updatePosition.bind(this));
            }
          };
          CommandBarTooltip2.prototype.$onMouseMove = function(e) {
            if (this.$mouseInTooltip) {
              return;
            }
            var cursorPosition = this.editor.getCursorPosition();
            var cursorScreenPosition = this.editor.renderer.textToScreenCoordinates(cursorPosition.row, cursorPosition.column);
            var lineHeight = this.editor.renderer.lineHeight;
            var isInCurrentLine = e.clientY >= cursorScreenPosition.pageY && e.clientY < cursorScreenPosition.pageY + lineHeight;
            if (isInCurrentLine) {
              if (!this.isShown() && !this.$showTooltipTimer.isPending()) {
                this.$showTooltipTimer.delay();
              }
              if (this.$hideTooltipTimer.isPending()) {
                this.$hideTooltipTimer.cancel();
              }
            } else {
              if (this.isShown() && !this.$hideTooltipTimer.isPending()) {
                this.$hideTooltipTimer.delay();
              }
              if (this.$showTooltipTimer.isPending()) {
                this.$showTooltipTimer.cancel();
              }
            }
          };
          CommandBarTooltip2.prototype.$preventMouseEvent = function(e) {
            if (this.editor) {
              this.editor.focus();
            }
            e.preventDefault();
          };
          CommandBarTooltip2.prototype.$scheduleTooltipForHide = function() {
            this.$mouseInTooltip = false;
            this.$showTooltipTimer.cancel();
            this.$hideTooltipTimer.delay();
          };
          CommandBarTooltip2.prototype.$tooltipEnter = function() {
            this.$mouseInTooltip = true;
            if (this.$showTooltipTimer.isPending()) {
              this.$showTooltipTimer.cancel();
            }
            if (this.$hideTooltipTimer.isPending()) {
              this.$hideTooltipTimer.cancel();
            }
          };
          CommandBarTooltip2.prototype.$updateOnHoverHandlers = function(enableHover) {
            var tooltipEl = this.tooltip.getElement();
            var moreOptionsEl = this.moreOptions.getElement();
            if (enableHover) {
              if (this.editor) {
                this.editor.on("mousemove", this.$onMouseMove);
                this.editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.$scheduleTooltipForHide, true);
              }
              tooltipEl.addEventListener("mouseenter", this.$tooltipEnter);
              tooltipEl.addEventListener("mouseleave", this.$scheduleTooltipForHide);
              moreOptionsEl.addEventListener("mouseenter", this.$tooltipEnter);
              moreOptionsEl.addEventListener("mouseleave", this.$scheduleTooltipForHide);
            } else {
              if (this.editor) {
                this.editor.off("mousemove", this.$onMouseMove);
                this.editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.$scheduleTooltipForHide, true);
              }
              tooltipEl.removeEventListener("mouseenter", this.$tooltipEnter);
              tooltipEl.removeEventListener("mouseleave", this.$scheduleTooltipForHide);
              moreOptionsEl.removeEventListener("mouseenter", this.$tooltipEnter);
              moreOptionsEl.removeEventListener("mouseleave", this.$scheduleTooltipForHide);
            }
          };
          CommandBarTooltip2.prototype.$showTooltip = function() {
            if (this.isShown()) {
              return;
            }
            this.tooltip.setTheme(this.editor.renderer.theme);
            this.tooltip.setClassName(TOOLTIP_CLASS_NAME + "_wrapper");
            this.tooltip.show();
            this.update();
            this.updatePosition();
            this._signal("show");
          };
          CommandBarTooltip2.prototype.$hideTooltip = function() {
            this.$mouseInTooltip = false;
            if (!this.isShown()) {
              return;
            }
            this.moreOptions.hide();
            this.tooltip.hide();
            this._signal("hide");
          };
          CommandBarTooltip2.prototype.$updateElement = function(id) {
            var command = this.commands[id];
            if (!command) {
              return;
            }
            var el = this.elements[id];
            var commandEnabled = command.enabled;
            if (typeof commandEnabled === "function") {
              commandEnabled = commandEnabled(this.editor);
            }
            if (typeof command.getValue === "function") {
              var value = command.getValue(this.editor);
              if (command.type === "text") {
                el.textContent = value;
              } else if (command.type === "checkbox") {
                var domCssFn = value ? dom.addCssClass : dom.removeCssClass;
                var isOnTooltip = el.parentElement === this.tooltipEl;
                el.ariaChecked = value;
                if (isOnTooltip) {
                  domCssFn(el, "ace_selected");
                } else {
                  el = el.querySelector("." + VALUE_CLASS_NAME);
                  domCssFn(el, "ace_checkmark");
                }
              }
            }
            if (commandEnabled && el.disabled) {
              dom.removeCssClass(el, "ace_disabled");
              el.ariaDisabled = el.disabled = false;
              el.removeAttribute("disabled");
            } else if (!commandEnabled && !el.disabled) {
              dom.addCssClass(el, "ace_disabled");
              el.ariaDisabled = el.disabled = true;
              el.setAttribute("disabled", "");
            }
          };
          return CommandBarTooltip2;
        }()
      );
      oop.implement(CommandBarTooltip.prototype, EventEmitter);
      dom.importCssString("\n.ace_tooltip.".concat(TOOLTIP_CLASS_NAME, "_wrapper {\n    padding: 0;\n}\n\n.ace_tooltip .").concat(TOOLTIP_CLASS_NAME, " {\n    padding: 1px 5px;\n    display: flex;\n    pointer-events: auto;\n}\n\n.ace_tooltip .").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options {\n    padding: 1px;\n    flex-direction: column;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, " {\n    display: inline-flex;\n    cursor: pointer;\n    margin: 1px;\n    border-radius: 2px;\n    padding: 2px 5px;\n    align-items: center;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, ".ace_selected,\ndiv.").concat(BUTTON_CLASS_NAME, ":hover:not(.ace_disabled) {\n    background-color: rgba(0, 0, 0, 0.1);\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, ".ace_disabled {\n    color: #777;\n    pointer-events: none;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, " .ace_icon_svg {\n    height: 12px;\n    background-color: #000;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, ".ace_disabled .ace_icon_svg {\n    background-color: #777;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options .").concat(BUTTON_CLASS_NAME, " {\n    display: flex;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".").concat(VALUE_CLASS_NAME, " {\n    display: none;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options .").concat(VALUE_CLASS_NAME, " {\n    display: inline-block;\n    width: 12px;\n}\n\n.").concat(CAPTION_CLASS_NAME, " {\n    display: inline-block;\n}\n\n.").concat(KEYBINDING_CLASS_NAME, " {\n    margin: 0 2px;\n    display: inline-block;\n    font-size: 8px;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options .").concat(KEYBINDING_CLASS_NAME, " {\n    margin-left: auto;\n}\n\n.").concat(KEYBINDING_CLASS_NAME, " div {\n    display: inline-block;\n    min-width: 8px;\n    padding: 2px;\n    margin: 0 1px;\n    border-radius: 2px;\n    background-color: #ccc;\n    text-align: center;\n}\n\n.ace_dark.ace_tooltip .").concat(TOOLTIP_CLASS_NAME, " {\n    background-color: #373737;\n    color: #eee;\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ".ace_disabled {\n    color: #979797;\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ".ace_selected,\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ":hover:not(.ace_disabled) {\n    background-color: rgba(255, 255, 255, 0.1);\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, " .ace_icon_svg {\n    background-color: #eee;\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ".ace_disabled .ace_icon_svg {\n    background-color: #979797;\n}\n\n.ace_dark .").concat(BUTTON_CLASS_NAME, ".ace_disabled {\n    color: #979797;\n}\n\n.ace_dark .").concat(KEYBINDING_CLASS_NAME, " div {\n    background-color: #575757;\n}\n\n.ace_checkmark::before {\n    content: '\u2713';\n}\n"), "commandbar.css", false);
      exports2.CommandBarTooltip = CommandBarTooltip;
      exports2.TOOLTIP_CLASS_NAME = TOOLTIP_CLASS_NAME;
      exports2.BUTTON_CLASS_NAME = BUTTON_CLASS_NAME;
    });
    (function() {
      ace.require(["ace/ext/command_bar"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-elastic_tabstops_lite.js
var require_ext_elastic_tabstops_lite = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-elastic_tabstops_lite.js"(exports, module2) {
    ace.define("ace/ext/elastic_tabstops_lite", ["require", "exports", "module", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var ElasticTabstopsLite = (
        /** @class */
        function() {
          function ElasticTabstopsLite2(editor) {
            this.$editor = editor;
            var self2 = this;
            var changedRows = [];
            var recordChanges = false;
            this.onAfterExec = function() {
              recordChanges = false;
              self2.processRows(changedRows);
              changedRows = [];
            };
            this.onExec = function() {
              recordChanges = true;
            };
            this.onChange = function(delta) {
              if (recordChanges) {
                if (changedRows.indexOf(delta.start.row) == -1)
                  changedRows.push(delta.start.row);
                if (delta.end.row != delta.start.row)
                  changedRows.push(delta.end.row);
              }
            };
          }
          ElasticTabstopsLite2.prototype.processRows = function(rows) {
            this.$inChange = true;
            var checkedRows = [];
            for (var r = 0, rowCount = rows.length; r < rowCount; r++) {
              var row = rows[r];
              if (checkedRows.indexOf(row) > -1)
                continue;
              var cellWidthObj = this.$findCellWidthsForBlock(row);
              var cellWidths = this.$setBlockCellWidthsToMax(cellWidthObj.cellWidths);
              var rowIndex = cellWidthObj.firstRow;
              for (var w2 = 0, l = cellWidths.length; w2 < l; w2++) {
                var widths = cellWidths[w2];
                checkedRows.push(rowIndex);
                this.$adjustRow(rowIndex, widths);
                rowIndex++;
              }
            }
            this.$inChange = false;
          };
          ElasticTabstopsLite2.prototype.$findCellWidthsForBlock = function(row) {
            var cellWidths = [], widths;
            var rowIter = row;
            while (rowIter >= 0) {
              widths = this.$cellWidthsForRow(rowIter);
              if (widths.length == 0)
                break;
              cellWidths.unshift(widths);
              rowIter--;
            }
            var firstRow = rowIter + 1;
            rowIter = row;
            var numRows = this.$editor.session.getLength();
            while (rowIter < numRows - 1) {
              rowIter++;
              widths = this.$cellWidthsForRow(rowIter);
              if (widths.length == 0)
                break;
              cellWidths.push(widths);
            }
            return { cellWidths, firstRow };
          };
          ElasticTabstopsLite2.prototype.$cellWidthsForRow = function(row) {
            var selectionColumns = this.$selectionColumnsForRow(row);
            var tabs = [-1].concat(this.$tabsForRow(row));
            var widths = tabs.map(function(el) {
              return 0;
            }).slice(1);
            var line = this.$editor.session.getLine(row);
            for (var i = 0, len = tabs.length - 1; i < len; i++) {
              var leftEdge = tabs[i] + 1;
              var rightEdge = tabs[i + 1];
              var rightmostSelection = this.$rightmostSelectionInCell(selectionColumns, rightEdge);
              var cell = line.substring(leftEdge, rightEdge);
              widths[i] = Math.max(cell.replace(/\s+$/g, "").length, rightmostSelection - leftEdge);
            }
            return widths;
          };
          ElasticTabstopsLite2.prototype.$selectionColumnsForRow = function(row) {
            var selections = [], cursor = this.$editor.getCursorPosition();
            if (this.$editor.session.getSelection().isEmpty()) {
              if (row == cursor.row)
                selections.push(cursor.column);
            }
            return selections;
          };
          ElasticTabstopsLite2.prototype.$setBlockCellWidthsToMax = function(cellWidths) {
            var startingNewBlock = true, blockStartRow, blockEndRow, maxWidth;
            var columnInfo = this.$izip_longest(cellWidths);
            for (var c = 0, l = columnInfo.length; c < l; c++) {
              var column = columnInfo[c];
              if (!column.push) {
                console.error(column);
                continue;
              }
              column.push(NaN);
              for (var r = 0, s = column.length; r < s; r++) {
                var width = column[r];
                if (startingNewBlock) {
                  blockStartRow = r;
                  maxWidth = 0;
                  startingNewBlock = false;
                }
                if (isNaN(width)) {
                  blockEndRow = r;
                  for (var j3 = blockStartRow; j3 < blockEndRow; j3++) {
                    cellWidths[j3][c] = maxWidth;
                  }
                  startingNewBlock = true;
                }
                maxWidth = Math.max(maxWidth, width);
              }
            }
            return cellWidths;
          };
          ElasticTabstopsLite2.prototype.$rightmostSelectionInCell = function(selectionColumns, cellRightEdge) {
            var rightmost = 0;
            if (selectionColumns.length) {
              var lengths = [];
              for (var s = 0, length = selectionColumns.length; s < length; s++) {
                if (selectionColumns[s] <= cellRightEdge)
                  lengths.push(s);
                else
                  lengths.push(0);
              }
              rightmost = Math.max.apply(Math, lengths);
            }
            return rightmost;
          };
          ElasticTabstopsLite2.prototype.$tabsForRow = function(row) {
            var rowTabs = [], line = this.$editor.session.getLine(row), re3 = /\t/g, match;
            while ((match = re3.exec(line)) != null) {
              rowTabs.push(match.index);
            }
            return rowTabs;
          };
          ElasticTabstopsLite2.prototype.$adjustRow = function(row, widths) {
            var rowTabs = this.$tabsForRow(row);
            if (rowTabs.length == 0)
              return;
            var bias = 0, location2 = -1;
            var expandedSet = this.$izip(widths, rowTabs);
            for (var i = 0, l = expandedSet.length; i < l; i++) {
              var w2 = expandedSet[i][0], it3 = expandedSet[i][1];
              location2 += 1 + w2;
              it3 += bias;
              var difference = location2 - it3;
              if (difference == 0)
                continue;
              var partialLine = this.$editor.session.getLine(row).substr(0, it3);
              var strippedPartialLine = partialLine.replace(/\s*$/g, "");
              var ispaces = partialLine.length - strippedPartialLine.length;
              if (difference > 0) {
                this.$editor.session.getDocument().insertInLine({ row, column: it3 + 1 }, Array(difference + 1).join(" ") + "	");
                this.$editor.session.getDocument().removeInLine(row, it3, it3 + 1);
                bias += difference;
              }
              if (difference < 0 && ispaces >= -difference) {
                this.$editor.session.getDocument().removeInLine(row, it3 + difference, it3);
                bias += difference;
              }
            }
          };
          ElasticTabstopsLite2.prototype.$izip_longest = function(iterables) {
            if (!iterables[0])
              return [];
            var longest = iterables[0].length;
            var iterablesLength = iterables.length;
            for (var i = 1; i < iterablesLength; i++) {
              var iLength = iterables[i].length;
              if (iLength > longest)
                longest = iLength;
            }
            var expandedSet = [];
            for (var l = 0; l < longest; l++) {
              var set = [];
              for (var i = 0; i < iterablesLength; i++) {
                if (iterables[i][l] === "")
                  set.push(NaN);
                else
                  set.push(iterables[i][l]);
              }
              expandedSet.push(set);
            }
            return expandedSet;
          };
          ElasticTabstopsLite2.prototype.$izip = function(widths, tabs) {
            var size = widths.length >= tabs.length ? tabs.length : widths.length;
            var expandedSet = [];
            for (var i = 0; i < size; i++) {
              var set = [widths[i], tabs[i]];
              expandedSet.push(set);
            }
            return expandedSet;
          };
          return ElasticTabstopsLite2;
        }()
      );
      exports2.ElasticTabstopsLite = ElasticTabstopsLite;
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        useElasticTabstops: {
          set: function(val) {
            if (val) {
              if (!this.elasticTabstops)
                this.elasticTabstops = new ElasticTabstopsLite(this);
              this.commands.on("afterExec", this.elasticTabstops.onAfterExec);
              this.commands.on("exec", this.elasticTabstops.onExec);
              this.on("change", this.elasticTabstops.onChange);
            } else if (this.elasticTabstops) {
              this.commands.removeListener("afterExec", this.elasticTabstops.onAfterExec);
              this.commands.removeListener("exec", this.elasticTabstops.onExec);
              this.removeListener("change", this.elasticTabstops.onChange);
            }
          }
        }
      });
    });
    (function() {
      ace.require(["ace/ext/elastic_tabstops_lite"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-error_marker.js
var require_ext_error_marker = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-error_marker.js"(exports, module2) {
    (function() {
      ace.require(["ace/ext/error_marker"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-hardwrap.js
var require_ext_hardwrap = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-hardwrap.js"(exports, module2) {
    ace.define("ace/ext/hardwrap", ["require", "exports", "module", "ace/range", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("../range").Range;
      function hardWrap(editor, options) {
        var max = options.column || editor.getOption("printMarginColumn");
        var allowMerge = options.allowMerge != false;
        var row = Math.min(options.startRow, options.endRow);
        var endRow = Math.max(options.startRow, options.endRow);
        var session = editor.session;
        while (row <= endRow) {
          var line = session.getLine(row);
          if (line.length > max) {
            var space = findSpace(line, max, 5);
            if (space) {
              var indentation = /^\s*/.exec(line)[0];
              session.replace(new Range(row, space.start, row, space.end), "\n" + indentation);
            }
            endRow++;
          } else if (allowMerge && /\S/.test(line) && row != endRow) {
            var nextLine = session.getLine(row + 1);
            if (nextLine && /\S/.test(nextLine)) {
              var trimmedLine = line.replace(/\s+$/, "");
              var trimmedNextLine = nextLine.replace(/^\s+/, "");
              var mergedLine = trimmedLine + " " + trimmedNextLine;
              var space = findSpace(mergedLine, max, 5);
              if (space && space.start > trimmedLine.length || mergedLine.length < max) {
                var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);
                session.replace(replaceRange, " ");
                row--;
                endRow--;
              } else if (trimmedLine.length < line.length) {
                session.remove(new Range(row, trimmedLine.length, row, line.length));
              }
            }
          }
          row++;
        }
        function findSpace(line2, max2, min2) {
          if (line2.length < max2)
            return;
          var before = line2.slice(0, max2);
          var after = line2.slice(max2);
          var spaceAfter = /^(?:(\s+)|(\S+)(\s+))/.exec(after);
          var spaceBefore = /(?:(\s+)|(\s+)(\S+))$/.exec(before);
          var start = 0;
          var end = 0;
          if (spaceBefore && !spaceBefore[2]) {
            start = max2 - spaceBefore[1].length;
            end = max2;
          }
          if (spaceAfter && !spaceAfter[2]) {
            if (!start)
              start = max2;
            end = max2 + spaceAfter[1].length;
          }
          if (start) {
            return {
              start,
              end
            };
          }
          if (spaceBefore && spaceBefore[2] && spaceBefore.index > min2) {
            return {
              start: spaceBefore.index,
              end: spaceBefore.index + spaceBefore[2].length
            };
          }
          if (spaceAfter && spaceAfter[2]) {
            start = max2 + spaceAfter[2].length;
            return {
              start,
              end: start + spaceAfter[3].length
            };
          }
        }
      }
      function wrapAfterInput(e) {
        if (e.command.name == "insertstring" && /\S/.test(e.args)) {
          var editor = e.editor;
          var cursor = editor.selection.cursor;
          if (cursor.column <= editor.renderer.$printMarginColumn)
            return;
          var lastDelta = editor.session.$undoManager.$lastDelta;
          hardWrap(editor, {
            startRow: cursor.row,
            endRow: cursor.row,
            allowMerge: false
          });
          if (lastDelta != editor.session.$undoManager.$lastDelta)
            editor.session.markUndoGroup();
        }
      }
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        hardWrap: {
          set: function(val) {
            if (val) {
              this.commands.on("afterExec", wrapAfterInput);
            } else {
              this.commands.off("afterExec", wrapAfterInput);
            }
          },
          value: false
        }
      });
      exports2.hardWrap = hardWrap;
    });
    (function() {
      ace.require(["ace/ext/hardwrap"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-inline_autocomplete.js
var require_ext_inline_autocomplete = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-inline_autocomplete.js"(exports, module2) {
    ace.define("ace/snippets", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/range_list", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/clipboard", "ace/editor"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("./lib/dom");
      var oop = require3("./lib/oop");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var lang = require3("./lib/lang");
      var Range = require3("./range").Range;
      var RangeList = require3("./range_list").RangeList;
      var HashHandler = require3("./keyboard/hash_handler").HashHandler;
      var Tokenizer = require3("./tokenizer").Tokenizer;
      var clipboard = require3("./clipboard");
      var VARIABLES = {
        CURRENT_WORD: function(editor) {
          return editor.session.getTextRange(editor.session.getWordRange());
        },
        SELECTION: function(editor, name, indentation) {
          var text = editor.session.getTextRange();
          if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, "\n" + indentation + "$1");
          return text;
        },
        CURRENT_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row);
        },
        PREV_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row - 1);
        },
        LINE_INDEX: function(editor) {
          return editor.getCursorPosition().row;
        },
        LINE_NUMBER: function(editor) {
          return editor.getCursorPosition().row + 1;
        },
        SOFT_TABS: function(editor) {
          return editor.session.getUseSoftTabs() ? "YES" : "NO";
        },
        TAB_SIZE: function(editor) {
          return editor.session.getTabSize();
        },
        CLIPBOARD: function(editor) {
          return clipboard.getText && clipboard.getText();
        },
        FILENAME: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
        },
        FILENAME_BASE: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, "");
        },
        DIRECTORY: function(editor) {
          return this.FILEPATH(editor).replace(/[^/\\]*$/, "");
        },
        FILEPATH: function(editor) {
          return "/not implemented.txt";
        },
        WORKSPACE_NAME: function() {
          return "Unknown";
        },
        FULLNAME: function() {
          return "Unknown";
        },
        BLOCK_COMMENT_START: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.start || "";
        },
        BLOCK_COMMENT_END: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.end || "";
        },
        LINE_COMMENT: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.lineCommentStart || "";
        },
        CURRENT_YEAR: date.bind(null, { year: "numeric" }),
        CURRENT_YEAR_SHORT: date.bind(null, { year: "2-digit" }),
        CURRENT_MONTH: date.bind(null, { month: "numeric" }),
        CURRENT_MONTH_NAME: date.bind(null, { month: "long" }),
        CURRENT_MONTH_NAME_SHORT: date.bind(null, { month: "short" }),
        CURRENT_DATE: date.bind(null, { day: "2-digit" }),
        CURRENT_DAY_NAME: date.bind(null, { weekday: "long" }),
        CURRENT_DAY_NAME_SHORT: date.bind(null, { weekday: "short" }),
        CURRENT_HOUR: date.bind(null, { hour: "2-digit", hour12: false }),
        CURRENT_MINUTE: date.bind(null, { minute: "2-digit" }),
        CURRENT_SECOND: date.bind(null, { second: "2-digit" })
      };
      VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;
      function date(dateFormat) {
        var str = (/* @__PURE__ */ new Date()).toLocaleString("en-us", dateFormat);
        return str.length == 1 ? "0" + str : str;
      }
      var SnippetManager = (
        /** @class */
        function() {
          function SnippetManager2() {
            this.snippetMap = {};
            this.snippetNameMap = {};
            this.variables = VARIABLES;
          }
          SnippetManager2.prototype.getTokenizer = function() {
            return SnippetManager2["$tokenizer"] || this.createTokenizer();
          };
          SnippetManager2.prototype.createTokenizer = function() {
            function TabstopToken(str) {
              str = str.substr(1);
              if (/^\d+$/.test(str))
                return [{ tabstopId: parseInt(str, 10) }];
              return [{ text: str }];
            }
            function escape(ch) {
              return "(?:[^\\\\" + ch + "]|\\\\.)";
            }
            var formatMatcher = {
              regex: "/(" + escape("/") + "+)/",
              onMatch: function(val, state, stack) {
                var ts2 = stack[0];
                ts2.fmtString = true;
                ts2.guard = val.slice(1, -1);
                ts2.flag = "";
                return "";
              },
              next: "formatString"
            };
            SnippetManager2["$tokenizer"] = new Tokenizer({
              start: [
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length) {
                    val = ch;
                  } else if ("`$\\".indexOf(ch) != -1) {
                    val = ch;
                  }
                  return [val];
                } },
                { regex: /}/, onMatch: function(val, state, stack) {
                  return [stack.length ? stack.shift() : val];
                } },
                { regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken },
                { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                  var t = TabstopToken(str.substr(1));
                  stack.unshift(t[0]);
                  return t;
                }, next: "snippetVar" },
                { regex: /\n/, token: "newline", merge: false }
              ],
              snippetVar: [
                { regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                  var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function(operator) {
                    return operator.length == 2 ? operator[1] : "\0";
                  }).split("\0").map(function(value) {
                    return { value };
                  });
                  stack[0].choices = choices;
                  return [choices[0]];
                }, next: "start" },
                formatMatcher,
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start" }
              ],
              formatString: [
                { regex: /:/, onMatch: function(val, state, stack) {
                  if (stack.length && stack[0].expectElse) {
                    stack[0].expectElse = false;
                    stack[0].ifEnd = { elseEnd: stack[0] };
                    return [stack[0].ifEnd];
                  }
                  return ":";
                } },
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length)
                    val = ch;
                  else if ("`$\\".indexOf(ch) != -1)
                    val = ch;
                  else if (ch == "n")
                    val = "\n";
                  else if (ch == "t")
                    val = "	";
                  else if ("ulULE".indexOf(ch) != -1)
                    val = { changeCase: ch, local: ch > "a" };
                  return [val];
                } },
                { regex: "/\\w*}", onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  if (next)
                    next.flag = val.slice(1, -1);
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" },
                { regex: /\$(?:\d+|\w+)/, onMatch: function(val, state, stack) {
                  return [{ text: val.slice(1) }];
                } },
                { regex: /\${\w+/, onMatch: function(val, state, stack) {
                  var token = { text: val.slice(2) };
                  stack.unshift(token);
                  return [token];
                }, next: "formatStringVar" },
                { regex: /\n/, token: "newline", merge: false },
                { regex: /}/, onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" }
              ],
              formatStringVar: [
                { regex: /:\/\w+}/, onMatch: function(val, state, stack) {
                  var ts2 = stack[0];
                  ts2.formatFunction = val.slice(2, -1);
                  return [stack.shift()];
                }, next: "formatString" },
                formatMatcher,
                { regex: /:[\?\-+]?/, onMatch: function(val, state, stack) {
                  if (val[1] == "+")
                    stack[0].ifEnd = stack[0];
                  if (val[1] == "?")
                    stack[0].expectElse = true;
                }, next: "formatString" },
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString" }
              ]
            });
            return SnippetManager2["$tokenizer"];
          };
          SnippetManager2.prototype.tokenizeTmSnippet = function(str, startState) {
            return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
              return x.value || x;
            });
          };
          SnippetManager2.prototype.getVariableValue = function(editor, name, indentation) {
            if (/^\d+$/.test(name))
              return (this.variables.__ || {})[name] || "";
            if (/^[A-Z]\d+$/.test(name))
              return (this.variables[name[0] + "__"] || {})[name.substr(1)] || "";
            name = name.replace(/^TM_/, "");
            if (!this.variables.hasOwnProperty(name))
              return "";
            var value = this.variables[name];
            if (typeof value == "function")
              value = this.variables[name](editor, name, indentation);
            return value == null ? "" : value;
          };
          SnippetManager2.prototype.tmStrFormat = function(str, ch, editor) {
            if (!ch.fmt)
              return str;
            var flag = ch.flag || "";
            var re3 = ch.guard;
            re3 = new RegExp(re3, flag.replace(/[^gim]/g, ""));
            var fmtTokens = typeof ch.fmt == "string" ? this.tokenizeTmSnippet(ch.fmt, "formatString") : ch.fmt;
            var _self = this;
            var formatted = str.replace(re3, function() {
              var oldArgs = _self.variables.__;
              _self.variables.__ = [].slice.call(arguments);
              var fmtParts = _self.resolveVariables(fmtTokens, editor);
              var gChangeCase = "E";
              for (var i = 0; i < fmtParts.length; i++) {
                var ch2 = fmtParts[i];
                if (typeof ch2 == "object") {
                  fmtParts[i] = "";
                  if (ch2.changeCase && ch2.local) {
                    var next = fmtParts[i + 1];
                    if (next && typeof next == "string") {
                      if (ch2.changeCase == "u")
                        fmtParts[i] = next[0].toUpperCase();
                      else
                        fmtParts[i] = next[0].toLowerCase();
                      fmtParts[i + 1] = next.substr(1);
                    }
                  } else if (ch2.changeCase) {
                    gChangeCase = ch2.changeCase;
                  }
                } else if (gChangeCase == "U") {
                  fmtParts[i] = ch2.toUpperCase();
                } else if (gChangeCase == "L") {
                  fmtParts[i] = ch2.toLowerCase();
                }
              }
              _self.variables.__ = oldArgs;
              return fmtParts.join("");
            });
            return formatted;
          };
          SnippetManager2.prototype.tmFormatFunction = function(str, ch, editor) {
            if (ch.formatFunction == "upcase")
              return str.toUpperCase();
            if (ch.formatFunction == "downcase")
              return str.toLowerCase();
            return str;
          };
          SnippetManager2.prototype.resolveVariables = function(snippet, editor) {
            var result = [];
            var indentation = "";
            var afterNewLine = true;
            for (var i = 0; i < snippet.length; i++) {
              var ch = snippet[i];
              if (typeof ch == "string") {
                result.push(ch);
                if (ch == "\n") {
                  afterNewLine = true;
                  indentation = "";
                } else if (afterNewLine) {
                  indentation = /^\t*/.exec(ch)[0];
                  afterNewLine = /\S/.test(ch);
                }
                continue;
              }
              if (!ch)
                continue;
              afterNewLine = false;
              if (ch.fmtString) {
                var j3 = snippet.indexOf(ch, i + 1);
                if (j3 == -1)
                  j3 = snippet.length;
                ch.fmt = snippet.slice(i + 1, j3);
                i = j3;
              }
              if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + "";
                if (ch.fmtString)
                  value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                  value = this.tmFormatFunction(value, ch, editor);
                if (value && !ch.ifEnd) {
                  result.push(value);
                  gotoNext(ch);
                } else if (!value && ch.ifEnd) {
                  gotoNext(ch.ifEnd);
                }
              } else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
              } else if (ch.tabstopId != null) {
                result.push(ch);
              } else if (ch.changeCase != null) {
                result.push(ch);
              }
            }
            function gotoNext(ch2) {
              var i1 = snippet.indexOf(ch2, i + 1);
              if (i1 != -1)
                i = i1;
            }
            return result;
          };
          SnippetManager2.prototype.getDisplayTextForSnippet = function(editor, snippetText) {
            var processedSnippet = processSnippetText.call(this, editor, snippetText);
            return processedSnippet.text;
          };
          SnippetManager2.prototype.insertSnippetForSelection = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var processedSnippet = processSnippetText.call(this, editor, snippetText, options);
            var range = editor.getSelectionRange();
            var end = editor.session.replace(range, processedSnippet.text);
            var tabstopManager = new TabstopManager(editor);
            var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
            tabstopManager.addTabstops(processedSnippet.tabstops, range.start, end, selectionId);
          };
          SnippetManager2.prototype.insertSnippet = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var self2 = this;
            if (editor.inVirtualSelectionMode)
              return self2.insertSnippetForSelection(editor, snippetText, options);
            editor.forEachSelection(function() {
              self2.insertSnippetForSelection(editor, snippetText, options);
            }, null, { keepOrder: true });
            if (editor.tabstopManager)
              editor.tabstopManager.tabNext();
          };
          SnippetManager2.prototype.$getScope = function(editor) {
            var scope = editor.session.$mode.$id || "";
            scope = scope.split("/").pop();
            if (scope === "html" || scope === "php") {
              if (scope === "php" && !editor.session.$mode.inlinePhp)
                scope = "html";
              var c = editor.getCursorPosition();
              var state = editor.session.getState(c.row);
              if (typeof state === "object") {
                state = state[0];
              }
              if (state.substring) {
                if (state.substring(0, 3) == "js-")
                  scope = "javascript";
                else if (state.substring(0, 4) == "css-")
                  scope = "css";
                else if (state.substring(0, 4) == "php-")
                  scope = "php";
              }
            }
            return scope;
          };
          SnippetManager2.prototype.getActiveScopes = function(editor) {
            var scope = this.$getScope(editor);
            var scopes = [scope];
            var snippetMap = this.snippetMap;
            if (snippetMap[scope] && snippetMap[scope].includeScopes) {
              scopes.push.apply(scopes, snippetMap[scope].includeScopes);
            }
            scopes.push("_");
            return scopes;
          };
          SnippetManager2.prototype.expandWithTab = function(editor, options) {
            var self2 = this;
            var result = editor.forEachSelection(function() {
              return self2.expandSnippetForSelection(editor, options);
            }, null, { keepOrder: true });
            if (result && editor.tabstopManager)
              editor.tabstopManager.tabNext();
            return result;
          };
          SnippetManager2.prototype.expandSnippetForSelection = function(editor, options) {
            var cursor = editor.getCursorPosition();
            var line = editor.session.getLine(cursor.row);
            var before = line.substring(0, cursor.column);
            var after = line.substr(cursor.column);
            var snippetMap = this.snippetMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
              return !!snippet;
            }, this);
            if (!snippet)
              return false;
            if (options && options.dryRun)
              return true;
            editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
            this.variables.M__ = snippet.matchBefore;
            this.variables.T__ = snippet.matchAfter;
            this.insertSnippetForSelection(editor, snippet.content);
            this.variables.M__ = this.variables.T__ = null;
            return true;
          };
          SnippetManager2.prototype.findMatchingSnippet = function(snippetList, before, after) {
            for (var i = snippetList.length; i--; ) {
              var s = snippetList[i];
              if (s.startRe && !s.startRe.test(before))
                continue;
              if (s.endRe && !s.endRe.test(after))
                continue;
              if (!s.startRe && !s.endRe)
                continue;
              s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
              s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
              s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
              s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
              return s;
            }
          };
          SnippetManager2.prototype.register = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            var self2 = this;
            if (!snippets)
              snippets = [];
            function wrapRegexp(src) {
              if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = "(?:" + src + ")";
              return src || "";
            }
            function guardedRegexp(re3, guard, opening) {
              re3 = wrapRegexp(re3);
              guard = wrapRegexp(guard);
              if (opening) {
                re3 = guard + re3;
                if (re3 && re3[re3.length - 1] != "$")
                  re3 = re3 + "$";
              } else {
                re3 = re3 + guard;
                if (re3 && re3[0] != "^")
                  re3 = "^" + re3;
              }
              return new RegExp(re3);
            }
            function addSnippet(s) {
              if (!s.scope)
                s.scope = scope || "_";
              scope = s.scope;
              if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
              }
              var map = snippetNameMap[scope];
              if (s.name) {
                var old = map[s.name];
                if (old)
                  self2.unregister(old);
                map[s.name] = s;
              }
              snippetMap[scope].push(s);
              if (s.prefix)
                s.tabTrigger = s.prefix;
              if (!s.content && s.body)
                s.content = Array.isArray(s.body) ? s.body.join("\n") : s.body;
              if (s.tabTrigger && !s.trigger) {
                if (!s.guard && /^\w/.test(s.tabTrigger))
                  s.guard = "\\b";
                s.trigger = lang.escapeRegExp(s.tabTrigger);
              }
              if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)
                return;
              s.startRe = guardedRegexp(s.trigger, s.guard, true);
              s.triggerRe = new RegExp(s.trigger);
              s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
              s.endTriggerRe = new RegExp(s.endTrigger);
            }
            if (Array.isArray(snippets)) {
              snippets.forEach(addSnippet);
            } else {
              Object.keys(snippets).forEach(function(key) {
                addSnippet(snippets[key]);
              });
            }
            this._signal("registerSnippets", { scope });
          };
          SnippetManager2.prototype.unregister = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            function removeSnippet(s) {
              var nameMap = snippetNameMap[s.scope || scope];
              if (nameMap && nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope || scope];
                var i = map && map.indexOf(s);
                if (i >= 0)
                  map.splice(i, 1);
              }
            }
            if (snippets.content)
              removeSnippet(snippets);
            else if (Array.isArray(snippets))
              snippets.forEach(removeSnippet);
          };
          SnippetManager2.prototype.parseSnippetFile = function(str) {
            str = str.replace(/\r/g, "");
            var list = [], snippet = {};
            var re3 = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
            var m;
            while (m = re3.exec(str)) {
              if (m[1]) {
                try {
                  snippet = JSON.parse(m[1]);
                  list.push(snippet);
                } catch (e) {
                }
              }
              if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, "");
                list.push(snippet);
                snippet = {};
              } else {
                var key = m[2], val = m[3];
                if (key == "regex") {
                  var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                  snippet.guard = guardRe.exec(val)[1];
                  snippet.trigger = guardRe.exec(val)[1];
                  snippet.endTrigger = guardRe.exec(val)[1];
                  snippet.endGuard = guardRe.exec(val)[1];
                } else if (key == "snippet") {
                  snippet.tabTrigger = val.match(/^\S*/)[0];
                  if (!snippet.name)
                    snippet.name = val;
                } else if (key) {
                  snippet[key] = val;
                }
              }
            }
            return list;
          };
          SnippetManager2.prototype.getSnippetByName = function(name, editor) {
            var snippetMap = this.snippetNameMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = snippets[name];
              return !!snippet;
            }, this);
            return snippet;
          };
          return SnippetManager2;
        }()
      );
      oop.implement(SnippetManager.prototype, EventEmitter);
      var processSnippetText = function(editor, snippetText, options) {
        if (options === void 0) {
          options = {};
        }
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var tabString = editor.session.getTabString();
        var indentString = line.match(/^\s*/)[0];
        if (cursor.column < indentString.length)
          indentString = indentString.slice(0, cursor.column);
        snippetText = snippetText.replace(/\r/g, "");
        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function(x) {
          if (x == "\n" && !options.excludeExtraIndent)
            return x + indentString;
          if (typeof x == "string")
            return x.replace(/\t/g, tabString);
          return x;
        });
        var tabstops = [];
        tokens.forEach(function(p2, i2) {
          if (typeof p2 != "object")
            return;
          var id2 = p2.tabstopId;
          var ts3 = tabstops[id2];
          if (!ts3) {
            ts3 = tabstops[id2] = [];
            ts3.index = id2;
            ts3.value = "";
            ts3.parents = {};
          }
          if (ts3.indexOf(p2) !== -1)
            return;
          if (p2.choices && !ts3.choices)
            ts3.choices = p2.choices;
          ts3.push(p2);
          var i12 = tokens.indexOf(p2, i2 + 1);
          if (i12 === -1)
            return;
          var value2 = tokens.slice(i2 + 1, i12);
          var isNested = value2.some(function(t) {
            return typeof t === "object";
          });
          if (isNested && !ts3.value) {
            ts3.value = value2;
          } else if (value2.length && (!ts3.value || typeof ts3.value !== "string")) {
            ts3.value = value2.join("");
          }
        });
        tabstops.forEach(function(ts3) {
          ts3.length = 0;
        });
        var expanding = {};
        function copyValue(val) {
          var copy = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            var p2 = val[i2];
            if (typeof p2 == "object") {
              if (expanding[p2.tabstopId])
                continue;
              var j3 = val.lastIndexOf(p2, i2 - 1);
              p2 = copy[j3] || { tabstopId: p2.tabstopId };
            }
            copy[i2] = p2;
          }
          return copy;
        }
        for (var i = 0; i < tokens.length; i++) {
          var p = tokens[i];
          if (typeof p != "object")
            continue;
          var id = p.tabstopId;
          var ts2 = tabstops[id];
          var i1 = tokens.indexOf(p, i + 1);
          if (expanding[id]) {
            if (expanding[id] === p) {
              delete expanding[id];
              Object.keys(expanding).forEach(function(parentId) {
                ts2.parents[parentId] = true;
              });
            }
            continue;
          }
          expanding[id] = p;
          var value = ts2.value;
          if (typeof value !== "string")
            value = copyValue(value);
          else if (p.fmt)
            value = this.tmStrFormat(value, p, editor);
          tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));
          if (ts2.indexOf(p) === -1)
            ts2.push(p);
        }
        var row = 0, column = 0;
        var text = "";
        tokens.forEach(function(t) {
          if (typeof t === "string") {
            var lines = t.split("\n");
            if (lines.length > 1) {
              column = lines[lines.length - 1].length;
              row += lines.length - 1;
            } else
              column += t.length;
            text += t;
          } else if (t) {
            if (!t.start)
              t.start = { row, column };
            else
              t.end = { row, column };
          }
        });
        return {
          text,
          tabstops,
          tokens
        };
      };
      var TabstopManager = (
        /** @class */
        function() {
          function TabstopManager2(editor) {
            this.index = 0;
            this.ranges = [];
            this.tabstops = [];
            if (editor.tabstopManager)
              return editor.tabstopManager;
            editor.tabstopManager = this;
            this.$onChange = this.onChange.bind(this);
            this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
            this.$onChangeSession = this.onChangeSession.bind(this);
            this.$onAfterExec = this.onAfterExec.bind(this);
            this.attach(editor);
          }
          TabstopManager2.prototype.attach = function(editor) {
            this.$openTabstops = null;
            this.selectedTabstop = null;
            this.editor = editor;
            this.session = editor.session;
            this.editor.on("change", this.$onChange);
            this.editor.on("changeSelection", this.$onChangeSelection);
            this.editor.on("changeSession", this.$onChangeSession);
            this.editor.commands.on("afterExec", this.$onAfterExec);
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
          };
          TabstopManager2.prototype.detach = function() {
            this.tabstops.forEach(this.removeTabstopMarkers, this);
            this.ranges.length = 0;
            this.tabstops.length = 0;
            this.selectedTabstop = null;
            this.editor.off("change", this.$onChange);
            this.editor.off("changeSelection", this.$onChangeSelection);
            this.editor.off("changeSession", this.$onChangeSession);
            this.editor.commands.off("afterExec", this.$onAfterExec);
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.tabstopManager = null;
            this.session = null;
            this.editor = null;
          };
          TabstopManager2.prototype.onChange = function(delta) {
            var isRemove = delta.action[0] == "r";
            var selectedTabstop = this.selectedTabstop || {};
            var parents = selectedTabstop.parents || {};
            var tabstops = this.tabstops.slice();
            for (var i = 0; i < tabstops.length; i++) {
              var ts2 = tabstops[i];
              var active = ts2 == selectedTabstop || parents[ts2.index];
              ts2.rangeList.$bias = active ? 0 : 1;
              if (delta.action == "remove" && ts2 !== selectedTabstop) {
                var parentActive = ts2.parents && ts2.parents[selectedTabstop.index];
                var startIndex = ts2.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts2.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts2.rangeList.ranges.slice(startIndex, endIndex);
                for (var j3 = 0; j3 < toRemove.length; j3++)
                  this.removeRange(toRemove[j3]);
              }
              ts2.rangeList.$onChange(delta);
            }
            var session = this.session;
            if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())
              this.detach();
          };
          TabstopManager2.prototype.updateLinkedFields = function() {
            var ts2 = this.selectedTabstop;
            if (!ts2 || !ts2.hasLinkedRanges || !ts2.firstNonLinked)
              return;
            this.$inChange = true;
            var session = this.session;
            var text = session.getTextRange(ts2.firstNonLinked);
            for (var i = 0; i < ts2.length; i++) {
              var range = ts2[i];
              if (!range.linked)
                continue;
              var original = range.original;
              var fmt = exports2.snippetManager.tmStrFormat(text, original, this.editor);
              session.replace(range, fmt);
            }
            this.$inChange = false;
          };
          TabstopManager2.prototype.onAfterExec = function(e) {
            if (e.command && !e.command.readOnly)
              this.updateLinkedFields();
          };
          TabstopManager2.prototype.onChangeSelection = function() {
            if (!this.editor)
              return;
            var lead = this.editor.selection.lead;
            var anchor = this.editor.selection.anchor;
            var isEmpty = this.editor.selection.isEmpty();
            for (var i = 0; i < this.ranges.length; i++) {
              if (this.ranges[i].linked)
                continue;
              var containsLead = this.ranges[i].contains(lead.row, lead.column);
              var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
              if (containsLead && containsAnchor)
                return;
            }
            this.detach();
          };
          TabstopManager2.prototype.onChangeSession = function() {
            this.detach();
          };
          TabstopManager2.prototype.tabNext = function(dir) {
            var max = this.tabstops.length;
            var index = this.index + (dir || 1);
            index = Math.min(Math.max(index, 1), max);
            if (index == max)
              index = 0;
            this.selectTabstop(index);
            this.updateTabstopMarkers();
            if (index === 0) {
              this.detach();
            }
          };
          TabstopManager2.prototype.selectTabstop = function(index) {
            this.$openTabstops = null;
            var ts2 = this.tabstops[this.index];
            if (ts2)
              this.addTabstopMarkers(ts2);
            this.index = index;
            ts2 = this.tabstops[this.index];
            if (!ts2 || !ts2.length)
              return;
            this.selectedTabstop = ts2;
            var range = ts2.firstNonLinked || ts2;
            if (ts2.choices)
              range.cursor = range.start;
            if (!this.editor.inVirtualSelectionMode) {
              var sel = this.editor.multiSelect;
              sel.toSingleRange(range);
              for (var i = 0; i < ts2.length; i++) {
                if (ts2.hasLinkedRanges && ts2[i].linked)
                  continue;
                sel.addRange(ts2[i].clone(), true);
              }
            } else {
              this.editor.selection.fromOrientedRange(range);
            }
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            if (this.selectedTabstop && this.selectedTabstop.choices)
              this.editor.execCommand("startAutocomplete", { matches: this.selectedTabstop.choices });
          };
          TabstopManager2.prototype.addTabstops = function(tabstops, start, end) {
            var useLink = this.useLink || !this.editor.getOption("enableMultiselect");
            if (!this.$openTabstops)
              this.$openTabstops = [];
            if (!tabstops[0]) {
              var p = Range.fromPoints(end, end);
              moveRelative(p.start, start);
              moveRelative(p.end, start);
              tabstops[0] = [p];
              tabstops[0].index = 0;
            }
            var i = this.index;
            var arg = [i + 1, 0];
            var ranges = this.ranges;
            var snippetId = this.snippetId = (this.snippetId || 0) + 1;
            tabstops.forEach(function(ts2, index) {
              var dest = this.$openTabstops[index] || ts2;
              dest.snippetId = snippetId;
              for (var i2 = 0; i2 < ts2.length; i2++) {
                var p2 = ts2[i2];
                var range = Range.fromPoints(p2.start, p2.end || p2.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p2;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts2)
                  dest.unshift(range);
                else
                  dest[i2] = range;
                if (p2.fmtString || dest.firstNonLinked && useLink) {
                  range.linked = true;
                  dest.hasLinkedRanges = true;
                } else if (!dest.firstNonLinked)
                  dest.firstNonLinked = range;
              }
              if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
              if (dest === ts2) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
              }
              this.addTabstopMarkers(dest);
              dest.rangeList = dest.rangeList || new RangeList();
              dest.rangeList.$bias = 0;
              dest.rangeList.addList(dest);
            }, this);
            if (arg.length > 2) {
              if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
              this.tabstops.splice.apply(this.tabstops, arg);
            }
          };
          TabstopManager2.prototype.addTabstopMarkers = function(ts2) {
            var session = this.session;
            ts2.forEach(function(range) {
              if (!range.markerId)
                range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
            });
          };
          TabstopManager2.prototype.removeTabstopMarkers = function(ts2) {
            var session = this.session;
            ts2.forEach(function(range) {
              session.removeMarker(range.markerId);
              range.markerId = null;
            });
          };
          TabstopManager2.prototype.updateTabstopMarkers = function() {
            if (!this.selectedTabstop)
              return;
            var currentSnippetId = this.selectedTabstop.snippetId;
            if (this.selectedTabstop.index === 0) {
              currentSnippetId--;
            }
            this.tabstops.forEach(function(ts2) {
              if (ts2.snippetId === currentSnippetId)
                this.addTabstopMarkers(ts2);
              else
                this.removeTabstopMarkers(ts2);
            }, this);
          };
          TabstopManager2.prototype.removeRange = function(range) {
            var i = range.tabstop.indexOf(range);
            if (i != -1)
              range.tabstop.splice(i, 1);
            i = this.ranges.indexOf(range);
            if (i != -1)
              this.ranges.splice(i, 1);
            i = range.tabstop.rangeList.ranges.indexOf(range);
            if (i != -1)
              range.tabstop.splice(i, 1);
            this.session.removeMarker(range.markerId);
            if (!range.tabstop.length) {
              i = this.tabstops.indexOf(range.tabstop);
              if (i != -1)
                this.tabstops.splice(i, 1);
              if (!this.tabstops.length)
                this.detach();
            }
          };
          return TabstopManager2;
        }()
      );
      TabstopManager.prototype.keyboardHandler = new HashHandler();
      TabstopManager.prototype.keyboardHandler.bindKeys({
        "Tab": function(editor) {
          if (exports2.snippetManager && exports2.snippetManager.expandWithTab(editor))
            return;
          editor.tabstopManager.tabNext(1);
          editor.renderer.scrollCursorIntoView();
        },
        "Shift-Tab": function(editor) {
          editor.tabstopManager.tabNext(-1);
          editor.renderer.scrollCursorIntoView();
        },
        "Esc": function(editor) {
          editor.tabstopManager.detach();
        }
      });
      var movePoint = function(point, diff) {
        if (point.row == 0)
          point.column += diff.column;
        point.row += diff.row;
      };
      var moveRelative = function(point, start) {
        if (point.row == start.row)
          point.column -= start.column;
        point.row -= start.row;
      };
      dom.importCssString("\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}", "snippets.css", false);
      exports2.snippetManager = new SnippetManager();
      var Editor = require3("./editor").Editor;
      (function() {
        this.insertSnippet = function(content, options) {
          return exports2.snippetManager.insertSnippet(this, content, options);
        };
        this.expandSnippet = function(options) {
          return exports2.snippetManager.expandWithTab(this, options);
        };
      }).call(Editor.prototype);
    });
    ace.define("ace/autocomplete/inline_screenreader", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var AceInlineScreenReader = (
        /** @class */
        function() {
          function AceInlineScreenReader2(editor) {
            this.editor = editor;
            this.screenReaderDiv = document.createElement("div");
            this.screenReaderDiv.classList.add("ace_screenreader-only");
            this.editor.container.appendChild(this.screenReaderDiv);
          }
          AceInlineScreenReader2.prototype.setScreenReaderContent = function(content) {
            if (!this.popup && this.editor.completer && /**@type{import("../autocomplete").Autocomplete}*/
            this.editor.completer.popup) {
              this.popup = /**@type{import("../autocomplete").Autocomplete}*/
              this.editor.completer.popup;
              this.popup.renderer.on("afterRender", function() {
                var row = this.popup.getRow();
                var t = this.popup.renderer.$textLayer;
                var selected = t.element.childNodes[row - t.config.firstRow];
                if (selected) {
                  var idString = "doc-tooltip ";
                  for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
                    idString += "ace-inline-screenreader-line-".concat(lineIndex, " ");
                  }
                  selected.setAttribute("aria-describedby", idString);
                }
              }.bind(this));
            }
            while (this.screenReaderDiv.firstChild) {
              this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);
            }
            this._lines = content.split(/\r\n|\r|\n/);
            var codeElement = this.createCodeBlock();
            this.screenReaderDiv.appendChild(codeElement);
          };
          AceInlineScreenReader2.prototype.destroy = function() {
            this.screenReaderDiv.remove();
          };
          AceInlineScreenReader2.prototype.createCodeBlock = function() {
            var container = document.createElement("pre");
            container.setAttribute("id", "ace-inline-screenreader");
            for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
              var codeElement = document.createElement("code");
              codeElement.setAttribute("id", "ace-inline-screenreader-line-".concat(lineIndex));
              var line = document.createTextNode(this._lines[lineIndex]);
              codeElement.appendChild(line);
              container.appendChild(codeElement);
            }
            return container;
          };
          return AceInlineScreenReader2;
        }()
      );
      exports2.AceInlineScreenReader = AceInlineScreenReader;
    });
    ace.define("ace/autocomplete/inline", ["require", "exports", "module", "ace/snippets", "ace/autocomplete/inline_screenreader"], function(require3, exports2, module3) {
      "use strict";
      var snippetManager = require3("../snippets").snippetManager;
      var AceInlineScreenReader = require3("./inline_screenreader").AceInlineScreenReader;
      var AceInline = (
        /** @class */
        function() {
          function AceInline2() {
            this.editor = null;
          }
          AceInline2.prototype.show = function(editor, completion, prefix) {
            prefix = prefix || "";
            if (editor && this.editor && this.editor !== editor) {
              this.hide();
              this.editor = null;
              this.inlineScreenReader = null;
            }
            if (!editor || !completion) {
              return false;
            }
            if (!this.inlineScreenReader) {
              this.inlineScreenReader = new AceInlineScreenReader(editor);
            }
            var displayText = completion.snippet ? snippetManager.getDisplayTextForSnippet(editor, completion.snippet) : completion.value;
            if (completion.hideInlinePreview || !displayText || !displayText.startsWith(prefix)) {
              return false;
            }
            this.editor = editor;
            this.inlineScreenReader.setScreenReaderContent(displayText);
            displayText = displayText.slice(prefix.length);
            if (displayText === "") {
              editor.removeGhostText();
            } else {
              editor.setGhostText(displayText);
            }
            return true;
          };
          AceInline2.prototype.isOpen = function() {
            if (!this.editor) {
              return false;
            }
            return !!this.editor.renderer.$ghostText;
          };
          AceInline2.prototype.hide = function() {
            if (!this.editor) {
              return false;
            }
            this.editor.removeGhostText();
            return true;
          };
          AceInline2.prototype.destroy = function() {
            this.hide();
            this.editor = null;
            if (this.inlineScreenReader) {
              this.inlineScreenReader.destroy();
              this.inlineScreenReader = null;
            }
          };
          return AceInline2;
        }()
      );
      exports2.AceInline = AceInline;
    });
    ace.define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom", "ace/config", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var Renderer = require3("../virtual_renderer").VirtualRenderer;
      var Editor = require3("../editor").Editor;
      var Range = require3("../range").Range;
      var event = require3("../lib/event");
      var lang = require3("../lib/lang");
      var dom = require3("../lib/dom");
      var nls = require3("../config").nls;
      var userAgent = require3("./../lib/useragent");
      var getAriaId = function(index) {
        return "suggest-aria-id:".concat(index);
      };
      var popupAriaRole = userAgent.isSafari ? "menu" : "listbox";
      var optionAriaRole = userAgent.isSafari ? "menuitem" : "option";
      var ariaActiveState = userAgent.isSafari ? "aria-current" : "aria-selected";
      var $singleLineEditor = function(el) {
        var renderer = new Renderer(el);
        renderer.$maxLines = 4;
        var editor = new Editor(renderer);
        editor.setHighlightActiveLine(false);
        editor.setShowPrintMargin(false);
        editor.renderer.setShowGutter(false);
        editor.renderer.setHighlightGutterLine(false);
        editor.$mouseHandler.$focusTimeout = 0;
        editor.$highlightTagPending = true;
        return editor;
      };
      var AcePopup = (
        /** @class */
        /* @__PURE__ */ function() {
          function AcePopup2(parentNode) {
            var el = dom.createElement("div");
            var popup = $singleLineEditor(el);
            if (parentNode) {
              parentNode.appendChild(el);
            }
            el.style.display = "none";
            popup.renderer.content.style.cursor = "default";
            popup.renderer.setStyle("ace_autocomplete");
            popup.renderer.$textLayer.element.setAttribute("role", popupAriaRole);
            popup.renderer.$textLayer.element.setAttribute("aria-roledescription", nls("autocomplete.popup.aria-roledescription", "Autocomplete suggestions"));
            popup.renderer.$textLayer.element.setAttribute("aria-label", nls("autocomplete.popup.aria-label", "Autocomplete suggestions"));
            popup.renderer.textarea.setAttribute("aria-hidden", "true");
            popup.setOption("displayIndentGuides", false);
            popup.setOption("dragDelay", 150);
            var noop = function() {
            };
            popup.focus = noop;
            popup.$isFocused = true;
            popup.renderer.$cursorLayer.restartTimer = noop;
            popup.renderer.$cursorLayer.element.style.opacity = "0";
            popup.renderer.$maxLines = 8;
            popup.renderer.$keepTextAreaAtCursor = false;
            popup.setHighlightActiveLine(false);
            popup.session.highlight("");
            popup.session.$searchHighlight.clazz = "ace_highlight-marker";
            popup.on("mousedown", function(e) {
              var pos = e.getDocumentPosition();
              popup.selection.moveToPosition(pos);
              selectionMarker.start.row = selectionMarker.end.row = pos.row;
              e.stop();
            });
            var lastMouseEvent;
            var hoverMarker = new Range(-1, 0, -1, Infinity);
            var selectionMarker = new Range(-1, 0, -1, Infinity);
            selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
            popup.setSelectOnHover = function(val) {
              if (!val) {
                hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
              } else if (hoverMarker.id) {
                popup.session.removeMarker(hoverMarker.id);
                hoverMarker.id = null;
              }
            };
            popup.setSelectOnHover(false);
            popup.on("mousemove", function(e) {
              if (!lastMouseEvent) {
                lastMouseEvent = e;
                return;
              }
              if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
                return;
              }
              lastMouseEvent = e;
              lastMouseEvent.scrollTop = popup.renderer.scrollTop;
              popup.isMouseOver = true;
              var row = lastMouseEvent.getDocumentPosition().row;
              if (hoverMarker.start.row != row) {
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row);
              }
            });
            popup.renderer.on("beforeRender", function() {
              if (lastMouseEvent && hoverMarker.start.row != -1) {
                lastMouseEvent.$pos = null;
                var row = lastMouseEvent.getDocumentPosition().row;
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row, true);
              }
            });
            popup.renderer.on("afterRender", function() {
              var t = popup.renderer.$textLayer;
              for (var row = t.config.firstRow, l = t.config.lastRow; row <= l; row++) {
                var popupRowElement = (
                  /** @type {HTMLElement|null} */
                  t.element.childNodes[row - t.config.firstRow]
                );
                popupRowElement.setAttribute("role", optionAriaRole);
                popupRowElement.setAttribute("aria-roledescription", nls("autocomplete.popup.item.aria-roledescription", "item"));
                popupRowElement.setAttribute("aria-setsize", popup.data.length);
                popupRowElement.setAttribute("aria-describedby", "doc-tooltip");
                popupRowElement.setAttribute("aria-posinset", row + 1);
                var rowData = popup.getData(row);
                if (rowData) {
                  var ariaLabel = "".concat(rowData.caption || rowData.value).concat(rowData.meta ? ", ".concat(rowData.meta) : "");
                  popupRowElement.setAttribute("aria-label", ariaLabel);
                }
                var highlightedSpans = popupRowElement.querySelectorAll(".ace_completion-highlight");
                highlightedSpans.forEach(function(span) {
                  span.setAttribute("role", "mark");
                });
              }
            });
            popup.renderer.on("afterRender", function() {
              var row = popup.getRow();
              var t = popup.renderer.$textLayer;
              var selected = (
                /** @type {HTMLElement|null} */
                t.element.childNodes[row - t.config.firstRow]
              );
              var el2 = document.activeElement;
              if (selected !== popup.selectedNode && popup.selectedNode) {
                dom.removeCssClass(popup.selectedNode, "ace_selected");
                popup.selectedNode.removeAttribute(ariaActiveState);
                popup.selectedNode.removeAttribute("id");
              }
              el2.removeAttribute("aria-activedescendant");
              popup.selectedNode = selected;
              if (selected) {
                var ariaId = getAriaId(row);
                dom.addCssClass(selected, "ace_selected");
                selected.id = ariaId;
                t.element.setAttribute("aria-activedescendant", ariaId);
                el2.setAttribute("aria-activedescendant", ariaId);
                selected.setAttribute(ariaActiveState, "true");
              }
            });
            var hideHoverMarker = function() {
              setHoverMarker(-1);
            };
            var setHoverMarker = function(row, suppressRedraw) {
              if (row !== hoverMarker.start.row) {
                hoverMarker.start.row = hoverMarker.end.row = row;
                if (!suppressRedraw)
                  popup.session._emit("changeBackMarker");
                popup._emit("changeHoverMarker");
              }
            };
            popup.getHoveredRow = function() {
              return hoverMarker.start.row;
            };
            event.addListener(popup.container, "mouseout", function() {
              popup.isMouseOver = false;
              hideHoverMarker();
            });
            popup.on("hide", hideHoverMarker);
            popup.on("changeSelection", hideHoverMarker);
            popup.session.doc.getLength = function() {
              return popup.data.length;
            };
            popup.session.doc.getLine = function(i) {
              var data = popup.data[i];
              if (typeof data == "string")
                return data;
              return data && data.value || "";
            };
            var bgTokenizer = popup.session.bgTokenizer;
            bgTokenizer.$tokenizeRow = function(row) {
              var data = popup.data[row];
              var tokens = [];
              if (!data)
                return tokens;
              if (typeof data == "string")
                data = { value: data };
              var caption = data.caption || data.value || data.name;
              function addToken(value, className) {
                value && tokens.push({
                  type: (data.className || "") + (className || ""),
                  value
                });
              }
              var lower = caption.toLowerCase();
              var filterText = (popup.filterText || "").toLowerCase();
              var lastIndex = 0;
              var lastI = 0;
              for (var i = 0; i <= filterText.length; i++) {
                if (i != lastI && (data.matchMask & 1 << i || i == filterText.length)) {
                  var sub = filterText.slice(lastI, i);
                  lastI = i;
                  var index = lower.indexOf(sub, lastIndex);
                  if (index == -1)
                    continue;
                  addToken(caption.slice(lastIndex, index), "");
                  lastIndex = index + sub.length;
                  addToken(caption.slice(index, lastIndex), "completion-highlight");
                }
              }
              addToken(caption.slice(lastIndex, caption.length), "");
              tokens.push({ type: "completion-spacer", value: " " });
              if (data.meta)
                tokens.push({ type: "completion-meta", value: data.meta });
              if (data.message)
                tokens.push({ type: "completion-message", value: data.message });
              return tokens;
            };
            bgTokenizer.$updateOnChange = noop;
            bgTokenizer.start = noop;
            popup.session.$computeWidth = function() {
              return this.screenWidth = 0;
            };
            popup.isOpen = false;
            popup.isTopdown = false;
            popup.autoSelect = true;
            popup.filterText = "";
            popup.isMouseOver = false;
            popup.data = [];
            popup.setData = function(list, filterText) {
              popup.filterText = filterText || "";
              popup.setValue(lang.stringRepeat("\n", list.length), -1);
              popup.data = list || [];
              popup.setRow(0);
            };
            popup.getData = function(row) {
              return popup.data[row];
            };
            popup.getRow = function() {
              return selectionMarker.start.row;
            };
            popup.setRow = function(line) {
              line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));
              if (selectionMarker.start.row != line) {
                popup.selection.clearSelection();
                selectionMarker.start.row = selectionMarker.end.row = line || 0;
                popup.session._emit("changeBackMarker");
                popup.moveCursorTo(line || 0, 0);
                if (popup.isOpen)
                  popup._signal("select");
              }
            };
            popup.on("changeSelection", function() {
              if (popup.isOpen)
                popup.setRow(popup.selection.lead.row);
              popup.renderer.scrollCursorIntoView();
            });
            popup.hide = function() {
              this.container.style.display = "none";
              popup.anchorPos = null;
              popup.anchor = null;
              if (popup.isOpen) {
                popup.isOpen = false;
                this._signal("hide");
              }
            };
            popup.tryShow = function(pos, lineHeight, anchor, forceShow) {
              if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor && popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left && popup.anchor === anchor) {
                return true;
              }
              var el2 = this.container;
              var scrollBarSize = this.renderer.scrollBar.width || 10;
              var screenHeight = window.innerHeight - scrollBarSize;
              var screenWidth = window.innerWidth - scrollBarSize;
              var renderer = this.renderer;
              var maxH = renderer.$maxLines * lineHeight * 1.4;
              var dims = { top: 0, bottom: 0, left: 0 };
              var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;
              var spaceAbove = pos.top - 3 * this.$borderSize;
              if (!anchor) {
                if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {
                  anchor = "bottom";
                } else {
                  anchor = "top";
                }
              }
              if (anchor === "top") {
                dims.bottom = pos.top - this.$borderSize;
                dims.top = dims.bottom - maxH;
              } else if (anchor === "bottom") {
                dims.top = pos.top + lineHeight + this.$borderSize;
                dims.bottom = dims.top + maxH;
              }
              var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;
              if (!forceShow && !fitsX) {
                return false;
              }
              if (!fitsX) {
                if (anchor === "top") {
                  renderer.$maxPixelHeight = spaceAbove;
                } else {
                  renderer.$maxPixelHeight = spaceBelow;
                }
              } else {
                renderer.$maxPixelHeight = null;
              }
              if (anchor === "top") {
                el2.style.top = "";
                el2.style.bottom = screenHeight + scrollBarSize - dims.bottom + "px";
                popup.isTopdown = false;
              } else {
                el2.style.top = dims.top + "px";
                el2.style.bottom = "";
                popup.isTopdown = true;
              }
              el2.style.display = "";
              var left = pos.left;
              if (left + el2.offsetWidth > screenWidth)
                left = screenWidth - el2.offsetWidth;
              el2.style.left = left + "px";
              el2.style.right = "";
              if (!popup.isOpen) {
                popup.isOpen = true;
                this._signal("show");
                lastMouseEvent = null;
              }
              popup.anchorPos = pos;
              popup.anchor = anchor;
              return true;
            };
            popup.show = function(pos, lineHeight, topdownOnly) {
              this.tryShow(pos, lineHeight, topdownOnly ? "bottom" : void 0, true);
            };
            popup.goTo = function(where) {
              var row = this.getRow();
              var max = this.session.getLength() - 1;
              switch (where) {
                case "up":
                  row = row <= 0 ? max : row - 1;
                  break;
                case "down":
                  row = row >= max ? -1 : row + 1;
                  break;
                case "start":
                  row = 0;
                  break;
                case "end":
                  row = max;
                  break;
              }
              this.setRow(row);
            };
            popup.getTextLeftOffset = function() {
              return this.$borderSize + this.renderer.$padding + this.$imageSize;
            };
            popup.$imageSize = 0;
            popup.$borderSize = 1;
            return popup;
          }
          return AcePopup2;
        }()
      );
      dom.importCssString('\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #CAD6FA;\n    z-index: 1;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #3a674e;\n}\n.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #abbffe;\n    margin-top: -1px;\n    background: rgba(233,233,253,0.4);\n    position: absolute;\n    z-index: 2;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid rgba(109, 150, 13, 0.8);\n    background: rgba(58, 103, 78, 0.62);\n}\n.ace_completion-meta {\n    opacity: 0.5;\n    margin-left: 0.9em;\n}\n.ace_completion-message {\n    margin-left: 0.9em;\n    color: blue;\n}\n.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #2d69c7;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #93ca12;\n}\n.ace_editor.ace_autocomplete {\n    width: 300px;\n    z-index: 200000;\n    border: 1px lightgray solid;\n    position: fixed;\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n    line-height: 1.4;\n    background: #fefefe;\n    color: #111;\n}\n.ace_dark.ace_editor.ace_autocomplete {\n    border: 1px #484747 solid;\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\n    line-height: 1.4;\n    background: #25282c;\n    color: #c1c1c1;\n}\n.ace_autocomplete .ace_text-layer  {\n    width: calc(100% - 8px);\n}\n.ace_autocomplete .ace_line {\n    display: flex;\n    align-items: center;\n}\n.ace_autocomplete .ace_line > * {\n    min-width: 0;\n    flex: 0 0 auto;\n}\n.ace_autocomplete .ace_line .ace_ {\n    flex: 0 1 auto;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.ace_autocomplete .ace_completion-spacer {\n    flex: 1;\n}\n.ace_autocomplete.ace_loading:after  {\n    content: "";\n    position: absolute;\n    top: 0px;\n    height: 2px;\n    width: 8%;\n    background: blue;\n    z-index: 100;\n    animation: ace_progress 3s infinite linear;\n    animation-delay: 300ms;\n    transform: translateX(-100%) scaleX(1);\n}\n@keyframes ace_progress {\n    0% { transform: translateX(-100%) scaleX(1) }\n    50% { transform: translateX(625%) scaleX(2) } \n    100% { transform: translateX(1500%) scaleX(3) } \n}\n@media (prefers-reduced-motion) {\n    .ace_autocomplete.ace_loading:after {\n        transform: translateX(625%) scaleX(2);\n        animation: none;\n     }\n}\n', "autocompletion.css", false);
      exports2.AcePopup = AcePopup;
      exports2.$singleLineEditor = $singleLineEditor;
      exports2.getAriaId = getAriaId;
    });
    ace.define("ace/autocomplete/util", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      exports2.parForEach = function(array, fn3, callback) {
        var completed = 0;
        var arLength = array.length;
        if (arLength === 0)
          callback();
        for (var i = 0; i < arLength; i++) {
          fn3(array[i], function(result, err) {
            completed++;
            if (completed === arLength)
              callback(result, err);
          });
        }
      };
      var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
      exports2.retrievePrecedingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos - 1; i >= 0; i--) {
          if (regex.test(text[i]))
            buf.push(text[i]);
          else
            break;
        }
        return buf.reverse().join("");
      };
      exports2.retrieveFollowingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos; i < text.length; i++) {
          if (regex.test(text[i]))
            buf.push(text[i]);
          else
            break;
        }
        return buf;
      };
      exports2.getCompletionPrefix = function(editor) {
        var pos = editor.getCursorPosition();
        var line = editor.session.getLine(pos.row);
        var prefix;
        editor.completers.forEach(function(completer) {
          if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach(function(identifierRegex) {
              if (!prefix && identifierRegex)
                prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }.bind(this));
          }
        }.bind(this));
        return prefix || this.retrievePrecedingIdentifier(line, pos.column);
      };
      exports2.triggerAutocomplete = function(editor, previousChar) {
        var previousChar = previousChar == null ? editor.session.getPrecedingCharacter() : previousChar;
        return editor.completers.some(function(completer) {
          if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {
            return completer.triggerCharacters.includes(previousChar);
          }
        });
      };
    });
    ace.define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/inline", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/lang", "ace/lib/dom", "ace/snippets", "ace/config", "ace/lib/event", "ace/lib/scroll"], function(require3, exports2, module3) {
      "use strict";
      var HashHandler = require3("./keyboard/hash_handler").HashHandler;
      var AcePopup = require3("./autocomplete/popup").AcePopup;
      var AceInline = require3("./autocomplete/inline").AceInline;
      var getAriaId = require3("./autocomplete/popup").getAriaId;
      var util = require3("./autocomplete/util");
      var lang = require3("./lib/lang");
      var dom = require3("./lib/dom");
      var snippetManager = require3("./snippets").snippetManager;
      var config = require3("./config");
      var event = require3("./lib/event");
      var preventParentScroll = require3("./lib/scroll").preventParentScroll;
      var destroyCompleter = function(e, editor) {
        editor.completer && editor.completer.destroy();
      };
      var Autocomplete = (
        /** @class */
        function() {
          function Autocomplete2() {
            this.autoInsert = false;
            this.autoSelect = true;
            this.autoShown = false;
            this.exactMatch = false;
            this.inlineEnabled = false;
            this.keyboardHandler = new HashHandler();
            this.keyboardHandler.bindKeys(this.commands);
            this.parentNode = null;
            this.setSelectOnHover = false;
            this.hasSeen = /* @__PURE__ */ new Set();
            this.showLoadingState = false;
            this.stickySelectionDelay = 500;
            this.blurListener = this.blurListener.bind(this);
            this.changeListener = this.changeListener.bind(this);
            this.mousedownListener = this.mousedownListener.bind(this);
            this.mousewheelListener = this.mousewheelListener.bind(this);
            this.onLayoutChange = this.onLayoutChange.bind(this);
            this.changeTimer = lang.delayedCall(function() {
              this.updateCompletions(true);
            }.bind(this));
            this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
            this.popupTimer = lang.delayedCall(this.$updatePopupPosition.bind(this), 50);
            this.stickySelectionTimer = lang.delayedCall(function() {
              this.stickySelection = true;
            }.bind(this), this.stickySelectionDelay);
            this.$firstOpenTimer = lang.delayedCall(
              /**@this{Autocomplete}*/
              function() {
                var initialPosition = this.completionProvider && this.completionProvider.initialPosition;
                if (this.autoShown || this.popup && this.popup.isOpen || !initialPosition || this.editor.completers.length === 0)
                  return;
                this.completions = new FilteredList(Autocomplete2.completionsForLoading);
                this.openPopup(this.editor, initialPosition.prefix, false);
                this.popup.renderer.setStyle("ace_loading", true);
              }.bind(this),
              this.stickySelectionDelay
            );
          }
          Object.defineProperty(Autocomplete2, "completionsForLoading", {
            get: function() {
              return [{
                caption: config.nls("autocomplete.loading", "Loading..."),
                value: ""
              }];
            },
            enumerable: false,
            configurable: true
          });
          Autocomplete2.prototype.$init = function() {
            this.popup = new AcePopup(this.parentNode || document.body || document.documentElement);
            this.popup.on("click", function(e) {
              this.insertMatch();
              e.stop();
            }.bind(this));
            this.popup.focus = this.editor.focus.bind(this.editor);
            this.popup.on("show", this.$onPopupShow.bind(this));
            this.popup.on("hide", this.$onHidePopup.bind(this));
            this.popup.on("select", this.$onPopupChange.bind(this));
            event.addListener(this.popup.container, "mouseout", this.mouseOutListener.bind(this));
            this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
            this.popup.renderer.on("afterRender", this.$onPopupRender.bind(this));
            return this.popup;
          };
          Autocomplete2.prototype.$initInline = function() {
            if (!this.inlineEnabled || this.inlineRenderer)
              return;
            this.inlineRenderer = new AceInline();
            return this.inlineRenderer;
          };
          Autocomplete2.prototype.getPopup = function() {
            return this.popup || this.$init();
          };
          Autocomplete2.prototype.$onHidePopup = function() {
            if (this.inlineRenderer) {
              this.inlineRenderer.hide();
            }
            this.hideDocTooltip();
            this.stickySelectionTimer.cancel();
            this.popupTimer.cancel();
            this.stickySelection = false;
          };
          Autocomplete2.prototype.$seen = function(completion) {
            if (!this.hasSeen.has(completion) && completion && completion.completer && completion.completer.onSeen && typeof completion.completer.onSeen === "function") {
              completion.completer.onSeen(this.editor, completion);
              this.hasSeen.add(completion);
            }
          };
          Autocomplete2.prototype.$onPopupChange = function(hide) {
            if (this.inlineRenderer && this.inlineEnabled) {
              var completion = hide ? null : this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
              if (this.popup.isMouseOver && this.setSelectOnHover) {
                this.tooltipTimer.call(null, null);
                return;
              }
              this.popupTimer.schedule();
              this.tooltipTimer.schedule();
            } else {
              this.popupTimer.call(null, null);
              this.tooltipTimer.call(null, null);
            }
          };
          Autocomplete2.prototype.$updateGhostText = function(completion) {
            var row = this.base.row;
            var column = this.base.column;
            var cursorColumn = this.editor.getCursorPosition().column;
            var prefix = this.editor.session.getLine(row).slice(column, cursorColumn);
            if (!this.inlineRenderer.show(this.editor, completion, prefix)) {
              this.inlineRenderer.hide();
            } else {
              this.$seen(completion);
            }
          };
          Autocomplete2.prototype.$onPopupRender = function() {
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (this.completions && this.completions.filtered && this.completions.filtered.length > 0) {
              for (var i = this.popup.getFirstVisibleRow(); i <= this.popup.getLastVisibleRow(); i++) {
                var completion = this.popup.getData(i);
                if (completion && (!inlineEnabled || completion.hideInlinePreview)) {
                  this.$seen(completion);
                }
              }
            }
          };
          Autocomplete2.prototype.$onPopupShow = function(hide) {
            this.$onPopupChange(hide);
            this.stickySelection = false;
            if (this.stickySelectionDelay >= 0)
              this.stickySelectionTimer.schedule(this.stickySelectionDelay);
          };
          Autocomplete2.prototype.observeLayoutChanges = function() {
            if (this.$elements || !this.editor)
              return;
            window.addEventListener("resize", this.onLayoutChange, { passive: true });
            window.addEventListener("wheel", this.mousewheelListener);
            var el = this.editor.container.parentNode;
            var elements = [];
            while (el) {
              elements.push(el);
              el.addEventListener("scroll", this.onLayoutChange, { passive: true });
              el = el.parentNode;
            }
            this.$elements = elements;
          };
          Autocomplete2.prototype.unObserveLayoutChanges = function() {
            var _this = this;
            window.removeEventListener("resize", this.onLayoutChange, { passive: true });
            window.removeEventListener("wheel", this.mousewheelListener);
            this.$elements && this.$elements.forEach(function(el) {
              el.removeEventListener("scroll", _this.onLayoutChange, { passive: true });
            });
            this.$elements = null;
          };
          Autocomplete2.prototype.onLayoutChange = function() {
            if (!this.popup.isOpen)
              return this.unObserveLayoutChanges();
            this.$updatePopupPosition();
            this.updateDocTooltip();
          };
          Autocomplete2.prototype.$updatePopupPosition = function() {
            var editor = this.editor;
            var renderer = editor.renderer;
            var lineHeight = renderer.layerConfig.lineHeight;
            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
            pos.left -= this.popup.getTextLeftOffset();
            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += renderer.gutterWidth;
            var posGhostText = {
              top: pos.top,
              left: pos.left
            };
            if (renderer.$ghostText && renderer.$ghostTextWidget) {
              if (this.base.row === renderer.$ghostText.position.row) {
                posGhostText.top += renderer.$ghostTextWidget.el.offsetHeight;
              }
            }
            var editorContainerBottom = editor.container.getBoundingClientRect().bottom - lineHeight;
            var lowestPosition = editorContainerBottom < posGhostText.top ? { top: editorContainerBottom, left: posGhostText.left } : posGhostText;
            if (this.popup.tryShow(lowestPosition, lineHeight, "bottom")) {
              return;
            }
            if (this.popup.tryShow(pos, lineHeight, "top")) {
              return;
            }
            this.popup.show(pos, lineHeight);
          };
          Autocomplete2.prototype.openPopup = function(editor, prefix, keepPopupPosition) {
            this.$firstOpenTimer.cancel();
            if (!this.popup)
              this.$init();
            if (this.inlineEnabled && !this.inlineRenderer)
              this.$initInline();
            this.popup.autoSelect = this.autoSelect;
            this.popup.setSelectOnHover(this.setSelectOnHover);
            var oldRow = this.popup.getRow();
            var previousSelectedItem = this.popup.data[oldRow];
            this.popup.setData(this.completions.filtered, this.completions.filterText);
            if (this.editor.textInput.setAriaOptions) {
              this.editor.textInput.setAriaOptions({
                activeDescendant: getAriaId(this.popup.getRow()),
                inline: this.inlineEnabled
              });
            }
            editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            var newRow;
            if (this.stickySelection)
              newRow = this.popup.data.indexOf(previousSelectedItem);
            if (!newRow || newRow === -1)
              newRow = 0;
            this.popup.setRow(this.autoSelect ? newRow : -1);
            if (newRow === oldRow && previousSelectedItem !== this.completions.filtered[newRow])
              this.$onPopupChange();
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (newRow === oldRow && inlineEnabled) {
              var completion = this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
            }
            if (!keepPopupPosition) {
              this.popup.setTheme(editor.getTheme());
              this.popup.setFontSize(editor.getFontSize());
              this.$updatePopupPosition();
              if (this.tooltipNode) {
                this.updateDocTooltip();
              }
            }
            this.changeTimer.cancel();
            this.observeLayoutChanges();
          };
          Autocomplete2.prototype.detach = function() {
            if (this.editor) {
              this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
              this.editor.off("changeSelection", this.changeListener);
              this.editor.off("blur", this.blurListener);
              this.editor.off("mousedown", this.mousedownListener);
              this.editor.off("mousewheel", this.mousewheelListener);
            }
            this.$firstOpenTimer.cancel();
            this.changeTimer.cancel();
            this.hideDocTooltip();
            if (this.completionProvider) {
              this.completionProvider.detach();
            }
            if (this.popup && this.popup.isOpen)
              this.popup.hide();
            if (this.popup && this.popup.renderer) {
              this.popup.renderer.off("afterRender", this.$onPopupRender);
            }
            if (this.base)
              this.base.detach();
            this.activated = false;
            this.completionProvider = this.completions = this.base = null;
            this.unObserveLayoutChanges();
          };
          Autocomplete2.prototype.changeListener = function(e) {
            var cursor = this.editor.selection.lead;
            if (cursor.row != this.base.row || cursor.column < this.base.column) {
              this.detach();
            }
            if (this.activated)
              this.changeTimer.schedule();
            else
              this.detach();
          };
          Autocomplete2.prototype.blurListener = function(e) {
            var el = document.activeElement;
            var text = this.editor.textInput.getElement();
            var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);
            var container = this.popup && this.popup.container;
            if (el != text && el.parentNode != container && !fromTooltip && el != this.tooltipNode && e.relatedTarget != text) {
              this.detach();
            }
          };
          Autocomplete2.prototype.mousedownListener = function(e) {
            this.detach();
          };
          Autocomplete2.prototype.mousewheelListener = function(e) {
            if (this.popup && !this.popup.isMouseOver)
              this.detach();
          };
          Autocomplete2.prototype.mouseOutListener = function(e) {
            if (this.popup.isOpen)
              this.$updatePopupPosition();
          };
          Autocomplete2.prototype.goTo = function(where) {
            this.popup.goTo(where);
          };
          Autocomplete2.prototype.insertMatch = function(data, options) {
            if (!data)
              data = this.popup.getData(this.popup.getRow());
            if (!data)
              return false;
            if (data.value === "")
              return this.detach();
            var completions = this.completions;
            var result = this.getCompletionProvider().insertMatch(this.editor, data, completions.filterText, options);
            if (this.completions == completions)
              this.detach();
            return result;
          };
          Autocomplete2.prototype.showPopup = function(editor, options) {
            if (this.editor)
              this.detach();
            this.activated = true;
            this.editor = editor;
            if (editor.completer != this) {
              if (editor.completer)
                editor.completer.detach();
              editor.completer = this;
            }
            editor.on("changeSelection", this.changeListener);
            editor.on("blur", this.blurListener);
            editor.on("mousedown", this.mousedownListener);
            editor.on("mousewheel", this.mousewheelListener);
            this.updateCompletions(false, options);
          };
          Autocomplete2.prototype.getCompletionProvider = function(initialPosition) {
            if (!this.completionProvider)
              this.completionProvider = new CompletionProvider(initialPosition);
            return this.completionProvider;
          };
          Autocomplete2.prototype.gatherCompletions = function(editor, callback) {
            return this.getCompletionProvider().gatherCompletions(editor, callback);
          };
          Autocomplete2.prototype.updateCompletions = function(keepPopupPosition, options) {
            if (keepPopupPosition && this.base && this.completions) {
              var pos = this.editor.getCursorPosition();
              var prefix = this.editor.session.getTextRange({ start: this.base, end: pos });
              if (prefix == this.completions.filterText)
                return;
              this.completions.setFilter(prefix);
              if (!this.completions.filtered.length)
                return this.detach();
              if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == prefix && !this.completions.filtered[0].snippet)
                return this.detach();
              this.openPopup(this.editor, prefix, keepPopupPosition);
              return;
            }
            if (options && options.matches) {
              var pos = this.editor.getSelectionRange().start;
              this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
              this.base.$insertRight = true;
              this.completions = new FilteredList(options.matches);
              this.getCompletionProvider().completions = this.completions;
              return this.openPopup(this.editor, "", keepPopupPosition);
            }
            var session = this.editor.getSession();
            var pos = this.editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(this.editor);
            this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
            this.base.$insertRight = true;
            var completionOptions = {
              exactMatch: this.exactMatch,
              ignoreCaption: this.ignoreCaption
            };
            this.getCompletionProvider({
              prefix,
              pos
            }).provideCompletions(
              this.editor,
              completionOptions,
              function(err, completions, finished) {
                var filtered = completions.filtered;
                var prefix2 = util.getCompletionPrefix(this.editor);
                this.$firstOpenTimer.cancel();
                if (finished) {
                  if (!filtered.length) {
                    var emptyMessage = !this.autoShown && this.emptyMessage;
                    if (typeof emptyMessage == "function")
                      emptyMessage = this.emptyMessage(prefix2);
                    if (emptyMessage) {
                      var completionsForEmpty = [
                        {
                          caption: emptyMessage,
                          value: ""
                        }
                      ];
                      this.completions = new FilteredList(completionsForEmpty);
                      this.openPopup(this.editor, prefix2, keepPopupPosition);
                      this.popup.renderer.setStyle("ace_loading", false);
                      this.popup.renderer.setStyle("ace_empty-message", true);
                      return;
                    }
                    return this.detach();
                  }
                  if (filtered.length == 1 && filtered[0].value == prefix2 && !filtered[0].snippet)
                    return this.detach();
                  if (this.autoInsert && !this.autoShown && filtered.length == 1)
                    return this.insertMatch(filtered[0]);
                }
                this.completions = !finished && this.showLoadingState ? new FilteredList(Autocomplete2.completionsForLoading.concat(filtered), completions.filterText) : completions;
                this.openPopup(this.editor, prefix2, keepPopupPosition);
                this.popup.renderer.setStyle("ace_empty-message", false);
                this.popup.renderer.setStyle("ace_loading", !finished);
              }.bind(this)
            );
            if (this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen)) {
              this.$firstOpenTimer.delay(this.stickySelectionDelay / 2);
            }
          };
          Autocomplete2.prototype.cancelContextMenu = function() {
            this.editor.$mouseHandler.cancelContextMenu();
          };
          Autocomplete2.prototype.updateDocTooltip = function() {
            var popup = this.popup;
            var all = this.completions && this.completions.filtered;
            var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
            var doc = null;
            if (!selected || !this.editor || !this.popup.isOpen)
              return this.hideDocTooltip();
            var completersLength = this.editor.completers.length;
            for (var i = 0; i < completersLength; i++) {
              var completer = this.editor.completers[i];
              if (completer.getDocTooltip && selected.completerId === completer.id) {
                doc = completer.getDocTooltip(selected);
                break;
              }
            }
            if (!doc && typeof selected != "string")
              doc = selected;
            if (typeof doc == "string")
              doc = { docText: doc };
            if (!doc || !(doc.docHTML || doc.docText))
              return this.hideDocTooltip();
            this.showDocTooltip(doc);
          };
          Autocomplete2.prototype.showDocTooltip = function(item) {
            if (!this.tooltipNode) {
              this.tooltipNode = dom.createElement("div");
              this.tooltipNode.style.margin = "0";
              this.tooltipNode.style.pointerEvents = "auto";
              this.tooltipNode.style.overscrollBehavior = "contain";
              this.tooltipNode.tabIndex = -1;
              this.tooltipNode.onblur = this.blurListener.bind(this);
              this.tooltipNode.onclick = this.onTooltipClick.bind(this);
              this.tooltipNode.id = "doc-tooltip";
              this.tooltipNode.setAttribute("role", "tooltip");
              this.tooltipNode.addEventListener("wheel", preventParentScroll);
            }
            var theme = this.editor.renderer.theme;
            this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
            var tooltipNode = this.tooltipNode;
            if (item.docHTML) {
              tooltipNode.innerHTML = item.docHTML;
            } else if (item.docText) {
              tooltipNode.textContent = item.docText;
            }
            if (!tooltipNode.parentNode)
              this.popup.container.appendChild(this.tooltipNode);
            var popup = this.popup;
            var rect = popup.container.getBoundingClientRect();
            var targetWidth = 400;
            var targetHeight = 300;
            var scrollBarSize = popup.renderer.scrollBar.width || 10;
            var leftSize = rect.left;
            var rightSize = window.innerWidth - rect.right - scrollBarSize;
            var topSize = popup.isTopdown ? rect.top : window.innerHeight - scrollBarSize - rect.bottom;
            var scores = [
              Math.min(rightSize / targetWidth, 1),
              Math.min(leftSize / targetWidth, 1),
              Math.min(topSize / targetHeight * 0.9)
            ];
            var max = Math.max.apply(Math, scores);
            var tooltipStyle = tooltipNode.style;
            tooltipStyle.display = "block";
            if (max == scores[0]) {
              tooltipStyle.left = rect.right + 1 + "px";
              tooltipStyle.right = "";
              tooltipStyle.maxWidth = targetWidth * max + "px";
              tooltipStyle.top = rect.top + "px";
              tooltipStyle.bottom = "";
              tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
            } else if (max == scores[1]) {
              tooltipStyle.right = window.innerWidth - rect.left + "px";
              tooltipStyle.left = "";
              tooltipStyle.maxWidth = targetWidth * max + "px";
              tooltipStyle.top = rect.top + "px";
              tooltipStyle.bottom = "";
              tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
            } else if (max == scores[2]) {
              tooltipStyle.left = window.innerWidth - rect.left + "px";
              tooltipStyle.maxWidth = Math.min(targetWidth, window.innerWidth) + "px";
              if (popup.isTopdown) {
                tooltipStyle.top = rect.bottom + "px";
                tooltipStyle.left = rect.left + "px";
                tooltipStyle.right = "";
                tooltipStyle.bottom = "";
                tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.bottom, targetHeight) + "px";
              } else {
                tooltipStyle.top = popup.container.offsetTop - tooltipNode.offsetHeight + "px";
                tooltipStyle.left = rect.left + "px";
                tooltipStyle.right = "";
                tooltipStyle.bottom = "";
                tooltipStyle.maxHeight = Math.min(popup.container.offsetTop, targetHeight) + "px";
              }
            }
          };
          Autocomplete2.prototype.hideDocTooltip = function() {
            this.tooltipTimer.cancel();
            if (!this.tooltipNode)
              return;
            var el = this.tooltipNode;
            if (!this.editor.isFocused() && document.activeElement == el)
              this.editor.focus();
            this.tooltipNode = null;
            if (el.parentNode)
              el.parentNode.removeChild(el);
          };
          Autocomplete2.prototype.onTooltipClick = function(e) {
            var a = e.target;
            while (a && a != this.tooltipNode) {
              if (a.nodeName == "A" && a.href) {
                a.rel = "noreferrer";
                a.target = "_blank";
                break;
              }
              a = a.parentNode;
            }
          };
          Autocomplete2.prototype.destroy = function() {
            this.detach();
            if (this.popup) {
              this.popup.destroy();
              var el = this.popup.container;
              if (el && el.parentNode)
                el.parentNode.removeChild(el);
            }
            if (this.editor && this.editor.completer == this) {
              this.editor.off("destroy", destroyCompleter);
              this.editor.completer = null;
            }
            this.inlineRenderer = this.popup = this.editor = null;
          };
          Autocomplete2.for = function(editor) {
            if (editor.completer instanceof Autocomplete2) {
              return editor.completer;
            }
            if (editor.completer) {
              editor.completer.destroy();
              editor.completer = null;
            }
            if (config.get("sharedPopups")) {
              if (!Autocomplete2["$sharedInstance"])
                Autocomplete2["$sharedInstance"] = new Autocomplete2();
              editor.completer = Autocomplete2["$sharedInstance"];
            } else {
              editor.completer = new Autocomplete2();
              editor.once("destroy", destroyCompleter);
            }
            return editor.completer;
          };
          return Autocomplete2;
        }()
      );
      Autocomplete.prototype.commands = {
        "Up": function(editor) {
          editor.completer.goTo("up");
        },
        "Down": function(editor) {
          editor.completer.goTo("down");
        },
        "Ctrl-Up|Ctrl-Home": function(editor) {
          editor.completer.goTo("start");
        },
        "Ctrl-Down|Ctrl-End": function(editor) {
          editor.completer.goTo("end");
        },
        "Esc": function(editor) {
          editor.completer.detach();
        },
        "Return": function(editor) {
          return editor.completer.insertMatch();
        },
        "Shift-Return": function(editor) {
          editor.completer.insertMatch(null, { deleteSuffix: true });
        },
        "Tab": function(editor) {
          var result = editor.completer.insertMatch();
          if (!result && !editor.tabstopManager)
            editor.completer.goTo("down");
          else
            return result;
        },
        "Backspace": function(editor) {
          editor.execCommand("backspace");
          var prefix = util.getCompletionPrefix(editor);
          if (!prefix && editor.completer)
            editor.completer.detach();
        },
        "PageUp": function(editor) {
          editor.completer.popup.gotoPageUp();
        },
        "PageDown": function(editor) {
          editor.completer.popup.gotoPageDown();
        }
      };
      Autocomplete.startCommand = {
        name: "startAutocomplete",
        exec: function(editor, options) {
          var completer = Autocomplete.for(editor);
          completer.autoInsert = false;
          completer.autoSelect = true;
          completer.autoShown = false;
          completer.showPopup(editor, options);
          completer.cancelContextMenu();
        },
        bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
      };
      var CompletionProvider = (
        /** @class */
        function() {
          function CompletionProvider2(initialPosition) {
            this.initialPosition = initialPosition;
            this.active = true;
          }
          CompletionProvider2.prototype.insertByIndex = function(editor, index, options) {
            if (!this.completions || !this.completions.filtered) {
              return false;
            }
            return this.insertMatch(editor, this.completions.filtered[index], options);
          };
          CompletionProvider2.prototype.insertMatch = function(editor, data, options) {
            if (!data)
              return false;
            editor.startOperation({ command: { name: "insertMatch" } });
            if (data.completer && data.completer.insertMatch) {
              data.completer.insertMatch(editor, data);
            } else {
              if (!this.completions)
                return false;
              var replaceBefore = this.completions.filterText.length;
              var replaceAfter = 0;
              if (data.range && data.range.start.row === data.range.end.row) {
                replaceBefore -= this.initialPosition.prefix.length;
                replaceBefore += this.initialPosition.pos.column - data.range.start.column;
                replaceAfter += data.range.end.column - this.initialPosition.pos.column;
              }
              if (replaceBefore || replaceAfter) {
                var ranges;
                if (editor.selection.getAllRanges) {
                  ranges = editor.selection.getAllRanges();
                } else {
                  ranges = [editor.getSelectionRange()];
                }
                for (var i = 0, range; range = ranges[i]; i++) {
                  range.start.column -= replaceBefore;
                  range.end.column += replaceAfter;
                  editor.session.remove(range);
                }
              }
              if (data.snippet) {
                snippetManager.insertSnippet(editor, data.snippet);
              } else {
                this.$insertString(editor, data);
              }
              if (data.completer && data.completer.onInsert && typeof data.completer.onInsert == "function") {
                data.completer.onInsert(editor, data);
              }
              if (data.command && data.command === "startAutocomplete") {
                editor.execCommand(data.command);
              }
            }
            editor.endOperation();
            return true;
          };
          CompletionProvider2.prototype.$insertString = function(editor, data) {
            var text = data.value || data;
            editor.execCommand("insertstring", text);
          };
          CompletionProvider2.prototype.gatherCompletions = function(editor, callback) {
            var session = editor.getSession();
            var pos = editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(editor);
            var matches = [];
            this.completers = editor.completers;
            var total = editor.completers.length;
            editor.completers.forEach(function(completer, i) {
              completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (completer.hideInlinePreview)
                  results = results.map(function(result) {
                    return Object.assign(result, { hideInlinePreview: completer.hideInlinePreview });
                  });
                if (!err && results)
                  matches = matches.concat(results);
                callback(null, {
                  prefix: util.getCompletionPrefix(editor),
                  matches,
                  finished: --total === 0
                });
              });
            });
            return true;
          };
          CompletionProvider2.prototype.provideCompletions = function(editor, options, callback) {
            var processResults = function(results2) {
              var prefix = results2.prefix;
              var matches = results2.matches;
              this.completions = new FilteredList(matches);
              if (options.exactMatch)
                this.completions.exactMatch = true;
              if (options.ignoreCaption)
                this.completions.ignoreCaption = true;
              this.completions.setFilter(prefix);
              if (results2.finished || this.completions.filtered.length)
                callback(null, this.completions, results2.finished);
            }.bind(this);
            var isImmediate = true;
            var immediateResults = null;
            this.gatherCompletions(editor, function(err, results2) {
              if (!this.active) {
                return;
              }
              if (err) {
                callback(err, [], true);
                this.detach();
              }
              var prefix = results2.prefix;
              if (prefix.indexOf(results2.prefix) !== 0)
                return;
              if (isImmediate) {
                immediateResults = results2;
                return;
              }
              processResults(results2);
            }.bind(this));
            isImmediate = false;
            if (immediateResults) {
              var results = immediateResults;
              immediateResults = null;
              processResults(results);
            }
          };
          CompletionProvider2.prototype.detach = function() {
            this.active = false;
            this.completers && this.completers.forEach(function(completer) {
              if (typeof completer.cancel === "function") {
                completer.cancel();
              }
            });
          };
          return CompletionProvider2;
        }()
      );
      var FilteredList = (
        /** @class */
        function() {
          function FilteredList2(array, filterText) {
            this.all = array;
            this.filtered = array;
            this.filterText = filterText || "";
            this.exactMatch = false;
            this.ignoreCaption = false;
          }
          FilteredList2.prototype.setFilter = function(str) {
            if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
              var matches = this.filtered;
            else
              var matches = this.all;
            this.filterText = str;
            matches = this.filterCompletions(matches, this.filterText);
            matches = matches.sort(function(a, b2) {
              return b2.exactMatch - a.exactMatch || b2.$score - a.$score || (a.caption || a.value).localeCompare(b2.caption || b2.value);
            });
            var prev = null;
            matches = matches.filter(function(item) {
              var caption = item.snippet || item.caption || item.value;
              if (caption === prev)
                return false;
              prev = caption;
              return true;
            });
            this.filtered = matches;
          };
          FilteredList2.prototype.filterCompletions = function(items, needle) {
            var results = [];
            var upper = needle.toUpperCase();
            var lower = needle.toLowerCase();
            loop: for (var i = 0, item; item = items[i]; i++) {
              if (item.skipFilter) {
                item.$score = item.score;
                results.push(item);
                continue;
              }
              var caption = !this.ignoreCaption && item.caption || item.value || item.snippet;
              if (!caption)
                continue;
              var lastIndex = -1;
              var matchMask = 0;
              var penalty = 0;
              var index, distance;
              if (this.exactMatch) {
                if (needle !== caption.substr(0, needle.length))
                  continue loop;
              } else {
                var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                if (fullMatchIndex > -1) {
                  penalty = fullMatchIndex;
                } else {
                  for (var j3 = 0; j3 < needle.length; j3++) {
                    var i1 = caption.indexOf(lower[j3], lastIndex + 1);
                    var i2 = caption.indexOf(upper[j3], lastIndex + 1);
                    index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                    if (index < 0)
                      continue loop;
                    distance = index - lastIndex - 1;
                    if (distance > 0) {
                      if (lastIndex === -1)
                        penalty += 10;
                      penalty += distance;
                      matchMask = matchMask | 1 << j3;
                    }
                    lastIndex = index;
                  }
                }
              }
              item.matchMask = matchMask;
              item.exactMatch = penalty ? 0 : 1;
              item.$score = (item.score || 0) - penalty;
              results.push(item);
            }
            return results;
          };
          return FilteredList2;
        }()
      );
      exports2.Autocomplete = Autocomplete;
      exports2.CompletionProvider = CompletionProvider;
      exports2.FilteredList = FilteredList;
    });
    ace.define("ace/ext/command_bar", ["require", "exports", "module", "ace/tooltip", "ace/lib/event_emitter", "ace/lib/lang", "ace/lib/dom", "ace/lib/oop", "ace/lib/useragent"], function(require3, exports2, module3) {
      var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var Tooltip = require3("../tooltip").Tooltip;
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var lang = require3("../lib/lang");
      var dom = require3("../lib/dom");
      var oop = require3("../lib/oop");
      var useragent = require3("../lib/useragent");
      var BUTTON_CLASS_NAME = "command_bar_tooltip_button";
      var VALUE_CLASS_NAME = "command_bar_button_value";
      var CAPTION_CLASS_NAME = "command_bar_button_caption";
      var KEYBINDING_CLASS_NAME = "command_bar_keybinding";
      var TOOLTIP_CLASS_NAME = "command_bar_tooltip";
      var MORE_OPTIONS_BUTTON_ID = "MoreOptionsButton";
      var defaultDelay = 100;
      var defaultMaxElements = 4;
      var minPosition = function(posA, posB) {
        if (posB.row > posA.row) {
          return posA;
        } else if (posB.row === posA.row && posB.column > posA.column) {
          return posA;
        }
        return posB;
      };
      var keyDisplayMap = {
        "Ctrl": { mac: "^" },
        "Option": { mac: "\u2325" },
        "Command": { mac: "\u2318" },
        "Cmd": { mac: "\u2318" },
        "Shift": "\u21E7",
        "Left": "\u2190",
        "Right": "\u2192",
        "Up": "\u2191",
        "Down": "\u2193"
      };
      var CommandBarTooltip = (
        /** @class */
        function() {
          function CommandBarTooltip2(parentNode, options) {
            var e_1, _a2;
            options = options || {};
            this.parentNode = parentNode;
            this.tooltip = new Tooltip(this.parentNode);
            this.moreOptions = new Tooltip(this.parentNode);
            this.maxElementsOnTooltip = options.maxElementsOnTooltip || defaultMaxElements;
            this.$alwaysShow = options.alwaysShow || false;
            this.eventListeners = {};
            this.elements = {};
            this.commands = {};
            this.tooltipEl = dom.buildDom(["div", { class: TOOLTIP_CLASS_NAME }], this.tooltip.getElement());
            this.moreOptionsEl = dom.buildDom(["div", { class: TOOLTIP_CLASS_NAME + " tooltip_more_options" }], this.moreOptions.getElement());
            this.$showTooltipTimer = lang.delayedCall(this.$showTooltip.bind(this), options.showDelay || defaultDelay);
            this.$hideTooltipTimer = lang.delayedCall(this.$hideTooltip.bind(this), options.hideDelay || defaultDelay);
            this.$tooltipEnter = this.$tooltipEnter.bind(this);
            this.$onMouseMove = this.$onMouseMove.bind(this);
            this.$onChangeScroll = this.$onChangeScroll.bind(this);
            this.$onEditorChangeSession = this.$onEditorChangeSession.bind(this);
            this.$scheduleTooltipForHide = this.$scheduleTooltipForHide.bind(this);
            this.$preventMouseEvent = this.$preventMouseEvent.bind(this);
            try {
              for (var _b = __values(["mousedown", "mouseup", "click"]), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
                var event = _c2.value;
                this.tooltip.getElement().addEventListener(event, this.$preventMouseEvent);
                this.moreOptions.getElement().addEventListener(event, this.$preventMouseEvent);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a2 = _b.return)) _a2.call(_b);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
          CommandBarTooltip2.prototype.registerCommand = function(id, command) {
            var registerForMainTooltip = Object.keys(this.commands).length < this.maxElementsOnTooltip;
            if (!registerForMainTooltip && !this.elements[MORE_OPTIONS_BUTTON_ID]) {
              this.$createCommand(MORE_OPTIONS_BUTTON_ID, {
                name: "\xB7\xB7\xB7",
                exec: function() {
                  this.$shouldHideMoreOptions = false;
                  this.$setMoreOptionsVisibility(!this.isMoreOptionsShown());
                }.bind(this),
                type: "checkbox",
                getValue: function() {
                  return this.isMoreOptionsShown();
                }.bind(this),
                enabled: true
              }, true);
            }
            this.$createCommand(id, command, registerForMainTooltip);
            if (this.isShown()) {
              this.updatePosition();
            }
          };
          CommandBarTooltip2.prototype.isShown = function() {
            return !!this.tooltip && this.tooltip.isOpen;
          };
          CommandBarTooltip2.prototype.isMoreOptionsShown = function() {
            return !!this.moreOptions && this.moreOptions.isOpen;
          };
          CommandBarTooltip2.prototype.getAlwaysShow = function() {
            return this.$alwaysShow;
          };
          CommandBarTooltip2.prototype.setAlwaysShow = function(alwaysShow) {
            this.$alwaysShow = alwaysShow;
            this.$updateOnHoverHandlers(!this.$alwaysShow);
            this._signal("alwaysShow", this.$alwaysShow);
          };
          CommandBarTooltip2.prototype.attach = function(editor) {
            if (!editor || this.isShown() && this.editor === editor) {
              return;
            }
            this.detach();
            this.editor = editor;
            this.editor.on("changeSession", this.$onEditorChangeSession);
            if (this.editor.session) {
              this.editor.session.on("changeScrollLeft", this.$onChangeScroll);
              this.editor.session.on("changeScrollTop", this.$onChangeScroll);
            }
            if (this.getAlwaysShow()) {
              this.$showTooltip();
            } else {
              this.$updateOnHoverHandlers(true);
            }
          };
          CommandBarTooltip2.prototype.updatePosition = function() {
            if (!this.editor) {
              return;
            }
            var renderer = this.editor.renderer;
            var ranges;
            if (this.editor.selection.getAllRanges) {
              ranges = this.editor.selection.getAllRanges();
            } else {
              ranges = [this.editor.getSelectionRange()];
            }
            if (!ranges.length) {
              return;
            }
            var minPos = minPosition(ranges[0].start, ranges[0].end);
            for (var i = 0, range; range = ranges[i]; i++) {
              minPos = minPosition(minPos, minPosition(range.start, range.end));
            }
            var pos = renderer.$cursorLayer.getPixelPosition(minPos, true);
            var tooltipEl = this.tooltip.getElement();
            var screenWidth = window.innerWidth;
            var screenHeight = window.innerHeight;
            var rect = this.editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left + renderer.gutterWidth - renderer.scrollLeft;
            var cursorVisible = pos.top >= rect.top && pos.top <= rect.bottom && pos.left >= rect.left + renderer.gutterWidth && pos.left <= rect.right;
            if (!cursorVisible && this.isShown()) {
              this.$hideTooltip();
              return;
            } else if (cursorVisible && !this.isShown() && this.getAlwaysShow()) {
              this.$showTooltip();
              return;
            }
            var top = pos.top - tooltipEl.offsetHeight;
            var left = Math.min(screenWidth - tooltipEl.offsetWidth, pos.left);
            var tooltipFits = top >= 0 && top + tooltipEl.offsetHeight <= screenHeight && left >= 0 && left + tooltipEl.offsetWidth <= screenWidth;
            if (!tooltipFits) {
              this.$hideTooltip();
              return;
            }
            this.tooltip.setPosition(left, top);
            if (this.isMoreOptionsShown()) {
              top = top + tooltipEl.offsetHeight;
              left = this.elements[MORE_OPTIONS_BUTTON_ID].getBoundingClientRect().left;
              var moreOptionsEl = this.moreOptions.getElement();
              var screenHeight = window.innerHeight;
              if (top + moreOptionsEl.offsetHeight > screenHeight) {
                top -= tooltipEl.offsetHeight + moreOptionsEl.offsetHeight;
              }
              if (left + moreOptionsEl.offsetWidth > screenWidth) {
                left = screenWidth - moreOptionsEl.offsetWidth;
              }
              this.moreOptions.setPosition(left, top);
            }
          };
          CommandBarTooltip2.prototype.update = function() {
            Object.keys(this.elements).forEach(this.$updateElement.bind(this));
          };
          CommandBarTooltip2.prototype.detach = function() {
            this.tooltip.hide();
            this.moreOptions.hide();
            this.$updateOnHoverHandlers(false);
            if (this.editor) {
              this.editor.off("changeSession", this.$onEditorChangeSession);
              if (this.editor.session) {
                this.editor.session.off("changeScrollLeft", this.$onChangeScroll);
                this.editor.session.off("changeScrollTop", this.$onChangeScroll);
              }
            }
            this.$mouseInTooltip = false;
            this.editor = null;
          };
          CommandBarTooltip2.prototype.destroy = function() {
            if (this.tooltip && this.moreOptions) {
              this.detach();
              this.tooltip.destroy();
              this.moreOptions.destroy();
            }
            this.eventListeners = {};
            this.commands = {};
            this.elements = {};
            this.tooltip = this.moreOptions = this.parentNode = null;
          };
          CommandBarTooltip2.prototype.$createCommand = function(id, command, forMainTooltip) {
            var parentEl = forMainTooltip ? this.tooltipEl : this.moreOptionsEl;
            var keyParts = [];
            var bindKey = command.bindKey;
            if (bindKey) {
              if (typeof bindKey === "object") {
                bindKey = useragent.isMac ? bindKey.mac : bindKey.win;
              }
              bindKey = bindKey.split("|")[0];
              keyParts = bindKey.split("-");
              keyParts = keyParts.map(function(key) {
                if (keyDisplayMap[key]) {
                  if (typeof keyDisplayMap[key] === "string") {
                    return keyDisplayMap[key];
                  } else if (useragent.isMac && keyDisplayMap[key].mac) {
                    return keyDisplayMap[key].mac;
                  }
                }
                return key;
              });
            }
            var buttonNode;
            if (forMainTooltip && command.iconCssClass) {
              buttonNode = [
                "div",
                {
                  class: ["ace_icon_svg", command.iconCssClass].join(" "),
                  "aria-label": command.name + " (" + command.bindKey + ")"
                }
              ];
            } else {
              buttonNode = [
                ["div", { class: VALUE_CLASS_NAME }],
                ["div", { class: CAPTION_CLASS_NAME }, command.name]
              ];
              if (keyParts.length) {
                buttonNode.push([
                  "div",
                  { class: KEYBINDING_CLASS_NAME },
                  keyParts.map(function(keyPart) {
                    return ["div", keyPart];
                  })
                ]);
              }
            }
            dom.buildDom(["div", { class: [BUTTON_CLASS_NAME, command.cssClass || ""].join(" "), ref: id }, buttonNode], parentEl, this.elements);
            this.commands[id] = command;
            var eventListener = function(e) {
              if (this.editor) {
                this.editor.focus();
              }
              this.$shouldHideMoreOptions = this.isMoreOptionsShown();
              if (!this.elements[id].disabled && command.exec) {
                command.exec(this.editor);
              }
              if (this.$shouldHideMoreOptions) {
                this.$setMoreOptionsVisibility(false);
              }
              this.update();
              e.preventDefault();
            }.bind(this);
            this.eventListeners[id] = eventListener;
            this.elements[id].addEventListener("click", eventListener.bind(this));
            this.$updateElement(id);
          };
          CommandBarTooltip2.prototype.$setMoreOptionsVisibility = function(visible) {
            if (visible) {
              this.moreOptions.setTheme(this.editor.renderer.theme);
              this.moreOptions.setClassName(TOOLTIP_CLASS_NAME + "_wrapper");
              this.moreOptions.show();
              this.update();
              this.updatePosition();
            } else {
              this.moreOptions.hide();
            }
          };
          CommandBarTooltip2.prototype.$onEditorChangeSession = function(e) {
            if (e.oldSession) {
              e.oldSession.off("changeScrollTop", this.$onChangeScroll);
              e.oldSession.off("changeScrollLeft", this.$onChangeScroll);
            }
            this.detach();
          };
          CommandBarTooltip2.prototype.$onChangeScroll = function() {
            if (this.editor.renderer && (this.isShown() || this.getAlwaysShow())) {
              this.editor.renderer.once("afterRender", this.updatePosition.bind(this));
            }
          };
          CommandBarTooltip2.prototype.$onMouseMove = function(e) {
            if (this.$mouseInTooltip) {
              return;
            }
            var cursorPosition = this.editor.getCursorPosition();
            var cursorScreenPosition = this.editor.renderer.textToScreenCoordinates(cursorPosition.row, cursorPosition.column);
            var lineHeight = this.editor.renderer.lineHeight;
            var isInCurrentLine = e.clientY >= cursorScreenPosition.pageY && e.clientY < cursorScreenPosition.pageY + lineHeight;
            if (isInCurrentLine) {
              if (!this.isShown() && !this.$showTooltipTimer.isPending()) {
                this.$showTooltipTimer.delay();
              }
              if (this.$hideTooltipTimer.isPending()) {
                this.$hideTooltipTimer.cancel();
              }
            } else {
              if (this.isShown() && !this.$hideTooltipTimer.isPending()) {
                this.$hideTooltipTimer.delay();
              }
              if (this.$showTooltipTimer.isPending()) {
                this.$showTooltipTimer.cancel();
              }
            }
          };
          CommandBarTooltip2.prototype.$preventMouseEvent = function(e) {
            if (this.editor) {
              this.editor.focus();
            }
            e.preventDefault();
          };
          CommandBarTooltip2.prototype.$scheduleTooltipForHide = function() {
            this.$mouseInTooltip = false;
            this.$showTooltipTimer.cancel();
            this.$hideTooltipTimer.delay();
          };
          CommandBarTooltip2.prototype.$tooltipEnter = function() {
            this.$mouseInTooltip = true;
            if (this.$showTooltipTimer.isPending()) {
              this.$showTooltipTimer.cancel();
            }
            if (this.$hideTooltipTimer.isPending()) {
              this.$hideTooltipTimer.cancel();
            }
          };
          CommandBarTooltip2.prototype.$updateOnHoverHandlers = function(enableHover) {
            var tooltipEl = this.tooltip.getElement();
            var moreOptionsEl = this.moreOptions.getElement();
            if (enableHover) {
              if (this.editor) {
                this.editor.on("mousemove", this.$onMouseMove);
                this.editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.$scheduleTooltipForHide, true);
              }
              tooltipEl.addEventListener("mouseenter", this.$tooltipEnter);
              tooltipEl.addEventListener("mouseleave", this.$scheduleTooltipForHide);
              moreOptionsEl.addEventListener("mouseenter", this.$tooltipEnter);
              moreOptionsEl.addEventListener("mouseleave", this.$scheduleTooltipForHide);
            } else {
              if (this.editor) {
                this.editor.off("mousemove", this.$onMouseMove);
                this.editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.$scheduleTooltipForHide, true);
              }
              tooltipEl.removeEventListener("mouseenter", this.$tooltipEnter);
              tooltipEl.removeEventListener("mouseleave", this.$scheduleTooltipForHide);
              moreOptionsEl.removeEventListener("mouseenter", this.$tooltipEnter);
              moreOptionsEl.removeEventListener("mouseleave", this.$scheduleTooltipForHide);
            }
          };
          CommandBarTooltip2.prototype.$showTooltip = function() {
            if (this.isShown()) {
              return;
            }
            this.tooltip.setTheme(this.editor.renderer.theme);
            this.tooltip.setClassName(TOOLTIP_CLASS_NAME + "_wrapper");
            this.tooltip.show();
            this.update();
            this.updatePosition();
            this._signal("show");
          };
          CommandBarTooltip2.prototype.$hideTooltip = function() {
            this.$mouseInTooltip = false;
            if (!this.isShown()) {
              return;
            }
            this.moreOptions.hide();
            this.tooltip.hide();
            this._signal("hide");
          };
          CommandBarTooltip2.prototype.$updateElement = function(id) {
            var command = this.commands[id];
            if (!command) {
              return;
            }
            var el = this.elements[id];
            var commandEnabled = command.enabled;
            if (typeof commandEnabled === "function") {
              commandEnabled = commandEnabled(this.editor);
            }
            if (typeof command.getValue === "function") {
              var value = command.getValue(this.editor);
              if (command.type === "text") {
                el.textContent = value;
              } else if (command.type === "checkbox") {
                var domCssFn = value ? dom.addCssClass : dom.removeCssClass;
                var isOnTooltip = el.parentElement === this.tooltipEl;
                el.ariaChecked = value;
                if (isOnTooltip) {
                  domCssFn(el, "ace_selected");
                } else {
                  el = el.querySelector("." + VALUE_CLASS_NAME);
                  domCssFn(el, "ace_checkmark");
                }
              }
            }
            if (commandEnabled && el.disabled) {
              dom.removeCssClass(el, "ace_disabled");
              el.ariaDisabled = el.disabled = false;
              el.removeAttribute("disabled");
            } else if (!commandEnabled && !el.disabled) {
              dom.addCssClass(el, "ace_disabled");
              el.ariaDisabled = el.disabled = true;
              el.setAttribute("disabled", "");
            }
          };
          return CommandBarTooltip2;
        }()
      );
      oop.implement(CommandBarTooltip.prototype, EventEmitter);
      dom.importCssString("\n.ace_tooltip.".concat(TOOLTIP_CLASS_NAME, "_wrapper {\n    padding: 0;\n}\n\n.ace_tooltip .").concat(TOOLTIP_CLASS_NAME, " {\n    padding: 1px 5px;\n    display: flex;\n    pointer-events: auto;\n}\n\n.ace_tooltip .").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options {\n    padding: 1px;\n    flex-direction: column;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, " {\n    display: inline-flex;\n    cursor: pointer;\n    margin: 1px;\n    border-radius: 2px;\n    padding: 2px 5px;\n    align-items: center;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, ".ace_selected,\ndiv.").concat(BUTTON_CLASS_NAME, ":hover:not(.ace_disabled) {\n    background-color: rgba(0, 0, 0, 0.1);\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, ".ace_disabled {\n    color: #777;\n    pointer-events: none;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, " .ace_icon_svg {\n    height: 12px;\n    background-color: #000;\n}\n\ndiv.").concat(BUTTON_CLASS_NAME, ".ace_disabled .ace_icon_svg {\n    background-color: #777;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options .").concat(BUTTON_CLASS_NAME, " {\n    display: flex;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".").concat(VALUE_CLASS_NAME, " {\n    display: none;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options .").concat(VALUE_CLASS_NAME, " {\n    display: inline-block;\n    width: 12px;\n}\n\n.").concat(CAPTION_CLASS_NAME, " {\n    display: inline-block;\n}\n\n.").concat(KEYBINDING_CLASS_NAME, " {\n    margin: 0 2px;\n    display: inline-block;\n    font-size: 8px;\n}\n\n.").concat(TOOLTIP_CLASS_NAME, ".tooltip_more_options .").concat(KEYBINDING_CLASS_NAME, " {\n    margin-left: auto;\n}\n\n.").concat(KEYBINDING_CLASS_NAME, " div {\n    display: inline-block;\n    min-width: 8px;\n    padding: 2px;\n    margin: 0 1px;\n    border-radius: 2px;\n    background-color: #ccc;\n    text-align: center;\n}\n\n.ace_dark.ace_tooltip .").concat(TOOLTIP_CLASS_NAME, " {\n    background-color: #373737;\n    color: #eee;\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ".ace_disabled {\n    color: #979797;\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ".ace_selected,\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ":hover:not(.ace_disabled) {\n    background-color: rgba(255, 255, 255, 0.1);\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, " .ace_icon_svg {\n    background-color: #eee;\n}\n\n.ace_dark div.").concat(BUTTON_CLASS_NAME, ".ace_disabled .ace_icon_svg {\n    background-color: #979797;\n}\n\n.ace_dark .").concat(BUTTON_CLASS_NAME, ".ace_disabled {\n    color: #979797;\n}\n\n.ace_dark .").concat(KEYBINDING_CLASS_NAME, " div {\n    background-color: #575757;\n}\n\n.ace_checkmark::before {\n    content: '\u2713';\n}\n"), "commandbar.css", false);
      exports2.CommandBarTooltip = CommandBarTooltip;
      exports2.TOOLTIP_CLASS_NAME = TOOLTIP_CLASS_NAME;
      exports2.BUTTON_CLASS_NAME = BUTTON_CLASS_NAME;
    });
    ace.define("ace/marker_group", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var MarkerGroup = (
        /** @class */
        function() {
          function MarkerGroup2(session, options) {
            if (options)
              this.markerType = options.markerType;
            this.markers = [];
            this.session = session;
            session.addDynamicMarker(this);
          }
          MarkerGroup2.prototype.getMarkerAtPosition = function(pos) {
            return this.markers.find(function(marker) {
              return marker.range.contains(pos.row, pos.column);
            });
          };
          MarkerGroup2.prototype.markersComparator = function(a, b2) {
            return a.range.start.row - b2.range.start.row;
          };
          MarkerGroup2.prototype.setMarkers = function(markers) {
            this.markers = markers.sort(this.markersComparator).slice(0, this.MAX_MARKERS);
            this.session._signal("changeBackMarker");
          };
          MarkerGroup2.prototype.update = function(html, markerLayer, session, config) {
            if (!this.markers || !this.markers.length)
              return;
            var visibleRangeStartRow = config.firstRow, visibleRangeEndRow = config.lastRow;
            var foldLine;
            var markersOnOneLine = 0;
            var lastRow = 0;
            for (var i = 0; i < this.markers.length; i++) {
              var marker = this.markers[i];
              if (marker.range.end.row < visibleRangeStartRow)
                continue;
              if (marker.range.start.row > visibleRangeEndRow)
                continue;
              if (marker.range.start.row === lastRow) {
                markersOnOneLine++;
              } else {
                lastRow = marker.range.start.row;
                markersOnOneLine = 0;
              }
              if (markersOnOneLine > 200) {
                continue;
              }
              var markerVisibleRange = marker.range.clipRows(visibleRangeStartRow, visibleRangeEndRow);
              if (markerVisibleRange.start.row === markerVisibleRange.end.row && markerVisibleRange.start.column === markerVisibleRange.end.column) {
                continue;
              }
              var screenRange = markerVisibleRange.toScreenRange(session);
              if (screenRange.isEmpty()) {
                foldLine = session.getNextFoldLine(markerVisibleRange.end.row, foldLine);
                if (foldLine && foldLine.end.row > markerVisibleRange.end.row) {
                  visibleRangeStartRow = foldLine.end.row;
                }
                continue;
              }
              if (this.markerType === "fullLine") {
                markerLayer.drawFullLineMarker(html, screenRange, marker.className, config);
              } else if (screenRange.isMultiLine()) {
                if (this.markerType === "line")
                  markerLayer.drawMultiLineMarker(html, screenRange, marker.className, config);
                else
                  markerLayer.drawTextMarker(html, screenRange, marker.className, config);
              } else {
                markerLayer.drawSingleLineMarker(html, screenRange, marker.className + " ace_br15", config);
              }
            }
          };
          return MarkerGroup2;
        }()
      );
      MarkerGroup.prototype.MAX_MARKERS = 1e4;
      exports2.MarkerGroup = MarkerGroup;
    });
    ace.define("ace/autocomplete/text_completer", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      var Range = require3("../range").Range;
      var splitRegex = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;
      function getWordIndex(doc, pos) {
        var textBefore = doc.getTextRange(Range.fromPoints({
          row: 0,
          column: 0
        }, pos));
        return textBefore.split(splitRegex).length - 1;
      }
      function wordDistance(doc, pos) {
        var prefixPos = getWordIndex(doc, pos);
        var words = doc.getValue().split(splitRegex);
        var wordScores = /* @__PURE__ */ Object.create(null);
        var currentWord = words[prefixPos];
        words.forEach(function(word, idx) {
          if (!word || word === currentWord)
            return;
          var distance = Math.abs(prefixPos - idx);
          var score = words.length - distance;
          if (wordScores[word]) {
            wordScores[word] = Math.max(score, wordScores[word]);
          } else {
            wordScores[word] = score;
          }
        });
        return wordScores;
      }
      exports2.getCompletions = function(editor, session, pos, prefix, callback) {
        var wordScore = wordDistance(session, pos);
        var wordList = Object.keys(wordScore);
        callback(null, wordList.map(function(word) {
          return {
            caption: word,
            value: word,
            score: wordScore[word],
            meta: "local"
          };
        }));
      };
    });
    ace.define("ace/ext/language_tools", ["require", "exports", "module", "ace/snippets", "ace/autocomplete", "ace/config", "ace/lib/lang", "ace/autocomplete/util", "ace/marker_group", "ace/autocomplete/text_completer", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var snippetManager = require3("../snippets").snippetManager;
      var Autocomplete = require3("../autocomplete").Autocomplete;
      var config = require3("../config");
      var lang = require3("../lib/lang");
      var util = require3("../autocomplete/util");
      var MarkerGroup = require3("../marker_group").MarkerGroup;
      var textCompleter = require3("../autocomplete/text_completer");
      var keyWordCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
          if (session.$mode.completer) {
            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);
          }
          var state = editor.session.getState(pos.row);
          var completions = session.$mode.getCompletions(state, session, pos, prefix);
          completions = completions.map(function(el) {
            el.completerId = keyWordCompleter.id;
            return el;
          });
          callback(null, completions);
        },
        id: "keywordCompleter"
      };
      var transformSnippetTooltip = function(str) {
        var record = {};
        return str.replace(/\${(\d+)(:(.*?))?}/g, function(_2, p1, p2, p3) {
          return record[p1] = p3 || "";
        }).replace(/\$(\d+?)/g, function(_2, p1) {
          return record[p1];
        });
      };
      var snippetCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
          var scopes = [];
          var token = session.getTokenAt(pos.row, pos.column);
          if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/))
            scopes.push("html-tag");
          else
            scopes = snippetManager.getActiveScopes(editor);
          var snippetMap = snippetManager.snippetMap;
          var completions = [];
          scopes.forEach(function(scope) {
            var snippets = snippetMap[scope] || [];
            for (var i = snippets.length; i--; ) {
              var s = snippets[i];
              var caption = s.name || s.tabTrigger;
              if (!caption)
                continue;
              completions.push({
                caption,
                snippet: s.content,
                meta: s.tabTrigger && !s.name ? s.tabTrigger + "\u21E5 " : "snippet",
                completerId: snippetCompleter.id
              });
            }
          }, this);
          callback(null, completions);
        },
        getDocTooltip: function(item) {
          if (item.snippet && !item.docHTML) {
            item.docHTML = [
              "<b>",
              lang.escapeHTML(item.caption),
              "</b>",
              "<hr></hr>",
              lang.escapeHTML(transformSnippetTooltip(item.snippet))
            ].join("");
          }
        },
        id: "snippetCompleter"
      };
      var completers = [snippetCompleter, textCompleter, keyWordCompleter];
      exports2.setCompleters = function(val) {
        completers.length = 0;
        if (val)
          completers.push.apply(completers, val);
      };
      exports2.addCompleter = function(completer) {
        completers.push(completer);
      };
      exports2.textCompleter = textCompleter;
      exports2.keyWordCompleter = keyWordCompleter;
      exports2.snippetCompleter = snippetCompleter;
      var expandSnippet = {
        name: "expandSnippet",
        exec: function(editor) {
          return snippetManager.expandWithTab(editor);
        },
        bindKey: "Tab"
      };
      var onChangeMode = function(e, editor) {
        loadSnippetsForMode(editor.session.$mode);
      };
      var loadSnippetsForMode = function(mode) {
        if (typeof mode == "string")
          mode = config.$modes[mode];
        if (!mode)
          return;
        if (!snippetManager.files)
          snippetManager.files = {};
        loadSnippetFile(mode.$id, mode.snippetFileId);
        if (mode.modes)
          mode.modes.forEach(loadSnippetsForMode);
      };
      var loadSnippetFile = function(id, snippetFilePath) {
        if (!snippetFilePath || !id || snippetManager.files[id])
          return;
        snippetManager.files[id] = {};
        config.loadModule(snippetFilePath, function(m) {
          if (!m)
            return;
          snippetManager.files[id] = m;
          if (!m.snippets && m.snippetText)
            m.snippets = snippetManager.parseSnippetFile(m.snippetText);
          snippetManager.register(m.snippets || [], m.scope);
          if (m.includeScopes) {
            snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;
            m.includeScopes.forEach(function(x) {
              loadSnippetsForMode("ace/mode/" + x);
            });
          }
        });
      };
      var doLiveAutocomplete = function(e) {
        var editor = e.editor;
        var hasCompleter = editor.completer && editor.completer.activated;
        if (e.command.name === "backspace") {
          if (hasCompleter && !util.getCompletionPrefix(editor))
            editor.completer.detach();
        } else if (e.command.name === "insertstring" && !hasCompleter) {
          lastExecEvent = e;
          var delay = e.editor.$liveAutocompletionDelay;
          if (delay) {
            liveAutocompleteTimer.delay(delay);
          } else {
            showLiveAutocomplete(e);
          }
        }
      };
      var lastExecEvent;
      var liveAutocompleteTimer = lang.delayedCall(function() {
        showLiveAutocomplete(lastExecEvent);
      }, 0);
      var showLiveAutocomplete = function(e) {
        var editor = e.editor;
        var prefix = util.getCompletionPrefix(editor);
        var previousChar = e.args;
        var triggerAutocomplete = util.triggerAutocomplete(editor, previousChar);
        if (prefix && prefix.length >= editor.$liveAutocompletionThreshold || triggerAutocomplete) {
          var completer = Autocomplete.for(editor);
          completer.autoShown = true;
          completer.showPopup(editor);
        }
      };
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        enableBasicAutocompletion: {
          set: function(val) {
            if (val) {
              Autocomplete.for(this);
              if (!this.completers)
                this.completers = Array.isArray(val) ? val : completers;
              this.commands.addCommand(Autocomplete.startCommand);
            } else {
              this.commands.removeCommand(Autocomplete.startCommand);
            }
          },
          value: false
        },
        enableLiveAutocompletion: {
          set: function(val) {
            if (val) {
              if (!this.completers)
                this.completers = Array.isArray(val) ? val : completers;
              this.commands.on("afterExec", doLiveAutocomplete);
            } else {
              this.commands.off("afterExec", doLiveAutocomplete);
            }
          },
          value: false
        },
        liveAutocompletionDelay: {
          initialValue: 0
        },
        liveAutocompletionThreshold: {
          initialValue: 0
        },
        enableSnippets: {
          set: function(val) {
            if (val) {
              this.commands.addCommand(expandSnippet);
              this.on("changeMode", onChangeMode);
              onChangeMode(null, this);
            } else {
              this.commands.removeCommand(expandSnippet);
              this.off("changeMode", onChangeMode);
            }
          },
          value: false
        }
      });
      exports2.MarkerGroup = MarkerGroup;
    });
    ace.define("ace/ext/inline_autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/inline", "ace/autocomplete", "ace/autocomplete", "ace/editor", "ace/autocomplete/util", "ace/lib/dom", "ace/lib/lang", "ace/ext/command_bar", "ace/ext/command_bar", "ace/ext/language_tools", "ace/ext/language_tools", "ace/ext/language_tools", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var HashHandler = require3("../keyboard/hash_handler").HashHandler;
      var AceInline = require3("../autocomplete/inline").AceInline;
      var FilteredList = require3("../autocomplete").FilteredList;
      var CompletionProvider = require3("../autocomplete").CompletionProvider;
      var Editor = require3("../editor").Editor;
      var util = require3("../autocomplete/util");
      var dom = require3("../lib/dom");
      var lang = require3("../lib/lang");
      var CommandBarTooltip = require3("./command_bar").CommandBarTooltip;
      var BUTTON_CLASS_NAME = require3("./command_bar").BUTTON_CLASS_NAME;
      var snippetCompleter = require3("./language_tools").snippetCompleter;
      var textCompleter = require3("./language_tools").textCompleter;
      var keyWordCompleter = require3("./language_tools").keyWordCompleter;
      var destroyCompleter = function(e, editor) {
        editor.completer && editor.completer.destroy();
      };
      var InlineAutocomplete = (
        /** @class */
        function() {
          function InlineAutocomplete2(editor) {
            this.editor = editor;
            this.keyboardHandler = new HashHandler(this.commands);
            this.$index = -1;
            this.blurListener = this.blurListener.bind(this);
            this.changeListener = this.changeListener.bind(this);
            this.changeTimer = lang.delayedCall(function() {
              this.updateCompletions();
            }.bind(this));
          }
          InlineAutocomplete2.prototype.getInlineRenderer = function() {
            if (!this.inlineRenderer)
              this.inlineRenderer = new AceInline();
            return this.inlineRenderer;
          };
          InlineAutocomplete2.prototype.getInlineTooltip = function() {
            if (!this.inlineTooltip) {
              this.inlineTooltip = InlineAutocomplete2.createInlineTooltip(document.body || document.documentElement);
            }
            return this.inlineTooltip;
          };
          InlineAutocomplete2.prototype.show = function(options) {
            this.activated = true;
            if (this.editor.completer !== this) {
              if (this.editor.completer)
                this.editor.completer.detach();
              this.editor.completer = this;
            }
            this.editor.on("changeSelection", this.changeListener);
            this.editor.on("blur", this.blurListener);
            this.updateCompletions(options);
          };
          InlineAutocomplete2.prototype.$open = function() {
            if (this.editor.textInput.setAriaOptions) {
              this.editor.textInput.setAriaOptions({});
            }
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            this.getInlineTooltip().attach(this.editor);
            if (this.$index === -1) {
              this.setIndex(0);
            } else {
              this.$showCompletion();
            }
            this.changeTimer.cancel();
          };
          InlineAutocomplete2.prototype.insertMatch = function() {
            var result = this.getCompletionProvider().insertByIndex(this.editor, this.$index);
            this.detach();
            return result;
          };
          InlineAutocomplete2.prototype.changeListener = function(e) {
            var cursor = this.editor.selection.lead;
            if (cursor.row != this.base.row || cursor.column < this.base.column) {
              this.detach();
            }
            if (this.activated)
              this.changeTimer.schedule();
            else
              this.detach();
          };
          InlineAutocomplete2.prototype.blurListener = function(e) {
            this.detach();
          };
          InlineAutocomplete2.prototype.goTo = function(where) {
            if (!this.completions || !this.completions.filtered) {
              return;
            }
            var completionLength = this.completions.filtered.length;
            switch (where.toLowerCase()) {
              case "prev":
                this.setIndex((this.$index - 1 + completionLength) % completionLength);
                break;
              case "next":
                this.setIndex((this.$index + 1 + completionLength) % completionLength);
                break;
              case "first":
                this.setIndex(0);
                break;
              case "last":
                this.setIndex(this.completions.filtered.length - 1);
                break;
            }
          };
          InlineAutocomplete2.prototype.getLength = function() {
            if (!this.completions || !this.completions.filtered) {
              return 0;
            }
            return this.completions.filtered.length;
          };
          InlineAutocomplete2.prototype.getData = function(index) {
            if (index == void 0 || index === null) {
              return this.completions.filtered[this.$index];
            } else {
              return this.completions.filtered[index];
            }
          };
          InlineAutocomplete2.prototype.getIndex = function() {
            return this.$index;
          };
          InlineAutocomplete2.prototype.isOpen = function() {
            return this.$index >= 0;
          };
          InlineAutocomplete2.prototype.setIndex = function(value) {
            if (!this.completions || !this.completions.filtered) {
              return;
            }
            var newIndex = Math.max(-1, Math.min(this.completions.filtered.length - 1, value));
            if (newIndex !== this.$index) {
              this.$index = newIndex;
              this.$showCompletion();
            }
          };
          InlineAutocomplete2.prototype.getCompletionProvider = function(initialPosition) {
            if (!this.completionProvider)
              this.completionProvider = new CompletionProvider(initialPosition);
            return this.completionProvider;
          };
          InlineAutocomplete2.prototype.$showCompletion = function() {
            if (!this.getInlineRenderer().show(this.editor, this.completions.filtered[this.$index], this.completions.filterText)) {
              this.getInlineRenderer().hide();
            }
            if (this.inlineTooltip && this.inlineTooltip.isShown()) {
              this.inlineTooltip.update();
            }
          };
          InlineAutocomplete2.prototype.$updatePrefix = function() {
            var pos = this.editor.getCursorPosition();
            var prefix = this.editor.session.getTextRange({ start: this.base, end: pos });
            this.completions.setFilter(prefix);
            if (!this.completions.filtered.length)
              return this.detach();
            if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == prefix && !this.completions.filtered[0].snippet)
              return this.detach();
            this.$open(this.editor, prefix);
            return prefix;
          };
          InlineAutocomplete2.prototype.updateCompletions = function(options) {
            var prefix = "";
            if (options && options.matches) {
              var pos = this.editor.getSelectionRange().start;
              this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
              this.base.$insertRight = true;
              this.completions = new FilteredList(options.matches);
              return this.$open(this.editor, "");
            }
            if (this.base && this.completions) {
              prefix = this.$updatePrefix();
            }
            var session = this.editor.getSession();
            var pos = this.editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(this.editor);
            this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
            this.base.$insertRight = true;
            var options = {
              exactMatch: true,
              ignoreCaption: true
            };
            this.getCompletionProvider({
              prefix,
              base: this.base,
              pos
            }).provideCompletions(
              this.editor,
              options,
              function(err, completions, finished) {
                var filtered = completions.filtered;
                var prefix2 = util.getCompletionPrefix(this.editor);
                if (finished) {
                  if (!filtered.length)
                    return this.detach();
                  if (filtered.length == 1 && filtered[0].value == prefix2 && !filtered[0].snippet)
                    return this.detach();
                }
                this.completions = completions;
                this.$open(this.editor, prefix2);
              }.bind(this)
            );
          };
          InlineAutocomplete2.prototype.detach = function() {
            if (this.editor) {
              this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
              this.editor.off("changeSelection", this.changeListener);
              this.editor.off("blur", this.blurListener);
            }
            this.changeTimer.cancel();
            if (this.inlineTooltip) {
              this.inlineTooltip.detach();
            }
            this.setIndex(-1);
            if (this.completionProvider) {
              this.completionProvider.detach();
            }
            if (this.inlineRenderer && this.inlineRenderer.isOpen()) {
              this.inlineRenderer.hide();
            }
            if (this.base)
              this.base.detach();
            this.activated = false;
            this.completionProvider = this.completions = this.base = null;
          };
          InlineAutocomplete2.prototype.destroy = function() {
            this.detach();
            if (this.inlineRenderer)
              this.inlineRenderer.destroy();
            if (this.inlineTooltip)
              this.inlineTooltip.destroy();
            if (this.editor && this.editor.completer == this) {
              this.editor.off("destroy", destroyCompleter);
              this.editor.completer = null;
            }
            this.inlineTooltip = this.editor = this.inlineRenderer = null;
          };
          InlineAutocomplete2.prototype.updateDocTooltip = function() {
          };
          return InlineAutocomplete2;
        }()
      );
      InlineAutocomplete.prototype.commands = {
        "Previous": {
          bindKey: "Alt-[",
          name: "Previous",
          exec: function(editor) {
            editor.completer.goTo("prev");
          }
        },
        "Next": {
          bindKey: "Alt-]",
          name: "Next",
          exec: function(editor) {
            editor.completer.goTo("next");
          }
        },
        "Accept": {
          bindKey: { win: "Tab|Ctrl-Right", mac: "Tab|Cmd-Right" },
          name: "Accept",
          exec: function(editor) {
            return (
              /**@type{InlineAutocomplete}*/
              editor.completer.insertMatch()
            );
          }
        },
        "Close": {
          bindKey: "Esc",
          name: "Close",
          exec: function(editor) {
            editor.completer.detach();
          }
        }
      };
      InlineAutocomplete.for = function(editor) {
        if (editor.completer instanceof InlineAutocomplete) {
          return editor.completer;
        }
        if (editor.completer) {
          editor.completer.destroy();
          editor.completer = null;
        }
        editor.completer = new InlineAutocomplete(editor);
        editor.once("destroy", destroyCompleter);
        return editor.completer;
      };
      InlineAutocomplete.startCommand = {
        name: "startInlineAutocomplete",
        exec: function(editor, options) {
          var completer = InlineAutocomplete.for(editor);
          completer.show(options);
        },
        bindKey: { win: "Alt-C", mac: "Option-C" }
      };
      var completers = [snippetCompleter, textCompleter, keyWordCompleter];
      require3("../config").defineOptions(Editor.prototype, "editor", {
        enableInlineAutocompletion: {
          set: function(val) {
            if (val) {
              if (!this.completers)
                this.completers = Array.isArray(val) ? val : completers;
              this.commands.addCommand(InlineAutocomplete.startCommand);
            } else {
              this.commands.removeCommand(InlineAutocomplete.startCommand);
            }
          },
          value: false
        }
      });
      InlineAutocomplete.createInlineTooltip = function(parentEl) {
        var inlineTooltip = new CommandBarTooltip(parentEl);
        inlineTooltip.registerCommand(
          "Previous",
          Object.assign({}, InlineAutocomplete.prototype.commands["Previous"], {
            enabled: true,
            type: "button",
            iconCssClass: "ace_arrow_rotated"
          })
        );
        inlineTooltip.registerCommand("Position", {
          enabled: false,
          getValue: function(editor) {
            return editor ? [
              editor.completer.getIndex() + 1,
              /**@type{InlineAutocomplete}*/
              editor.completer.getLength()
            ].join("/") : "";
          },
          type: "text",
          cssClass: "completion_position"
        });
        inlineTooltip.registerCommand(
          "Next",
          Object.assign({}, InlineAutocomplete.prototype.commands["Next"], {
            enabled: true,
            type: "button",
            iconCssClass: "ace_arrow"
          })
        );
        inlineTooltip.registerCommand(
          "Accept",
          Object.assign({}, InlineAutocomplete.prototype.commands["Accept"], {
            enabled: function(editor) {
              return !!editor && editor.completer.getIndex() >= 0;
            },
            type: "button"
          })
        );
        inlineTooltip.registerCommand("ShowTooltip", {
          name: "Always Show Tooltip",
          exec: function() {
            inlineTooltip.setAlwaysShow(!inlineTooltip.getAlwaysShow());
          },
          enabled: true,
          getValue: function() {
            return inlineTooltip.getAlwaysShow();
          },
          type: "checkbox"
        });
        return inlineTooltip;
      };
      dom.importCssString('\n\n.ace_icon_svg.ace_arrow,\n.ace_icon_svg.ace_arrow_rotated {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODM3MDEgMTVMNC41ODc1MSAxMy43MTU1TDEwLjE0NjggOEw0LjU4NzUxIDIuMjg0NDZMNS44MzcwMSAxTDEyLjY0NjUgOEw1LjgzNzAxIDE1WiIgZmlsbD0iYmxhY2siLz48L3N2Zz4=");\n}\n\n.ace_icon_svg.ace_arrow_rotated {\n    transform: rotate(180deg);\n}\n\ndiv.'.concat(BUTTON_CLASS_NAME, ".completion_position {\n    padding: 0;\n}\n"), "inlineautocomplete.css", false);
      exports2.InlineAutocomplete = InlineAutocomplete;
    });
    (function() {
      ace.require(["ace/ext/inline_autocomplete"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-keybinding_menu.js
var require_ext_keybinding_menu = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-keybinding_menu.js"(exports, module2) {
    ace.define("ace/ext/menu_tools/settings_menu.css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = "#ace_settingsmenu, #kbshortcutmenu {\n    background-color: #F7F7F7;\n    color: black;\n    box-shadow: -5px 4px 5px rgba(126, 126, 126, 0.55);\n    padding: 1em 0.5em 2em 1em;\n    overflow: auto;\n    position: absolute;\n    margin: 0;\n    bottom: 0;\n    right: 0;\n    top: 0;\n    z-index: 9991;\n    cursor: default;\n}\n\n.ace_dark #ace_settingsmenu, .ace_dark #kbshortcutmenu {\n    box-shadow: -20px 10px 25px rgba(126, 126, 126, 0.25);\n    background-color: rgba(255, 255, 255, 0.6);\n    color: black;\n}\n\n.ace_optionsMenuEntry:hover {\n    background-color: rgba(100, 100, 100, 0.1);\n    transition: all 0.3s\n}\n\n.ace_closeButton {\n    background: rgba(245, 146, 146, 0.5);\n    border: 1px solid #F48A8A;\n    border-radius: 50%;\n    padding: 7px;\n    position: absolute;\n    right: -8px;\n    top: -8px;\n    z-index: 100000;\n}\n.ace_closeButton{\n    background: rgba(245, 146, 146, 0.9);\n}\n.ace_optionsMenuKey {\n    color: darkslateblue;\n    font-weight: bold;\n}\n.ace_optionsMenuCommand {\n    color: darkcyan;\n    font-weight: normal;\n}\n.ace_optionsMenuEntry input, .ace_optionsMenuEntry button {\n    vertical-align: middle;\n}\n\n.ace_optionsMenuEntry button[ace_selected_button=true] {\n    background: #e7e7e7;\n    box-shadow: 1px 0px 2px 0px #adadad inset;\n    border-color: #adadad;\n}\n.ace_optionsMenuEntry button {\n    background: white;\n    border: 1px solid lightgray;\n    margin: 0px;\n}\n.ace_optionsMenuEntry button:hover{\n    background: #f0f0f0;\n}";
    });
    ace.define("ace/ext/menu_tools/overlay_page", ["require", "exports", "module", "ace/ext/menu_tools/overlay_page", "ace/lib/dom", "ace/ext/menu_tools/settings_menu.css"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../../lib/dom");
      var cssText = require3("./settings_menu.css");
      dom.importCssString(cssText, "settings_menu.css", false);
      module3.exports.overlayPage = function overlayPage(editor, contentElement, callback) {
        var closer = document.createElement("div");
        var ignoreFocusOut = false;
        function documentEscListener(e) {
          if (e.keyCode === 27) {
            close();
          }
        }
        function close() {
          if (!closer)
            return;
          document.removeEventListener("keydown", documentEscListener);
          closer.parentNode.removeChild(closer);
          if (editor) {
            editor.focus();
          }
          closer = null;
          callback && callback();
        }
        function setIgnoreFocusOut(ignore) {
          ignoreFocusOut = ignore;
          if (ignore) {
            closer.style.pointerEvents = "none";
            contentElement.style.pointerEvents = "auto";
          }
        }
        closer.style.cssText = "margin: 0; padding: 0; position: fixed; top:0; bottom:0; left:0; right:0;z-index: 9990; " + (editor ? "background-color: rgba(0, 0, 0, 0.3);" : "");
        closer.addEventListener("click", function(e) {
          if (!ignoreFocusOut) {
            close();
          }
        });
        document.addEventListener("keydown", documentEscListener);
        contentElement.addEventListener("click", function(e) {
          e.stopPropagation();
        });
        closer.appendChild(contentElement);
        document.body.appendChild(closer);
        if (editor) {
          editor.blur();
        }
        return {
          close,
          setIgnoreFocusOut
        };
      };
    });
    ace.define("ace/ext/menu_tools/get_editor_keyboard_shortcuts", ["require", "exports", "module", "ace/ext/menu_tools/get_editor_keyboard_shortcuts", "ace/lib/keys"], function(require3, exports2, module3) {
      "use strict";
      var keys = require3("../../lib/keys");
      module3.exports.getEditorKeybordShortcuts = function(editor) {
        var KEY_MODS = keys.KEY_MODS;
        var keybindings = [];
        var commandMap = {};
        editor.keyBinding.$handlers.forEach(function(handler) {
          var ckb = handler["commandKeyBinding"];
          for (var i in ckb) {
            var key = i.replace(/(^|-)\w/g, function(x) {
              return x.toUpperCase();
            });
            var commands = ckb[i];
            if (!Array.isArray(commands))
              commands = [commands];
            commands.forEach(function(command) {
              if (typeof command != "string")
                command = command.name;
              if (commandMap[command]) {
                commandMap[command].key += "|" + key;
              } else {
                commandMap[command] = { key, command };
                keybindings.push(commandMap[command]);
              }
            });
          }
        });
        return keybindings;
      };
    });
    ace.define("ace/ext/keybinding_menu", ["require", "exports", "module", "ace/editor", "ace/ext/menu_tools/overlay_page", "ace/ext/menu_tools/get_editor_keyboard_shortcuts"], function(require3, exports2, module3) {
      "use strict";
      var Editor = require3("../editor").Editor;
      function showKeyboardShortcuts(editor) {
        if (!document.getElementById("kbshortcutmenu")) {
          var overlayPage = require3("./menu_tools/overlay_page").overlayPage;
          var getEditorKeybordShortcuts = require3("./menu_tools/get_editor_keyboard_shortcuts").getEditorKeybordShortcuts;
          var kb = getEditorKeybordShortcuts(editor);
          var el = document.createElement("div");
          var commands = kb.reduce(function(previous, current) {
            return previous + '<div class="ace_optionsMenuEntry"><span class="ace_optionsMenuCommand">' + current.command + '</span> : <span class="ace_optionsMenuKey">' + current.key + "</span></div>";
          }, "");
          el.id = "kbshortcutmenu";
          el.innerHTML = "<h1>Keyboard Shortcuts</h1>" + commands + "</div>";
          overlayPage(editor, el);
        }
      }
      module3.exports.init = function(editor) {
        Editor.prototype.showKeyboardShortcuts = function() {
          showKeyboardShortcuts(this);
        };
        editor.commands.addCommands([{
          name: "showKeyboardShortcuts",
          bindKey: {
            win: "Ctrl-Alt-h",
            mac: "Command-Alt-h"
          },
          exec: function(editor2, line) {
            editor2.showKeyboardShortcuts();
          }
        }]);
      };
    });
    (function() {
      ace.require(["ace/ext/keybinding_menu"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-language_tools.js
var require_ext_language_tools = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-language_tools.js"(exports, module2) {
    ace.define("ace/snippets", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/range_list", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/clipboard", "ace/editor"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("./lib/dom");
      var oop = require3("./lib/oop");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var lang = require3("./lib/lang");
      var Range = require3("./range").Range;
      var RangeList = require3("./range_list").RangeList;
      var HashHandler = require3("./keyboard/hash_handler").HashHandler;
      var Tokenizer = require3("./tokenizer").Tokenizer;
      var clipboard = require3("./clipboard");
      var VARIABLES = {
        CURRENT_WORD: function(editor) {
          return editor.session.getTextRange(editor.session.getWordRange());
        },
        SELECTION: function(editor, name, indentation) {
          var text = editor.session.getTextRange();
          if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, "\n" + indentation + "$1");
          return text;
        },
        CURRENT_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row);
        },
        PREV_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row - 1);
        },
        LINE_INDEX: function(editor) {
          return editor.getCursorPosition().row;
        },
        LINE_NUMBER: function(editor) {
          return editor.getCursorPosition().row + 1;
        },
        SOFT_TABS: function(editor) {
          return editor.session.getUseSoftTabs() ? "YES" : "NO";
        },
        TAB_SIZE: function(editor) {
          return editor.session.getTabSize();
        },
        CLIPBOARD: function(editor) {
          return clipboard.getText && clipboard.getText();
        },
        FILENAME: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
        },
        FILENAME_BASE: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, "");
        },
        DIRECTORY: function(editor) {
          return this.FILEPATH(editor).replace(/[^/\\]*$/, "");
        },
        FILEPATH: function(editor) {
          return "/not implemented.txt";
        },
        WORKSPACE_NAME: function() {
          return "Unknown";
        },
        FULLNAME: function() {
          return "Unknown";
        },
        BLOCK_COMMENT_START: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.start || "";
        },
        BLOCK_COMMENT_END: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.end || "";
        },
        LINE_COMMENT: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.lineCommentStart || "";
        },
        CURRENT_YEAR: date.bind(null, { year: "numeric" }),
        CURRENT_YEAR_SHORT: date.bind(null, { year: "2-digit" }),
        CURRENT_MONTH: date.bind(null, { month: "numeric" }),
        CURRENT_MONTH_NAME: date.bind(null, { month: "long" }),
        CURRENT_MONTH_NAME_SHORT: date.bind(null, { month: "short" }),
        CURRENT_DATE: date.bind(null, { day: "2-digit" }),
        CURRENT_DAY_NAME: date.bind(null, { weekday: "long" }),
        CURRENT_DAY_NAME_SHORT: date.bind(null, { weekday: "short" }),
        CURRENT_HOUR: date.bind(null, { hour: "2-digit", hour12: false }),
        CURRENT_MINUTE: date.bind(null, { minute: "2-digit" }),
        CURRENT_SECOND: date.bind(null, { second: "2-digit" })
      };
      VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;
      function date(dateFormat) {
        var str = (/* @__PURE__ */ new Date()).toLocaleString("en-us", dateFormat);
        return str.length == 1 ? "0" + str : str;
      }
      var SnippetManager = (
        /** @class */
        function() {
          function SnippetManager2() {
            this.snippetMap = {};
            this.snippetNameMap = {};
            this.variables = VARIABLES;
          }
          SnippetManager2.prototype.getTokenizer = function() {
            return SnippetManager2["$tokenizer"] || this.createTokenizer();
          };
          SnippetManager2.prototype.createTokenizer = function() {
            function TabstopToken(str) {
              str = str.substr(1);
              if (/^\d+$/.test(str))
                return [{ tabstopId: parseInt(str, 10) }];
              return [{ text: str }];
            }
            function escape(ch) {
              return "(?:[^\\\\" + ch + "]|\\\\.)";
            }
            var formatMatcher = {
              regex: "/(" + escape("/") + "+)/",
              onMatch: function(val, state, stack) {
                var ts2 = stack[0];
                ts2.fmtString = true;
                ts2.guard = val.slice(1, -1);
                ts2.flag = "";
                return "";
              },
              next: "formatString"
            };
            SnippetManager2["$tokenizer"] = new Tokenizer({
              start: [
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length) {
                    val = ch;
                  } else if ("`$\\".indexOf(ch) != -1) {
                    val = ch;
                  }
                  return [val];
                } },
                { regex: /}/, onMatch: function(val, state, stack) {
                  return [stack.length ? stack.shift() : val];
                } },
                { regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken },
                { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                  var t = TabstopToken(str.substr(1));
                  stack.unshift(t[0]);
                  return t;
                }, next: "snippetVar" },
                { regex: /\n/, token: "newline", merge: false }
              ],
              snippetVar: [
                { regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                  var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function(operator) {
                    return operator.length == 2 ? operator[1] : "\0";
                  }).split("\0").map(function(value) {
                    return { value };
                  });
                  stack[0].choices = choices;
                  return [choices[0]];
                }, next: "start" },
                formatMatcher,
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start" }
              ],
              formatString: [
                { regex: /:/, onMatch: function(val, state, stack) {
                  if (stack.length && stack[0].expectElse) {
                    stack[0].expectElse = false;
                    stack[0].ifEnd = { elseEnd: stack[0] };
                    return [stack[0].ifEnd];
                  }
                  return ":";
                } },
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length)
                    val = ch;
                  else if ("`$\\".indexOf(ch) != -1)
                    val = ch;
                  else if (ch == "n")
                    val = "\n";
                  else if (ch == "t")
                    val = "	";
                  else if ("ulULE".indexOf(ch) != -1)
                    val = { changeCase: ch, local: ch > "a" };
                  return [val];
                } },
                { regex: "/\\w*}", onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  if (next)
                    next.flag = val.slice(1, -1);
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" },
                { regex: /\$(?:\d+|\w+)/, onMatch: function(val, state, stack) {
                  return [{ text: val.slice(1) }];
                } },
                { regex: /\${\w+/, onMatch: function(val, state, stack) {
                  var token = { text: val.slice(2) };
                  stack.unshift(token);
                  return [token];
                }, next: "formatStringVar" },
                { regex: /\n/, token: "newline", merge: false },
                { regex: /}/, onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" }
              ],
              formatStringVar: [
                { regex: /:\/\w+}/, onMatch: function(val, state, stack) {
                  var ts2 = stack[0];
                  ts2.formatFunction = val.slice(2, -1);
                  return [stack.shift()];
                }, next: "formatString" },
                formatMatcher,
                { regex: /:[\?\-+]?/, onMatch: function(val, state, stack) {
                  if (val[1] == "+")
                    stack[0].ifEnd = stack[0];
                  if (val[1] == "?")
                    stack[0].expectElse = true;
                }, next: "formatString" },
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString" }
              ]
            });
            return SnippetManager2["$tokenizer"];
          };
          SnippetManager2.prototype.tokenizeTmSnippet = function(str, startState) {
            return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
              return x.value || x;
            });
          };
          SnippetManager2.prototype.getVariableValue = function(editor, name, indentation) {
            if (/^\d+$/.test(name))
              return (this.variables.__ || {})[name] || "";
            if (/^[A-Z]\d+$/.test(name))
              return (this.variables[name[0] + "__"] || {})[name.substr(1)] || "";
            name = name.replace(/^TM_/, "");
            if (!this.variables.hasOwnProperty(name))
              return "";
            var value = this.variables[name];
            if (typeof value == "function")
              value = this.variables[name](editor, name, indentation);
            return value == null ? "" : value;
          };
          SnippetManager2.prototype.tmStrFormat = function(str, ch, editor) {
            if (!ch.fmt)
              return str;
            var flag = ch.flag || "";
            var re3 = ch.guard;
            re3 = new RegExp(re3, flag.replace(/[^gim]/g, ""));
            var fmtTokens = typeof ch.fmt == "string" ? this.tokenizeTmSnippet(ch.fmt, "formatString") : ch.fmt;
            var _self = this;
            var formatted = str.replace(re3, function() {
              var oldArgs = _self.variables.__;
              _self.variables.__ = [].slice.call(arguments);
              var fmtParts = _self.resolveVariables(fmtTokens, editor);
              var gChangeCase = "E";
              for (var i = 0; i < fmtParts.length; i++) {
                var ch2 = fmtParts[i];
                if (typeof ch2 == "object") {
                  fmtParts[i] = "";
                  if (ch2.changeCase && ch2.local) {
                    var next = fmtParts[i + 1];
                    if (next && typeof next == "string") {
                      if (ch2.changeCase == "u")
                        fmtParts[i] = next[0].toUpperCase();
                      else
                        fmtParts[i] = next[0].toLowerCase();
                      fmtParts[i + 1] = next.substr(1);
                    }
                  } else if (ch2.changeCase) {
                    gChangeCase = ch2.changeCase;
                  }
                } else if (gChangeCase == "U") {
                  fmtParts[i] = ch2.toUpperCase();
                } else if (gChangeCase == "L") {
                  fmtParts[i] = ch2.toLowerCase();
                }
              }
              _self.variables.__ = oldArgs;
              return fmtParts.join("");
            });
            return formatted;
          };
          SnippetManager2.prototype.tmFormatFunction = function(str, ch, editor) {
            if (ch.formatFunction == "upcase")
              return str.toUpperCase();
            if (ch.formatFunction == "downcase")
              return str.toLowerCase();
            return str;
          };
          SnippetManager2.prototype.resolveVariables = function(snippet, editor) {
            var result = [];
            var indentation = "";
            var afterNewLine = true;
            for (var i = 0; i < snippet.length; i++) {
              var ch = snippet[i];
              if (typeof ch == "string") {
                result.push(ch);
                if (ch == "\n") {
                  afterNewLine = true;
                  indentation = "";
                } else if (afterNewLine) {
                  indentation = /^\t*/.exec(ch)[0];
                  afterNewLine = /\S/.test(ch);
                }
                continue;
              }
              if (!ch)
                continue;
              afterNewLine = false;
              if (ch.fmtString) {
                var j3 = snippet.indexOf(ch, i + 1);
                if (j3 == -1)
                  j3 = snippet.length;
                ch.fmt = snippet.slice(i + 1, j3);
                i = j3;
              }
              if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + "";
                if (ch.fmtString)
                  value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                  value = this.tmFormatFunction(value, ch, editor);
                if (value && !ch.ifEnd) {
                  result.push(value);
                  gotoNext(ch);
                } else if (!value && ch.ifEnd) {
                  gotoNext(ch.ifEnd);
                }
              } else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
              } else if (ch.tabstopId != null) {
                result.push(ch);
              } else if (ch.changeCase != null) {
                result.push(ch);
              }
            }
            function gotoNext(ch2) {
              var i1 = snippet.indexOf(ch2, i + 1);
              if (i1 != -1)
                i = i1;
            }
            return result;
          };
          SnippetManager2.prototype.getDisplayTextForSnippet = function(editor, snippetText) {
            var processedSnippet = processSnippetText.call(this, editor, snippetText);
            return processedSnippet.text;
          };
          SnippetManager2.prototype.insertSnippetForSelection = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var processedSnippet = processSnippetText.call(this, editor, snippetText, options);
            var range = editor.getSelectionRange();
            var end = editor.session.replace(range, processedSnippet.text);
            var tabstopManager = new TabstopManager(editor);
            var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
            tabstopManager.addTabstops(processedSnippet.tabstops, range.start, end, selectionId);
          };
          SnippetManager2.prototype.insertSnippet = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var self2 = this;
            if (editor.inVirtualSelectionMode)
              return self2.insertSnippetForSelection(editor, snippetText, options);
            editor.forEachSelection(function() {
              self2.insertSnippetForSelection(editor, snippetText, options);
            }, null, { keepOrder: true });
            if (editor.tabstopManager)
              editor.tabstopManager.tabNext();
          };
          SnippetManager2.prototype.$getScope = function(editor) {
            var scope = editor.session.$mode.$id || "";
            scope = scope.split("/").pop();
            if (scope === "html" || scope === "php") {
              if (scope === "php" && !editor.session.$mode.inlinePhp)
                scope = "html";
              var c = editor.getCursorPosition();
              var state = editor.session.getState(c.row);
              if (typeof state === "object") {
                state = state[0];
              }
              if (state.substring) {
                if (state.substring(0, 3) == "js-")
                  scope = "javascript";
                else if (state.substring(0, 4) == "css-")
                  scope = "css";
                else if (state.substring(0, 4) == "php-")
                  scope = "php";
              }
            }
            return scope;
          };
          SnippetManager2.prototype.getActiveScopes = function(editor) {
            var scope = this.$getScope(editor);
            var scopes = [scope];
            var snippetMap = this.snippetMap;
            if (snippetMap[scope] && snippetMap[scope].includeScopes) {
              scopes.push.apply(scopes, snippetMap[scope].includeScopes);
            }
            scopes.push("_");
            return scopes;
          };
          SnippetManager2.prototype.expandWithTab = function(editor, options) {
            var self2 = this;
            var result = editor.forEachSelection(function() {
              return self2.expandSnippetForSelection(editor, options);
            }, null, { keepOrder: true });
            if (result && editor.tabstopManager)
              editor.tabstopManager.tabNext();
            return result;
          };
          SnippetManager2.prototype.expandSnippetForSelection = function(editor, options) {
            var cursor = editor.getCursorPosition();
            var line = editor.session.getLine(cursor.row);
            var before = line.substring(0, cursor.column);
            var after = line.substr(cursor.column);
            var snippetMap = this.snippetMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
              return !!snippet;
            }, this);
            if (!snippet)
              return false;
            if (options && options.dryRun)
              return true;
            editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
            this.variables.M__ = snippet.matchBefore;
            this.variables.T__ = snippet.matchAfter;
            this.insertSnippetForSelection(editor, snippet.content);
            this.variables.M__ = this.variables.T__ = null;
            return true;
          };
          SnippetManager2.prototype.findMatchingSnippet = function(snippetList, before, after) {
            for (var i = snippetList.length; i--; ) {
              var s = snippetList[i];
              if (s.startRe && !s.startRe.test(before))
                continue;
              if (s.endRe && !s.endRe.test(after))
                continue;
              if (!s.startRe && !s.endRe)
                continue;
              s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
              s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
              s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
              s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
              return s;
            }
          };
          SnippetManager2.prototype.register = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            var self2 = this;
            if (!snippets)
              snippets = [];
            function wrapRegexp(src) {
              if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = "(?:" + src + ")";
              return src || "";
            }
            function guardedRegexp(re3, guard, opening) {
              re3 = wrapRegexp(re3);
              guard = wrapRegexp(guard);
              if (opening) {
                re3 = guard + re3;
                if (re3 && re3[re3.length - 1] != "$")
                  re3 = re3 + "$";
              } else {
                re3 = re3 + guard;
                if (re3 && re3[0] != "^")
                  re3 = "^" + re3;
              }
              return new RegExp(re3);
            }
            function addSnippet(s) {
              if (!s.scope)
                s.scope = scope || "_";
              scope = s.scope;
              if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
              }
              var map = snippetNameMap[scope];
              if (s.name) {
                var old = map[s.name];
                if (old)
                  self2.unregister(old);
                map[s.name] = s;
              }
              snippetMap[scope].push(s);
              if (s.prefix)
                s.tabTrigger = s.prefix;
              if (!s.content && s.body)
                s.content = Array.isArray(s.body) ? s.body.join("\n") : s.body;
              if (s.tabTrigger && !s.trigger) {
                if (!s.guard && /^\w/.test(s.tabTrigger))
                  s.guard = "\\b";
                s.trigger = lang.escapeRegExp(s.tabTrigger);
              }
              if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)
                return;
              s.startRe = guardedRegexp(s.trigger, s.guard, true);
              s.triggerRe = new RegExp(s.trigger);
              s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
              s.endTriggerRe = new RegExp(s.endTrigger);
            }
            if (Array.isArray(snippets)) {
              snippets.forEach(addSnippet);
            } else {
              Object.keys(snippets).forEach(function(key) {
                addSnippet(snippets[key]);
              });
            }
            this._signal("registerSnippets", { scope });
          };
          SnippetManager2.prototype.unregister = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            function removeSnippet(s) {
              var nameMap = snippetNameMap[s.scope || scope];
              if (nameMap && nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope || scope];
                var i = map && map.indexOf(s);
                if (i >= 0)
                  map.splice(i, 1);
              }
            }
            if (snippets.content)
              removeSnippet(snippets);
            else if (Array.isArray(snippets))
              snippets.forEach(removeSnippet);
          };
          SnippetManager2.prototype.parseSnippetFile = function(str) {
            str = str.replace(/\r/g, "");
            var list = [], snippet = {};
            var re3 = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
            var m;
            while (m = re3.exec(str)) {
              if (m[1]) {
                try {
                  snippet = JSON.parse(m[1]);
                  list.push(snippet);
                } catch (e) {
                }
              }
              if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, "");
                list.push(snippet);
                snippet = {};
              } else {
                var key = m[2], val = m[3];
                if (key == "regex") {
                  var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                  snippet.guard = guardRe.exec(val)[1];
                  snippet.trigger = guardRe.exec(val)[1];
                  snippet.endTrigger = guardRe.exec(val)[1];
                  snippet.endGuard = guardRe.exec(val)[1];
                } else if (key == "snippet") {
                  snippet.tabTrigger = val.match(/^\S*/)[0];
                  if (!snippet.name)
                    snippet.name = val;
                } else if (key) {
                  snippet[key] = val;
                }
              }
            }
            return list;
          };
          SnippetManager2.prototype.getSnippetByName = function(name, editor) {
            var snippetMap = this.snippetNameMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = snippets[name];
              return !!snippet;
            }, this);
            return snippet;
          };
          return SnippetManager2;
        }()
      );
      oop.implement(SnippetManager.prototype, EventEmitter);
      var processSnippetText = function(editor, snippetText, options) {
        if (options === void 0) {
          options = {};
        }
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var tabString = editor.session.getTabString();
        var indentString = line.match(/^\s*/)[0];
        if (cursor.column < indentString.length)
          indentString = indentString.slice(0, cursor.column);
        snippetText = snippetText.replace(/\r/g, "");
        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function(x) {
          if (x == "\n" && !options.excludeExtraIndent)
            return x + indentString;
          if (typeof x == "string")
            return x.replace(/\t/g, tabString);
          return x;
        });
        var tabstops = [];
        tokens.forEach(function(p2, i2) {
          if (typeof p2 != "object")
            return;
          var id2 = p2.tabstopId;
          var ts3 = tabstops[id2];
          if (!ts3) {
            ts3 = tabstops[id2] = [];
            ts3.index = id2;
            ts3.value = "";
            ts3.parents = {};
          }
          if (ts3.indexOf(p2) !== -1)
            return;
          if (p2.choices && !ts3.choices)
            ts3.choices = p2.choices;
          ts3.push(p2);
          var i12 = tokens.indexOf(p2, i2 + 1);
          if (i12 === -1)
            return;
          var value2 = tokens.slice(i2 + 1, i12);
          var isNested = value2.some(function(t) {
            return typeof t === "object";
          });
          if (isNested && !ts3.value) {
            ts3.value = value2;
          } else if (value2.length && (!ts3.value || typeof ts3.value !== "string")) {
            ts3.value = value2.join("");
          }
        });
        tabstops.forEach(function(ts3) {
          ts3.length = 0;
        });
        var expanding = {};
        function copyValue(val) {
          var copy = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            var p2 = val[i2];
            if (typeof p2 == "object") {
              if (expanding[p2.tabstopId])
                continue;
              var j3 = val.lastIndexOf(p2, i2 - 1);
              p2 = copy[j3] || { tabstopId: p2.tabstopId };
            }
            copy[i2] = p2;
          }
          return copy;
        }
        for (var i = 0; i < tokens.length; i++) {
          var p = tokens[i];
          if (typeof p != "object")
            continue;
          var id = p.tabstopId;
          var ts2 = tabstops[id];
          var i1 = tokens.indexOf(p, i + 1);
          if (expanding[id]) {
            if (expanding[id] === p) {
              delete expanding[id];
              Object.keys(expanding).forEach(function(parentId) {
                ts2.parents[parentId] = true;
              });
            }
            continue;
          }
          expanding[id] = p;
          var value = ts2.value;
          if (typeof value !== "string")
            value = copyValue(value);
          else if (p.fmt)
            value = this.tmStrFormat(value, p, editor);
          tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));
          if (ts2.indexOf(p) === -1)
            ts2.push(p);
        }
        var row = 0, column = 0;
        var text = "";
        tokens.forEach(function(t) {
          if (typeof t === "string") {
            var lines = t.split("\n");
            if (lines.length > 1) {
              column = lines[lines.length - 1].length;
              row += lines.length - 1;
            } else
              column += t.length;
            text += t;
          } else if (t) {
            if (!t.start)
              t.start = { row, column };
            else
              t.end = { row, column };
          }
        });
        return {
          text,
          tabstops,
          tokens
        };
      };
      var TabstopManager = (
        /** @class */
        function() {
          function TabstopManager2(editor) {
            this.index = 0;
            this.ranges = [];
            this.tabstops = [];
            if (editor.tabstopManager)
              return editor.tabstopManager;
            editor.tabstopManager = this;
            this.$onChange = this.onChange.bind(this);
            this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
            this.$onChangeSession = this.onChangeSession.bind(this);
            this.$onAfterExec = this.onAfterExec.bind(this);
            this.attach(editor);
          }
          TabstopManager2.prototype.attach = function(editor) {
            this.$openTabstops = null;
            this.selectedTabstop = null;
            this.editor = editor;
            this.session = editor.session;
            this.editor.on("change", this.$onChange);
            this.editor.on("changeSelection", this.$onChangeSelection);
            this.editor.on("changeSession", this.$onChangeSession);
            this.editor.commands.on("afterExec", this.$onAfterExec);
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
          };
          TabstopManager2.prototype.detach = function() {
            this.tabstops.forEach(this.removeTabstopMarkers, this);
            this.ranges.length = 0;
            this.tabstops.length = 0;
            this.selectedTabstop = null;
            this.editor.off("change", this.$onChange);
            this.editor.off("changeSelection", this.$onChangeSelection);
            this.editor.off("changeSession", this.$onChangeSession);
            this.editor.commands.off("afterExec", this.$onAfterExec);
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.tabstopManager = null;
            this.session = null;
            this.editor = null;
          };
          TabstopManager2.prototype.onChange = function(delta) {
            var isRemove = delta.action[0] == "r";
            var selectedTabstop = this.selectedTabstop || {};
            var parents = selectedTabstop.parents || {};
            var tabstops = this.tabstops.slice();
            for (var i = 0; i < tabstops.length; i++) {
              var ts2 = tabstops[i];
              var active = ts2 == selectedTabstop || parents[ts2.index];
              ts2.rangeList.$bias = active ? 0 : 1;
              if (delta.action == "remove" && ts2 !== selectedTabstop) {
                var parentActive = ts2.parents && ts2.parents[selectedTabstop.index];
                var startIndex = ts2.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts2.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts2.rangeList.ranges.slice(startIndex, endIndex);
                for (var j3 = 0; j3 < toRemove.length; j3++)
                  this.removeRange(toRemove[j3]);
              }
              ts2.rangeList.$onChange(delta);
            }
            var session = this.session;
            if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())
              this.detach();
          };
          TabstopManager2.prototype.updateLinkedFields = function() {
            var ts2 = this.selectedTabstop;
            if (!ts2 || !ts2.hasLinkedRanges || !ts2.firstNonLinked)
              return;
            this.$inChange = true;
            var session = this.session;
            var text = session.getTextRange(ts2.firstNonLinked);
            for (var i = 0; i < ts2.length; i++) {
              var range = ts2[i];
              if (!range.linked)
                continue;
              var original = range.original;
              var fmt = exports2.snippetManager.tmStrFormat(text, original, this.editor);
              session.replace(range, fmt);
            }
            this.$inChange = false;
          };
          TabstopManager2.prototype.onAfterExec = function(e) {
            if (e.command && !e.command.readOnly)
              this.updateLinkedFields();
          };
          TabstopManager2.prototype.onChangeSelection = function() {
            if (!this.editor)
              return;
            var lead = this.editor.selection.lead;
            var anchor = this.editor.selection.anchor;
            var isEmpty = this.editor.selection.isEmpty();
            for (var i = 0; i < this.ranges.length; i++) {
              if (this.ranges[i].linked)
                continue;
              var containsLead = this.ranges[i].contains(lead.row, lead.column);
              var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
              if (containsLead && containsAnchor)
                return;
            }
            this.detach();
          };
          TabstopManager2.prototype.onChangeSession = function() {
            this.detach();
          };
          TabstopManager2.prototype.tabNext = function(dir) {
            var max = this.tabstops.length;
            var index = this.index + (dir || 1);
            index = Math.min(Math.max(index, 1), max);
            if (index == max)
              index = 0;
            this.selectTabstop(index);
            this.updateTabstopMarkers();
            if (index === 0) {
              this.detach();
            }
          };
          TabstopManager2.prototype.selectTabstop = function(index) {
            this.$openTabstops = null;
            var ts2 = this.tabstops[this.index];
            if (ts2)
              this.addTabstopMarkers(ts2);
            this.index = index;
            ts2 = this.tabstops[this.index];
            if (!ts2 || !ts2.length)
              return;
            this.selectedTabstop = ts2;
            var range = ts2.firstNonLinked || ts2;
            if (ts2.choices)
              range.cursor = range.start;
            if (!this.editor.inVirtualSelectionMode) {
              var sel = this.editor.multiSelect;
              sel.toSingleRange(range);
              for (var i = 0; i < ts2.length; i++) {
                if (ts2.hasLinkedRanges && ts2[i].linked)
                  continue;
                sel.addRange(ts2[i].clone(), true);
              }
            } else {
              this.editor.selection.fromOrientedRange(range);
            }
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            if (this.selectedTabstop && this.selectedTabstop.choices)
              this.editor.execCommand("startAutocomplete", { matches: this.selectedTabstop.choices });
          };
          TabstopManager2.prototype.addTabstops = function(tabstops, start, end) {
            var useLink = this.useLink || !this.editor.getOption("enableMultiselect");
            if (!this.$openTabstops)
              this.$openTabstops = [];
            if (!tabstops[0]) {
              var p = Range.fromPoints(end, end);
              moveRelative(p.start, start);
              moveRelative(p.end, start);
              tabstops[0] = [p];
              tabstops[0].index = 0;
            }
            var i = this.index;
            var arg = [i + 1, 0];
            var ranges = this.ranges;
            var snippetId = this.snippetId = (this.snippetId || 0) + 1;
            tabstops.forEach(function(ts2, index) {
              var dest = this.$openTabstops[index] || ts2;
              dest.snippetId = snippetId;
              for (var i2 = 0; i2 < ts2.length; i2++) {
                var p2 = ts2[i2];
                var range = Range.fromPoints(p2.start, p2.end || p2.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p2;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts2)
                  dest.unshift(range);
                else
                  dest[i2] = range;
                if (p2.fmtString || dest.firstNonLinked && useLink) {
                  range.linked = true;
                  dest.hasLinkedRanges = true;
                } else if (!dest.firstNonLinked)
                  dest.firstNonLinked = range;
              }
              if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
              if (dest === ts2) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
              }
              this.addTabstopMarkers(dest);
              dest.rangeList = dest.rangeList || new RangeList();
              dest.rangeList.$bias = 0;
              dest.rangeList.addList(dest);
            }, this);
            if (arg.length > 2) {
              if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
              this.tabstops.splice.apply(this.tabstops, arg);
            }
          };
          TabstopManager2.prototype.addTabstopMarkers = function(ts2) {
            var session = this.session;
            ts2.forEach(function(range) {
              if (!range.markerId)
                range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
            });
          };
          TabstopManager2.prototype.removeTabstopMarkers = function(ts2) {
            var session = this.session;
            ts2.forEach(function(range) {
              session.removeMarker(range.markerId);
              range.markerId = null;
            });
          };
          TabstopManager2.prototype.updateTabstopMarkers = function() {
            if (!this.selectedTabstop)
              return;
            var currentSnippetId = this.selectedTabstop.snippetId;
            if (this.selectedTabstop.index === 0) {
              currentSnippetId--;
            }
            this.tabstops.forEach(function(ts2) {
              if (ts2.snippetId === currentSnippetId)
                this.addTabstopMarkers(ts2);
              else
                this.removeTabstopMarkers(ts2);
            }, this);
          };
          TabstopManager2.prototype.removeRange = function(range) {
            var i = range.tabstop.indexOf(range);
            if (i != -1)
              range.tabstop.splice(i, 1);
            i = this.ranges.indexOf(range);
            if (i != -1)
              this.ranges.splice(i, 1);
            i = range.tabstop.rangeList.ranges.indexOf(range);
            if (i != -1)
              range.tabstop.splice(i, 1);
            this.session.removeMarker(range.markerId);
            if (!range.tabstop.length) {
              i = this.tabstops.indexOf(range.tabstop);
              if (i != -1)
                this.tabstops.splice(i, 1);
              if (!this.tabstops.length)
                this.detach();
            }
          };
          return TabstopManager2;
        }()
      );
      TabstopManager.prototype.keyboardHandler = new HashHandler();
      TabstopManager.prototype.keyboardHandler.bindKeys({
        "Tab": function(editor) {
          if (exports2.snippetManager && exports2.snippetManager.expandWithTab(editor))
            return;
          editor.tabstopManager.tabNext(1);
          editor.renderer.scrollCursorIntoView();
        },
        "Shift-Tab": function(editor) {
          editor.tabstopManager.tabNext(-1);
          editor.renderer.scrollCursorIntoView();
        },
        "Esc": function(editor) {
          editor.tabstopManager.detach();
        }
      });
      var movePoint = function(point, diff) {
        if (point.row == 0)
          point.column += diff.column;
        point.row += diff.row;
      };
      var moveRelative = function(point, start) {
        if (point.row == start.row)
          point.column -= start.column;
        point.row -= start.row;
      };
      dom.importCssString("\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}", "snippets.css", false);
      exports2.snippetManager = new SnippetManager();
      var Editor = require3("./editor").Editor;
      (function() {
        this.insertSnippet = function(content, options) {
          return exports2.snippetManager.insertSnippet(this, content, options);
        };
        this.expandSnippet = function(options) {
          return exports2.snippetManager.expandWithTab(this, options);
        };
      }).call(Editor.prototype);
    });
    ace.define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom", "ace/config", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var Renderer = require3("../virtual_renderer").VirtualRenderer;
      var Editor = require3("../editor").Editor;
      var Range = require3("../range").Range;
      var event = require3("../lib/event");
      var lang = require3("../lib/lang");
      var dom = require3("../lib/dom");
      var nls = require3("../config").nls;
      var userAgent = require3("./../lib/useragent");
      var getAriaId = function(index) {
        return "suggest-aria-id:".concat(index);
      };
      var popupAriaRole = userAgent.isSafari ? "menu" : "listbox";
      var optionAriaRole = userAgent.isSafari ? "menuitem" : "option";
      var ariaActiveState = userAgent.isSafari ? "aria-current" : "aria-selected";
      var $singleLineEditor = function(el) {
        var renderer = new Renderer(el);
        renderer.$maxLines = 4;
        var editor = new Editor(renderer);
        editor.setHighlightActiveLine(false);
        editor.setShowPrintMargin(false);
        editor.renderer.setShowGutter(false);
        editor.renderer.setHighlightGutterLine(false);
        editor.$mouseHandler.$focusTimeout = 0;
        editor.$highlightTagPending = true;
        return editor;
      };
      var AcePopup = (
        /** @class */
        /* @__PURE__ */ function() {
          function AcePopup2(parentNode) {
            var el = dom.createElement("div");
            var popup = $singleLineEditor(el);
            if (parentNode) {
              parentNode.appendChild(el);
            }
            el.style.display = "none";
            popup.renderer.content.style.cursor = "default";
            popup.renderer.setStyle("ace_autocomplete");
            popup.renderer.$textLayer.element.setAttribute("role", popupAriaRole);
            popup.renderer.$textLayer.element.setAttribute("aria-roledescription", nls("autocomplete.popup.aria-roledescription", "Autocomplete suggestions"));
            popup.renderer.$textLayer.element.setAttribute("aria-label", nls("autocomplete.popup.aria-label", "Autocomplete suggestions"));
            popup.renderer.textarea.setAttribute("aria-hidden", "true");
            popup.setOption("displayIndentGuides", false);
            popup.setOption("dragDelay", 150);
            var noop = function() {
            };
            popup.focus = noop;
            popup.$isFocused = true;
            popup.renderer.$cursorLayer.restartTimer = noop;
            popup.renderer.$cursorLayer.element.style.opacity = "0";
            popup.renderer.$maxLines = 8;
            popup.renderer.$keepTextAreaAtCursor = false;
            popup.setHighlightActiveLine(false);
            popup.session.highlight("");
            popup.session.$searchHighlight.clazz = "ace_highlight-marker";
            popup.on("mousedown", function(e) {
              var pos = e.getDocumentPosition();
              popup.selection.moveToPosition(pos);
              selectionMarker.start.row = selectionMarker.end.row = pos.row;
              e.stop();
            });
            var lastMouseEvent;
            var hoverMarker = new Range(-1, 0, -1, Infinity);
            var selectionMarker = new Range(-1, 0, -1, Infinity);
            selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
            popup.setSelectOnHover = function(val) {
              if (!val) {
                hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
              } else if (hoverMarker.id) {
                popup.session.removeMarker(hoverMarker.id);
                hoverMarker.id = null;
              }
            };
            popup.setSelectOnHover(false);
            popup.on("mousemove", function(e) {
              if (!lastMouseEvent) {
                lastMouseEvent = e;
                return;
              }
              if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
                return;
              }
              lastMouseEvent = e;
              lastMouseEvent.scrollTop = popup.renderer.scrollTop;
              popup.isMouseOver = true;
              var row = lastMouseEvent.getDocumentPosition().row;
              if (hoverMarker.start.row != row) {
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row);
              }
            });
            popup.renderer.on("beforeRender", function() {
              if (lastMouseEvent && hoverMarker.start.row != -1) {
                lastMouseEvent.$pos = null;
                var row = lastMouseEvent.getDocumentPosition().row;
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row, true);
              }
            });
            popup.renderer.on("afterRender", function() {
              var t = popup.renderer.$textLayer;
              for (var row = t.config.firstRow, l = t.config.lastRow; row <= l; row++) {
                var popupRowElement = (
                  /** @type {HTMLElement|null} */
                  t.element.childNodes[row - t.config.firstRow]
                );
                popupRowElement.setAttribute("role", optionAriaRole);
                popupRowElement.setAttribute("aria-roledescription", nls("autocomplete.popup.item.aria-roledescription", "item"));
                popupRowElement.setAttribute("aria-setsize", popup.data.length);
                popupRowElement.setAttribute("aria-describedby", "doc-tooltip");
                popupRowElement.setAttribute("aria-posinset", row + 1);
                var rowData = popup.getData(row);
                if (rowData) {
                  var ariaLabel = "".concat(rowData.caption || rowData.value).concat(rowData.meta ? ", ".concat(rowData.meta) : "");
                  popupRowElement.setAttribute("aria-label", ariaLabel);
                }
                var highlightedSpans = popupRowElement.querySelectorAll(".ace_completion-highlight");
                highlightedSpans.forEach(function(span) {
                  span.setAttribute("role", "mark");
                });
              }
            });
            popup.renderer.on("afterRender", function() {
              var row = popup.getRow();
              var t = popup.renderer.$textLayer;
              var selected = (
                /** @type {HTMLElement|null} */
                t.element.childNodes[row - t.config.firstRow]
              );
              var el2 = document.activeElement;
              if (selected !== popup.selectedNode && popup.selectedNode) {
                dom.removeCssClass(popup.selectedNode, "ace_selected");
                popup.selectedNode.removeAttribute(ariaActiveState);
                popup.selectedNode.removeAttribute("id");
              }
              el2.removeAttribute("aria-activedescendant");
              popup.selectedNode = selected;
              if (selected) {
                var ariaId = getAriaId(row);
                dom.addCssClass(selected, "ace_selected");
                selected.id = ariaId;
                t.element.setAttribute("aria-activedescendant", ariaId);
                el2.setAttribute("aria-activedescendant", ariaId);
                selected.setAttribute(ariaActiveState, "true");
              }
            });
            var hideHoverMarker = function() {
              setHoverMarker(-1);
            };
            var setHoverMarker = function(row, suppressRedraw) {
              if (row !== hoverMarker.start.row) {
                hoverMarker.start.row = hoverMarker.end.row = row;
                if (!suppressRedraw)
                  popup.session._emit("changeBackMarker");
                popup._emit("changeHoverMarker");
              }
            };
            popup.getHoveredRow = function() {
              return hoverMarker.start.row;
            };
            event.addListener(popup.container, "mouseout", function() {
              popup.isMouseOver = false;
              hideHoverMarker();
            });
            popup.on("hide", hideHoverMarker);
            popup.on("changeSelection", hideHoverMarker);
            popup.session.doc.getLength = function() {
              return popup.data.length;
            };
            popup.session.doc.getLine = function(i) {
              var data = popup.data[i];
              if (typeof data == "string")
                return data;
              return data && data.value || "";
            };
            var bgTokenizer = popup.session.bgTokenizer;
            bgTokenizer.$tokenizeRow = function(row) {
              var data = popup.data[row];
              var tokens = [];
              if (!data)
                return tokens;
              if (typeof data == "string")
                data = { value: data };
              var caption = data.caption || data.value || data.name;
              function addToken(value, className) {
                value && tokens.push({
                  type: (data.className || "") + (className || ""),
                  value
                });
              }
              var lower = caption.toLowerCase();
              var filterText = (popup.filterText || "").toLowerCase();
              var lastIndex = 0;
              var lastI = 0;
              for (var i = 0; i <= filterText.length; i++) {
                if (i != lastI && (data.matchMask & 1 << i || i == filterText.length)) {
                  var sub = filterText.slice(lastI, i);
                  lastI = i;
                  var index = lower.indexOf(sub, lastIndex);
                  if (index == -1)
                    continue;
                  addToken(caption.slice(lastIndex, index), "");
                  lastIndex = index + sub.length;
                  addToken(caption.slice(index, lastIndex), "completion-highlight");
                }
              }
              addToken(caption.slice(lastIndex, caption.length), "");
              tokens.push({ type: "completion-spacer", value: " " });
              if (data.meta)
                tokens.push({ type: "completion-meta", value: data.meta });
              if (data.message)
                tokens.push({ type: "completion-message", value: data.message });
              return tokens;
            };
            bgTokenizer.$updateOnChange = noop;
            bgTokenizer.start = noop;
            popup.session.$computeWidth = function() {
              return this.screenWidth = 0;
            };
            popup.isOpen = false;
            popup.isTopdown = false;
            popup.autoSelect = true;
            popup.filterText = "";
            popup.isMouseOver = false;
            popup.data = [];
            popup.setData = function(list, filterText) {
              popup.filterText = filterText || "";
              popup.setValue(lang.stringRepeat("\n", list.length), -1);
              popup.data = list || [];
              popup.setRow(0);
            };
            popup.getData = function(row) {
              return popup.data[row];
            };
            popup.getRow = function() {
              return selectionMarker.start.row;
            };
            popup.setRow = function(line) {
              line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));
              if (selectionMarker.start.row != line) {
                popup.selection.clearSelection();
                selectionMarker.start.row = selectionMarker.end.row = line || 0;
                popup.session._emit("changeBackMarker");
                popup.moveCursorTo(line || 0, 0);
                if (popup.isOpen)
                  popup._signal("select");
              }
            };
            popup.on("changeSelection", function() {
              if (popup.isOpen)
                popup.setRow(popup.selection.lead.row);
              popup.renderer.scrollCursorIntoView();
            });
            popup.hide = function() {
              this.container.style.display = "none";
              popup.anchorPos = null;
              popup.anchor = null;
              if (popup.isOpen) {
                popup.isOpen = false;
                this._signal("hide");
              }
            };
            popup.tryShow = function(pos, lineHeight, anchor, forceShow) {
              if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor && popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left && popup.anchor === anchor) {
                return true;
              }
              var el2 = this.container;
              var scrollBarSize = this.renderer.scrollBar.width || 10;
              var screenHeight = window.innerHeight - scrollBarSize;
              var screenWidth = window.innerWidth - scrollBarSize;
              var renderer = this.renderer;
              var maxH = renderer.$maxLines * lineHeight * 1.4;
              var dims = { top: 0, bottom: 0, left: 0 };
              var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;
              var spaceAbove = pos.top - 3 * this.$borderSize;
              if (!anchor) {
                if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {
                  anchor = "bottom";
                } else {
                  anchor = "top";
                }
              }
              if (anchor === "top") {
                dims.bottom = pos.top - this.$borderSize;
                dims.top = dims.bottom - maxH;
              } else if (anchor === "bottom") {
                dims.top = pos.top + lineHeight + this.$borderSize;
                dims.bottom = dims.top + maxH;
              }
              var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;
              if (!forceShow && !fitsX) {
                return false;
              }
              if (!fitsX) {
                if (anchor === "top") {
                  renderer.$maxPixelHeight = spaceAbove;
                } else {
                  renderer.$maxPixelHeight = spaceBelow;
                }
              } else {
                renderer.$maxPixelHeight = null;
              }
              if (anchor === "top") {
                el2.style.top = "";
                el2.style.bottom = screenHeight + scrollBarSize - dims.bottom + "px";
                popup.isTopdown = false;
              } else {
                el2.style.top = dims.top + "px";
                el2.style.bottom = "";
                popup.isTopdown = true;
              }
              el2.style.display = "";
              var left = pos.left;
              if (left + el2.offsetWidth > screenWidth)
                left = screenWidth - el2.offsetWidth;
              el2.style.left = left + "px";
              el2.style.right = "";
              if (!popup.isOpen) {
                popup.isOpen = true;
                this._signal("show");
                lastMouseEvent = null;
              }
              popup.anchorPos = pos;
              popup.anchor = anchor;
              return true;
            };
            popup.show = function(pos, lineHeight, topdownOnly) {
              this.tryShow(pos, lineHeight, topdownOnly ? "bottom" : void 0, true);
            };
            popup.goTo = function(where) {
              var row = this.getRow();
              var max = this.session.getLength() - 1;
              switch (where) {
                case "up":
                  row = row <= 0 ? max : row - 1;
                  break;
                case "down":
                  row = row >= max ? -1 : row + 1;
                  break;
                case "start":
                  row = 0;
                  break;
                case "end":
                  row = max;
                  break;
              }
              this.setRow(row);
            };
            popup.getTextLeftOffset = function() {
              return this.$borderSize + this.renderer.$padding + this.$imageSize;
            };
            popup.$imageSize = 0;
            popup.$borderSize = 1;
            return popup;
          }
          return AcePopup2;
        }()
      );
      dom.importCssString('\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #CAD6FA;\n    z-index: 1;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #3a674e;\n}\n.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #abbffe;\n    margin-top: -1px;\n    background: rgba(233,233,253,0.4);\n    position: absolute;\n    z-index: 2;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid rgba(109, 150, 13, 0.8);\n    background: rgba(58, 103, 78, 0.62);\n}\n.ace_completion-meta {\n    opacity: 0.5;\n    margin-left: 0.9em;\n}\n.ace_completion-message {\n    margin-left: 0.9em;\n    color: blue;\n}\n.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #2d69c7;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #93ca12;\n}\n.ace_editor.ace_autocomplete {\n    width: 300px;\n    z-index: 200000;\n    border: 1px lightgray solid;\n    position: fixed;\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n    line-height: 1.4;\n    background: #fefefe;\n    color: #111;\n}\n.ace_dark.ace_editor.ace_autocomplete {\n    border: 1px #484747 solid;\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\n    line-height: 1.4;\n    background: #25282c;\n    color: #c1c1c1;\n}\n.ace_autocomplete .ace_text-layer  {\n    width: calc(100% - 8px);\n}\n.ace_autocomplete .ace_line {\n    display: flex;\n    align-items: center;\n}\n.ace_autocomplete .ace_line > * {\n    min-width: 0;\n    flex: 0 0 auto;\n}\n.ace_autocomplete .ace_line .ace_ {\n    flex: 0 1 auto;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.ace_autocomplete .ace_completion-spacer {\n    flex: 1;\n}\n.ace_autocomplete.ace_loading:after  {\n    content: "";\n    position: absolute;\n    top: 0px;\n    height: 2px;\n    width: 8%;\n    background: blue;\n    z-index: 100;\n    animation: ace_progress 3s infinite linear;\n    animation-delay: 300ms;\n    transform: translateX(-100%) scaleX(1);\n}\n@keyframes ace_progress {\n    0% { transform: translateX(-100%) scaleX(1) }\n    50% { transform: translateX(625%) scaleX(2) } \n    100% { transform: translateX(1500%) scaleX(3) } \n}\n@media (prefers-reduced-motion) {\n    .ace_autocomplete.ace_loading:after {\n        transform: translateX(625%) scaleX(2);\n        animation: none;\n     }\n}\n', "autocompletion.css", false);
      exports2.AcePopup = AcePopup;
      exports2.$singleLineEditor = $singleLineEditor;
      exports2.getAriaId = getAriaId;
    });
    ace.define("ace/autocomplete/inline_screenreader", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var AceInlineScreenReader = (
        /** @class */
        function() {
          function AceInlineScreenReader2(editor) {
            this.editor = editor;
            this.screenReaderDiv = document.createElement("div");
            this.screenReaderDiv.classList.add("ace_screenreader-only");
            this.editor.container.appendChild(this.screenReaderDiv);
          }
          AceInlineScreenReader2.prototype.setScreenReaderContent = function(content) {
            if (!this.popup && this.editor.completer && /**@type{import("../autocomplete").Autocomplete}*/
            this.editor.completer.popup) {
              this.popup = /**@type{import("../autocomplete").Autocomplete}*/
              this.editor.completer.popup;
              this.popup.renderer.on("afterRender", function() {
                var row = this.popup.getRow();
                var t = this.popup.renderer.$textLayer;
                var selected = t.element.childNodes[row - t.config.firstRow];
                if (selected) {
                  var idString = "doc-tooltip ";
                  for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
                    idString += "ace-inline-screenreader-line-".concat(lineIndex, " ");
                  }
                  selected.setAttribute("aria-describedby", idString);
                }
              }.bind(this));
            }
            while (this.screenReaderDiv.firstChild) {
              this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);
            }
            this._lines = content.split(/\r\n|\r|\n/);
            var codeElement = this.createCodeBlock();
            this.screenReaderDiv.appendChild(codeElement);
          };
          AceInlineScreenReader2.prototype.destroy = function() {
            this.screenReaderDiv.remove();
          };
          AceInlineScreenReader2.prototype.createCodeBlock = function() {
            var container = document.createElement("pre");
            container.setAttribute("id", "ace-inline-screenreader");
            for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
              var codeElement = document.createElement("code");
              codeElement.setAttribute("id", "ace-inline-screenreader-line-".concat(lineIndex));
              var line = document.createTextNode(this._lines[lineIndex]);
              codeElement.appendChild(line);
              container.appendChild(codeElement);
            }
            return container;
          };
          return AceInlineScreenReader2;
        }()
      );
      exports2.AceInlineScreenReader = AceInlineScreenReader;
    });
    ace.define("ace/autocomplete/inline", ["require", "exports", "module", "ace/snippets", "ace/autocomplete/inline_screenreader"], function(require3, exports2, module3) {
      "use strict";
      var snippetManager = require3("../snippets").snippetManager;
      var AceInlineScreenReader = require3("./inline_screenreader").AceInlineScreenReader;
      var AceInline = (
        /** @class */
        function() {
          function AceInline2() {
            this.editor = null;
          }
          AceInline2.prototype.show = function(editor, completion, prefix) {
            prefix = prefix || "";
            if (editor && this.editor && this.editor !== editor) {
              this.hide();
              this.editor = null;
              this.inlineScreenReader = null;
            }
            if (!editor || !completion) {
              return false;
            }
            if (!this.inlineScreenReader) {
              this.inlineScreenReader = new AceInlineScreenReader(editor);
            }
            var displayText = completion.snippet ? snippetManager.getDisplayTextForSnippet(editor, completion.snippet) : completion.value;
            if (completion.hideInlinePreview || !displayText || !displayText.startsWith(prefix)) {
              return false;
            }
            this.editor = editor;
            this.inlineScreenReader.setScreenReaderContent(displayText);
            displayText = displayText.slice(prefix.length);
            if (displayText === "") {
              editor.removeGhostText();
            } else {
              editor.setGhostText(displayText);
            }
            return true;
          };
          AceInline2.prototype.isOpen = function() {
            if (!this.editor) {
              return false;
            }
            return !!this.editor.renderer.$ghostText;
          };
          AceInline2.prototype.hide = function() {
            if (!this.editor) {
              return false;
            }
            this.editor.removeGhostText();
            return true;
          };
          AceInline2.prototype.destroy = function() {
            this.hide();
            this.editor = null;
            if (this.inlineScreenReader) {
              this.inlineScreenReader.destroy();
              this.inlineScreenReader = null;
            }
          };
          return AceInline2;
        }()
      );
      exports2.AceInline = AceInline;
    });
    ace.define("ace/autocomplete/util", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      exports2.parForEach = function(array, fn3, callback) {
        var completed = 0;
        var arLength = array.length;
        if (arLength === 0)
          callback();
        for (var i = 0; i < arLength; i++) {
          fn3(array[i], function(result, err) {
            completed++;
            if (completed === arLength)
              callback(result, err);
          });
        }
      };
      var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
      exports2.retrievePrecedingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos - 1; i >= 0; i--) {
          if (regex.test(text[i]))
            buf.push(text[i]);
          else
            break;
        }
        return buf.reverse().join("");
      };
      exports2.retrieveFollowingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos; i < text.length; i++) {
          if (regex.test(text[i]))
            buf.push(text[i]);
          else
            break;
        }
        return buf;
      };
      exports2.getCompletionPrefix = function(editor) {
        var pos = editor.getCursorPosition();
        var line = editor.session.getLine(pos.row);
        var prefix;
        editor.completers.forEach(function(completer) {
          if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach(function(identifierRegex) {
              if (!prefix && identifierRegex)
                prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }.bind(this));
          }
        }.bind(this));
        return prefix || this.retrievePrecedingIdentifier(line, pos.column);
      };
      exports2.triggerAutocomplete = function(editor, previousChar) {
        var previousChar = previousChar == null ? editor.session.getPrecedingCharacter() : previousChar;
        return editor.completers.some(function(completer) {
          if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {
            return completer.triggerCharacters.includes(previousChar);
          }
        });
      };
    });
    ace.define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/inline", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/lang", "ace/lib/dom", "ace/snippets", "ace/config", "ace/lib/event", "ace/lib/scroll"], function(require3, exports2, module3) {
      "use strict";
      var HashHandler = require3("./keyboard/hash_handler").HashHandler;
      var AcePopup = require3("./autocomplete/popup").AcePopup;
      var AceInline = require3("./autocomplete/inline").AceInline;
      var getAriaId = require3("./autocomplete/popup").getAriaId;
      var util = require3("./autocomplete/util");
      var lang = require3("./lib/lang");
      var dom = require3("./lib/dom");
      var snippetManager = require3("./snippets").snippetManager;
      var config = require3("./config");
      var event = require3("./lib/event");
      var preventParentScroll = require3("./lib/scroll").preventParentScroll;
      var destroyCompleter = function(e, editor) {
        editor.completer && editor.completer.destroy();
      };
      var Autocomplete = (
        /** @class */
        function() {
          function Autocomplete2() {
            this.autoInsert = false;
            this.autoSelect = true;
            this.autoShown = false;
            this.exactMatch = false;
            this.inlineEnabled = false;
            this.keyboardHandler = new HashHandler();
            this.keyboardHandler.bindKeys(this.commands);
            this.parentNode = null;
            this.setSelectOnHover = false;
            this.hasSeen = /* @__PURE__ */ new Set();
            this.showLoadingState = false;
            this.stickySelectionDelay = 500;
            this.blurListener = this.blurListener.bind(this);
            this.changeListener = this.changeListener.bind(this);
            this.mousedownListener = this.mousedownListener.bind(this);
            this.mousewheelListener = this.mousewheelListener.bind(this);
            this.onLayoutChange = this.onLayoutChange.bind(this);
            this.changeTimer = lang.delayedCall(function() {
              this.updateCompletions(true);
            }.bind(this));
            this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
            this.popupTimer = lang.delayedCall(this.$updatePopupPosition.bind(this), 50);
            this.stickySelectionTimer = lang.delayedCall(function() {
              this.stickySelection = true;
            }.bind(this), this.stickySelectionDelay);
            this.$firstOpenTimer = lang.delayedCall(
              /**@this{Autocomplete}*/
              function() {
                var initialPosition = this.completionProvider && this.completionProvider.initialPosition;
                if (this.autoShown || this.popup && this.popup.isOpen || !initialPosition || this.editor.completers.length === 0)
                  return;
                this.completions = new FilteredList(Autocomplete2.completionsForLoading);
                this.openPopup(this.editor, initialPosition.prefix, false);
                this.popup.renderer.setStyle("ace_loading", true);
              }.bind(this),
              this.stickySelectionDelay
            );
          }
          Object.defineProperty(Autocomplete2, "completionsForLoading", {
            get: function() {
              return [{
                caption: config.nls("autocomplete.loading", "Loading..."),
                value: ""
              }];
            },
            enumerable: false,
            configurable: true
          });
          Autocomplete2.prototype.$init = function() {
            this.popup = new AcePopup(this.parentNode || document.body || document.documentElement);
            this.popup.on("click", function(e) {
              this.insertMatch();
              e.stop();
            }.bind(this));
            this.popup.focus = this.editor.focus.bind(this.editor);
            this.popup.on("show", this.$onPopupShow.bind(this));
            this.popup.on("hide", this.$onHidePopup.bind(this));
            this.popup.on("select", this.$onPopupChange.bind(this));
            event.addListener(this.popup.container, "mouseout", this.mouseOutListener.bind(this));
            this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
            this.popup.renderer.on("afterRender", this.$onPopupRender.bind(this));
            return this.popup;
          };
          Autocomplete2.prototype.$initInline = function() {
            if (!this.inlineEnabled || this.inlineRenderer)
              return;
            this.inlineRenderer = new AceInline();
            return this.inlineRenderer;
          };
          Autocomplete2.prototype.getPopup = function() {
            return this.popup || this.$init();
          };
          Autocomplete2.prototype.$onHidePopup = function() {
            if (this.inlineRenderer) {
              this.inlineRenderer.hide();
            }
            this.hideDocTooltip();
            this.stickySelectionTimer.cancel();
            this.popupTimer.cancel();
            this.stickySelection = false;
          };
          Autocomplete2.prototype.$seen = function(completion) {
            if (!this.hasSeen.has(completion) && completion && completion.completer && completion.completer.onSeen && typeof completion.completer.onSeen === "function") {
              completion.completer.onSeen(this.editor, completion);
              this.hasSeen.add(completion);
            }
          };
          Autocomplete2.prototype.$onPopupChange = function(hide) {
            if (this.inlineRenderer && this.inlineEnabled) {
              var completion = hide ? null : this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
              if (this.popup.isMouseOver && this.setSelectOnHover) {
                this.tooltipTimer.call(null, null);
                return;
              }
              this.popupTimer.schedule();
              this.tooltipTimer.schedule();
            } else {
              this.popupTimer.call(null, null);
              this.tooltipTimer.call(null, null);
            }
          };
          Autocomplete2.prototype.$updateGhostText = function(completion) {
            var row = this.base.row;
            var column = this.base.column;
            var cursorColumn = this.editor.getCursorPosition().column;
            var prefix = this.editor.session.getLine(row).slice(column, cursorColumn);
            if (!this.inlineRenderer.show(this.editor, completion, prefix)) {
              this.inlineRenderer.hide();
            } else {
              this.$seen(completion);
            }
          };
          Autocomplete2.prototype.$onPopupRender = function() {
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (this.completions && this.completions.filtered && this.completions.filtered.length > 0) {
              for (var i = this.popup.getFirstVisibleRow(); i <= this.popup.getLastVisibleRow(); i++) {
                var completion = this.popup.getData(i);
                if (completion && (!inlineEnabled || completion.hideInlinePreview)) {
                  this.$seen(completion);
                }
              }
            }
          };
          Autocomplete2.prototype.$onPopupShow = function(hide) {
            this.$onPopupChange(hide);
            this.stickySelection = false;
            if (this.stickySelectionDelay >= 0)
              this.stickySelectionTimer.schedule(this.stickySelectionDelay);
          };
          Autocomplete2.prototype.observeLayoutChanges = function() {
            if (this.$elements || !this.editor)
              return;
            window.addEventListener("resize", this.onLayoutChange, { passive: true });
            window.addEventListener("wheel", this.mousewheelListener);
            var el = this.editor.container.parentNode;
            var elements = [];
            while (el) {
              elements.push(el);
              el.addEventListener("scroll", this.onLayoutChange, { passive: true });
              el = el.parentNode;
            }
            this.$elements = elements;
          };
          Autocomplete2.prototype.unObserveLayoutChanges = function() {
            var _this = this;
            window.removeEventListener("resize", this.onLayoutChange, { passive: true });
            window.removeEventListener("wheel", this.mousewheelListener);
            this.$elements && this.$elements.forEach(function(el) {
              el.removeEventListener("scroll", _this.onLayoutChange, { passive: true });
            });
            this.$elements = null;
          };
          Autocomplete2.prototype.onLayoutChange = function() {
            if (!this.popup.isOpen)
              return this.unObserveLayoutChanges();
            this.$updatePopupPosition();
            this.updateDocTooltip();
          };
          Autocomplete2.prototype.$updatePopupPosition = function() {
            var editor = this.editor;
            var renderer = editor.renderer;
            var lineHeight = renderer.layerConfig.lineHeight;
            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
            pos.left -= this.popup.getTextLeftOffset();
            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += renderer.gutterWidth;
            var posGhostText = {
              top: pos.top,
              left: pos.left
            };
            if (renderer.$ghostText && renderer.$ghostTextWidget) {
              if (this.base.row === renderer.$ghostText.position.row) {
                posGhostText.top += renderer.$ghostTextWidget.el.offsetHeight;
              }
            }
            var editorContainerBottom = editor.container.getBoundingClientRect().bottom - lineHeight;
            var lowestPosition = editorContainerBottom < posGhostText.top ? { top: editorContainerBottom, left: posGhostText.left } : posGhostText;
            if (this.popup.tryShow(lowestPosition, lineHeight, "bottom")) {
              return;
            }
            if (this.popup.tryShow(pos, lineHeight, "top")) {
              return;
            }
            this.popup.show(pos, lineHeight);
          };
          Autocomplete2.prototype.openPopup = function(editor, prefix, keepPopupPosition) {
            this.$firstOpenTimer.cancel();
            if (!this.popup)
              this.$init();
            if (this.inlineEnabled && !this.inlineRenderer)
              this.$initInline();
            this.popup.autoSelect = this.autoSelect;
            this.popup.setSelectOnHover(this.setSelectOnHover);
            var oldRow = this.popup.getRow();
            var previousSelectedItem = this.popup.data[oldRow];
            this.popup.setData(this.completions.filtered, this.completions.filterText);
            if (this.editor.textInput.setAriaOptions) {
              this.editor.textInput.setAriaOptions({
                activeDescendant: getAriaId(this.popup.getRow()),
                inline: this.inlineEnabled
              });
            }
            editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            var newRow;
            if (this.stickySelection)
              newRow = this.popup.data.indexOf(previousSelectedItem);
            if (!newRow || newRow === -1)
              newRow = 0;
            this.popup.setRow(this.autoSelect ? newRow : -1);
            if (newRow === oldRow && previousSelectedItem !== this.completions.filtered[newRow])
              this.$onPopupChange();
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (newRow === oldRow && inlineEnabled) {
              var completion = this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
            }
            if (!keepPopupPosition) {
              this.popup.setTheme(editor.getTheme());
              this.popup.setFontSize(editor.getFontSize());
              this.$updatePopupPosition();
              if (this.tooltipNode) {
                this.updateDocTooltip();
              }
            }
            this.changeTimer.cancel();
            this.observeLayoutChanges();
          };
          Autocomplete2.prototype.detach = function() {
            if (this.editor) {
              this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
              this.editor.off("changeSelection", this.changeListener);
              this.editor.off("blur", this.blurListener);
              this.editor.off("mousedown", this.mousedownListener);
              this.editor.off("mousewheel", this.mousewheelListener);
            }
            this.$firstOpenTimer.cancel();
            this.changeTimer.cancel();
            this.hideDocTooltip();
            if (this.completionProvider) {
              this.completionProvider.detach();
            }
            if (this.popup && this.popup.isOpen)
              this.popup.hide();
            if (this.popup && this.popup.renderer) {
              this.popup.renderer.off("afterRender", this.$onPopupRender);
            }
            if (this.base)
              this.base.detach();
            this.activated = false;
            this.completionProvider = this.completions = this.base = null;
            this.unObserveLayoutChanges();
          };
          Autocomplete2.prototype.changeListener = function(e) {
            var cursor = this.editor.selection.lead;
            if (cursor.row != this.base.row || cursor.column < this.base.column) {
              this.detach();
            }
            if (this.activated)
              this.changeTimer.schedule();
            else
              this.detach();
          };
          Autocomplete2.prototype.blurListener = function(e) {
            var el = document.activeElement;
            var text = this.editor.textInput.getElement();
            var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);
            var container = this.popup && this.popup.container;
            if (el != text && el.parentNode != container && !fromTooltip && el != this.tooltipNode && e.relatedTarget != text) {
              this.detach();
            }
          };
          Autocomplete2.prototype.mousedownListener = function(e) {
            this.detach();
          };
          Autocomplete2.prototype.mousewheelListener = function(e) {
            if (this.popup && !this.popup.isMouseOver)
              this.detach();
          };
          Autocomplete2.prototype.mouseOutListener = function(e) {
            if (this.popup.isOpen)
              this.$updatePopupPosition();
          };
          Autocomplete2.prototype.goTo = function(where) {
            this.popup.goTo(where);
          };
          Autocomplete2.prototype.insertMatch = function(data, options) {
            if (!data)
              data = this.popup.getData(this.popup.getRow());
            if (!data)
              return false;
            if (data.value === "")
              return this.detach();
            var completions = this.completions;
            var result = this.getCompletionProvider().insertMatch(this.editor, data, completions.filterText, options);
            if (this.completions == completions)
              this.detach();
            return result;
          };
          Autocomplete2.prototype.showPopup = function(editor, options) {
            if (this.editor)
              this.detach();
            this.activated = true;
            this.editor = editor;
            if (editor.completer != this) {
              if (editor.completer)
                editor.completer.detach();
              editor.completer = this;
            }
            editor.on("changeSelection", this.changeListener);
            editor.on("blur", this.blurListener);
            editor.on("mousedown", this.mousedownListener);
            editor.on("mousewheel", this.mousewheelListener);
            this.updateCompletions(false, options);
          };
          Autocomplete2.prototype.getCompletionProvider = function(initialPosition) {
            if (!this.completionProvider)
              this.completionProvider = new CompletionProvider(initialPosition);
            return this.completionProvider;
          };
          Autocomplete2.prototype.gatherCompletions = function(editor, callback) {
            return this.getCompletionProvider().gatherCompletions(editor, callback);
          };
          Autocomplete2.prototype.updateCompletions = function(keepPopupPosition, options) {
            if (keepPopupPosition && this.base && this.completions) {
              var pos = this.editor.getCursorPosition();
              var prefix = this.editor.session.getTextRange({ start: this.base, end: pos });
              if (prefix == this.completions.filterText)
                return;
              this.completions.setFilter(prefix);
              if (!this.completions.filtered.length)
                return this.detach();
              if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == prefix && !this.completions.filtered[0].snippet)
                return this.detach();
              this.openPopup(this.editor, prefix, keepPopupPosition);
              return;
            }
            if (options && options.matches) {
              var pos = this.editor.getSelectionRange().start;
              this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
              this.base.$insertRight = true;
              this.completions = new FilteredList(options.matches);
              this.getCompletionProvider().completions = this.completions;
              return this.openPopup(this.editor, "", keepPopupPosition);
            }
            var session = this.editor.getSession();
            var pos = this.editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(this.editor);
            this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
            this.base.$insertRight = true;
            var completionOptions = {
              exactMatch: this.exactMatch,
              ignoreCaption: this.ignoreCaption
            };
            this.getCompletionProvider({
              prefix,
              pos
            }).provideCompletions(
              this.editor,
              completionOptions,
              function(err, completions, finished) {
                var filtered = completions.filtered;
                var prefix2 = util.getCompletionPrefix(this.editor);
                this.$firstOpenTimer.cancel();
                if (finished) {
                  if (!filtered.length) {
                    var emptyMessage = !this.autoShown && this.emptyMessage;
                    if (typeof emptyMessage == "function")
                      emptyMessage = this.emptyMessage(prefix2);
                    if (emptyMessage) {
                      var completionsForEmpty = [
                        {
                          caption: emptyMessage,
                          value: ""
                        }
                      ];
                      this.completions = new FilteredList(completionsForEmpty);
                      this.openPopup(this.editor, prefix2, keepPopupPosition);
                      this.popup.renderer.setStyle("ace_loading", false);
                      this.popup.renderer.setStyle("ace_empty-message", true);
                      return;
                    }
                    return this.detach();
                  }
                  if (filtered.length == 1 && filtered[0].value == prefix2 && !filtered[0].snippet)
                    return this.detach();
                  if (this.autoInsert && !this.autoShown && filtered.length == 1)
                    return this.insertMatch(filtered[0]);
                }
                this.completions = !finished && this.showLoadingState ? new FilteredList(Autocomplete2.completionsForLoading.concat(filtered), completions.filterText) : completions;
                this.openPopup(this.editor, prefix2, keepPopupPosition);
                this.popup.renderer.setStyle("ace_empty-message", false);
                this.popup.renderer.setStyle("ace_loading", !finished);
              }.bind(this)
            );
            if (this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen)) {
              this.$firstOpenTimer.delay(this.stickySelectionDelay / 2);
            }
          };
          Autocomplete2.prototype.cancelContextMenu = function() {
            this.editor.$mouseHandler.cancelContextMenu();
          };
          Autocomplete2.prototype.updateDocTooltip = function() {
            var popup = this.popup;
            var all = this.completions && this.completions.filtered;
            var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
            var doc = null;
            if (!selected || !this.editor || !this.popup.isOpen)
              return this.hideDocTooltip();
            var completersLength = this.editor.completers.length;
            for (var i = 0; i < completersLength; i++) {
              var completer = this.editor.completers[i];
              if (completer.getDocTooltip && selected.completerId === completer.id) {
                doc = completer.getDocTooltip(selected);
                break;
              }
            }
            if (!doc && typeof selected != "string")
              doc = selected;
            if (typeof doc == "string")
              doc = { docText: doc };
            if (!doc || !(doc.docHTML || doc.docText))
              return this.hideDocTooltip();
            this.showDocTooltip(doc);
          };
          Autocomplete2.prototype.showDocTooltip = function(item) {
            if (!this.tooltipNode) {
              this.tooltipNode = dom.createElement("div");
              this.tooltipNode.style.margin = "0";
              this.tooltipNode.style.pointerEvents = "auto";
              this.tooltipNode.style.overscrollBehavior = "contain";
              this.tooltipNode.tabIndex = -1;
              this.tooltipNode.onblur = this.blurListener.bind(this);
              this.tooltipNode.onclick = this.onTooltipClick.bind(this);
              this.tooltipNode.id = "doc-tooltip";
              this.tooltipNode.setAttribute("role", "tooltip");
              this.tooltipNode.addEventListener("wheel", preventParentScroll);
            }
            var theme = this.editor.renderer.theme;
            this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
            var tooltipNode = this.tooltipNode;
            if (item.docHTML) {
              tooltipNode.innerHTML = item.docHTML;
            } else if (item.docText) {
              tooltipNode.textContent = item.docText;
            }
            if (!tooltipNode.parentNode)
              this.popup.container.appendChild(this.tooltipNode);
            var popup = this.popup;
            var rect = popup.container.getBoundingClientRect();
            var targetWidth = 400;
            var targetHeight = 300;
            var scrollBarSize = popup.renderer.scrollBar.width || 10;
            var leftSize = rect.left;
            var rightSize = window.innerWidth - rect.right - scrollBarSize;
            var topSize = popup.isTopdown ? rect.top : window.innerHeight - scrollBarSize - rect.bottom;
            var scores = [
              Math.min(rightSize / targetWidth, 1),
              Math.min(leftSize / targetWidth, 1),
              Math.min(topSize / targetHeight * 0.9)
            ];
            var max = Math.max.apply(Math, scores);
            var tooltipStyle = tooltipNode.style;
            tooltipStyle.display = "block";
            if (max == scores[0]) {
              tooltipStyle.left = rect.right + 1 + "px";
              tooltipStyle.right = "";
              tooltipStyle.maxWidth = targetWidth * max + "px";
              tooltipStyle.top = rect.top + "px";
              tooltipStyle.bottom = "";
              tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
            } else if (max == scores[1]) {
              tooltipStyle.right = window.innerWidth - rect.left + "px";
              tooltipStyle.left = "";
              tooltipStyle.maxWidth = targetWidth * max + "px";
              tooltipStyle.top = rect.top + "px";
              tooltipStyle.bottom = "";
              tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
            } else if (max == scores[2]) {
              tooltipStyle.left = window.innerWidth - rect.left + "px";
              tooltipStyle.maxWidth = Math.min(targetWidth, window.innerWidth) + "px";
              if (popup.isTopdown) {
                tooltipStyle.top = rect.bottom + "px";
                tooltipStyle.left = rect.left + "px";
                tooltipStyle.right = "";
                tooltipStyle.bottom = "";
                tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.bottom, targetHeight) + "px";
              } else {
                tooltipStyle.top = popup.container.offsetTop - tooltipNode.offsetHeight + "px";
                tooltipStyle.left = rect.left + "px";
                tooltipStyle.right = "";
                tooltipStyle.bottom = "";
                tooltipStyle.maxHeight = Math.min(popup.container.offsetTop, targetHeight) + "px";
              }
            }
          };
          Autocomplete2.prototype.hideDocTooltip = function() {
            this.tooltipTimer.cancel();
            if (!this.tooltipNode)
              return;
            var el = this.tooltipNode;
            if (!this.editor.isFocused() && document.activeElement == el)
              this.editor.focus();
            this.tooltipNode = null;
            if (el.parentNode)
              el.parentNode.removeChild(el);
          };
          Autocomplete2.prototype.onTooltipClick = function(e) {
            var a = e.target;
            while (a && a != this.tooltipNode) {
              if (a.nodeName == "A" && a.href) {
                a.rel = "noreferrer";
                a.target = "_blank";
                break;
              }
              a = a.parentNode;
            }
          };
          Autocomplete2.prototype.destroy = function() {
            this.detach();
            if (this.popup) {
              this.popup.destroy();
              var el = this.popup.container;
              if (el && el.parentNode)
                el.parentNode.removeChild(el);
            }
            if (this.editor && this.editor.completer == this) {
              this.editor.off("destroy", destroyCompleter);
              this.editor.completer = null;
            }
            this.inlineRenderer = this.popup = this.editor = null;
          };
          Autocomplete2.for = function(editor) {
            if (editor.completer instanceof Autocomplete2) {
              return editor.completer;
            }
            if (editor.completer) {
              editor.completer.destroy();
              editor.completer = null;
            }
            if (config.get("sharedPopups")) {
              if (!Autocomplete2["$sharedInstance"])
                Autocomplete2["$sharedInstance"] = new Autocomplete2();
              editor.completer = Autocomplete2["$sharedInstance"];
            } else {
              editor.completer = new Autocomplete2();
              editor.once("destroy", destroyCompleter);
            }
            return editor.completer;
          };
          return Autocomplete2;
        }()
      );
      Autocomplete.prototype.commands = {
        "Up": function(editor) {
          editor.completer.goTo("up");
        },
        "Down": function(editor) {
          editor.completer.goTo("down");
        },
        "Ctrl-Up|Ctrl-Home": function(editor) {
          editor.completer.goTo("start");
        },
        "Ctrl-Down|Ctrl-End": function(editor) {
          editor.completer.goTo("end");
        },
        "Esc": function(editor) {
          editor.completer.detach();
        },
        "Return": function(editor) {
          return editor.completer.insertMatch();
        },
        "Shift-Return": function(editor) {
          editor.completer.insertMatch(null, { deleteSuffix: true });
        },
        "Tab": function(editor) {
          var result = editor.completer.insertMatch();
          if (!result && !editor.tabstopManager)
            editor.completer.goTo("down");
          else
            return result;
        },
        "Backspace": function(editor) {
          editor.execCommand("backspace");
          var prefix = util.getCompletionPrefix(editor);
          if (!prefix && editor.completer)
            editor.completer.detach();
        },
        "PageUp": function(editor) {
          editor.completer.popup.gotoPageUp();
        },
        "PageDown": function(editor) {
          editor.completer.popup.gotoPageDown();
        }
      };
      Autocomplete.startCommand = {
        name: "startAutocomplete",
        exec: function(editor, options) {
          var completer = Autocomplete.for(editor);
          completer.autoInsert = false;
          completer.autoSelect = true;
          completer.autoShown = false;
          completer.showPopup(editor, options);
          completer.cancelContextMenu();
        },
        bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
      };
      var CompletionProvider = (
        /** @class */
        function() {
          function CompletionProvider2(initialPosition) {
            this.initialPosition = initialPosition;
            this.active = true;
          }
          CompletionProvider2.prototype.insertByIndex = function(editor, index, options) {
            if (!this.completions || !this.completions.filtered) {
              return false;
            }
            return this.insertMatch(editor, this.completions.filtered[index], options);
          };
          CompletionProvider2.prototype.insertMatch = function(editor, data, options) {
            if (!data)
              return false;
            editor.startOperation({ command: { name: "insertMatch" } });
            if (data.completer && data.completer.insertMatch) {
              data.completer.insertMatch(editor, data);
            } else {
              if (!this.completions)
                return false;
              var replaceBefore = this.completions.filterText.length;
              var replaceAfter = 0;
              if (data.range && data.range.start.row === data.range.end.row) {
                replaceBefore -= this.initialPosition.prefix.length;
                replaceBefore += this.initialPosition.pos.column - data.range.start.column;
                replaceAfter += data.range.end.column - this.initialPosition.pos.column;
              }
              if (replaceBefore || replaceAfter) {
                var ranges;
                if (editor.selection.getAllRanges) {
                  ranges = editor.selection.getAllRanges();
                } else {
                  ranges = [editor.getSelectionRange()];
                }
                for (var i = 0, range; range = ranges[i]; i++) {
                  range.start.column -= replaceBefore;
                  range.end.column += replaceAfter;
                  editor.session.remove(range);
                }
              }
              if (data.snippet) {
                snippetManager.insertSnippet(editor, data.snippet);
              } else {
                this.$insertString(editor, data);
              }
              if (data.completer && data.completer.onInsert && typeof data.completer.onInsert == "function") {
                data.completer.onInsert(editor, data);
              }
              if (data.command && data.command === "startAutocomplete") {
                editor.execCommand(data.command);
              }
            }
            editor.endOperation();
            return true;
          };
          CompletionProvider2.prototype.$insertString = function(editor, data) {
            var text = data.value || data;
            editor.execCommand("insertstring", text);
          };
          CompletionProvider2.prototype.gatherCompletions = function(editor, callback) {
            var session = editor.getSession();
            var pos = editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(editor);
            var matches = [];
            this.completers = editor.completers;
            var total = editor.completers.length;
            editor.completers.forEach(function(completer, i) {
              completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (completer.hideInlinePreview)
                  results = results.map(function(result) {
                    return Object.assign(result, { hideInlinePreview: completer.hideInlinePreview });
                  });
                if (!err && results)
                  matches = matches.concat(results);
                callback(null, {
                  prefix: util.getCompletionPrefix(editor),
                  matches,
                  finished: --total === 0
                });
              });
            });
            return true;
          };
          CompletionProvider2.prototype.provideCompletions = function(editor, options, callback) {
            var processResults = function(results2) {
              var prefix = results2.prefix;
              var matches = results2.matches;
              this.completions = new FilteredList(matches);
              if (options.exactMatch)
                this.completions.exactMatch = true;
              if (options.ignoreCaption)
                this.completions.ignoreCaption = true;
              this.completions.setFilter(prefix);
              if (results2.finished || this.completions.filtered.length)
                callback(null, this.completions, results2.finished);
            }.bind(this);
            var isImmediate = true;
            var immediateResults = null;
            this.gatherCompletions(editor, function(err, results2) {
              if (!this.active) {
                return;
              }
              if (err) {
                callback(err, [], true);
                this.detach();
              }
              var prefix = results2.prefix;
              if (prefix.indexOf(results2.prefix) !== 0)
                return;
              if (isImmediate) {
                immediateResults = results2;
                return;
              }
              processResults(results2);
            }.bind(this));
            isImmediate = false;
            if (immediateResults) {
              var results = immediateResults;
              immediateResults = null;
              processResults(results);
            }
          };
          CompletionProvider2.prototype.detach = function() {
            this.active = false;
            this.completers && this.completers.forEach(function(completer) {
              if (typeof completer.cancel === "function") {
                completer.cancel();
              }
            });
          };
          return CompletionProvider2;
        }()
      );
      var FilteredList = (
        /** @class */
        function() {
          function FilteredList2(array, filterText) {
            this.all = array;
            this.filtered = array;
            this.filterText = filterText || "";
            this.exactMatch = false;
            this.ignoreCaption = false;
          }
          FilteredList2.prototype.setFilter = function(str) {
            if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
              var matches = this.filtered;
            else
              var matches = this.all;
            this.filterText = str;
            matches = this.filterCompletions(matches, this.filterText);
            matches = matches.sort(function(a, b2) {
              return b2.exactMatch - a.exactMatch || b2.$score - a.$score || (a.caption || a.value).localeCompare(b2.caption || b2.value);
            });
            var prev = null;
            matches = matches.filter(function(item) {
              var caption = item.snippet || item.caption || item.value;
              if (caption === prev)
                return false;
              prev = caption;
              return true;
            });
            this.filtered = matches;
          };
          FilteredList2.prototype.filterCompletions = function(items, needle) {
            var results = [];
            var upper = needle.toUpperCase();
            var lower = needle.toLowerCase();
            loop: for (var i = 0, item; item = items[i]; i++) {
              if (item.skipFilter) {
                item.$score = item.score;
                results.push(item);
                continue;
              }
              var caption = !this.ignoreCaption && item.caption || item.value || item.snippet;
              if (!caption)
                continue;
              var lastIndex = -1;
              var matchMask = 0;
              var penalty = 0;
              var index, distance;
              if (this.exactMatch) {
                if (needle !== caption.substr(0, needle.length))
                  continue loop;
              } else {
                var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                if (fullMatchIndex > -1) {
                  penalty = fullMatchIndex;
                } else {
                  for (var j3 = 0; j3 < needle.length; j3++) {
                    var i1 = caption.indexOf(lower[j3], lastIndex + 1);
                    var i2 = caption.indexOf(upper[j3], lastIndex + 1);
                    index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                    if (index < 0)
                      continue loop;
                    distance = index - lastIndex - 1;
                    if (distance > 0) {
                      if (lastIndex === -1)
                        penalty += 10;
                      penalty += distance;
                      matchMask = matchMask | 1 << j3;
                    }
                    lastIndex = index;
                  }
                }
              }
              item.matchMask = matchMask;
              item.exactMatch = penalty ? 0 : 1;
              item.$score = (item.score || 0) - penalty;
              results.push(item);
            }
            return results;
          };
          return FilteredList2;
        }()
      );
      exports2.Autocomplete = Autocomplete;
      exports2.CompletionProvider = CompletionProvider;
      exports2.FilteredList = FilteredList;
    });
    ace.define("ace/marker_group", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var MarkerGroup = (
        /** @class */
        function() {
          function MarkerGroup2(session, options) {
            if (options)
              this.markerType = options.markerType;
            this.markers = [];
            this.session = session;
            session.addDynamicMarker(this);
          }
          MarkerGroup2.prototype.getMarkerAtPosition = function(pos) {
            return this.markers.find(function(marker) {
              return marker.range.contains(pos.row, pos.column);
            });
          };
          MarkerGroup2.prototype.markersComparator = function(a, b2) {
            return a.range.start.row - b2.range.start.row;
          };
          MarkerGroup2.prototype.setMarkers = function(markers) {
            this.markers = markers.sort(this.markersComparator).slice(0, this.MAX_MARKERS);
            this.session._signal("changeBackMarker");
          };
          MarkerGroup2.prototype.update = function(html, markerLayer, session, config) {
            if (!this.markers || !this.markers.length)
              return;
            var visibleRangeStartRow = config.firstRow, visibleRangeEndRow = config.lastRow;
            var foldLine;
            var markersOnOneLine = 0;
            var lastRow = 0;
            for (var i = 0; i < this.markers.length; i++) {
              var marker = this.markers[i];
              if (marker.range.end.row < visibleRangeStartRow)
                continue;
              if (marker.range.start.row > visibleRangeEndRow)
                continue;
              if (marker.range.start.row === lastRow) {
                markersOnOneLine++;
              } else {
                lastRow = marker.range.start.row;
                markersOnOneLine = 0;
              }
              if (markersOnOneLine > 200) {
                continue;
              }
              var markerVisibleRange = marker.range.clipRows(visibleRangeStartRow, visibleRangeEndRow);
              if (markerVisibleRange.start.row === markerVisibleRange.end.row && markerVisibleRange.start.column === markerVisibleRange.end.column) {
                continue;
              }
              var screenRange = markerVisibleRange.toScreenRange(session);
              if (screenRange.isEmpty()) {
                foldLine = session.getNextFoldLine(markerVisibleRange.end.row, foldLine);
                if (foldLine && foldLine.end.row > markerVisibleRange.end.row) {
                  visibleRangeStartRow = foldLine.end.row;
                }
                continue;
              }
              if (this.markerType === "fullLine") {
                markerLayer.drawFullLineMarker(html, screenRange, marker.className, config);
              } else if (screenRange.isMultiLine()) {
                if (this.markerType === "line")
                  markerLayer.drawMultiLineMarker(html, screenRange, marker.className, config);
                else
                  markerLayer.drawTextMarker(html, screenRange, marker.className, config);
              } else {
                markerLayer.drawSingleLineMarker(html, screenRange, marker.className + " ace_br15", config);
              }
            }
          };
          return MarkerGroup2;
        }()
      );
      MarkerGroup.prototype.MAX_MARKERS = 1e4;
      exports2.MarkerGroup = MarkerGroup;
    });
    ace.define("ace/autocomplete/text_completer", ["require", "exports", "module", "ace/range"], function(require3, exports2, module3) {
      var Range = require3("../range").Range;
      var splitRegex = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;
      function getWordIndex(doc, pos) {
        var textBefore = doc.getTextRange(Range.fromPoints({
          row: 0,
          column: 0
        }, pos));
        return textBefore.split(splitRegex).length - 1;
      }
      function wordDistance(doc, pos) {
        var prefixPos = getWordIndex(doc, pos);
        var words = doc.getValue().split(splitRegex);
        var wordScores = /* @__PURE__ */ Object.create(null);
        var currentWord = words[prefixPos];
        words.forEach(function(word, idx) {
          if (!word || word === currentWord)
            return;
          var distance = Math.abs(prefixPos - idx);
          var score = words.length - distance;
          if (wordScores[word]) {
            wordScores[word] = Math.max(score, wordScores[word]);
          } else {
            wordScores[word] = score;
          }
        });
        return wordScores;
      }
      exports2.getCompletions = function(editor, session, pos, prefix, callback) {
        var wordScore = wordDistance(session, pos);
        var wordList = Object.keys(wordScore);
        callback(null, wordList.map(function(word) {
          return {
            caption: word,
            value: word,
            score: wordScore[word],
            meta: "local"
          };
        }));
      };
    });
    ace.define("ace/ext/language_tools", ["require", "exports", "module", "ace/snippets", "ace/autocomplete", "ace/config", "ace/lib/lang", "ace/autocomplete/util", "ace/marker_group", "ace/autocomplete/text_completer", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var snippetManager = require3("../snippets").snippetManager;
      var Autocomplete = require3("../autocomplete").Autocomplete;
      var config = require3("../config");
      var lang = require3("../lib/lang");
      var util = require3("../autocomplete/util");
      var MarkerGroup = require3("../marker_group").MarkerGroup;
      var textCompleter = require3("../autocomplete/text_completer");
      var keyWordCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
          if (session.$mode.completer) {
            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);
          }
          var state = editor.session.getState(pos.row);
          var completions = session.$mode.getCompletions(state, session, pos, prefix);
          completions = completions.map(function(el) {
            el.completerId = keyWordCompleter.id;
            return el;
          });
          callback(null, completions);
        },
        id: "keywordCompleter"
      };
      var transformSnippetTooltip = function(str) {
        var record = {};
        return str.replace(/\${(\d+)(:(.*?))?}/g, function(_2, p1, p2, p3) {
          return record[p1] = p3 || "";
        }).replace(/\$(\d+?)/g, function(_2, p1) {
          return record[p1];
        });
      };
      var snippetCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
          var scopes = [];
          var token = session.getTokenAt(pos.row, pos.column);
          if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/))
            scopes.push("html-tag");
          else
            scopes = snippetManager.getActiveScopes(editor);
          var snippetMap = snippetManager.snippetMap;
          var completions = [];
          scopes.forEach(function(scope) {
            var snippets = snippetMap[scope] || [];
            for (var i = snippets.length; i--; ) {
              var s = snippets[i];
              var caption = s.name || s.tabTrigger;
              if (!caption)
                continue;
              completions.push({
                caption,
                snippet: s.content,
                meta: s.tabTrigger && !s.name ? s.tabTrigger + "\u21E5 " : "snippet",
                completerId: snippetCompleter.id
              });
            }
          }, this);
          callback(null, completions);
        },
        getDocTooltip: function(item) {
          if (item.snippet && !item.docHTML) {
            item.docHTML = [
              "<b>",
              lang.escapeHTML(item.caption),
              "</b>",
              "<hr></hr>",
              lang.escapeHTML(transformSnippetTooltip(item.snippet))
            ].join("");
          }
        },
        id: "snippetCompleter"
      };
      var completers = [snippetCompleter, textCompleter, keyWordCompleter];
      exports2.setCompleters = function(val) {
        completers.length = 0;
        if (val)
          completers.push.apply(completers, val);
      };
      exports2.addCompleter = function(completer) {
        completers.push(completer);
      };
      exports2.textCompleter = textCompleter;
      exports2.keyWordCompleter = keyWordCompleter;
      exports2.snippetCompleter = snippetCompleter;
      var expandSnippet = {
        name: "expandSnippet",
        exec: function(editor) {
          return snippetManager.expandWithTab(editor);
        },
        bindKey: "Tab"
      };
      var onChangeMode = function(e, editor) {
        loadSnippetsForMode(editor.session.$mode);
      };
      var loadSnippetsForMode = function(mode) {
        if (typeof mode == "string")
          mode = config.$modes[mode];
        if (!mode)
          return;
        if (!snippetManager.files)
          snippetManager.files = {};
        loadSnippetFile(mode.$id, mode.snippetFileId);
        if (mode.modes)
          mode.modes.forEach(loadSnippetsForMode);
      };
      var loadSnippetFile = function(id, snippetFilePath) {
        if (!snippetFilePath || !id || snippetManager.files[id])
          return;
        snippetManager.files[id] = {};
        config.loadModule(snippetFilePath, function(m) {
          if (!m)
            return;
          snippetManager.files[id] = m;
          if (!m.snippets && m.snippetText)
            m.snippets = snippetManager.parseSnippetFile(m.snippetText);
          snippetManager.register(m.snippets || [], m.scope);
          if (m.includeScopes) {
            snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;
            m.includeScopes.forEach(function(x) {
              loadSnippetsForMode("ace/mode/" + x);
            });
          }
        });
      };
      var doLiveAutocomplete = function(e) {
        var editor = e.editor;
        var hasCompleter = editor.completer && editor.completer.activated;
        if (e.command.name === "backspace") {
          if (hasCompleter && !util.getCompletionPrefix(editor))
            editor.completer.detach();
        } else if (e.command.name === "insertstring" && !hasCompleter) {
          lastExecEvent = e;
          var delay = e.editor.$liveAutocompletionDelay;
          if (delay) {
            liveAutocompleteTimer.delay(delay);
          } else {
            showLiveAutocomplete(e);
          }
        }
      };
      var lastExecEvent;
      var liveAutocompleteTimer = lang.delayedCall(function() {
        showLiveAutocomplete(lastExecEvent);
      }, 0);
      var showLiveAutocomplete = function(e) {
        var editor = e.editor;
        var prefix = util.getCompletionPrefix(editor);
        var previousChar = e.args;
        var triggerAutocomplete = util.triggerAutocomplete(editor, previousChar);
        if (prefix && prefix.length >= editor.$liveAutocompletionThreshold || triggerAutocomplete) {
          var completer = Autocomplete.for(editor);
          completer.autoShown = true;
          completer.showPopup(editor);
        }
      };
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        enableBasicAutocompletion: {
          set: function(val) {
            if (val) {
              Autocomplete.for(this);
              if (!this.completers)
                this.completers = Array.isArray(val) ? val : completers;
              this.commands.addCommand(Autocomplete.startCommand);
            } else {
              this.commands.removeCommand(Autocomplete.startCommand);
            }
          },
          value: false
        },
        enableLiveAutocompletion: {
          set: function(val) {
            if (val) {
              if (!this.completers)
                this.completers = Array.isArray(val) ? val : completers;
              this.commands.on("afterExec", doLiveAutocomplete);
            } else {
              this.commands.off("afterExec", doLiveAutocomplete);
            }
          },
          value: false
        },
        liveAutocompletionDelay: {
          initialValue: 0
        },
        liveAutocompletionThreshold: {
          initialValue: 0
        },
        enableSnippets: {
          set: function(val) {
            if (val) {
              this.commands.addCommand(expandSnippet);
              this.on("changeMode", onChangeMode);
              onChangeMode(null, this);
            } else {
              this.commands.removeCommand(expandSnippet);
              this.off("changeMode", onChangeMode);
            }
          },
          value: false
        }
      });
      exports2.MarkerGroup = MarkerGroup;
    });
    (function() {
      ace.require(["ace/ext/language_tools"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-linking.js
var require_ext_linking = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-linking.js"(exports, module2) {
    ace.define("ace/ext/linking", ["require", "exports", "module", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        enableLinking: {
          set: function(val) {
            if (val) {
              this.on("click", onClick);
              this.on("mousemove", onMouseMove);
            } else {
              this.off("click", onClick);
              this.off("mousemove", onMouseMove);
            }
          },
          value: false
        }
      });
      exports2.previousLinkingHover = false;
      function onMouseMove(e) {
        var editor = e.editor;
        var ctrl = e.getAccelKey();
        if (ctrl) {
          var editor = e.editor;
          var docPos = e.getDocumentPosition();
          var session = editor.session;
          var token = session.getTokenAt(docPos.row, docPos.column);
          if (exports2.previousLinkingHover && exports2.previousLinkingHover != token) {
            editor._emit("linkHoverOut");
          }
          editor._emit("linkHover", { position: docPos, token });
          exports2.previousLinkingHover = token;
        } else if (exports2.previousLinkingHover) {
          editor._emit("linkHoverOut");
          exports2.previousLinkingHover = false;
        }
      }
      function onClick(e) {
        var ctrl = e.getAccelKey();
        var button = e.getButton();
        if (button == 0 && ctrl) {
          var editor = e.editor;
          var docPos = e.getDocumentPosition();
          var session = editor.session;
          var token = session.getTokenAt(docPos.row, docPos.column);
          editor._emit("linkClick", { position: docPos, token });
        }
      }
    });
    (function() {
      ace.require(["ace/ext/linking"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-modelist.js
var require_ext_modelist = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-modelist.js"(exports, module2) {
    ace.define("ace/ext/modelist", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var modes = [];
      function getModeForPath(path2) {
        var mode2 = modesByName.text;
        var fileName = path2.split(/[\/\\]/).pop();
        for (var i = 0; i < modes.length; i++) {
          if (modes[i].supportsFile(fileName)) {
            mode2 = modes[i];
            break;
          }
        }
        return mode2;
      }
      var Mode = (
        /** @class */
        function() {
          function Mode2(name2, caption, extensions) {
            this.name = name2;
            this.caption = caption;
            this.mode = "ace/mode/" + name2;
            this.extensions = extensions;
            var re3;
            if (/\^/.test(extensions)) {
              re3 = extensions.replace(/\|(\^)?/g, function(a, b2) {
                return "$|" + (b2 ? "^" : "^.*\\.");
              }) + "$";
            } else {
              re3 = "\\.(" + extensions + ")$";
            }
            this.extRe = new RegExp(re3, "gi");
          }
          Mode2.prototype.supportsFile = function(filename2) {
            return filename2.match(this.extRe);
          };
          return Mode2;
        }()
      );
      var supportedModes = {
        ABAP: ["abap"],
        ABC: ["abc"],
        ActionScript: ["as"],
        ADA: ["ada|adb"],
        Alda: ["alda"],
        Apache_Conf: ["^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd"],
        Apex: ["apex|cls|trigger|tgr"],
        AQL: ["aql"],
        AsciiDoc: ["asciidoc|adoc"],
        ASL: ["dsl|asl|asl.json"],
        Assembly_ARM32: ["s"],
        Assembly_x86: ["asm|a"],
        Astro: ["astro"],
        AutoHotKey: ["ahk"],
        Basic: ["bas|bak"],
        BatchFile: ["bat|cmd"],
        BibTeX: ["bib"],
        C_Cpp: ["cpp|c|cc|cxx|h|hh|hpp|ino"],
        C9Search: ["c9search_results"],
        Cirru: ["cirru|cr"],
        Clojure: ["clj|cljs"],
        Clue: ["clue"],
        Cobol: ["CBL|COB"],
        coffee: ["coffee|cf|cson|^Cakefile"],
        ColdFusion: ["cfm|cfc"],
        Crystal: ["cr"],
        CSharp: ["cs"],
        Csound_Document: ["csd"],
        Csound_Orchestra: ["orc"],
        Csound_Score: ["sco"],
        CSS: ["css"],
        CSV: ["csv"],
        Curly: ["curly"],
        Cuttlefish: ["conf"],
        D: ["d|di"],
        Dart: ["dart"],
        Diff: ["diff|patch"],
        Django: ["djt|html.djt|dj.html|djhtml"],
        Dockerfile: ["^Dockerfile"],
        Dot: ["dot"],
        Drools: ["drl"],
        Edifact: ["edi"],
        Eiffel: ["e|ge"],
        EJS: ["ejs"],
        Elixir: ["ex|exs"],
        Elm: ["elm"],
        Erlang: ["erl|hrl"],
        Flix: ["flix"],
        Forth: ["frt|fs|ldr|fth|4th"],
        Fortran: ["f|f90"],
        FSharp: ["fsi|fs|ml|mli|fsx|fsscript"],
        FSL: ["fsl"],
        FTL: ["ftl"],
        Gcode: ["gcode"],
        Gherkin: ["feature"],
        Gitignore: ["^.gitignore"],
        Glsl: ["glsl|frag|vert"],
        Gobstones: ["gbs"],
        golang: ["go"],
        GraphQLSchema: ["gql"],
        Groovy: ["groovy"],
        HAML: ["haml"],
        Handlebars: ["hbs|handlebars|tpl|mustache"],
        Haskell: ["hs"],
        Haskell_Cabal: ["cabal"],
        haXe: ["hx"],
        Hjson: ["hjson"],
        HTML: ["html|htm|xhtml|we|wpy"],
        HTML_Elixir: ["eex|html.eex"],
        HTML_Ruby: ["erb|rhtml|html.erb"],
        INI: ["ini|conf|cfg|prefs"],
        Io: ["io"],
        Ion: ["ion"],
        Jack: ["jack"],
        Jade: ["jade|pug"],
        Java: ["java"],
        JavaScript: ["js|jsm|cjs|mjs"],
        JEXL: ["jexl"],
        JSON: ["json"],
        JSON5: ["json5"],
        JSONiq: ["jq"],
        JSP: ["jsp"],
        JSSM: ["jssm|jssm_state"],
        JSX: ["jsx"],
        Julia: ["jl"],
        Kotlin: ["kt|kts"],
        LaTeX: ["tex|latex|ltx|bib"],
        Latte: ["latte"],
        LESS: ["less"],
        Liquid: ["liquid"],
        Lisp: ["lisp"],
        LiveScript: ["ls"],
        Log: ["log"],
        LogiQL: ["logic|lql"],
        Logtalk: ["lgt"],
        LSL: ["lsl"],
        Lua: ["lua"],
        LuaPage: ["lp"],
        Lucene: ["lucene"],
        Makefile: ["^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make"],
        Markdown: ["md|markdown"],
        Mask: ["mask"],
        MATLAB: ["matlab"],
        Maze: ["mz"],
        MediaWiki: ["wiki|mediawiki"],
        MEL: ["mel"],
        MIPS: ["s|asm"],
        MIXAL: ["mixal"],
        MUSHCode: ["mc|mush"],
        MySQL: ["mysql"],
        Nasal: ["nas"],
        Nginx: ["nginx|conf"],
        Nim: ["nim"],
        Nix: ["nix"],
        NSIS: ["nsi|nsh"],
        Nunjucks: ["nunjucks|nunjs|nj|njk"],
        ObjectiveC: ["m|mm"],
        OCaml: ["ml|mli"],
        Odin: ["odin"],
        PartiQL: ["partiql|pql"],
        Pascal: ["pas|p"],
        Perl: ["pl|pm"],
        pgSQL: ["pgsql"],
        PHP: ["php|inc|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module"],
        PHP_Laravel_blade: ["blade.php"],
        Pig: ["pig"],
        PLSQL: ["plsql"],
        Powershell: ["ps1"],
        Praat: ["praat|praatscript|psc|proc"],
        Prisma: ["prisma"],
        Prolog: ["plg|prolog"],
        Properties: ["properties"],
        Protobuf: ["proto"],
        PRQL: ["prql"],
        Puppet: ["epp|pp"],
        Python: ["py"],
        QML: ["qml"],
        R: ["r"],
        Raku: ["raku|rakumod|rakutest|p6|pl6|pm6"],
        Razor: ["cshtml|asp"],
        RDoc: ["Rd"],
        Red: ["red|reds"],
        RHTML: ["Rhtml"],
        Robot: ["robot|resource"],
        RST: ["rst"],
        Ruby: ["rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile"],
        Rust: ["rs"],
        SaC: ["sac"],
        SASS: ["sass"],
        SCAD: ["scad"],
        Scala: ["scala|sbt"],
        Scheme: ["scm|sm|rkt|oak|scheme"],
        Scrypt: ["scrypt"],
        SCSS: ["scss"],
        SH: ["sh|bash|^.bashrc"],
        SJS: ["sjs"],
        Slim: ["slim|skim"],
        Smarty: ["smarty|tpl"],
        Smithy: ["smithy"],
        snippets: ["snippets"],
        Soy_Template: ["soy"],
        Space: ["space"],
        SPARQL: ["rq"],
        SQL: ["sql"],
        SQLServer: ["sqlserver"],
        Stylus: ["styl|stylus"],
        SVG: ["svg"],
        Swift: ["swift"],
        Tcl: ["tcl"],
        Terraform: ["tf", "tfvars", "terragrunt"],
        Tex: ["tex"],
        Text: ["txt"],
        Textile: ["textile"],
        Toml: ["toml"],
        TSV: ["tsv"],
        TSX: ["tsx"],
        Turtle: ["ttl"],
        Twig: ["twig|swig"],
        Typescript: ["ts|mts|cts|typescript|str"],
        Vala: ["vala"],
        VBScript: ["vbs|vb"],
        Velocity: ["vm"],
        Verilog: ["v|vh|sv|svh"],
        VHDL: ["vhd|vhdl"],
        Visualforce: ["vfp|component|page"],
        Vue: ["vue"],
        Wollok: ["wlk|wpgm|wtest"],
        XML: ["xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml"],
        XQuery: ["xq"],
        YAML: ["yaml|yml"],
        Zeek: ["zeek|bro"],
        Zig: ["zig"]
      };
      var nameOverrides = {
        ObjectiveC: "Objective-C",
        CSharp: "C#",
        golang: "Go",
        C_Cpp: "C and C++",
        Csound_Document: "Csound Document",
        Csound_Orchestra: "Csound",
        Csound_Score: "Csound Score",
        coffee: "CoffeeScript",
        HTML_Ruby: "HTML (Ruby)",
        HTML_Elixir: "HTML (Elixir)",
        FTL: "FreeMarker",
        PHP_Laravel_blade: "PHP (Blade Template)",
        Perl6: "Perl 6",
        AutoHotKey: "AutoHotkey / AutoIt"
      };
      var modesByName = {};
      for (var name in supportedModes) {
        var data = supportedModes[name];
        var displayName = (nameOverrides[name] || name).replace(/_/g, " ");
        var filename = name.toLowerCase();
        var mode = new Mode(filename, displayName, data[0]);
        modesByName[filename] = mode;
        modes.push(mode);
      }
      exports2.getModeForPath = getModeForPath;
      exports2.modes = modes;
      exports2.modesByName = modesByName;
    });
    (function() {
      ace.require(["ace/ext/modelist"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-options.js
var require_ext_options = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-options.js"(exports, module2) {
    ace.define("ace/ext/menu_tools/settings_menu.css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = "#ace_settingsmenu, #kbshortcutmenu {\n    background-color: #F7F7F7;\n    color: black;\n    box-shadow: -5px 4px 5px rgba(126, 126, 126, 0.55);\n    padding: 1em 0.5em 2em 1em;\n    overflow: auto;\n    position: absolute;\n    margin: 0;\n    bottom: 0;\n    right: 0;\n    top: 0;\n    z-index: 9991;\n    cursor: default;\n}\n\n.ace_dark #ace_settingsmenu, .ace_dark #kbshortcutmenu {\n    box-shadow: -20px 10px 25px rgba(126, 126, 126, 0.25);\n    background-color: rgba(255, 255, 255, 0.6);\n    color: black;\n}\n\n.ace_optionsMenuEntry:hover {\n    background-color: rgba(100, 100, 100, 0.1);\n    transition: all 0.3s\n}\n\n.ace_closeButton {\n    background: rgba(245, 146, 146, 0.5);\n    border: 1px solid #F48A8A;\n    border-radius: 50%;\n    padding: 7px;\n    position: absolute;\n    right: -8px;\n    top: -8px;\n    z-index: 100000;\n}\n.ace_closeButton{\n    background: rgba(245, 146, 146, 0.9);\n}\n.ace_optionsMenuKey {\n    color: darkslateblue;\n    font-weight: bold;\n}\n.ace_optionsMenuCommand {\n    color: darkcyan;\n    font-weight: normal;\n}\n.ace_optionsMenuEntry input, .ace_optionsMenuEntry button {\n    vertical-align: middle;\n}\n\n.ace_optionsMenuEntry button[ace_selected_button=true] {\n    background: #e7e7e7;\n    box-shadow: 1px 0px 2px 0px #adadad inset;\n    border-color: #adadad;\n}\n.ace_optionsMenuEntry button {\n    background: white;\n    border: 1px solid lightgray;\n    margin: 0px;\n}\n.ace_optionsMenuEntry button:hover{\n    background: #f0f0f0;\n}";
    });
    ace.define("ace/ext/menu_tools/overlay_page", ["require", "exports", "module", "ace/ext/menu_tools/overlay_page", "ace/lib/dom", "ace/ext/menu_tools/settings_menu.css"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../../lib/dom");
      var cssText = require3("./settings_menu.css");
      dom.importCssString(cssText, "settings_menu.css", false);
      module3.exports.overlayPage = function overlayPage(editor, contentElement, callback) {
        var closer = document.createElement("div");
        var ignoreFocusOut = false;
        function documentEscListener(e) {
          if (e.keyCode === 27) {
            close();
          }
        }
        function close() {
          if (!closer)
            return;
          document.removeEventListener("keydown", documentEscListener);
          closer.parentNode.removeChild(closer);
          if (editor) {
            editor.focus();
          }
          closer = null;
          callback && callback();
        }
        function setIgnoreFocusOut(ignore) {
          ignoreFocusOut = ignore;
          if (ignore) {
            closer.style.pointerEvents = "none";
            contentElement.style.pointerEvents = "auto";
          }
        }
        closer.style.cssText = "margin: 0; padding: 0; position: fixed; top:0; bottom:0; left:0; right:0;z-index: 9990; " + (editor ? "background-color: rgba(0, 0, 0, 0.3);" : "");
        closer.addEventListener("click", function(e) {
          if (!ignoreFocusOut) {
            close();
          }
        });
        document.addEventListener("keydown", documentEscListener);
        contentElement.addEventListener("click", function(e) {
          e.stopPropagation();
        });
        closer.appendChild(contentElement);
        document.body.appendChild(closer);
        if (editor) {
          editor.blur();
        }
        return {
          close,
          setIgnoreFocusOut
        };
      };
    });
    ace.define("ace/ext/settings_menu", ["require", "exports", "module", "ace/ext/options", "ace/ext/menu_tools/overlay_page", "ace/editor"], function(require3, exports2, module3) {
      "use strict";
      var OptionPanel = require3("./options").OptionPanel;
      var overlayPage = require3("./menu_tools/overlay_page").overlayPage;
      function showSettingsMenu(editor) {
        if (!document.getElementById("ace_settingsmenu")) {
          var options = new OptionPanel(editor);
          options.render();
          options.container.id = "ace_settingsmenu";
          overlayPage(editor, options.container);
          options.container.querySelector("select,input,button,checkbox").focus();
        }
      }
      module3.exports.init = function() {
        var Editor = require3("../editor").Editor;
        Editor.prototype.showSettingsMenu = function() {
          showSettingsMenu(this);
        };
      };
    });
    ace.define("ace/ext/modelist", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var modes = [];
      function getModeForPath(path2) {
        var mode2 = modesByName.text;
        var fileName = path2.split(/[\/\\]/).pop();
        for (var i = 0; i < modes.length; i++) {
          if (modes[i].supportsFile(fileName)) {
            mode2 = modes[i];
            break;
          }
        }
        return mode2;
      }
      var Mode = (
        /** @class */
        function() {
          function Mode2(name2, caption, extensions) {
            this.name = name2;
            this.caption = caption;
            this.mode = "ace/mode/" + name2;
            this.extensions = extensions;
            var re3;
            if (/\^/.test(extensions)) {
              re3 = extensions.replace(/\|(\^)?/g, function(a, b2) {
                return "$|" + (b2 ? "^" : "^.*\\.");
              }) + "$";
            } else {
              re3 = "\\.(" + extensions + ")$";
            }
            this.extRe = new RegExp(re3, "gi");
          }
          Mode2.prototype.supportsFile = function(filename2) {
            return filename2.match(this.extRe);
          };
          return Mode2;
        }()
      );
      var supportedModes = {
        ABAP: ["abap"],
        ABC: ["abc"],
        ActionScript: ["as"],
        ADA: ["ada|adb"],
        Alda: ["alda"],
        Apache_Conf: ["^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd"],
        Apex: ["apex|cls|trigger|tgr"],
        AQL: ["aql"],
        AsciiDoc: ["asciidoc|adoc"],
        ASL: ["dsl|asl|asl.json"],
        Assembly_ARM32: ["s"],
        Assembly_x86: ["asm|a"],
        Astro: ["astro"],
        AutoHotKey: ["ahk"],
        Basic: ["bas|bak"],
        BatchFile: ["bat|cmd"],
        BibTeX: ["bib"],
        C_Cpp: ["cpp|c|cc|cxx|h|hh|hpp|ino"],
        C9Search: ["c9search_results"],
        Cirru: ["cirru|cr"],
        Clojure: ["clj|cljs"],
        Clue: ["clue"],
        Cobol: ["CBL|COB"],
        coffee: ["coffee|cf|cson|^Cakefile"],
        ColdFusion: ["cfm|cfc"],
        Crystal: ["cr"],
        CSharp: ["cs"],
        Csound_Document: ["csd"],
        Csound_Orchestra: ["orc"],
        Csound_Score: ["sco"],
        CSS: ["css"],
        CSV: ["csv"],
        Curly: ["curly"],
        Cuttlefish: ["conf"],
        D: ["d|di"],
        Dart: ["dart"],
        Diff: ["diff|patch"],
        Django: ["djt|html.djt|dj.html|djhtml"],
        Dockerfile: ["^Dockerfile"],
        Dot: ["dot"],
        Drools: ["drl"],
        Edifact: ["edi"],
        Eiffel: ["e|ge"],
        EJS: ["ejs"],
        Elixir: ["ex|exs"],
        Elm: ["elm"],
        Erlang: ["erl|hrl"],
        Flix: ["flix"],
        Forth: ["frt|fs|ldr|fth|4th"],
        Fortran: ["f|f90"],
        FSharp: ["fsi|fs|ml|mli|fsx|fsscript"],
        FSL: ["fsl"],
        FTL: ["ftl"],
        Gcode: ["gcode"],
        Gherkin: ["feature"],
        Gitignore: ["^.gitignore"],
        Glsl: ["glsl|frag|vert"],
        Gobstones: ["gbs"],
        golang: ["go"],
        GraphQLSchema: ["gql"],
        Groovy: ["groovy"],
        HAML: ["haml"],
        Handlebars: ["hbs|handlebars|tpl|mustache"],
        Haskell: ["hs"],
        Haskell_Cabal: ["cabal"],
        haXe: ["hx"],
        Hjson: ["hjson"],
        HTML: ["html|htm|xhtml|we|wpy"],
        HTML_Elixir: ["eex|html.eex"],
        HTML_Ruby: ["erb|rhtml|html.erb"],
        INI: ["ini|conf|cfg|prefs"],
        Io: ["io"],
        Ion: ["ion"],
        Jack: ["jack"],
        Jade: ["jade|pug"],
        Java: ["java"],
        JavaScript: ["js|jsm|cjs|mjs"],
        JEXL: ["jexl"],
        JSON: ["json"],
        JSON5: ["json5"],
        JSONiq: ["jq"],
        JSP: ["jsp"],
        JSSM: ["jssm|jssm_state"],
        JSX: ["jsx"],
        Julia: ["jl"],
        Kotlin: ["kt|kts"],
        LaTeX: ["tex|latex|ltx|bib"],
        Latte: ["latte"],
        LESS: ["less"],
        Liquid: ["liquid"],
        Lisp: ["lisp"],
        LiveScript: ["ls"],
        Log: ["log"],
        LogiQL: ["logic|lql"],
        Logtalk: ["lgt"],
        LSL: ["lsl"],
        Lua: ["lua"],
        LuaPage: ["lp"],
        Lucene: ["lucene"],
        Makefile: ["^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make"],
        Markdown: ["md|markdown"],
        Mask: ["mask"],
        MATLAB: ["matlab"],
        Maze: ["mz"],
        MediaWiki: ["wiki|mediawiki"],
        MEL: ["mel"],
        MIPS: ["s|asm"],
        MIXAL: ["mixal"],
        MUSHCode: ["mc|mush"],
        MySQL: ["mysql"],
        Nasal: ["nas"],
        Nginx: ["nginx|conf"],
        Nim: ["nim"],
        Nix: ["nix"],
        NSIS: ["nsi|nsh"],
        Nunjucks: ["nunjucks|nunjs|nj|njk"],
        ObjectiveC: ["m|mm"],
        OCaml: ["ml|mli"],
        Odin: ["odin"],
        PartiQL: ["partiql|pql"],
        Pascal: ["pas|p"],
        Perl: ["pl|pm"],
        pgSQL: ["pgsql"],
        PHP: ["php|inc|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module"],
        PHP_Laravel_blade: ["blade.php"],
        Pig: ["pig"],
        PLSQL: ["plsql"],
        Powershell: ["ps1"],
        Praat: ["praat|praatscript|psc|proc"],
        Prisma: ["prisma"],
        Prolog: ["plg|prolog"],
        Properties: ["properties"],
        Protobuf: ["proto"],
        PRQL: ["prql"],
        Puppet: ["epp|pp"],
        Python: ["py"],
        QML: ["qml"],
        R: ["r"],
        Raku: ["raku|rakumod|rakutest|p6|pl6|pm6"],
        Razor: ["cshtml|asp"],
        RDoc: ["Rd"],
        Red: ["red|reds"],
        RHTML: ["Rhtml"],
        Robot: ["robot|resource"],
        RST: ["rst"],
        Ruby: ["rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile"],
        Rust: ["rs"],
        SaC: ["sac"],
        SASS: ["sass"],
        SCAD: ["scad"],
        Scala: ["scala|sbt"],
        Scheme: ["scm|sm|rkt|oak|scheme"],
        Scrypt: ["scrypt"],
        SCSS: ["scss"],
        SH: ["sh|bash|^.bashrc"],
        SJS: ["sjs"],
        Slim: ["slim|skim"],
        Smarty: ["smarty|tpl"],
        Smithy: ["smithy"],
        snippets: ["snippets"],
        Soy_Template: ["soy"],
        Space: ["space"],
        SPARQL: ["rq"],
        SQL: ["sql"],
        SQLServer: ["sqlserver"],
        Stylus: ["styl|stylus"],
        SVG: ["svg"],
        Swift: ["swift"],
        Tcl: ["tcl"],
        Terraform: ["tf", "tfvars", "terragrunt"],
        Tex: ["tex"],
        Text: ["txt"],
        Textile: ["textile"],
        Toml: ["toml"],
        TSV: ["tsv"],
        TSX: ["tsx"],
        Turtle: ["ttl"],
        Twig: ["twig|swig"],
        Typescript: ["ts|mts|cts|typescript|str"],
        Vala: ["vala"],
        VBScript: ["vbs|vb"],
        Velocity: ["vm"],
        Verilog: ["v|vh|sv|svh"],
        VHDL: ["vhd|vhdl"],
        Visualforce: ["vfp|component|page"],
        Vue: ["vue"],
        Wollok: ["wlk|wpgm|wtest"],
        XML: ["xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml"],
        XQuery: ["xq"],
        YAML: ["yaml|yml"],
        Zeek: ["zeek|bro"],
        Zig: ["zig"]
      };
      var nameOverrides = {
        ObjectiveC: "Objective-C",
        CSharp: "C#",
        golang: "Go",
        C_Cpp: "C and C++",
        Csound_Document: "Csound Document",
        Csound_Orchestra: "Csound",
        Csound_Score: "Csound Score",
        coffee: "CoffeeScript",
        HTML_Ruby: "HTML (Ruby)",
        HTML_Elixir: "HTML (Elixir)",
        FTL: "FreeMarker",
        PHP_Laravel_blade: "PHP (Blade Template)",
        Perl6: "Perl 6",
        AutoHotKey: "AutoHotkey / AutoIt"
      };
      var modesByName = {};
      for (var name in supportedModes) {
        var data = supportedModes[name];
        var displayName = (nameOverrides[name] || name).replace(/_/g, " ");
        var filename = name.toLowerCase();
        var mode = new Mode(filename, displayName, data[0]);
        modesByName[filename] = mode;
        modes.push(mode);
      }
      exports2.getModeForPath = getModeForPath;
      exports2.modes = modes;
      exports2.modesByName = modesByName;
    });
    ace.define("ace/ext/themelist", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var themeData = [
        ["Chrome"],
        ["Clouds"],
        ["Crimson Editor"],
        ["Dawn"],
        ["Dreamweaver"],
        ["Eclipse"],
        ["GitHub Light Default"],
        ["GitHub (Legacy)", "github", "light"],
        ["IPlastic"],
        ["Solarized Light"],
        ["TextMate"],
        ["Tomorrow"],
        ["XCode"],
        ["Kuroir"],
        ["KatzenMilch"],
        ["SQL Server", "sqlserver", "light"],
        ["CloudEditor", "cloud_editor", "light"],
        ["Ambiance", "ambiance", "dark"],
        ["Chaos", "chaos", "dark"],
        ["Clouds Midnight", "clouds_midnight", "dark"],
        ["Dracula", "", "dark"],
        ["Cobalt", "cobalt", "dark"],
        ["Gruvbox", "gruvbox", "dark"],
        ["Green on Black", "gob", "dark"],
        ["idle Fingers", "idle_fingers", "dark"],
        ["krTheme", "kr_theme", "dark"],
        ["Merbivore", "merbivore", "dark"],
        ["Merbivore Soft", "merbivore_soft", "dark"],
        ["Mono Industrial", "mono_industrial", "dark"],
        ["Monokai", "monokai", "dark"],
        ["Nord Dark", "nord_dark", "dark"],
        ["One Dark", "one_dark", "dark"],
        ["Pastel on dark", "pastel_on_dark", "dark"],
        ["Solarized Dark", "solarized_dark", "dark"],
        ["Terminal", "terminal", "dark"],
        ["Tomorrow Night", "tomorrow_night", "dark"],
        ["Tomorrow Night Blue", "tomorrow_night_blue", "dark"],
        ["Tomorrow Night Bright", "tomorrow_night_bright", "dark"],
        ["Tomorrow Night 80s", "tomorrow_night_eighties", "dark"],
        ["Twilight", "twilight", "dark"],
        ["Vibrant Ink", "vibrant_ink", "dark"],
        ["GitHub Dark", "github_dark", "dark"],
        ["CloudEditor Dark", "cloud_editor_dark", "dark"]
      ];
      exports2.themesByName = {};
      exports2.themes = themeData.map(function(data) {
        var name = data[1] || data[0].replace(/ /g, "_").toLowerCase();
        var theme = {
          caption: data[0],
          theme: "ace/theme/" + name,
          isDark: data[2] == "dark",
          name
        };
        exports2.themesByName[name] = theme;
        return theme;
      });
    });
    ace.define("ace/ext/options", ["require", "exports", "module", "ace/ext/settings_menu", "ace/ext/menu_tools/overlay_page", "ace/lib/dom", "ace/lib/oop", "ace/config", "ace/lib/event_emitter", "ace/ext/modelist", "ace/ext/themelist"], function(require3, exports2, module3) {
      "use strict";
      require3("./menu_tools/overlay_page");
      var dom = require3("../lib/dom");
      var oop = require3("../lib/oop");
      var config = require3("../config");
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var buildDom = dom.buildDom;
      var modelist = require3("./modelist");
      var themelist = require3("./themelist");
      var themes = { Bright: [], Dark: [] };
      themelist.themes.forEach(function(x) {
        themes[x.isDark ? "Dark" : "Bright"].push({ caption: x.caption, value: x.theme });
      });
      var modes = modelist.modes.map(function(x) {
        return { caption: x.caption, value: x.mode };
      });
      var optionGroups = {
        Main: {
          Mode: {
            path: "mode",
            type: "select",
            items: modes
          },
          Theme: {
            path: "theme",
            type: "select",
            items: themes
          },
          "Keybinding": {
            type: "buttonBar",
            path: "keyboardHandler",
            items: [
              { caption: "Ace", value: null },
              { caption: "Vim", value: "ace/keyboard/vim" },
              { caption: "Emacs", value: "ace/keyboard/emacs" },
              { caption: "Sublime", value: "ace/keyboard/sublime" },
              { caption: "VSCode", value: "ace/keyboard/vscode" }
            ]
          },
          "Font Size": {
            path: "fontSize",
            type: "number",
            defaultValue: 12,
            defaults: [
              { caption: "12px", value: 12 },
              { caption: "24px", value: 24 }
            ]
          },
          "Soft Wrap": {
            type: "buttonBar",
            path: "wrap",
            items: [
              { caption: "Off", value: "off" },
              { caption: "View", value: "free" },
              { caption: "margin", value: "printMargin" },
              { caption: "40", value: "40" }
            ]
          },
          "Cursor Style": {
            path: "cursorStyle",
            items: [
              { caption: "Ace", value: "ace" },
              { caption: "Slim", value: "slim" },
              { caption: "Smooth", value: "smooth" },
              { caption: "Smooth And Slim", value: "smooth slim" },
              { caption: "Wide", value: "wide" }
            ]
          },
          "Folding": {
            path: "foldStyle",
            items: [
              { caption: "Manual", value: "manual" },
              { caption: "Mark begin", value: "markbegin" },
              { caption: "Mark begin and end", value: "markbeginend" }
            ]
          },
          "Soft Tabs": [{
            path: "useSoftTabs"
          }, {
            ariaLabel: "Tab Size",
            path: "tabSize",
            type: "number",
            values: [2, 3, 4, 8, 16]
          }],
          "Overscroll": {
            type: "buttonBar",
            path: "scrollPastEnd",
            items: [
              { caption: "None", value: 0 },
              { caption: "Half", value: 0.5 },
              { caption: "Full", value: 1 }
            ]
          }
        },
        More: {
          "Atomic soft tabs": {
            path: "navigateWithinSoftTabs"
          },
          "Enable Behaviours": {
            path: "behavioursEnabled"
          },
          "Wrap with quotes": {
            path: "wrapBehavioursEnabled"
          },
          "Enable Auto Indent": {
            path: "enableAutoIndent"
          },
          "Full Line Selection": {
            type: "checkbox",
            values: "text|line",
            path: "selectionStyle"
          },
          "Highlight Active Line": {
            path: "highlightActiveLine"
          },
          "Show Invisibles": {
            path: "showInvisibles"
          },
          "Show Indent Guides": {
            path: "displayIndentGuides"
          },
          "Highlight Indent Guides": {
            path: "highlightIndentGuides"
          },
          "Persistent HScrollbar": {
            path: "hScrollBarAlwaysVisible"
          },
          "Persistent VScrollbar": {
            path: "vScrollBarAlwaysVisible"
          },
          "Animate scrolling": {
            path: "animatedScroll"
          },
          "Show Gutter": {
            path: "showGutter"
          },
          "Show Line Numbers": {
            path: "showLineNumbers"
          },
          "Relative Line Numbers": {
            path: "relativeLineNumbers"
          },
          "Fixed Gutter Width": {
            path: "fixedWidthGutter"
          },
          "Show Print Margin": [{
            path: "showPrintMargin"
          }, {
            ariaLabel: "Print Margin",
            type: "number",
            path: "printMarginColumn"
          }],
          "Indented Soft Wrap": {
            path: "indentedSoftWrap"
          },
          "Highlight selected word": {
            path: "highlightSelectedWord"
          },
          "Fade Fold Widgets": {
            path: "fadeFoldWidgets"
          },
          "Use textarea for IME": {
            path: "useTextareaForIME"
          },
          "Merge Undo Deltas": {
            path: "mergeUndoDeltas",
            items: [
              { caption: "Always", value: "always" },
              { caption: "Never", value: "false" },
              { caption: "Timed", value: "true" }
            ]
          },
          "Elastic Tabstops": {
            path: "useElasticTabstops"
          },
          "Incremental Search": {
            path: "useIncrementalSearch"
          },
          "Read-only": {
            path: "readOnly"
          },
          "Copy without selection": {
            path: "copyWithEmptySelection"
          },
          "Live Autocompletion": {
            path: "enableLiveAutocompletion"
          },
          "Custom scrollbar": {
            path: "customScrollbar"
          },
          "Use SVG gutter icons": {
            path: "useSvgGutterIcons"
          },
          "Annotations for folded lines": {
            path: "showFoldedAnnotations"
          },
          "Keyboard Accessibility Mode": {
            path: "enableKeyboardAccessibility"
          },
          "Gutter tooltip follows mouse": {
            path: "tooltipFollowsMouse",
            defaultValue: true
          }
        }
      };
      var OptionPanel = (
        /** @class */
        function() {
          function OptionPanel2(editor, element) {
            this.editor = editor;
            this.container = element || document.createElement("div");
            this.groups = [];
            this.options = {};
          }
          OptionPanel2.prototype.add = function(config2) {
            if (config2.Main)
              oop.mixin(optionGroups.Main, config2.Main);
            if (config2.More)
              oop.mixin(optionGroups.More, config2.More);
          };
          OptionPanel2.prototype.render = function() {
            this.container.innerHTML = "";
            buildDom([
              "table",
              { role: "presentation", id: "controls" },
              this.renderOptionGroup(optionGroups.Main),
              ["tr", null, [
                "td",
                { colspan: 2 },
                [
                  "table",
                  { role: "presentation", id: "more-controls" },
                  this.renderOptionGroup(optionGroups.More)
                ]
              ]],
              ["tr", null, ["td", { colspan: 2 }, "version " + config.version]]
            ], this.container);
          };
          OptionPanel2.prototype.renderOptionGroup = function(group) {
            return Object.keys(group).map(function(key, i) {
              var item = group[key];
              if (!item.position)
                item.position = i / 1e4;
              if (!item.label)
                item.label = key;
              return item;
            }).sort(function(a, b2) {
              return a.position - b2.position;
            }).map(function(item) {
              return this.renderOption(item.label, item);
            }, this);
          };
          OptionPanel2.prototype.renderOptionControl = function(key, option) {
            var self2 = this;
            if (Array.isArray(option)) {
              return option.map(function(x) {
                return self2.renderOptionControl(key, x);
              });
            }
            var control;
            var value = self2.getOption(option);
            if (option.values && option.type != "checkbox") {
              if (typeof option.values == "string")
                option.values = option.values.split("|");
              option.items = option.values.map(function(v2) {
                return { value: v2, name: v2 };
              });
            }
            if (option.type == "buttonBar") {
              control = ["div", { role: "group", "aria-labelledby": option.path + "-label" }, option.items.map(function(item) {
                return ["button", {
                  value: item.value,
                  ace_selected_button: value == item.value,
                  "aria-pressed": value == item.value,
                  onclick: function() {
                    self2.setOption(option, item.value);
                    var nodes = this.parentNode.querySelectorAll("[ace_selected_button]");
                    for (var i = 0; i < nodes.length; i++) {
                      nodes[i].removeAttribute("ace_selected_button");
                      nodes[i].setAttribute("aria-pressed", false);
                    }
                    this.setAttribute("ace_selected_button", true);
                    this.setAttribute("aria-pressed", true);
                  }
                }, item.desc || item.caption || item.name];
              })];
            } else if (option.type == "number") {
              control = ["input", { type: "number", value: value || option.defaultValue, style: "width:3em", oninput: function() {
                self2.setOption(option, parseInt(this.value));
              } }];
              if (option.ariaLabel) {
                control[1]["aria-label"] = option.ariaLabel;
              } else {
                control[1].id = key;
              }
              if (option.defaults) {
                control = [control, option.defaults.map(function(item) {
                  return ["button", { onclick: function() {
                    var input = this.parentNode.firstChild;
                    input.value = item.value;
                    input.oninput();
                  } }, item.caption];
                })];
              }
            } else if (option.items) {
              var buildItems = function(items2) {
                return items2.map(function(item) {
                  return ["option", { value: item.value || item.name }, item.desc || item.caption || item.name];
                });
              };
              var items = Array.isArray(option.items) ? buildItems(option.items) : Object.keys(option.items).map(function(key2) {
                return ["optgroup", { "label": key2 }, buildItems(option.items[key2])];
              });
              control = ["select", { id: key, value, onchange: function() {
                self2.setOption(option, this.value);
              } }, items];
            } else {
              if (typeof option.values == "string")
                option.values = option.values.split("|");
              if (option.values)
                value = value == option.values[1];
              control = ["input", { type: "checkbox", id: key, checked: value || null, onchange: function() {
                var value2 = this.checked;
                if (option.values)
                  value2 = option.values[value2 ? 1 : 0];
                self2.setOption(option, value2);
              } }];
              if (option.type == "checkedNumber") {
                control = [control, []];
              }
            }
            return control;
          };
          OptionPanel2.prototype.renderOption = function(key, option) {
            if (option.path && !option.onchange && !this.editor.$options[option.path])
              return;
            var path2 = Array.isArray(option) ? option[0].path : option.path;
            this.options[path2] = option;
            var safeKey = "-" + path2;
            var safeId = path2 + "-label";
            var control = this.renderOptionControl(safeKey, option);
            return ["tr", { class: "ace_optionsMenuEntry" }, [
              "td",
              ["label", { for: safeKey, id: safeId }, key]
            ], ["td", control]];
          };
          OptionPanel2.prototype.setOption = function(option, value) {
            if (typeof option == "string")
              option = this.options[option];
            if (value == "false")
              value = false;
            if (value == "true")
              value = true;
            if (value == "null")
              value = null;
            if (value == "undefined")
              value = void 0;
            if (typeof value == "string" && parseFloat(value).toString() == value)
              value = parseFloat(value);
            if (option.onchange)
              option.onchange(value);
            else if (option.path)
              this.editor.setOption(option.path, value);
            this._signal("setOption", { name: option.path, value });
          };
          OptionPanel2.prototype.getOption = function(option) {
            if (option.getValue)
              return option.getValue();
            return this.editor.getOption(option.path);
          };
          return OptionPanel2;
        }()
      );
      oop.implement(OptionPanel.prototype, EventEmitter);
      exports2.OptionPanel = OptionPanel;
      exports2.optionGroups = optionGroups;
    });
    (function() {
      ace.require(["ace/ext/options"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-prompt.js
var require_ext_prompt = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-prompt.js"(exports, module2) {
    ace.define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom", "ace/config", "ace/lib/useragent"], function(require3, exports2, module3) {
      "use strict";
      var Renderer = require3("../virtual_renderer").VirtualRenderer;
      var Editor = require3("../editor").Editor;
      var Range = require3("../range").Range;
      var event = require3("../lib/event");
      var lang = require3("../lib/lang");
      var dom = require3("../lib/dom");
      var nls = require3("../config").nls;
      var userAgent = require3("./../lib/useragent");
      var getAriaId = function(index) {
        return "suggest-aria-id:".concat(index);
      };
      var popupAriaRole = userAgent.isSafari ? "menu" : "listbox";
      var optionAriaRole = userAgent.isSafari ? "menuitem" : "option";
      var ariaActiveState = userAgent.isSafari ? "aria-current" : "aria-selected";
      var $singleLineEditor = function(el) {
        var renderer = new Renderer(el);
        renderer.$maxLines = 4;
        var editor = new Editor(renderer);
        editor.setHighlightActiveLine(false);
        editor.setShowPrintMargin(false);
        editor.renderer.setShowGutter(false);
        editor.renderer.setHighlightGutterLine(false);
        editor.$mouseHandler.$focusTimeout = 0;
        editor.$highlightTagPending = true;
        return editor;
      };
      var AcePopup = (
        /** @class */
        /* @__PURE__ */ function() {
          function AcePopup2(parentNode) {
            var el = dom.createElement("div");
            var popup = $singleLineEditor(el);
            if (parentNode) {
              parentNode.appendChild(el);
            }
            el.style.display = "none";
            popup.renderer.content.style.cursor = "default";
            popup.renderer.setStyle("ace_autocomplete");
            popup.renderer.$textLayer.element.setAttribute("role", popupAriaRole);
            popup.renderer.$textLayer.element.setAttribute("aria-roledescription", nls("autocomplete.popup.aria-roledescription", "Autocomplete suggestions"));
            popup.renderer.$textLayer.element.setAttribute("aria-label", nls("autocomplete.popup.aria-label", "Autocomplete suggestions"));
            popup.renderer.textarea.setAttribute("aria-hidden", "true");
            popup.setOption("displayIndentGuides", false);
            popup.setOption("dragDelay", 150);
            var noop = function() {
            };
            popup.focus = noop;
            popup.$isFocused = true;
            popup.renderer.$cursorLayer.restartTimer = noop;
            popup.renderer.$cursorLayer.element.style.opacity = "0";
            popup.renderer.$maxLines = 8;
            popup.renderer.$keepTextAreaAtCursor = false;
            popup.setHighlightActiveLine(false);
            popup.session.highlight("");
            popup.session.$searchHighlight.clazz = "ace_highlight-marker";
            popup.on("mousedown", function(e) {
              var pos = e.getDocumentPosition();
              popup.selection.moveToPosition(pos);
              selectionMarker.start.row = selectionMarker.end.row = pos.row;
              e.stop();
            });
            var lastMouseEvent;
            var hoverMarker = new Range(-1, 0, -1, Infinity);
            var selectionMarker = new Range(-1, 0, -1, Infinity);
            selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
            popup.setSelectOnHover = function(val) {
              if (!val) {
                hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
              } else if (hoverMarker.id) {
                popup.session.removeMarker(hoverMarker.id);
                hoverMarker.id = null;
              }
            };
            popup.setSelectOnHover(false);
            popup.on("mousemove", function(e) {
              if (!lastMouseEvent) {
                lastMouseEvent = e;
                return;
              }
              if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {
                return;
              }
              lastMouseEvent = e;
              lastMouseEvent.scrollTop = popup.renderer.scrollTop;
              popup.isMouseOver = true;
              var row = lastMouseEvent.getDocumentPosition().row;
              if (hoverMarker.start.row != row) {
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row);
              }
            });
            popup.renderer.on("beforeRender", function() {
              if (lastMouseEvent && hoverMarker.start.row != -1) {
                lastMouseEvent.$pos = null;
                var row = lastMouseEvent.getDocumentPosition().row;
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row, true);
              }
            });
            popup.renderer.on("afterRender", function() {
              var t = popup.renderer.$textLayer;
              for (var row = t.config.firstRow, l = t.config.lastRow; row <= l; row++) {
                var popupRowElement = (
                  /** @type {HTMLElement|null} */
                  t.element.childNodes[row - t.config.firstRow]
                );
                popupRowElement.setAttribute("role", optionAriaRole);
                popupRowElement.setAttribute("aria-roledescription", nls("autocomplete.popup.item.aria-roledescription", "item"));
                popupRowElement.setAttribute("aria-setsize", popup.data.length);
                popupRowElement.setAttribute("aria-describedby", "doc-tooltip");
                popupRowElement.setAttribute("aria-posinset", row + 1);
                var rowData = popup.getData(row);
                if (rowData) {
                  var ariaLabel = "".concat(rowData.caption || rowData.value).concat(rowData.meta ? ", ".concat(rowData.meta) : "");
                  popupRowElement.setAttribute("aria-label", ariaLabel);
                }
                var highlightedSpans = popupRowElement.querySelectorAll(".ace_completion-highlight");
                highlightedSpans.forEach(function(span) {
                  span.setAttribute("role", "mark");
                });
              }
            });
            popup.renderer.on("afterRender", function() {
              var row = popup.getRow();
              var t = popup.renderer.$textLayer;
              var selected = (
                /** @type {HTMLElement|null} */
                t.element.childNodes[row - t.config.firstRow]
              );
              var el2 = document.activeElement;
              if (selected !== popup.selectedNode && popup.selectedNode) {
                dom.removeCssClass(popup.selectedNode, "ace_selected");
                popup.selectedNode.removeAttribute(ariaActiveState);
                popup.selectedNode.removeAttribute("id");
              }
              el2.removeAttribute("aria-activedescendant");
              popup.selectedNode = selected;
              if (selected) {
                var ariaId = getAriaId(row);
                dom.addCssClass(selected, "ace_selected");
                selected.id = ariaId;
                t.element.setAttribute("aria-activedescendant", ariaId);
                el2.setAttribute("aria-activedescendant", ariaId);
                selected.setAttribute(ariaActiveState, "true");
              }
            });
            var hideHoverMarker = function() {
              setHoverMarker(-1);
            };
            var setHoverMarker = function(row, suppressRedraw) {
              if (row !== hoverMarker.start.row) {
                hoverMarker.start.row = hoverMarker.end.row = row;
                if (!suppressRedraw)
                  popup.session._emit("changeBackMarker");
                popup._emit("changeHoverMarker");
              }
            };
            popup.getHoveredRow = function() {
              return hoverMarker.start.row;
            };
            event.addListener(popup.container, "mouseout", function() {
              popup.isMouseOver = false;
              hideHoverMarker();
            });
            popup.on("hide", hideHoverMarker);
            popup.on("changeSelection", hideHoverMarker);
            popup.session.doc.getLength = function() {
              return popup.data.length;
            };
            popup.session.doc.getLine = function(i) {
              var data = popup.data[i];
              if (typeof data == "string")
                return data;
              return data && data.value || "";
            };
            var bgTokenizer = popup.session.bgTokenizer;
            bgTokenizer.$tokenizeRow = function(row) {
              var data = popup.data[row];
              var tokens = [];
              if (!data)
                return tokens;
              if (typeof data == "string")
                data = { value: data };
              var caption = data.caption || data.value || data.name;
              function addToken(value, className) {
                value && tokens.push({
                  type: (data.className || "") + (className || ""),
                  value
                });
              }
              var lower = caption.toLowerCase();
              var filterText = (popup.filterText || "").toLowerCase();
              var lastIndex = 0;
              var lastI = 0;
              for (var i = 0; i <= filterText.length; i++) {
                if (i != lastI && (data.matchMask & 1 << i || i == filterText.length)) {
                  var sub = filterText.slice(lastI, i);
                  lastI = i;
                  var index = lower.indexOf(sub, lastIndex);
                  if (index == -1)
                    continue;
                  addToken(caption.slice(lastIndex, index), "");
                  lastIndex = index + sub.length;
                  addToken(caption.slice(index, lastIndex), "completion-highlight");
                }
              }
              addToken(caption.slice(lastIndex, caption.length), "");
              tokens.push({ type: "completion-spacer", value: " " });
              if (data.meta)
                tokens.push({ type: "completion-meta", value: data.meta });
              if (data.message)
                tokens.push({ type: "completion-message", value: data.message });
              return tokens;
            };
            bgTokenizer.$updateOnChange = noop;
            bgTokenizer.start = noop;
            popup.session.$computeWidth = function() {
              return this.screenWidth = 0;
            };
            popup.isOpen = false;
            popup.isTopdown = false;
            popup.autoSelect = true;
            popup.filterText = "";
            popup.isMouseOver = false;
            popup.data = [];
            popup.setData = function(list, filterText) {
              popup.filterText = filterText || "";
              popup.setValue(lang.stringRepeat("\n", list.length), -1);
              popup.data = list || [];
              popup.setRow(0);
            };
            popup.getData = function(row) {
              return popup.data[row];
            };
            popup.getRow = function() {
              return selectionMarker.start.row;
            };
            popup.setRow = function(line) {
              line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));
              if (selectionMarker.start.row != line) {
                popup.selection.clearSelection();
                selectionMarker.start.row = selectionMarker.end.row = line || 0;
                popup.session._emit("changeBackMarker");
                popup.moveCursorTo(line || 0, 0);
                if (popup.isOpen)
                  popup._signal("select");
              }
            };
            popup.on("changeSelection", function() {
              if (popup.isOpen)
                popup.setRow(popup.selection.lead.row);
              popup.renderer.scrollCursorIntoView();
            });
            popup.hide = function() {
              this.container.style.display = "none";
              popup.anchorPos = null;
              popup.anchor = null;
              if (popup.isOpen) {
                popup.isOpen = false;
                this._signal("hide");
              }
            };
            popup.tryShow = function(pos, lineHeight, anchor, forceShow) {
              if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor && popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left && popup.anchor === anchor) {
                return true;
              }
              var el2 = this.container;
              var scrollBarSize = this.renderer.scrollBar.width || 10;
              var screenHeight = window.innerHeight - scrollBarSize;
              var screenWidth = window.innerWidth - scrollBarSize;
              var renderer = this.renderer;
              var maxH = renderer.$maxLines * lineHeight * 1.4;
              var dims = { top: 0, bottom: 0, left: 0 };
              var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;
              var spaceAbove = pos.top - 3 * this.$borderSize;
              if (!anchor) {
                if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {
                  anchor = "bottom";
                } else {
                  anchor = "top";
                }
              }
              if (anchor === "top") {
                dims.bottom = pos.top - this.$borderSize;
                dims.top = dims.bottom - maxH;
              } else if (anchor === "bottom") {
                dims.top = pos.top + lineHeight + this.$borderSize;
                dims.bottom = dims.top + maxH;
              }
              var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;
              if (!forceShow && !fitsX) {
                return false;
              }
              if (!fitsX) {
                if (anchor === "top") {
                  renderer.$maxPixelHeight = spaceAbove;
                } else {
                  renderer.$maxPixelHeight = spaceBelow;
                }
              } else {
                renderer.$maxPixelHeight = null;
              }
              if (anchor === "top") {
                el2.style.top = "";
                el2.style.bottom = screenHeight + scrollBarSize - dims.bottom + "px";
                popup.isTopdown = false;
              } else {
                el2.style.top = dims.top + "px";
                el2.style.bottom = "";
                popup.isTopdown = true;
              }
              el2.style.display = "";
              var left = pos.left;
              if (left + el2.offsetWidth > screenWidth)
                left = screenWidth - el2.offsetWidth;
              el2.style.left = left + "px";
              el2.style.right = "";
              if (!popup.isOpen) {
                popup.isOpen = true;
                this._signal("show");
                lastMouseEvent = null;
              }
              popup.anchorPos = pos;
              popup.anchor = anchor;
              return true;
            };
            popup.show = function(pos, lineHeight, topdownOnly) {
              this.tryShow(pos, lineHeight, topdownOnly ? "bottom" : void 0, true);
            };
            popup.goTo = function(where) {
              var row = this.getRow();
              var max = this.session.getLength() - 1;
              switch (where) {
                case "up":
                  row = row <= 0 ? max : row - 1;
                  break;
                case "down":
                  row = row >= max ? -1 : row + 1;
                  break;
                case "start":
                  row = 0;
                  break;
                case "end":
                  row = max;
                  break;
              }
              this.setRow(row);
            };
            popup.getTextLeftOffset = function() {
              return this.$borderSize + this.renderer.$padding + this.$imageSize;
            };
            popup.$imageSize = 0;
            popup.$borderSize = 1;
            return popup;
          }
          return AcePopup2;
        }()
      );
      dom.importCssString('\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #CAD6FA;\n    z-index: 1;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #3a674e;\n}\n.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #abbffe;\n    margin-top: -1px;\n    background: rgba(233,233,253,0.4);\n    position: absolute;\n    z-index: 2;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid rgba(109, 150, 13, 0.8);\n    background: rgba(58, 103, 78, 0.62);\n}\n.ace_completion-meta {\n    opacity: 0.5;\n    margin-left: 0.9em;\n}\n.ace_completion-message {\n    margin-left: 0.9em;\n    color: blue;\n}\n.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #2d69c7;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #93ca12;\n}\n.ace_editor.ace_autocomplete {\n    width: 300px;\n    z-index: 200000;\n    border: 1px lightgray solid;\n    position: fixed;\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n    line-height: 1.4;\n    background: #fefefe;\n    color: #111;\n}\n.ace_dark.ace_editor.ace_autocomplete {\n    border: 1px #484747 solid;\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\n    line-height: 1.4;\n    background: #25282c;\n    color: #c1c1c1;\n}\n.ace_autocomplete .ace_text-layer  {\n    width: calc(100% - 8px);\n}\n.ace_autocomplete .ace_line {\n    display: flex;\n    align-items: center;\n}\n.ace_autocomplete .ace_line > * {\n    min-width: 0;\n    flex: 0 0 auto;\n}\n.ace_autocomplete .ace_line .ace_ {\n    flex: 0 1 auto;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.ace_autocomplete .ace_completion-spacer {\n    flex: 1;\n}\n.ace_autocomplete.ace_loading:after  {\n    content: "";\n    position: absolute;\n    top: 0px;\n    height: 2px;\n    width: 8%;\n    background: blue;\n    z-index: 100;\n    animation: ace_progress 3s infinite linear;\n    animation-delay: 300ms;\n    transform: translateX(-100%) scaleX(1);\n}\n@keyframes ace_progress {\n    0% { transform: translateX(-100%) scaleX(1) }\n    50% { transform: translateX(625%) scaleX(2) } \n    100% { transform: translateX(1500%) scaleX(3) } \n}\n@media (prefers-reduced-motion) {\n    .ace_autocomplete.ace_loading:after {\n        transform: translateX(625%) scaleX(2);\n        animation: none;\n     }\n}\n', "autocompletion.css", false);
      exports2.AcePopup = AcePopup;
      exports2.$singleLineEditor = $singleLineEditor;
      exports2.getAriaId = getAriaId;
    });
    ace.define("ace/snippets", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/range_list", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/clipboard", "ace/editor"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("./lib/dom");
      var oop = require3("./lib/oop");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var lang = require3("./lib/lang");
      var Range = require3("./range").Range;
      var RangeList = require3("./range_list").RangeList;
      var HashHandler = require3("./keyboard/hash_handler").HashHandler;
      var Tokenizer = require3("./tokenizer").Tokenizer;
      var clipboard = require3("./clipboard");
      var VARIABLES = {
        CURRENT_WORD: function(editor) {
          return editor.session.getTextRange(editor.session.getWordRange());
        },
        SELECTION: function(editor, name, indentation) {
          var text = editor.session.getTextRange();
          if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, "\n" + indentation + "$1");
          return text;
        },
        CURRENT_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row);
        },
        PREV_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row - 1);
        },
        LINE_INDEX: function(editor) {
          return editor.getCursorPosition().row;
        },
        LINE_NUMBER: function(editor) {
          return editor.getCursorPosition().row + 1;
        },
        SOFT_TABS: function(editor) {
          return editor.session.getUseSoftTabs() ? "YES" : "NO";
        },
        TAB_SIZE: function(editor) {
          return editor.session.getTabSize();
        },
        CLIPBOARD: function(editor) {
          return clipboard.getText && clipboard.getText();
        },
        FILENAME: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
        },
        FILENAME_BASE: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, "");
        },
        DIRECTORY: function(editor) {
          return this.FILEPATH(editor).replace(/[^/\\]*$/, "");
        },
        FILEPATH: function(editor) {
          return "/not implemented.txt";
        },
        WORKSPACE_NAME: function() {
          return "Unknown";
        },
        FULLNAME: function() {
          return "Unknown";
        },
        BLOCK_COMMENT_START: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.start || "";
        },
        BLOCK_COMMENT_END: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.end || "";
        },
        LINE_COMMENT: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.lineCommentStart || "";
        },
        CURRENT_YEAR: date.bind(null, { year: "numeric" }),
        CURRENT_YEAR_SHORT: date.bind(null, { year: "2-digit" }),
        CURRENT_MONTH: date.bind(null, { month: "numeric" }),
        CURRENT_MONTH_NAME: date.bind(null, { month: "long" }),
        CURRENT_MONTH_NAME_SHORT: date.bind(null, { month: "short" }),
        CURRENT_DATE: date.bind(null, { day: "2-digit" }),
        CURRENT_DAY_NAME: date.bind(null, { weekday: "long" }),
        CURRENT_DAY_NAME_SHORT: date.bind(null, { weekday: "short" }),
        CURRENT_HOUR: date.bind(null, { hour: "2-digit", hour12: false }),
        CURRENT_MINUTE: date.bind(null, { minute: "2-digit" }),
        CURRENT_SECOND: date.bind(null, { second: "2-digit" })
      };
      VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;
      function date(dateFormat) {
        var str = (/* @__PURE__ */ new Date()).toLocaleString("en-us", dateFormat);
        return str.length == 1 ? "0" + str : str;
      }
      var SnippetManager = (
        /** @class */
        function() {
          function SnippetManager2() {
            this.snippetMap = {};
            this.snippetNameMap = {};
            this.variables = VARIABLES;
          }
          SnippetManager2.prototype.getTokenizer = function() {
            return SnippetManager2["$tokenizer"] || this.createTokenizer();
          };
          SnippetManager2.prototype.createTokenizer = function() {
            function TabstopToken(str) {
              str = str.substr(1);
              if (/^\d+$/.test(str))
                return [{ tabstopId: parseInt(str, 10) }];
              return [{ text: str }];
            }
            function escape(ch) {
              return "(?:[^\\\\" + ch + "]|\\\\.)";
            }
            var formatMatcher = {
              regex: "/(" + escape("/") + "+)/",
              onMatch: function(val, state, stack) {
                var ts2 = stack[0];
                ts2.fmtString = true;
                ts2.guard = val.slice(1, -1);
                ts2.flag = "";
                return "";
              },
              next: "formatString"
            };
            SnippetManager2["$tokenizer"] = new Tokenizer({
              start: [
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length) {
                    val = ch;
                  } else if ("`$\\".indexOf(ch) != -1) {
                    val = ch;
                  }
                  return [val];
                } },
                { regex: /}/, onMatch: function(val, state, stack) {
                  return [stack.length ? stack.shift() : val];
                } },
                { regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken },
                { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                  var t = TabstopToken(str.substr(1));
                  stack.unshift(t[0]);
                  return t;
                }, next: "snippetVar" },
                { regex: /\n/, token: "newline", merge: false }
              ],
              snippetVar: [
                { regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                  var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function(operator) {
                    return operator.length == 2 ? operator[1] : "\0";
                  }).split("\0").map(function(value) {
                    return { value };
                  });
                  stack[0].choices = choices;
                  return [choices[0]];
                }, next: "start" },
                formatMatcher,
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start" }
              ],
              formatString: [
                { regex: /:/, onMatch: function(val, state, stack) {
                  if (stack.length && stack[0].expectElse) {
                    stack[0].expectElse = false;
                    stack[0].ifEnd = { elseEnd: stack[0] };
                    return [stack[0].ifEnd];
                  }
                  return ":";
                } },
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length)
                    val = ch;
                  else if ("`$\\".indexOf(ch) != -1)
                    val = ch;
                  else if (ch == "n")
                    val = "\n";
                  else if (ch == "t")
                    val = "	";
                  else if ("ulULE".indexOf(ch) != -1)
                    val = { changeCase: ch, local: ch > "a" };
                  return [val];
                } },
                { regex: "/\\w*}", onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  if (next)
                    next.flag = val.slice(1, -1);
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" },
                { regex: /\$(?:\d+|\w+)/, onMatch: function(val, state, stack) {
                  return [{ text: val.slice(1) }];
                } },
                { regex: /\${\w+/, onMatch: function(val, state, stack) {
                  var token = { text: val.slice(2) };
                  stack.unshift(token);
                  return [token];
                }, next: "formatStringVar" },
                { regex: /\n/, token: "newline", merge: false },
                { regex: /}/, onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" }
              ],
              formatStringVar: [
                { regex: /:\/\w+}/, onMatch: function(val, state, stack) {
                  var ts2 = stack[0];
                  ts2.formatFunction = val.slice(2, -1);
                  return [stack.shift()];
                }, next: "formatString" },
                formatMatcher,
                { regex: /:[\?\-+]?/, onMatch: function(val, state, stack) {
                  if (val[1] == "+")
                    stack[0].ifEnd = stack[0];
                  if (val[1] == "?")
                    stack[0].expectElse = true;
                }, next: "formatString" },
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString" }
              ]
            });
            return SnippetManager2["$tokenizer"];
          };
          SnippetManager2.prototype.tokenizeTmSnippet = function(str, startState) {
            return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {
              return x.value || x;
            });
          };
          SnippetManager2.prototype.getVariableValue = function(editor, name, indentation) {
            if (/^\d+$/.test(name))
              return (this.variables.__ || {})[name] || "";
            if (/^[A-Z]\d+$/.test(name))
              return (this.variables[name[0] + "__"] || {})[name.substr(1)] || "";
            name = name.replace(/^TM_/, "");
            if (!this.variables.hasOwnProperty(name))
              return "";
            var value = this.variables[name];
            if (typeof value == "function")
              value = this.variables[name](editor, name, indentation);
            return value == null ? "" : value;
          };
          SnippetManager2.prototype.tmStrFormat = function(str, ch, editor) {
            if (!ch.fmt)
              return str;
            var flag = ch.flag || "";
            var re3 = ch.guard;
            re3 = new RegExp(re3, flag.replace(/[^gim]/g, ""));
            var fmtTokens = typeof ch.fmt == "string" ? this.tokenizeTmSnippet(ch.fmt, "formatString") : ch.fmt;
            var _self = this;
            var formatted = str.replace(re3, function() {
              var oldArgs = _self.variables.__;
              _self.variables.__ = [].slice.call(arguments);
              var fmtParts = _self.resolveVariables(fmtTokens, editor);
              var gChangeCase = "E";
              for (var i = 0; i < fmtParts.length; i++) {
                var ch2 = fmtParts[i];
                if (typeof ch2 == "object") {
                  fmtParts[i] = "";
                  if (ch2.changeCase && ch2.local) {
                    var next = fmtParts[i + 1];
                    if (next && typeof next == "string") {
                      if (ch2.changeCase == "u")
                        fmtParts[i] = next[0].toUpperCase();
                      else
                        fmtParts[i] = next[0].toLowerCase();
                      fmtParts[i + 1] = next.substr(1);
                    }
                  } else if (ch2.changeCase) {
                    gChangeCase = ch2.changeCase;
                  }
                } else if (gChangeCase == "U") {
                  fmtParts[i] = ch2.toUpperCase();
                } else if (gChangeCase == "L") {
                  fmtParts[i] = ch2.toLowerCase();
                }
              }
              _self.variables.__ = oldArgs;
              return fmtParts.join("");
            });
            return formatted;
          };
          SnippetManager2.prototype.tmFormatFunction = function(str, ch, editor) {
            if (ch.formatFunction == "upcase")
              return str.toUpperCase();
            if (ch.formatFunction == "downcase")
              return str.toLowerCase();
            return str;
          };
          SnippetManager2.prototype.resolveVariables = function(snippet, editor) {
            var result = [];
            var indentation = "";
            var afterNewLine = true;
            for (var i = 0; i < snippet.length; i++) {
              var ch = snippet[i];
              if (typeof ch == "string") {
                result.push(ch);
                if (ch == "\n") {
                  afterNewLine = true;
                  indentation = "";
                } else if (afterNewLine) {
                  indentation = /^\t*/.exec(ch)[0];
                  afterNewLine = /\S/.test(ch);
                }
                continue;
              }
              if (!ch)
                continue;
              afterNewLine = false;
              if (ch.fmtString) {
                var j3 = snippet.indexOf(ch, i + 1);
                if (j3 == -1)
                  j3 = snippet.length;
                ch.fmt = snippet.slice(i + 1, j3);
                i = j3;
              }
              if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + "";
                if (ch.fmtString)
                  value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                  value = this.tmFormatFunction(value, ch, editor);
                if (value && !ch.ifEnd) {
                  result.push(value);
                  gotoNext(ch);
                } else if (!value && ch.ifEnd) {
                  gotoNext(ch.ifEnd);
                }
              } else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
              } else if (ch.tabstopId != null) {
                result.push(ch);
              } else if (ch.changeCase != null) {
                result.push(ch);
              }
            }
            function gotoNext(ch2) {
              var i1 = snippet.indexOf(ch2, i + 1);
              if (i1 != -1)
                i = i1;
            }
            return result;
          };
          SnippetManager2.prototype.getDisplayTextForSnippet = function(editor, snippetText) {
            var processedSnippet = processSnippetText.call(this, editor, snippetText);
            return processedSnippet.text;
          };
          SnippetManager2.prototype.insertSnippetForSelection = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var processedSnippet = processSnippetText.call(this, editor, snippetText, options);
            var range = editor.getSelectionRange();
            var end = editor.session.replace(range, processedSnippet.text);
            var tabstopManager = new TabstopManager(editor);
            var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
            tabstopManager.addTabstops(processedSnippet.tabstops, range.start, end, selectionId);
          };
          SnippetManager2.prototype.insertSnippet = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var self2 = this;
            if (editor.inVirtualSelectionMode)
              return self2.insertSnippetForSelection(editor, snippetText, options);
            editor.forEachSelection(function() {
              self2.insertSnippetForSelection(editor, snippetText, options);
            }, null, { keepOrder: true });
            if (editor.tabstopManager)
              editor.tabstopManager.tabNext();
          };
          SnippetManager2.prototype.$getScope = function(editor) {
            var scope = editor.session.$mode.$id || "";
            scope = scope.split("/").pop();
            if (scope === "html" || scope === "php") {
              if (scope === "php" && !editor.session.$mode.inlinePhp)
                scope = "html";
              var c = editor.getCursorPosition();
              var state = editor.session.getState(c.row);
              if (typeof state === "object") {
                state = state[0];
              }
              if (state.substring) {
                if (state.substring(0, 3) == "js-")
                  scope = "javascript";
                else if (state.substring(0, 4) == "css-")
                  scope = "css";
                else if (state.substring(0, 4) == "php-")
                  scope = "php";
              }
            }
            return scope;
          };
          SnippetManager2.prototype.getActiveScopes = function(editor) {
            var scope = this.$getScope(editor);
            var scopes = [scope];
            var snippetMap = this.snippetMap;
            if (snippetMap[scope] && snippetMap[scope].includeScopes) {
              scopes.push.apply(scopes, snippetMap[scope].includeScopes);
            }
            scopes.push("_");
            return scopes;
          };
          SnippetManager2.prototype.expandWithTab = function(editor, options) {
            var self2 = this;
            var result = editor.forEachSelection(function() {
              return self2.expandSnippetForSelection(editor, options);
            }, null, { keepOrder: true });
            if (result && editor.tabstopManager)
              editor.tabstopManager.tabNext();
            return result;
          };
          SnippetManager2.prototype.expandSnippetForSelection = function(editor, options) {
            var cursor = editor.getCursorPosition();
            var line = editor.session.getLine(cursor.row);
            var before = line.substring(0, cursor.column);
            var after = line.substr(cursor.column);
            var snippetMap = this.snippetMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
              return !!snippet;
            }, this);
            if (!snippet)
              return false;
            if (options && options.dryRun)
              return true;
            editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
            this.variables.M__ = snippet.matchBefore;
            this.variables.T__ = snippet.matchAfter;
            this.insertSnippetForSelection(editor, snippet.content);
            this.variables.M__ = this.variables.T__ = null;
            return true;
          };
          SnippetManager2.prototype.findMatchingSnippet = function(snippetList, before, after) {
            for (var i = snippetList.length; i--; ) {
              var s = snippetList[i];
              if (s.startRe && !s.startRe.test(before))
                continue;
              if (s.endRe && !s.endRe.test(after))
                continue;
              if (!s.startRe && !s.endRe)
                continue;
              s.matchBefore = s.startRe ? s.startRe.exec(before) : [""];
              s.matchAfter = s.endRe ? s.endRe.exec(after) : [""];
              s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : "";
              s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : "";
              return s;
            }
          };
          SnippetManager2.prototype.register = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            var self2 = this;
            if (!snippets)
              snippets = [];
            function wrapRegexp(src) {
              if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = "(?:" + src + ")";
              return src || "";
            }
            function guardedRegexp(re3, guard, opening) {
              re3 = wrapRegexp(re3);
              guard = wrapRegexp(guard);
              if (opening) {
                re3 = guard + re3;
                if (re3 && re3[re3.length - 1] != "$")
                  re3 = re3 + "$";
              } else {
                re3 = re3 + guard;
                if (re3 && re3[0] != "^")
                  re3 = "^" + re3;
              }
              return new RegExp(re3);
            }
            function addSnippet(s) {
              if (!s.scope)
                s.scope = scope || "_";
              scope = s.scope;
              if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
              }
              var map = snippetNameMap[scope];
              if (s.name) {
                var old = map[s.name];
                if (old)
                  self2.unregister(old);
                map[s.name] = s;
              }
              snippetMap[scope].push(s);
              if (s.prefix)
                s.tabTrigger = s.prefix;
              if (!s.content && s.body)
                s.content = Array.isArray(s.body) ? s.body.join("\n") : s.body;
              if (s.tabTrigger && !s.trigger) {
                if (!s.guard && /^\w/.test(s.tabTrigger))
                  s.guard = "\\b";
                s.trigger = lang.escapeRegExp(s.tabTrigger);
              }
              if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)
                return;
              s.startRe = guardedRegexp(s.trigger, s.guard, true);
              s.triggerRe = new RegExp(s.trigger);
              s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);
              s.endTriggerRe = new RegExp(s.endTrigger);
            }
            if (Array.isArray(snippets)) {
              snippets.forEach(addSnippet);
            } else {
              Object.keys(snippets).forEach(function(key) {
                addSnippet(snippets[key]);
              });
            }
            this._signal("registerSnippets", { scope });
          };
          SnippetManager2.prototype.unregister = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            function removeSnippet(s) {
              var nameMap = snippetNameMap[s.scope || scope];
              if (nameMap && nameMap[s.name]) {
                delete nameMap[s.name];
                var map = snippetMap[s.scope || scope];
                var i = map && map.indexOf(s);
                if (i >= 0)
                  map.splice(i, 1);
              }
            }
            if (snippets.content)
              removeSnippet(snippets);
            else if (Array.isArray(snippets))
              snippets.forEach(removeSnippet);
          };
          SnippetManager2.prototype.parseSnippetFile = function(str) {
            str = str.replace(/\r/g, "");
            var list = [], snippet = {};
            var re3 = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
            var m;
            while (m = re3.exec(str)) {
              if (m[1]) {
                try {
                  snippet = JSON.parse(m[1]);
                  list.push(snippet);
                } catch (e) {
                }
              }
              if (m[4]) {
                snippet.content = m[4].replace(/^\t/gm, "");
                list.push(snippet);
                snippet = {};
              } else {
                var key = m[2], val = m[3];
                if (key == "regex") {
                  var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                  snippet.guard = guardRe.exec(val)[1];
                  snippet.trigger = guardRe.exec(val)[1];
                  snippet.endTrigger = guardRe.exec(val)[1];
                  snippet.endGuard = guardRe.exec(val)[1];
                } else if (key == "snippet") {
                  snippet.tabTrigger = val.match(/^\S*/)[0];
                  if (!snippet.name)
                    snippet.name = val;
                } else if (key) {
                  snippet[key] = val;
                }
              }
            }
            return list;
          };
          SnippetManager2.prototype.getSnippetByName = function(name, editor) {
            var snippetMap = this.snippetNameMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = snippets[name];
              return !!snippet;
            }, this);
            return snippet;
          };
          return SnippetManager2;
        }()
      );
      oop.implement(SnippetManager.prototype, EventEmitter);
      var processSnippetText = function(editor, snippetText, options) {
        if (options === void 0) {
          options = {};
        }
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var tabString = editor.session.getTabString();
        var indentString = line.match(/^\s*/)[0];
        if (cursor.column < indentString.length)
          indentString = indentString.slice(0, cursor.column);
        snippetText = snippetText.replace(/\r/g, "");
        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function(x) {
          if (x == "\n" && !options.excludeExtraIndent)
            return x + indentString;
          if (typeof x == "string")
            return x.replace(/\t/g, tabString);
          return x;
        });
        var tabstops = [];
        tokens.forEach(function(p2, i2) {
          if (typeof p2 != "object")
            return;
          var id2 = p2.tabstopId;
          var ts3 = tabstops[id2];
          if (!ts3) {
            ts3 = tabstops[id2] = [];
            ts3.index = id2;
            ts3.value = "";
            ts3.parents = {};
          }
          if (ts3.indexOf(p2) !== -1)
            return;
          if (p2.choices && !ts3.choices)
            ts3.choices = p2.choices;
          ts3.push(p2);
          var i12 = tokens.indexOf(p2, i2 + 1);
          if (i12 === -1)
            return;
          var value2 = tokens.slice(i2 + 1, i12);
          var isNested = value2.some(function(t) {
            return typeof t === "object";
          });
          if (isNested && !ts3.value) {
            ts3.value = value2;
          } else if (value2.length && (!ts3.value || typeof ts3.value !== "string")) {
            ts3.value = value2.join("");
          }
        });
        tabstops.forEach(function(ts3) {
          ts3.length = 0;
        });
        var expanding = {};
        function copyValue(val) {
          var copy = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            var p2 = val[i2];
            if (typeof p2 == "object") {
              if (expanding[p2.tabstopId])
                continue;
              var j3 = val.lastIndexOf(p2, i2 - 1);
              p2 = copy[j3] || { tabstopId: p2.tabstopId };
            }
            copy[i2] = p2;
          }
          return copy;
        }
        for (var i = 0; i < tokens.length; i++) {
          var p = tokens[i];
          if (typeof p != "object")
            continue;
          var id = p.tabstopId;
          var ts2 = tabstops[id];
          var i1 = tokens.indexOf(p, i + 1);
          if (expanding[id]) {
            if (expanding[id] === p) {
              delete expanding[id];
              Object.keys(expanding).forEach(function(parentId) {
                ts2.parents[parentId] = true;
              });
            }
            continue;
          }
          expanding[id] = p;
          var value = ts2.value;
          if (typeof value !== "string")
            value = copyValue(value);
          else if (p.fmt)
            value = this.tmStrFormat(value, p, editor);
          tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));
          if (ts2.indexOf(p) === -1)
            ts2.push(p);
        }
        var row = 0, column = 0;
        var text = "";
        tokens.forEach(function(t) {
          if (typeof t === "string") {
            var lines = t.split("\n");
            if (lines.length > 1) {
              column = lines[lines.length - 1].length;
              row += lines.length - 1;
            } else
              column += t.length;
            text += t;
          } else if (t) {
            if (!t.start)
              t.start = { row, column };
            else
              t.end = { row, column };
          }
        });
        return {
          text,
          tabstops,
          tokens
        };
      };
      var TabstopManager = (
        /** @class */
        function() {
          function TabstopManager2(editor) {
            this.index = 0;
            this.ranges = [];
            this.tabstops = [];
            if (editor.tabstopManager)
              return editor.tabstopManager;
            editor.tabstopManager = this;
            this.$onChange = this.onChange.bind(this);
            this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
            this.$onChangeSession = this.onChangeSession.bind(this);
            this.$onAfterExec = this.onAfterExec.bind(this);
            this.attach(editor);
          }
          TabstopManager2.prototype.attach = function(editor) {
            this.$openTabstops = null;
            this.selectedTabstop = null;
            this.editor = editor;
            this.session = editor.session;
            this.editor.on("change", this.$onChange);
            this.editor.on("changeSelection", this.$onChangeSelection);
            this.editor.on("changeSession", this.$onChangeSession);
            this.editor.commands.on("afterExec", this.$onAfterExec);
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
          };
          TabstopManager2.prototype.detach = function() {
            this.tabstops.forEach(this.removeTabstopMarkers, this);
            this.ranges.length = 0;
            this.tabstops.length = 0;
            this.selectedTabstop = null;
            this.editor.off("change", this.$onChange);
            this.editor.off("changeSelection", this.$onChangeSelection);
            this.editor.off("changeSession", this.$onChangeSession);
            this.editor.commands.off("afterExec", this.$onAfterExec);
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.tabstopManager = null;
            this.session = null;
            this.editor = null;
          };
          TabstopManager2.prototype.onChange = function(delta) {
            var isRemove = delta.action[0] == "r";
            var selectedTabstop = this.selectedTabstop || {};
            var parents = selectedTabstop.parents || {};
            var tabstops = this.tabstops.slice();
            for (var i = 0; i < tabstops.length; i++) {
              var ts2 = tabstops[i];
              var active = ts2 == selectedTabstop || parents[ts2.index];
              ts2.rangeList.$bias = active ? 0 : 1;
              if (delta.action == "remove" && ts2 !== selectedTabstop) {
                var parentActive = ts2.parents && ts2.parents[selectedTabstop.index];
                var startIndex = ts2.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts2.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts2.rangeList.ranges.slice(startIndex, endIndex);
                for (var j3 = 0; j3 < toRemove.length; j3++)
                  this.removeRange(toRemove[j3]);
              }
              ts2.rangeList.$onChange(delta);
            }
            var session = this.session;
            if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())
              this.detach();
          };
          TabstopManager2.prototype.updateLinkedFields = function() {
            var ts2 = this.selectedTabstop;
            if (!ts2 || !ts2.hasLinkedRanges || !ts2.firstNonLinked)
              return;
            this.$inChange = true;
            var session = this.session;
            var text = session.getTextRange(ts2.firstNonLinked);
            for (var i = 0; i < ts2.length; i++) {
              var range = ts2[i];
              if (!range.linked)
                continue;
              var original = range.original;
              var fmt = exports2.snippetManager.tmStrFormat(text, original, this.editor);
              session.replace(range, fmt);
            }
            this.$inChange = false;
          };
          TabstopManager2.prototype.onAfterExec = function(e) {
            if (e.command && !e.command.readOnly)
              this.updateLinkedFields();
          };
          TabstopManager2.prototype.onChangeSelection = function() {
            if (!this.editor)
              return;
            var lead = this.editor.selection.lead;
            var anchor = this.editor.selection.anchor;
            var isEmpty = this.editor.selection.isEmpty();
            for (var i = 0; i < this.ranges.length; i++) {
              if (this.ranges[i].linked)
                continue;
              var containsLead = this.ranges[i].contains(lead.row, lead.column);
              var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);
              if (containsLead && containsAnchor)
                return;
            }
            this.detach();
          };
          TabstopManager2.prototype.onChangeSession = function() {
            this.detach();
          };
          TabstopManager2.prototype.tabNext = function(dir) {
            var max = this.tabstops.length;
            var index = this.index + (dir || 1);
            index = Math.min(Math.max(index, 1), max);
            if (index == max)
              index = 0;
            this.selectTabstop(index);
            this.updateTabstopMarkers();
            if (index === 0) {
              this.detach();
            }
          };
          TabstopManager2.prototype.selectTabstop = function(index) {
            this.$openTabstops = null;
            var ts2 = this.tabstops[this.index];
            if (ts2)
              this.addTabstopMarkers(ts2);
            this.index = index;
            ts2 = this.tabstops[this.index];
            if (!ts2 || !ts2.length)
              return;
            this.selectedTabstop = ts2;
            var range = ts2.firstNonLinked || ts2;
            if (ts2.choices)
              range.cursor = range.start;
            if (!this.editor.inVirtualSelectionMode) {
              var sel = this.editor.multiSelect;
              sel.toSingleRange(range);
              for (var i = 0; i < ts2.length; i++) {
                if (ts2.hasLinkedRanges && ts2[i].linked)
                  continue;
                sel.addRange(ts2[i].clone(), true);
              }
            } else {
              this.editor.selection.fromOrientedRange(range);
            }
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            if (this.selectedTabstop && this.selectedTabstop.choices)
              this.editor.execCommand("startAutocomplete", { matches: this.selectedTabstop.choices });
          };
          TabstopManager2.prototype.addTabstops = function(tabstops, start, end) {
            var useLink = this.useLink || !this.editor.getOption("enableMultiselect");
            if (!this.$openTabstops)
              this.$openTabstops = [];
            if (!tabstops[0]) {
              var p = Range.fromPoints(end, end);
              moveRelative(p.start, start);
              moveRelative(p.end, start);
              tabstops[0] = [p];
              tabstops[0].index = 0;
            }
            var i = this.index;
            var arg = [i + 1, 0];
            var ranges = this.ranges;
            var snippetId = this.snippetId = (this.snippetId || 0) + 1;
            tabstops.forEach(function(ts2, index) {
              var dest = this.$openTabstops[index] || ts2;
              dest.snippetId = snippetId;
              for (var i2 = 0; i2 < ts2.length; i2++) {
                var p2 = ts2[i2];
                var range = Range.fromPoints(p2.start, p2.end || p2.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p2;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts2)
                  dest.unshift(range);
                else
                  dest[i2] = range;
                if (p2.fmtString || dest.firstNonLinked && useLink) {
                  range.linked = true;
                  dest.hasLinkedRanges = true;
                } else if (!dest.firstNonLinked)
                  dest.firstNonLinked = range;
              }
              if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
              if (dest === ts2) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
              }
              this.addTabstopMarkers(dest);
              dest.rangeList = dest.rangeList || new RangeList();
              dest.rangeList.$bias = 0;
              dest.rangeList.addList(dest);
            }, this);
            if (arg.length > 2) {
              if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
              this.tabstops.splice.apply(this.tabstops, arg);
            }
          };
          TabstopManager2.prototype.addTabstopMarkers = function(ts2) {
            var session = this.session;
            ts2.forEach(function(range) {
              if (!range.markerId)
                range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
            });
          };
          TabstopManager2.prototype.removeTabstopMarkers = function(ts2) {
            var session = this.session;
            ts2.forEach(function(range) {
              session.removeMarker(range.markerId);
              range.markerId = null;
            });
          };
          TabstopManager2.prototype.updateTabstopMarkers = function() {
            if (!this.selectedTabstop)
              return;
            var currentSnippetId = this.selectedTabstop.snippetId;
            if (this.selectedTabstop.index === 0) {
              currentSnippetId--;
            }
            this.tabstops.forEach(function(ts2) {
              if (ts2.snippetId === currentSnippetId)
                this.addTabstopMarkers(ts2);
              else
                this.removeTabstopMarkers(ts2);
            }, this);
          };
          TabstopManager2.prototype.removeRange = function(range) {
            var i = range.tabstop.indexOf(range);
            if (i != -1)
              range.tabstop.splice(i, 1);
            i = this.ranges.indexOf(range);
            if (i != -1)
              this.ranges.splice(i, 1);
            i = range.tabstop.rangeList.ranges.indexOf(range);
            if (i != -1)
              range.tabstop.splice(i, 1);
            this.session.removeMarker(range.markerId);
            if (!range.tabstop.length) {
              i = this.tabstops.indexOf(range.tabstop);
              if (i != -1)
                this.tabstops.splice(i, 1);
              if (!this.tabstops.length)
                this.detach();
            }
          };
          return TabstopManager2;
        }()
      );
      TabstopManager.prototype.keyboardHandler = new HashHandler();
      TabstopManager.prototype.keyboardHandler.bindKeys({
        "Tab": function(editor) {
          if (exports2.snippetManager && exports2.snippetManager.expandWithTab(editor))
            return;
          editor.tabstopManager.tabNext(1);
          editor.renderer.scrollCursorIntoView();
        },
        "Shift-Tab": function(editor) {
          editor.tabstopManager.tabNext(-1);
          editor.renderer.scrollCursorIntoView();
        },
        "Esc": function(editor) {
          editor.tabstopManager.detach();
        }
      });
      var movePoint = function(point, diff) {
        if (point.row == 0)
          point.column += diff.column;
        point.row += diff.row;
      };
      var moveRelative = function(point, start) {
        if (point.row == start.row)
          point.column -= start.column;
        point.row -= start.row;
      };
      dom.importCssString("\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}", "snippets.css", false);
      exports2.snippetManager = new SnippetManager();
      var Editor = require3("./editor").Editor;
      (function() {
        this.insertSnippet = function(content, options) {
          return exports2.snippetManager.insertSnippet(this, content, options);
        };
        this.expandSnippet = function(options) {
          return exports2.snippetManager.expandWithTab(this, options);
        };
      }).call(Editor.prototype);
    });
    ace.define("ace/autocomplete/inline_screenreader", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var AceInlineScreenReader = (
        /** @class */
        function() {
          function AceInlineScreenReader2(editor) {
            this.editor = editor;
            this.screenReaderDiv = document.createElement("div");
            this.screenReaderDiv.classList.add("ace_screenreader-only");
            this.editor.container.appendChild(this.screenReaderDiv);
          }
          AceInlineScreenReader2.prototype.setScreenReaderContent = function(content) {
            if (!this.popup && this.editor.completer && /**@type{import("../autocomplete").Autocomplete}*/
            this.editor.completer.popup) {
              this.popup = /**@type{import("../autocomplete").Autocomplete}*/
              this.editor.completer.popup;
              this.popup.renderer.on("afterRender", function() {
                var row = this.popup.getRow();
                var t = this.popup.renderer.$textLayer;
                var selected = t.element.childNodes[row - t.config.firstRow];
                if (selected) {
                  var idString = "doc-tooltip ";
                  for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
                    idString += "ace-inline-screenreader-line-".concat(lineIndex, " ");
                  }
                  selected.setAttribute("aria-describedby", idString);
                }
              }.bind(this));
            }
            while (this.screenReaderDiv.firstChild) {
              this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);
            }
            this._lines = content.split(/\r\n|\r|\n/);
            var codeElement = this.createCodeBlock();
            this.screenReaderDiv.appendChild(codeElement);
          };
          AceInlineScreenReader2.prototype.destroy = function() {
            this.screenReaderDiv.remove();
          };
          AceInlineScreenReader2.prototype.createCodeBlock = function() {
            var container = document.createElement("pre");
            container.setAttribute("id", "ace-inline-screenreader");
            for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
              var codeElement = document.createElement("code");
              codeElement.setAttribute("id", "ace-inline-screenreader-line-".concat(lineIndex));
              var line = document.createTextNode(this._lines[lineIndex]);
              codeElement.appendChild(line);
              container.appendChild(codeElement);
            }
            return container;
          };
          return AceInlineScreenReader2;
        }()
      );
      exports2.AceInlineScreenReader = AceInlineScreenReader;
    });
    ace.define("ace/autocomplete/inline", ["require", "exports", "module", "ace/snippets", "ace/autocomplete/inline_screenreader"], function(require3, exports2, module3) {
      "use strict";
      var snippetManager = require3("../snippets").snippetManager;
      var AceInlineScreenReader = require3("./inline_screenreader").AceInlineScreenReader;
      var AceInline = (
        /** @class */
        function() {
          function AceInline2() {
            this.editor = null;
          }
          AceInline2.prototype.show = function(editor, completion, prefix) {
            prefix = prefix || "";
            if (editor && this.editor && this.editor !== editor) {
              this.hide();
              this.editor = null;
              this.inlineScreenReader = null;
            }
            if (!editor || !completion) {
              return false;
            }
            if (!this.inlineScreenReader) {
              this.inlineScreenReader = new AceInlineScreenReader(editor);
            }
            var displayText = completion.snippet ? snippetManager.getDisplayTextForSnippet(editor, completion.snippet) : completion.value;
            if (completion.hideInlinePreview || !displayText || !displayText.startsWith(prefix)) {
              return false;
            }
            this.editor = editor;
            this.inlineScreenReader.setScreenReaderContent(displayText);
            displayText = displayText.slice(prefix.length);
            if (displayText === "") {
              editor.removeGhostText();
            } else {
              editor.setGhostText(displayText);
            }
            return true;
          };
          AceInline2.prototype.isOpen = function() {
            if (!this.editor) {
              return false;
            }
            return !!this.editor.renderer.$ghostText;
          };
          AceInline2.prototype.hide = function() {
            if (!this.editor) {
              return false;
            }
            this.editor.removeGhostText();
            return true;
          };
          AceInline2.prototype.destroy = function() {
            this.hide();
            this.editor = null;
            if (this.inlineScreenReader) {
              this.inlineScreenReader.destroy();
              this.inlineScreenReader = null;
            }
          };
          return AceInline2;
        }()
      );
      exports2.AceInline = AceInline;
    });
    ace.define("ace/autocomplete/util", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      exports2.parForEach = function(array, fn3, callback) {
        var completed = 0;
        var arLength = array.length;
        if (arLength === 0)
          callback();
        for (var i = 0; i < arLength; i++) {
          fn3(array[i], function(result, err) {
            completed++;
            if (completed === arLength)
              callback(result, err);
          });
        }
      };
      var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
      exports2.retrievePrecedingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos - 1; i >= 0; i--) {
          if (regex.test(text[i]))
            buf.push(text[i]);
          else
            break;
        }
        return buf.reverse().join("");
      };
      exports2.retrieveFollowingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i = pos; i < text.length; i++) {
          if (regex.test(text[i]))
            buf.push(text[i]);
          else
            break;
        }
        return buf;
      };
      exports2.getCompletionPrefix = function(editor) {
        var pos = editor.getCursorPosition();
        var line = editor.session.getLine(pos.row);
        var prefix;
        editor.completers.forEach(function(completer) {
          if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach(function(identifierRegex) {
              if (!prefix && identifierRegex)
                prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }.bind(this));
          }
        }.bind(this));
        return prefix || this.retrievePrecedingIdentifier(line, pos.column);
      };
      exports2.triggerAutocomplete = function(editor, previousChar) {
        var previousChar = previousChar == null ? editor.session.getPrecedingCharacter() : previousChar;
        return editor.completers.some(function(completer) {
          if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {
            return completer.triggerCharacters.includes(previousChar);
          }
        });
      };
    });
    ace.define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/inline", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/lang", "ace/lib/dom", "ace/snippets", "ace/config", "ace/lib/event", "ace/lib/scroll"], function(require3, exports2, module3) {
      "use strict";
      var HashHandler = require3("./keyboard/hash_handler").HashHandler;
      var AcePopup = require3("./autocomplete/popup").AcePopup;
      var AceInline = require3("./autocomplete/inline").AceInline;
      var getAriaId = require3("./autocomplete/popup").getAriaId;
      var util = require3("./autocomplete/util");
      var lang = require3("./lib/lang");
      var dom = require3("./lib/dom");
      var snippetManager = require3("./snippets").snippetManager;
      var config = require3("./config");
      var event = require3("./lib/event");
      var preventParentScroll = require3("./lib/scroll").preventParentScroll;
      var destroyCompleter = function(e, editor) {
        editor.completer && editor.completer.destroy();
      };
      var Autocomplete = (
        /** @class */
        function() {
          function Autocomplete2() {
            this.autoInsert = false;
            this.autoSelect = true;
            this.autoShown = false;
            this.exactMatch = false;
            this.inlineEnabled = false;
            this.keyboardHandler = new HashHandler();
            this.keyboardHandler.bindKeys(this.commands);
            this.parentNode = null;
            this.setSelectOnHover = false;
            this.hasSeen = /* @__PURE__ */ new Set();
            this.showLoadingState = false;
            this.stickySelectionDelay = 500;
            this.blurListener = this.blurListener.bind(this);
            this.changeListener = this.changeListener.bind(this);
            this.mousedownListener = this.mousedownListener.bind(this);
            this.mousewheelListener = this.mousewheelListener.bind(this);
            this.onLayoutChange = this.onLayoutChange.bind(this);
            this.changeTimer = lang.delayedCall(function() {
              this.updateCompletions(true);
            }.bind(this));
            this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
            this.popupTimer = lang.delayedCall(this.$updatePopupPosition.bind(this), 50);
            this.stickySelectionTimer = lang.delayedCall(function() {
              this.stickySelection = true;
            }.bind(this), this.stickySelectionDelay);
            this.$firstOpenTimer = lang.delayedCall(
              /**@this{Autocomplete}*/
              function() {
                var initialPosition = this.completionProvider && this.completionProvider.initialPosition;
                if (this.autoShown || this.popup && this.popup.isOpen || !initialPosition || this.editor.completers.length === 0)
                  return;
                this.completions = new FilteredList(Autocomplete2.completionsForLoading);
                this.openPopup(this.editor, initialPosition.prefix, false);
                this.popup.renderer.setStyle("ace_loading", true);
              }.bind(this),
              this.stickySelectionDelay
            );
          }
          Object.defineProperty(Autocomplete2, "completionsForLoading", {
            get: function() {
              return [{
                caption: config.nls("autocomplete.loading", "Loading..."),
                value: ""
              }];
            },
            enumerable: false,
            configurable: true
          });
          Autocomplete2.prototype.$init = function() {
            this.popup = new AcePopup(this.parentNode || document.body || document.documentElement);
            this.popup.on("click", function(e) {
              this.insertMatch();
              e.stop();
            }.bind(this));
            this.popup.focus = this.editor.focus.bind(this.editor);
            this.popup.on("show", this.$onPopupShow.bind(this));
            this.popup.on("hide", this.$onHidePopup.bind(this));
            this.popup.on("select", this.$onPopupChange.bind(this));
            event.addListener(this.popup.container, "mouseout", this.mouseOutListener.bind(this));
            this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
            this.popup.renderer.on("afterRender", this.$onPopupRender.bind(this));
            return this.popup;
          };
          Autocomplete2.prototype.$initInline = function() {
            if (!this.inlineEnabled || this.inlineRenderer)
              return;
            this.inlineRenderer = new AceInline();
            return this.inlineRenderer;
          };
          Autocomplete2.prototype.getPopup = function() {
            return this.popup || this.$init();
          };
          Autocomplete2.prototype.$onHidePopup = function() {
            if (this.inlineRenderer) {
              this.inlineRenderer.hide();
            }
            this.hideDocTooltip();
            this.stickySelectionTimer.cancel();
            this.popupTimer.cancel();
            this.stickySelection = false;
          };
          Autocomplete2.prototype.$seen = function(completion) {
            if (!this.hasSeen.has(completion) && completion && completion.completer && completion.completer.onSeen && typeof completion.completer.onSeen === "function") {
              completion.completer.onSeen(this.editor, completion);
              this.hasSeen.add(completion);
            }
          };
          Autocomplete2.prototype.$onPopupChange = function(hide) {
            if (this.inlineRenderer && this.inlineEnabled) {
              var completion = hide ? null : this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
              if (this.popup.isMouseOver && this.setSelectOnHover) {
                this.tooltipTimer.call(null, null);
                return;
              }
              this.popupTimer.schedule();
              this.tooltipTimer.schedule();
            } else {
              this.popupTimer.call(null, null);
              this.tooltipTimer.call(null, null);
            }
          };
          Autocomplete2.prototype.$updateGhostText = function(completion) {
            var row = this.base.row;
            var column = this.base.column;
            var cursorColumn = this.editor.getCursorPosition().column;
            var prefix = this.editor.session.getLine(row).slice(column, cursorColumn);
            if (!this.inlineRenderer.show(this.editor, completion, prefix)) {
              this.inlineRenderer.hide();
            } else {
              this.$seen(completion);
            }
          };
          Autocomplete2.prototype.$onPopupRender = function() {
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (this.completions && this.completions.filtered && this.completions.filtered.length > 0) {
              for (var i = this.popup.getFirstVisibleRow(); i <= this.popup.getLastVisibleRow(); i++) {
                var completion = this.popup.getData(i);
                if (completion && (!inlineEnabled || completion.hideInlinePreview)) {
                  this.$seen(completion);
                }
              }
            }
          };
          Autocomplete2.prototype.$onPopupShow = function(hide) {
            this.$onPopupChange(hide);
            this.stickySelection = false;
            if (this.stickySelectionDelay >= 0)
              this.stickySelectionTimer.schedule(this.stickySelectionDelay);
          };
          Autocomplete2.prototype.observeLayoutChanges = function() {
            if (this.$elements || !this.editor)
              return;
            window.addEventListener("resize", this.onLayoutChange, { passive: true });
            window.addEventListener("wheel", this.mousewheelListener);
            var el = this.editor.container.parentNode;
            var elements = [];
            while (el) {
              elements.push(el);
              el.addEventListener("scroll", this.onLayoutChange, { passive: true });
              el = el.parentNode;
            }
            this.$elements = elements;
          };
          Autocomplete2.prototype.unObserveLayoutChanges = function() {
            var _this = this;
            window.removeEventListener("resize", this.onLayoutChange, { passive: true });
            window.removeEventListener("wheel", this.mousewheelListener);
            this.$elements && this.$elements.forEach(function(el) {
              el.removeEventListener("scroll", _this.onLayoutChange, { passive: true });
            });
            this.$elements = null;
          };
          Autocomplete2.prototype.onLayoutChange = function() {
            if (!this.popup.isOpen)
              return this.unObserveLayoutChanges();
            this.$updatePopupPosition();
            this.updateDocTooltip();
          };
          Autocomplete2.prototype.$updatePopupPosition = function() {
            var editor = this.editor;
            var renderer = editor.renderer;
            var lineHeight = renderer.layerConfig.lineHeight;
            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
            pos.left -= this.popup.getTextLeftOffset();
            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += renderer.gutterWidth;
            var posGhostText = {
              top: pos.top,
              left: pos.left
            };
            if (renderer.$ghostText && renderer.$ghostTextWidget) {
              if (this.base.row === renderer.$ghostText.position.row) {
                posGhostText.top += renderer.$ghostTextWidget.el.offsetHeight;
              }
            }
            var editorContainerBottom = editor.container.getBoundingClientRect().bottom - lineHeight;
            var lowestPosition = editorContainerBottom < posGhostText.top ? { top: editorContainerBottom, left: posGhostText.left } : posGhostText;
            if (this.popup.tryShow(lowestPosition, lineHeight, "bottom")) {
              return;
            }
            if (this.popup.tryShow(pos, lineHeight, "top")) {
              return;
            }
            this.popup.show(pos, lineHeight);
          };
          Autocomplete2.prototype.openPopup = function(editor, prefix, keepPopupPosition) {
            this.$firstOpenTimer.cancel();
            if (!this.popup)
              this.$init();
            if (this.inlineEnabled && !this.inlineRenderer)
              this.$initInline();
            this.popup.autoSelect = this.autoSelect;
            this.popup.setSelectOnHover(this.setSelectOnHover);
            var oldRow = this.popup.getRow();
            var previousSelectedItem = this.popup.data[oldRow];
            this.popup.setData(this.completions.filtered, this.completions.filterText);
            if (this.editor.textInput.setAriaOptions) {
              this.editor.textInput.setAriaOptions({
                activeDescendant: getAriaId(this.popup.getRow()),
                inline: this.inlineEnabled
              });
            }
            editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            var newRow;
            if (this.stickySelection)
              newRow = this.popup.data.indexOf(previousSelectedItem);
            if (!newRow || newRow === -1)
              newRow = 0;
            this.popup.setRow(this.autoSelect ? newRow : -1);
            if (newRow === oldRow && previousSelectedItem !== this.completions.filtered[newRow])
              this.$onPopupChange();
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (newRow === oldRow && inlineEnabled) {
              var completion = this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
            }
            if (!keepPopupPosition) {
              this.popup.setTheme(editor.getTheme());
              this.popup.setFontSize(editor.getFontSize());
              this.$updatePopupPosition();
              if (this.tooltipNode) {
                this.updateDocTooltip();
              }
            }
            this.changeTimer.cancel();
            this.observeLayoutChanges();
          };
          Autocomplete2.prototype.detach = function() {
            if (this.editor) {
              this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
              this.editor.off("changeSelection", this.changeListener);
              this.editor.off("blur", this.blurListener);
              this.editor.off("mousedown", this.mousedownListener);
              this.editor.off("mousewheel", this.mousewheelListener);
            }
            this.$firstOpenTimer.cancel();
            this.changeTimer.cancel();
            this.hideDocTooltip();
            if (this.completionProvider) {
              this.completionProvider.detach();
            }
            if (this.popup && this.popup.isOpen)
              this.popup.hide();
            if (this.popup && this.popup.renderer) {
              this.popup.renderer.off("afterRender", this.$onPopupRender);
            }
            if (this.base)
              this.base.detach();
            this.activated = false;
            this.completionProvider = this.completions = this.base = null;
            this.unObserveLayoutChanges();
          };
          Autocomplete2.prototype.changeListener = function(e) {
            var cursor = this.editor.selection.lead;
            if (cursor.row != this.base.row || cursor.column < this.base.column) {
              this.detach();
            }
            if (this.activated)
              this.changeTimer.schedule();
            else
              this.detach();
          };
          Autocomplete2.prototype.blurListener = function(e) {
            var el = document.activeElement;
            var text = this.editor.textInput.getElement();
            var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);
            var container = this.popup && this.popup.container;
            if (el != text && el.parentNode != container && !fromTooltip && el != this.tooltipNode && e.relatedTarget != text) {
              this.detach();
            }
          };
          Autocomplete2.prototype.mousedownListener = function(e) {
            this.detach();
          };
          Autocomplete2.prototype.mousewheelListener = function(e) {
            if (this.popup && !this.popup.isMouseOver)
              this.detach();
          };
          Autocomplete2.prototype.mouseOutListener = function(e) {
            if (this.popup.isOpen)
              this.$updatePopupPosition();
          };
          Autocomplete2.prototype.goTo = function(where) {
            this.popup.goTo(where);
          };
          Autocomplete2.prototype.insertMatch = function(data, options) {
            if (!data)
              data = this.popup.getData(this.popup.getRow());
            if (!data)
              return false;
            if (data.value === "")
              return this.detach();
            var completions = this.completions;
            var result = this.getCompletionProvider().insertMatch(this.editor, data, completions.filterText, options);
            if (this.completions == completions)
              this.detach();
            return result;
          };
          Autocomplete2.prototype.showPopup = function(editor, options) {
            if (this.editor)
              this.detach();
            this.activated = true;
            this.editor = editor;
            if (editor.completer != this) {
              if (editor.completer)
                editor.completer.detach();
              editor.completer = this;
            }
            editor.on("changeSelection", this.changeListener);
            editor.on("blur", this.blurListener);
            editor.on("mousedown", this.mousedownListener);
            editor.on("mousewheel", this.mousewheelListener);
            this.updateCompletions(false, options);
          };
          Autocomplete2.prototype.getCompletionProvider = function(initialPosition) {
            if (!this.completionProvider)
              this.completionProvider = new CompletionProvider(initialPosition);
            return this.completionProvider;
          };
          Autocomplete2.prototype.gatherCompletions = function(editor, callback) {
            return this.getCompletionProvider().gatherCompletions(editor, callback);
          };
          Autocomplete2.prototype.updateCompletions = function(keepPopupPosition, options) {
            if (keepPopupPosition && this.base && this.completions) {
              var pos = this.editor.getCursorPosition();
              var prefix = this.editor.session.getTextRange({ start: this.base, end: pos });
              if (prefix == this.completions.filterText)
                return;
              this.completions.setFilter(prefix);
              if (!this.completions.filtered.length)
                return this.detach();
              if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == prefix && !this.completions.filtered[0].snippet)
                return this.detach();
              this.openPopup(this.editor, prefix, keepPopupPosition);
              return;
            }
            if (options && options.matches) {
              var pos = this.editor.getSelectionRange().start;
              this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
              this.base.$insertRight = true;
              this.completions = new FilteredList(options.matches);
              this.getCompletionProvider().completions = this.completions;
              return this.openPopup(this.editor, "", keepPopupPosition);
            }
            var session = this.editor.getSession();
            var pos = this.editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(this.editor);
            this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
            this.base.$insertRight = true;
            var completionOptions = {
              exactMatch: this.exactMatch,
              ignoreCaption: this.ignoreCaption
            };
            this.getCompletionProvider({
              prefix,
              pos
            }).provideCompletions(
              this.editor,
              completionOptions,
              function(err, completions, finished) {
                var filtered = completions.filtered;
                var prefix2 = util.getCompletionPrefix(this.editor);
                this.$firstOpenTimer.cancel();
                if (finished) {
                  if (!filtered.length) {
                    var emptyMessage = !this.autoShown && this.emptyMessage;
                    if (typeof emptyMessage == "function")
                      emptyMessage = this.emptyMessage(prefix2);
                    if (emptyMessage) {
                      var completionsForEmpty = [
                        {
                          caption: emptyMessage,
                          value: ""
                        }
                      ];
                      this.completions = new FilteredList(completionsForEmpty);
                      this.openPopup(this.editor, prefix2, keepPopupPosition);
                      this.popup.renderer.setStyle("ace_loading", false);
                      this.popup.renderer.setStyle("ace_empty-message", true);
                      return;
                    }
                    return this.detach();
                  }
                  if (filtered.length == 1 && filtered[0].value == prefix2 && !filtered[0].snippet)
                    return this.detach();
                  if (this.autoInsert && !this.autoShown && filtered.length == 1)
                    return this.insertMatch(filtered[0]);
                }
                this.completions = !finished && this.showLoadingState ? new FilteredList(Autocomplete2.completionsForLoading.concat(filtered), completions.filterText) : completions;
                this.openPopup(this.editor, prefix2, keepPopupPosition);
                this.popup.renderer.setStyle("ace_empty-message", false);
                this.popup.renderer.setStyle("ace_loading", !finished);
              }.bind(this)
            );
            if (this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen)) {
              this.$firstOpenTimer.delay(this.stickySelectionDelay / 2);
            }
          };
          Autocomplete2.prototype.cancelContextMenu = function() {
            this.editor.$mouseHandler.cancelContextMenu();
          };
          Autocomplete2.prototype.updateDocTooltip = function() {
            var popup = this.popup;
            var all = this.completions && this.completions.filtered;
            var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
            var doc = null;
            if (!selected || !this.editor || !this.popup.isOpen)
              return this.hideDocTooltip();
            var completersLength = this.editor.completers.length;
            for (var i = 0; i < completersLength; i++) {
              var completer = this.editor.completers[i];
              if (completer.getDocTooltip && selected.completerId === completer.id) {
                doc = completer.getDocTooltip(selected);
                break;
              }
            }
            if (!doc && typeof selected != "string")
              doc = selected;
            if (typeof doc == "string")
              doc = { docText: doc };
            if (!doc || !(doc.docHTML || doc.docText))
              return this.hideDocTooltip();
            this.showDocTooltip(doc);
          };
          Autocomplete2.prototype.showDocTooltip = function(item) {
            if (!this.tooltipNode) {
              this.tooltipNode = dom.createElement("div");
              this.tooltipNode.style.margin = "0";
              this.tooltipNode.style.pointerEvents = "auto";
              this.tooltipNode.style.overscrollBehavior = "contain";
              this.tooltipNode.tabIndex = -1;
              this.tooltipNode.onblur = this.blurListener.bind(this);
              this.tooltipNode.onclick = this.onTooltipClick.bind(this);
              this.tooltipNode.id = "doc-tooltip";
              this.tooltipNode.setAttribute("role", "tooltip");
              this.tooltipNode.addEventListener("wheel", preventParentScroll);
            }
            var theme = this.editor.renderer.theme;
            this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
            var tooltipNode = this.tooltipNode;
            if (item.docHTML) {
              tooltipNode.innerHTML = item.docHTML;
            } else if (item.docText) {
              tooltipNode.textContent = item.docText;
            }
            if (!tooltipNode.parentNode)
              this.popup.container.appendChild(this.tooltipNode);
            var popup = this.popup;
            var rect = popup.container.getBoundingClientRect();
            var targetWidth = 400;
            var targetHeight = 300;
            var scrollBarSize = popup.renderer.scrollBar.width || 10;
            var leftSize = rect.left;
            var rightSize = window.innerWidth - rect.right - scrollBarSize;
            var topSize = popup.isTopdown ? rect.top : window.innerHeight - scrollBarSize - rect.bottom;
            var scores = [
              Math.min(rightSize / targetWidth, 1),
              Math.min(leftSize / targetWidth, 1),
              Math.min(topSize / targetHeight * 0.9)
            ];
            var max = Math.max.apply(Math, scores);
            var tooltipStyle = tooltipNode.style;
            tooltipStyle.display = "block";
            if (max == scores[0]) {
              tooltipStyle.left = rect.right + 1 + "px";
              tooltipStyle.right = "";
              tooltipStyle.maxWidth = targetWidth * max + "px";
              tooltipStyle.top = rect.top + "px";
              tooltipStyle.bottom = "";
              tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
            } else if (max == scores[1]) {
              tooltipStyle.right = window.innerWidth - rect.left + "px";
              tooltipStyle.left = "";
              tooltipStyle.maxWidth = targetWidth * max + "px";
              tooltipStyle.top = rect.top + "px";
              tooltipStyle.bottom = "";
              tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.top, targetHeight) + "px";
            } else if (max == scores[2]) {
              tooltipStyle.left = window.innerWidth - rect.left + "px";
              tooltipStyle.maxWidth = Math.min(targetWidth, window.innerWidth) + "px";
              if (popup.isTopdown) {
                tooltipStyle.top = rect.bottom + "px";
                tooltipStyle.left = rect.left + "px";
                tooltipStyle.right = "";
                tooltipStyle.bottom = "";
                tooltipStyle.maxHeight = Math.min(window.innerHeight - scrollBarSize - rect.bottom, targetHeight) + "px";
              } else {
                tooltipStyle.top = popup.container.offsetTop - tooltipNode.offsetHeight + "px";
                tooltipStyle.left = rect.left + "px";
                tooltipStyle.right = "";
                tooltipStyle.bottom = "";
                tooltipStyle.maxHeight = Math.min(popup.container.offsetTop, targetHeight) + "px";
              }
            }
          };
          Autocomplete2.prototype.hideDocTooltip = function() {
            this.tooltipTimer.cancel();
            if (!this.tooltipNode)
              return;
            var el = this.tooltipNode;
            if (!this.editor.isFocused() && document.activeElement == el)
              this.editor.focus();
            this.tooltipNode = null;
            if (el.parentNode)
              el.parentNode.removeChild(el);
          };
          Autocomplete2.prototype.onTooltipClick = function(e) {
            var a = e.target;
            while (a && a != this.tooltipNode) {
              if (a.nodeName == "A" && a.href) {
                a.rel = "noreferrer";
                a.target = "_blank";
                break;
              }
              a = a.parentNode;
            }
          };
          Autocomplete2.prototype.destroy = function() {
            this.detach();
            if (this.popup) {
              this.popup.destroy();
              var el = this.popup.container;
              if (el && el.parentNode)
                el.parentNode.removeChild(el);
            }
            if (this.editor && this.editor.completer == this) {
              this.editor.off("destroy", destroyCompleter);
              this.editor.completer = null;
            }
            this.inlineRenderer = this.popup = this.editor = null;
          };
          Autocomplete2.for = function(editor) {
            if (editor.completer instanceof Autocomplete2) {
              return editor.completer;
            }
            if (editor.completer) {
              editor.completer.destroy();
              editor.completer = null;
            }
            if (config.get("sharedPopups")) {
              if (!Autocomplete2["$sharedInstance"])
                Autocomplete2["$sharedInstance"] = new Autocomplete2();
              editor.completer = Autocomplete2["$sharedInstance"];
            } else {
              editor.completer = new Autocomplete2();
              editor.once("destroy", destroyCompleter);
            }
            return editor.completer;
          };
          return Autocomplete2;
        }()
      );
      Autocomplete.prototype.commands = {
        "Up": function(editor) {
          editor.completer.goTo("up");
        },
        "Down": function(editor) {
          editor.completer.goTo("down");
        },
        "Ctrl-Up|Ctrl-Home": function(editor) {
          editor.completer.goTo("start");
        },
        "Ctrl-Down|Ctrl-End": function(editor) {
          editor.completer.goTo("end");
        },
        "Esc": function(editor) {
          editor.completer.detach();
        },
        "Return": function(editor) {
          return editor.completer.insertMatch();
        },
        "Shift-Return": function(editor) {
          editor.completer.insertMatch(null, { deleteSuffix: true });
        },
        "Tab": function(editor) {
          var result = editor.completer.insertMatch();
          if (!result && !editor.tabstopManager)
            editor.completer.goTo("down");
          else
            return result;
        },
        "Backspace": function(editor) {
          editor.execCommand("backspace");
          var prefix = util.getCompletionPrefix(editor);
          if (!prefix && editor.completer)
            editor.completer.detach();
        },
        "PageUp": function(editor) {
          editor.completer.popup.gotoPageUp();
        },
        "PageDown": function(editor) {
          editor.completer.popup.gotoPageDown();
        }
      };
      Autocomplete.startCommand = {
        name: "startAutocomplete",
        exec: function(editor, options) {
          var completer = Autocomplete.for(editor);
          completer.autoInsert = false;
          completer.autoSelect = true;
          completer.autoShown = false;
          completer.showPopup(editor, options);
          completer.cancelContextMenu();
        },
        bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
      };
      var CompletionProvider = (
        /** @class */
        function() {
          function CompletionProvider2(initialPosition) {
            this.initialPosition = initialPosition;
            this.active = true;
          }
          CompletionProvider2.prototype.insertByIndex = function(editor, index, options) {
            if (!this.completions || !this.completions.filtered) {
              return false;
            }
            return this.insertMatch(editor, this.completions.filtered[index], options);
          };
          CompletionProvider2.prototype.insertMatch = function(editor, data, options) {
            if (!data)
              return false;
            editor.startOperation({ command: { name: "insertMatch" } });
            if (data.completer && data.completer.insertMatch) {
              data.completer.insertMatch(editor, data);
            } else {
              if (!this.completions)
                return false;
              var replaceBefore = this.completions.filterText.length;
              var replaceAfter = 0;
              if (data.range && data.range.start.row === data.range.end.row) {
                replaceBefore -= this.initialPosition.prefix.length;
                replaceBefore += this.initialPosition.pos.column - data.range.start.column;
                replaceAfter += data.range.end.column - this.initialPosition.pos.column;
              }
              if (replaceBefore || replaceAfter) {
                var ranges;
                if (editor.selection.getAllRanges) {
                  ranges = editor.selection.getAllRanges();
                } else {
                  ranges = [editor.getSelectionRange()];
                }
                for (var i = 0, range; range = ranges[i]; i++) {
                  range.start.column -= replaceBefore;
                  range.end.column += replaceAfter;
                  editor.session.remove(range);
                }
              }
              if (data.snippet) {
                snippetManager.insertSnippet(editor, data.snippet);
              } else {
                this.$insertString(editor, data);
              }
              if (data.completer && data.completer.onInsert && typeof data.completer.onInsert == "function") {
                data.completer.onInsert(editor, data);
              }
              if (data.command && data.command === "startAutocomplete") {
                editor.execCommand(data.command);
              }
            }
            editor.endOperation();
            return true;
          };
          CompletionProvider2.prototype.$insertString = function(editor, data) {
            var text = data.value || data;
            editor.execCommand("insertstring", text);
          };
          CompletionProvider2.prototype.gatherCompletions = function(editor, callback) {
            var session = editor.getSession();
            var pos = editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(editor);
            var matches = [];
            this.completers = editor.completers;
            var total = editor.completers.length;
            editor.completers.forEach(function(completer, i) {
              completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (completer.hideInlinePreview)
                  results = results.map(function(result) {
                    return Object.assign(result, { hideInlinePreview: completer.hideInlinePreview });
                  });
                if (!err && results)
                  matches = matches.concat(results);
                callback(null, {
                  prefix: util.getCompletionPrefix(editor),
                  matches,
                  finished: --total === 0
                });
              });
            });
            return true;
          };
          CompletionProvider2.prototype.provideCompletions = function(editor, options, callback) {
            var processResults = function(results2) {
              var prefix = results2.prefix;
              var matches = results2.matches;
              this.completions = new FilteredList(matches);
              if (options.exactMatch)
                this.completions.exactMatch = true;
              if (options.ignoreCaption)
                this.completions.ignoreCaption = true;
              this.completions.setFilter(prefix);
              if (results2.finished || this.completions.filtered.length)
                callback(null, this.completions, results2.finished);
            }.bind(this);
            var isImmediate = true;
            var immediateResults = null;
            this.gatherCompletions(editor, function(err, results2) {
              if (!this.active) {
                return;
              }
              if (err) {
                callback(err, [], true);
                this.detach();
              }
              var prefix = results2.prefix;
              if (prefix.indexOf(results2.prefix) !== 0)
                return;
              if (isImmediate) {
                immediateResults = results2;
                return;
              }
              processResults(results2);
            }.bind(this));
            isImmediate = false;
            if (immediateResults) {
              var results = immediateResults;
              immediateResults = null;
              processResults(results);
            }
          };
          CompletionProvider2.prototype.detach = function() {
            this.active = false;
            this.completers && this.completers.forEach(function(completer) {
              if (typeof completer.cancel === "function") {
                completer.cancel();
              }
            });
          };
          return CompletionProvider2;
        }()
      );
      var FilteredList = (
        /** @class */
        function() {
          function FilteredList2(array, filterText) {
            this.all = array;
            this.filtered = array;
            this.filterText = filterText || "";
            this.exactMatch = false;
            this.ignoreCaption = false;
          }
          FilteredList2.prototype.setFilter = function(str) {
            if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
              var matches = this.filtered;
            else
              var matches = this.all;
            this.filterText = str;
            matches = this.filterCompletions(matches, this.filterText);
            matches = matches.sort(function(a, b2) {
              return b2.exactMatch - a.exactMatch || b2.$score - a.$score || (a.caption || a.value).localeCompare(b2.caption || b2.value);
            });
            var prev = null;
            matches = matches.filter(function(item) {
              var caption = item.snippet || item.caption || item.value;
              if (caption === prev)
                return false;
              prev = caption;
              return true;
            });
            this.filtered = matches;
          };
          FilteredList2.prototype.filterCompletions = function(items, needle) {
            var results = [];
            var upper = needle.toUpperCase();
            var lower = needle.toLowerCase();
            loop: for (var i = 0, item; item = items[i]; i++) {
              if (item.skipFilter) {
                item.$score = item.score;
                results.push(item);
                continue;
              }
              var caption = !this.ignoreCaption && item.caption || item.value || item.snippet;
              if (!caption)
                continue;
              var lastIndex = -1;
              var matchMask = 0;
              var penalty = 0;
              var index, distance;
              if (this.exactMatch) {
                if (needle !== caption.substr(0, needle.length))
                  continue loop;
              } else {
                var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                if (fullMatchIndex > -1) {
                  penalty = fullMatchIndex;
                } else {
                  for (var j3 = 0; j3 < needle.length; j3++) {
                    var i1 = caption.indexOf(lower[j3], lastIndex + 1);
                    var i2 = caption.indexOf(upper[j3], lastIndex + 1);
                    index = i1 >= 0 ? i2 < 0 || i1 < i2 ? i1 : i2 : i2;
                    if (index < 0)
                      continue loop;
                    distance = index - lastIndex - 1;
                    if (distance > 0) {
                      if (lastIndex === -1)
                        penalty += 10;
                      penalty += distance;
                      matchMask = matchMask | 1 << j3;
                    }
                    lastIndex = index;
                  }
                }
              }
              item.matchMask = matchMask;
              item.exactMatch = penalty ? 0 : 1;
              item.$score = (item.score || 0) - penalty;
              results.push(item);
            }
            return results;
          };
          return FilteredList2;
        }()
      );
      exports2.Autocomplete = Autocomplete;
      exports2.CompletionProvider = CompletionProvider;
      exports2.FilteredList = FilteredList;
    });
    ace.define("ace/ext/menu_tools/settings_menu.css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = "#ace_settingsmenu, #kbshortcutmenu {\n    background-color: #F7F7F7;\n    color: black;\n    box-shadow: -5px 4px 5px rgba(126, 126, 126, 0.55);\n    padding: 1em 0.5em 2em 1em;\n    overflow: auto;\n    position: absolute;\n    margin: 0;\n    bottom: 0;\n    right: 0;\n    top: 0;\n    z-index: 9991;\n    cursor: default;\n}\n\n.ace_dark #ace_settingsmenu, .ace_dark #kbshortcutmenu {\n    box-shadow: -20px 10px 25px rgba(126, 126, 126, 0.25);\n    background-color: rgba(255, 255, 255, 0.6);\n    color: black;\n}\n\n.ace_optionsMenuEntry:hover {\n    background-color: rgba(100, 100, 100, 0.1);\n    transition: all 0.3s\n}\n\n.ace_closeButton {\n    background: rgba(245, 146, 146, 0.5);\n    border: 1px solid #F48A8A;\n    border-radius: 50%;\n    padding: 7px;\n    position: absolute;\n    right: -8px;\n    top: -8px;\n    z-index: 100000;\n}\n.ace_closeButton{\n    background: rgba(245, 146, 146, 0.9);\n}\n.ace_optionsMenuKey {\n    color: darkslateblue;\n    font-weight: bold;\n}\n.ace_optionsMenuCommand {\n    color: darkcyan;\n    font-weight: normal;\n}\n.ace_optionsMenuEntry input, .ace_optionsMenuEntry button {\n    vertical-align: middle;\n}\n\n.ace_optionsMenuEntry button[ace_selected_button=true] {\n    background: #e7e7e7;\n    box-shadow: 1px 0px 2px 0px #adadad inset;\n    border-color: #adadad;\n}\n.ace_optionsMenuEntry button {\n    background: white;\n    border: 1px solid lightgray;\n    margin: 0px;\n}\n.ace_optionsMenuEntry button:hover{\n    background: #f0f0f0;\n}";
    });
    ace.define("ace/ext/menu_tools/overlay_page", ["require", "exports", "module", "ace/ext/menu_tools/overlay_page", "ace/lib/dom", "ace/ext/menu_tools/settings_menu.css"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../../lib/dom");
      var cssText = require3("./settings_menu.css");
      dom.importCssString(cssText, "settings_menu.css", false);
      module3.exports.overlayPage = function overlayPage(editor, contentElement, callback) {
        var closer = document.createElement("div");
        var ignoreFocusOut = false;
        function documentEscListener(e) {
          if (e.keyCode === 27) {
            close();
          }
        }
        function close() {
          if (!closer)
            return;
          document.removeEventListener("keydown", documentEscListener);
          closer.parentNode.removeChild(closer);
          if (editor) {
            editor.focus();
          }
          closer = null;
          callback && callback();
        }
        function setIgnoreFocusOut(ignore) {
          ignoreFocusOut = ignore;
          if (ignore) {
            closer.style.pointerEvents = "none";
            contentElement.style.pointerEvents = "auto";
          }
        }
        closer.style.cssText = "margin: 0; padding: 0; position: fixed; top:0; bottom:0; left:0; right:0;z-index: 9990; " + (editor ? "background-color: rgba(0, 0, 0, 0.3);" : "");
        closer.addEventListener("click", function(e) {
          if (!ignoreFocusOut) {
            close();
          }
        });
        document.addEventListener("keydown", documentEscListener);
        contentElement.addEventListener("click", function(e) {
          e.stopPropagation();
        });
        closer.appendChild(contentElement);
        document.body.appendChild(closer);
        if (editor) {
          editor.blur();
        }
        return {
          close,
          setIgnoreFocusOut
        };
      };
    });
    ace.define("ace/ext/modelist", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var modes = [];
      function getModeForPath(path2) {
        var mode2 = modesByName.text;
        var fileName = path2.split(/[\/\\]/).pop();
        for (var i = 0; i < modes.length; i++) {
          if (modes[i].supportsFile(fileName)) {
            mode2 = modes[i];
            break;
          }
        }
        return mode2;
      }
      var Mode = (
        /** @class */
        function() {
          function Mode2(name2, caption, extensions) {
            this.name = name2;
            this.caption = caption;
            this.mode = "ace/mode/" + name2;
            this.extensions = extensions;
            var re3;
            if (/\^/.test(extensions)) {
              re3 = extensions.replace(/\|(\^)?/g, function(a, b2) {
                return "$|" + (b2 ? "^" : "^.*\\.");
              }) + "$";
            } else {
              re3 = "\\.(" + extensions + ")$";
            }
            this.extRe = new RegExp(re3, "gi");
          }
          Mode2.prototype.supportsFile = function(filename2) {
            return filename2.match(this.extRe);
          };
          return Mode2;
        }()
      );
      var supportedModes = {
        ABAP: ["abap"],
        ABC: ["abc"],
        ActionScript: ["as"],
        ADA: ["ada|adb"],
        Alda: ["alda"],
        Apache_Conf: ["^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd"],
        Apex: ["apex|cls|trigger|tgr"],
        AQL: ["aql"],
        AsciiDoc: ["asciidoc|adoc"],
        ASL: ["dsl|asl|asl.json"],
        Assembly_ARM32: ["s"],
        Assembly_x86: ["asm|a"],
        Astro: ["astro"],
        AutoHotKey: ["ahk"],
        Basic: ["bas|bak"],
        BatchFile: ["bat|cmd"],
        BibTeX: ["bib"],
        C_Cpp: ["cpp|c|cc|cxx|h|hh|hpp|ino"],
        C9Search: ["c9search_results"],
        Cirru: ["cirru|cr"],
        Clojure: ["clj|cljs"],
        Clue: ["clue"],
        Cobol: ["CBL|COB"],
        coffee: ["coffee|cf|cson|^Cakefile"],
        ColdFusion: ["cfm|cfc"],
        Crystal: ["cr"],
        CSharp: ["cs"],
        Csound_Document: ["csd"],
        Csound_Orchestra: ["orc"],
        Csound_Score: ["sco"],
        CSS: ["css"],
        CSV: ["csv"],
        Curly: ["curly"],
        Cuttlefish: ["conf"],
        D: ["d|di"],
        Dart: ["dart"],
        Diff: ["diff|patch"],
        Django: ["djt|html.djt|dj.html|djhtml"],
        Dockerfile: ["^Dockerfile"],
        Dot: ["dot"],
        Drools: ["drl"],
        Edifact: ["edi"],
        Eiffel: ["e|ge"],
        EJS: ["ejs"],
        Elixir: ["ex|exs"],
        Elm: ["elm"],
        Erlang: ["erl|hrl"],
        Flix: ["flix"],
        Forth: ["frt|fs|ldr|fth|4th"],
        Fortran: ["f|f90"],
        FSharp: ["fsi|fs|ml|mli|fsx|fsscript"],
        FSL: ["fsl"],
        FTL: ["ftl"],
        Gcode: ["gcode"],
        Gherkin: ["feature"],
        Gitignore: ["^.gitignore"],
        Glsl: ["glsl|frag|vert"],
        Gobstones: ["gbs"],
        golang: ["go"],
        GraphQLSchema: ["gql"],
        Groovy: ["groovy"],
        HAML: ["haml"],
        Handlebars: ["hbs|handlebars|tpl|mustache"],
        Haskell: ["hs"],
        Haskell_Cabal: ["cabal"],
        haXe: ["hx"],
        Hjson: ["hjson"],
        HTML: ["html|htm|xhtml|we|wpy"],
        HTML_Elixir: ["eex|html.eex"],
        HTML_Ruby: ["erb|rhtml|html.erb"],
        INI: ["ini|conf|cfg|prefs"],
        Io: ["io"],
        Ion: ["ion"],
        Jack: ["jack"],
        Jade: ["jade|pug"],
        Java: ["java"],
        JavaScript: ["js|jsm|cjs|mjs"],
        JEXL: ["jexl"],
        JSON: ["json"],
        JSON5: ["json5"],
        JSONiq: ["jq"],
        JSP: ["jsp"],
        JSSM: ["jssm|jssm_state"],
        JSX: ["jsx"],
        Julia: ["jl"],
        Kotlin: ["kt|kts"],
        LaTeX: ["tex|latex|ltx|bib"],
        Latte: ["latte"],
        LESS: ["less"],
        Liquid: ["liquid"],
        Lisp: ["lisp"],
        LiveScript: ["ls"],
        Log: ["log"],
        LogiQL: ["logic|lql"],
        Logtalk: ["lgt"],
        LSL: ["lsl"],
        Lua: ["lua"],
        LuaPage: ["lp"],
        Lucene: ["lucene"],
        Makefile: ["^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make"],
        Markdown: ["md|markdown"],
        Mask: ["mask"],
        MATLAB: ["matlab"],
        Maze: ["mz"],
        MediaWiki: ["wiki|mediawiki"],
        MEL: ["mel"],
        MIPS: ["s|asm"],
        MIXAL: ["mixal"],
        MUSHCode: ["mc|mush"],
        MySQL: ["mysql"],
        Nasal: ["nas"],
        Nginx: ["nginx|conf"],
        Nim: ["nim"],
        Nix: ["nix"],
        NSIS: ["nsi|nsh"],
        Nunjucks: ["nunjucks|nunjs|nj|njk"],
        ObjectiveC: ["m|mm"],
        OCaml: ["ml|mli"],
        Odin: ["odin"],
        PartiQL: ["partiql|pql"],
        Pascal: ["pas|p"],
        Perl: ["pl|pm"],
        pgSQL: ["pgsql"],
        PHP: ["php|inc|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module"],
        PHP_Laravel_blade: ["blade.php"],
        Pig: ["pig"],
        PLSQL: ["plsql"],
        Powershell: ["ps1"],
        Praat: ["praat|praatscript|psc|proc"],
        Prisma: ["prisma"],
        Prolog: ["plg|prolog"],
        Properties: ["properties"],
        Protobuf: ["proto"],
        PRQL: ["prql"],
        Puppet: ["epp|pp"],
        Python: ["py"],
        QML: ["qml"],
        R: ["r"],
        Raku: ["raku|rakumod|rakutest|p6|pl6|pm6"],
        Razor: ["cshtml|asp"],
        RDoc: ["Rd"],
        Red: ["red|reds"],
        RHTML: ["Rhtml"],
        Robot: ["robot|resource"],
        RST: ["rst"],
        Ruby: ["rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile"],
        Rust: ["rs"],
        SaC: ["sac"],
        SASS: ["sass"],
        SCAD: ["scad"],
        Scala: ["scala|sbt"],
        Scheme: ["scm|sm|rkt|oak|scheme"],
        Scrypt: ["scrypt"],
        SCSS: ["scss"],
        SH: ["sh|bash|^.bashrc"],
        SJS: ["sjs"],
        Slim: ["slim|skim"],
        Smarty: ["smarty|tpl"],
        Smithy: ["smithy"],
        snippets: ["snippets"],
        Soy_Template: ["soy"],
        Space: ["space"],
        SPARQL: ["rq"],
        SQL: ["sql"],
        SQLServer: ["sqlserver"],
        Stylus: ["styl|stylus"],
        SVG: ["svg"],
        Swift: ["swift"],
        Tcl: ["tcl"],
        Terraform: ["tf", "tfvars", "terragrunt"],
        Tex: ["tex"],
        Text: ["txt"],
        Textile: ["textile"],
        Toml: ["toml"],
        TSV: ["tsv"],
        TSX: ["tsx"],
        Turtle: ["ttl"],
        Twig: ["twig|swig"],
        Typescript: ["ts|mts|cts|typescript|str"],
        Vala: ["vala"],
        VBScript: ["vbs|vb"],
        Velocity: ["vm"],
        Verilog: ["v|vh|sv|svh"],
        VHDL: ["vhd|vhdl"],
        Visualforce: ["vfp|component|page"],
        Vue: ["vue"],
        Wollok: ["wlk|wpgm|wtest"],
        XML: ["xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml"],
        XQuery: ["xq"],
        YAML: ["yaml|yml"],
        Zeek: ["zeek|bro"],
        Zig: ["zig"]
      };
      var nameOverrides = {
        ObjectiveC: "Objective-C",
        CSharp: "C#",
        golang: "Go",
        C_Cpp: "C and C++",
        Csound_Document: "Csound Document",
        Csound_Orchestra: "Csound",
        Csound_Score: "Csound Score",
        coffee: "CoffeeScript",
        HTML_Ruby: "HTML (Ruby)",
        HTML_Elixir: "HTML (Elixir)",
        FTL: "FreeMarker",
        PHP_Laravel_blade: "PHP (Blade Template)",
        Perl6: "Perl 6",
        AutoHotKey: "AutoHotkey / AutoIt"
      };
      var modesByName = {};
      for (var name in supportedModes) {
        var data = supportedModes[name];
        var displayName = (nameOverrides[name] || name).replace(/_/g, " ");
        var filename = name.toLowerCase();
        var mode = new Mode(filename, displayName, data[0]);
        modesByName[filename] = mode;
        modes.push(mode);
      }
      exports2.getModeForPath = getModeForPath;
      exports2.modes = modes;
      exports2.modesByName = modesByName;
    });
    ace.define("ace/ext/prompt", ["require", "exports", "module", "ace/config", "ace/range", "ace/lib/dom", "ace/autocomplete", "ace/autocomplete/popup", "ace/autocomplete/popup", "ace/undomanager", "ace/tokenizer", "ace/ext/menu_tools/overlay_page", "ace/ext/modelist"], function(require3, exports2, module3) {
      "use strict";
      var nls = require3("../config").nls;
      var Range = require3("../range").Range;
      var dom = require3("../lib/dom");
      var FilteredList = require3("../autocomplete").FilteredList;
      var AcePopup = require3("../autocomplete/popup").AcePopup;
      var $singleLineEditor = require3("../autocomplete/popup").$singleLineEditor;
      var UndoManager = require3("../undomanager").UndoManager;
      var Tokenizer = require3("../tokenizer").Tokenizer;
      var overlayPage = require3("./menu_tools/overlay_page").overlayPage;
      var modelist = require3("./modelist");
      var openPrompt;
      function prompt2(editor, message, options, callback) {
        if (typeof message == "object") {
          return prompt2(editor, "", message, options);
        }
        if (openPrompt) {
          var lastPrompt = openPrompt;
          editor = lastPrompt.editor;
          lastPrompt.close();
          if (lastPrompt.name && lastPrompt.name == options.name)
            return;
        }
        if (options.$type)
          return prompt2[options.$type](editor, callback);
        var cmdLine = $singleLineEditor();
        cmdLine.session.setUndoManager(new UndoManager());
        var el = dom.buildDom(["div", { class: "ace_prompt_container" + (options.hasDescription ? " input-box-with-description" : "") }]);
        var overlay = overlayPage(editor, el, done);
        el.appendChild(cmdLine.container);
        if (editor) {
          editor.cmdLine = cmdLine;
          cmdLine.setOption("fontSize", editor.getOption("fontSize"));
        }
        if (message) {
          cmdLine.setValue(message, 1);
        }
        if (options.selection) {
          cmdLine.selection.setRange({
            start: cmdLine.session.doc.indexToPosition(options.selection[0]),
            end: cmdLine.session.doc.indexToPosition(options.selection[1])
          });
        }
        if (options.getCompletions) {
          var popup = new AcePopup();
          popup.renderer.setStyle("ace_autocomplete_inline");
          popup.container.style.display = "block";
          popup.container.style.maxWidth = "600px";
          popup.container.style.width = "100%";
          popup.container.style.marginTop = "3px";
          popup.renderer.setScrollMargin(2, 2, 0, 0);
          popup.autoSelect = false;
          popup.renderer.$maxLines = 15;
          popup.setRow(-1);
          popup.on("click", function(e) {
            var data = popup.getData(popup.getRow());
            if (!data["error"]) {
              cmdLine.setValue(data.value || data["name"] || data);
              accept();
              e.stop();
            }
          });
          el.appendChild(popup.container);
          updateCompletions();
        }
        if (options.$rules) {
          var tokenizer = new Tokenizer(options.$rules);
          cmdLine.session.bgTokenizer.setTokenizer(tokenizer);
        }
        if (options.placeholder) {
          cmdLine.setOption("placeholder", options.placeholder);
        }
        if (options.hasDescription) {
          var promptTextContainer = dom.buildDom(["div", { class: "ace_prompt_text_container" }]);
          dom.buildDom(options.prompt || "Press 'Enter' to confirm or 'Escape' to cancel", promptTextContainer);
          el.appendChild(promptTextContainer);
        }
        overlay.setIgnoreFocusOut(options.ignoreFocusOut);
        function accept() {
          var val;
          if (popup && popup.getCursorPosition().row > 0) {
            val = valueFromRecentList();
          } else {
            val = cmdLine.getValue();
          }
          var curData = popup ? popup.getData(popup.getRow()) : val;
          if (curData && !curData["error"]) {
            done();
            options.onAccept && options.onAccept({
              value: val,
              item: curData
            }, cmdLine);
          }
        }
        var keys = {
          "Enter": accept,
          "Esc|Shift-Esc": function() {
            options.onCancel && options.onCancel(cmdLine.getValue(), cmdLine);
            done();
          }
        };
        if (popup) {
          Object.assign(keys, {
            "Up": function(editor2) {
              popup.goTo("up");
              valueFromRecentList();
            },
            "Down": function(editor2) {
              popup.goTo("down");
              valueFromRecentList();
            },
            "Ctrl-Up|Ctrl-Home": function(editor2) {
              popup.goTo("start");
              valueFromRecentList();
            },
            "Ctrl-Down|Ctrl-End": function(editor2) {
              popup.goTo("end");
              valueFromRecentList();
            },
            "Tab": function(editor2) {
              popup.goTo("down");
              valueFromRecentList();
            },
            "PageUp": function(editor2) {
              popup.gotoPageUp();
              valueFromRecentList();
            },
            "PageDown": function(editor2) {
              popup.gotoPageDown();
              valueFromRecentList();
            }
          });
        }
        cmdLine.commands.bindKeys(keys);
        function done() {
          overlay.close();
          callback && callback();
          openPrompt = null;
        }
        cmdLine.on("input", function() {
          options.onInput && options.onInput();
          updateCompletions();
        });
        function updateCompletions() {
          if (options.getCompletions) {
            var prefix;
            if (options.getPrefix) {
              prefix = options.getPrefix(cmdLine);
            }
            var completions = options.getCompletions(cmdLine);
            popup.setData(completions, prefix);
            popup.resize(true);
          }
        }
        function valueFromRecentList() {
          var current = popup.getData(popup.getRow());
          if (current && !current["error"])
            return current.value || current.caption || current;
        }
        cmdLine.resize(true);
        if (popup) {
          popup.resize(true);
        }
        cmdLine.focus();
        openPrompt = {
          close: done,
          name: options.name,
          editor
        };
      }
      prompt2.gotoLine = function(editor, callback) {
        function stringifySelection(selection) {
          if (!Array.isArray(selection))
            selection = [selection];
          return selection.map(function(r) {
            var cursor = r.isBackwards ? r.start : r.end;
            var anchor = r.isBackwards ? r.end : r.start;
            var row = anchor.row;
            var s = row + 1 + ":" + anchor.column;
            if (anchor.row == cursor.row) {
              if (anchor.column != cursor.column)
                s += ">:" + cursor.column;
            } else {
              s += ">" + (cursor.row + 1) + ":" + cursor.column;
            }
            return s;
          }).reverse().join(", ");
        }
        prompt2(editor, ":" + stringifySelection(editor.selection.toJSON()), {
          name: "gotoLine",
          selection: [1, Number.MAX_VALUE],
          onAccept: function(data) {
            var value = data.value;
            var _history = prompt2.gotoLine["_history"];
            if (!_history)
              prompt2.gotoLine["_history"] = _history = [];
            if (_history.indexOf(value) != -1)
              _history.splice(_history.indexOf(value), 1);
            _history.unshift(value);
            if (_history.length > 20)
              _history.length = 20;
            var pos = editor.getCursorPosition();
            var ranges = [];
            value.replace(/^:/, "").split(/,/).map(function(str) {
              var parts = str.split(/([<>:+-]|c?\d+)|[^c\d<>:+-]+/).filter(Boolean);
              var i = 0;
              function readPosition() {
                var c = parts[i++];
                if (!c)
                  return;
                if (c[0] == "c") {
                  var index = parseInt(c.slice(1)) || 0;
                  return editor.session.doc.indexToPosition(index);
                }
                var row = pos.row;
                var column = 0;
                if (/\d/.test(c)) {
                  row = parseInt(c) - 1;
                  c = parts[i++];
                }
                if (c == ":") {
                  c = parts[i++];
                  if (/\d/.test(c)) {
                    column = parseInt(c) || 0;
                  }
                }
                return { row, column };
              }
              pos = readPosition();
              var range = Range.fromPoints(pos, pos);
              if (parts[i] == ">") {
                i++;
                range.end = readPosition();
              } else if (parts[i] == "<") {
                i++;
                range.start = readPosition();
              }
              ranges.unshift(range);
            });
            editor.selection.fromJSON(ranges);
            var scrollTop = editor.renderer.scrollTop;
            editor.renderer.scrollSelectionIntoView(editor.selection.anchor, editor.selection.cursor, 0.5);
            editor.renderer.animateScrolling(scrollTop);
          },
          history: function() {
            if (!prompt2.gotoLine["_history"])
              return [];
            return prompt2.gotoLine["_history"];
          },
          getCompletions: function(cmdLine) {
            var value = cmdLine.getValue();
            var m = value.replace(/^:/, "").split(":");
            var row = Math.min(parseInt(m[0]) || 1, editor.session.getLength()) - 1;
            var line = editor.session.getLine(row);
            var current = value + "  " + line;
            return [current].concat(this.history());
          },
          $rules: {
            start: [{
              regex: /\d+/,
              token: "string"
            }, {
              regex: /[:,><+\-c]/,
              token: "keyword"
            }]
          }
        });
      };
      prompt2.commands = function(editor, callback) {
        function normalizeName(name) {
          return (name || "").replace(/^./, function(x) {
            return x.toUpperCase(x);
          }).replace(/[a-z][A-Z]/g, function(x) {
            return x[0] + " " + x[1].toLowerCase(x);
          });
        }
        function getEditorCommandsByName(excludeCommands) {
          var commandsByName = [];
          var commandMap = {};
          editor.keyBinding.$handlers.forEach(function(handler) {
            var platform = handler["platform"];
            var cbn = handler["byName"];
            for (var i in cbn) {
              var key = cbn[i].bindKey;
              if (typeof key !== "string") {
                key = key && key[platform] || "";
              }
              var commands = cbn[i];
              var description = commands.description || normalizeName(commands.name);
              if (!Array.isArray(commands))
                commands = [commands];
              commands.forEach(function(command) {
                if (typeof command != "string")
                  command = command.name;
                var needle = excludeCommands.find(function(el) {
                  return el === command;
                });
                if (!needle) {
                  if (commandMap[command]) {
                    commandMap[command].key += "|" + key;
                  } else {
                    commandMap[command] = { key, command, description };
                    commandsByName.push(commandMap[command]);
                  }
                }
              });
            }
          });
          return commandsByName;
        }
        var excludeCommandsList = ["insertstring", "inserttext", "setIndentation", "paste"];
        var shortcutsArray = getEditorCommandsByName(excludeCommandsList);
        shortcutsArray = shortcutsArray.map(function(item) {
          return { value: item.description, meta: item.key, command: item.command };
        });
        prompt2(editor, "", {
          name: "commands",
          selection: [0, Number.MAX_VALUE],
          maxHistoryCount: 5,
          onAccept: function(data) {
            if (data.item) {
              var commandName = data.item.command;
              this.addToHistory(data.item);
              editor.execCommand(commandName);
            }
          },
          addToHistory: function(item) {
            var history = this.history();
            history.unshift(item);
            delete item.message;
            for (var i = 1; i < history.length; i++) {
              if (history[i]["command"] == item.command) {
                history.splice(i, 1);
                break;
              }
            }
            if (this.maxHistoryCount > 0 && history.length > this.maxHistoryCount) {
              history.splice(history.length - 1, 1);
            }
            prompt2.commands["history"] = history;
          },
          history: function() {
            return prompt2.commands["history"] || [];
          },
          getPrefix: function(cmdLine) {
            var currentPos = cmdLine.getCursorPosition();
            var filterValue = cmdLine.getValue();
            return filterValue.substring(0, currentPos.column);
          },
          getCompletions: function(cmdLine) {
            function getFilteredCompletions(commands, prefix2) {
              var resultCommands = JSON.parse(JSON.stringify(commands));
              var filtered = new FilteredList(resultCommands);
              return filtered.filterCompletions(resultCommands, prefix2);
            }
            function getUniqueCommandList(commands, usedCommands) {
              if (!usedCommands || !usedCommands.length) {
                return commands;
              }
              var excludeCommands = [];
              usedCommands.forEach(function(item) {
                excludeCommands.push(item.command);
              });
              var resultCommands = [];
              commands.forEach(function(item) {
                if (excludeCommands.indexOf(item.command) === -1) {
                  resultCommands.push(item);
                }
              });
              return resultCommands;
            }
            var prefix = this.getPrefix(cmdLine);
            var recentlyUsedCommands = getFilteredCompletions(this.history(), prefix);
            var otherCommands = getUniqueCommandList(shortcutsArray, recentlyUsedCommands);
            otherCommands = getFilteredCompletions(otherCommands, prefix);
            if (recentlyUsedCommands.length && otherCommands.length) {
              recentlyUsedCommands[0].message = nls("prompt.recently-used", "Recently used");
              otherCommands[0].message = nls("prompt.other-commands", "Other commands");
            }
            var completions = recentlyUsedCommands.concat(otherCommands);
            return completions.length > 0 ? completions : [{
              value: nls("prompt.no-matching-commands", "No matching commands"),
              error: 1
            }];
          }
        });
      };
      prompt2.modes = function(editor, callback) {
        var modesArray = modelist.modes;
        modesArray = modesArray.map(function(item) {
          return { value: item.caption, mode: item.name };
        });
        prompt2(editor, "", {
          name: "modes",
          selection: [0, Number.MAX_VALUE],
          onAccept: function(data) {
            if (data.item) {
              var modeName = "ace/mode/" + data.item.mode;
              editor.session.setMode(modeName);
            }
          },
          getPrefix: function(cmdLine) {
            var currentPos = cmdLine.getCursorPosition();
            var filterValue = cmdLine.getValue();
            return filterValue.substring(0, currentPos.column);
          },
          getCompletions: function(cmdLine) {
            function getFilteredCompletions(modes, prefix2) {
              var resultCommands = JSON.parse(JSON.stringify(modes));
              var filtered = new FilteredList(resultCommands);
              return filtered.filterCompletions(resultCommands, prefix2);
            }
            var prefix = this.getPrefix(cmdLine);
            var completions = getFilteredCompletions(modesArray, prefix);
            return completions.length > 0 ? completions : [{
              "caption": "No mode matching",
              "value": "No mode matching",
              "error": 1
            }];
          }
        });
      };
      dom.importCssString(".ace_prompt_container {\n    max-width: 603px;\n    width: 100%;\n    margin: 20px auto;\n    padding: 3px;\n    background: white;\n    border-radius: 2px;\n    box-shadow: 0px 2px 3px 0px #555;\n}", "promtp.css", false);
      exports2.prompt = prompt2;
    });
    (function() {
      ace.require(["ace/ext/prompt"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-rtl.js
var require_ext_rtl = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-rtl.js"(exports, module2) {
    ace.define("ace/ext/rtl", ["require", "exports", "module", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var commands = [{
        name: "leftToRight",
        bindKey: { win: "Ctrl-Alt-Shift-L", mac: "Command-Alt-Shift-L" },
        exec: function(editor) {
          editor.session.$bidiHandler.setRtlDirection(editor, false);
        },
        readOnly: true
      }, {
        name: "rightToLeft",
        bindKey: { win: "Ctrl-Alt-Shift-R", mac: "Command-Alt-Shift-R" },
        exec: function(editor) {
          editor.session.$bidiHandler.setRtlDirection(editor, true);
        },
        readOnly: true
      }];
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        rtlText: {
          set: function(val) {
            if (val) {
              this.on("change", onChange);
              this.on("changeSelection", onChangeSelection);
              this.renderer.on("afterRender", updateLineDirection);
              this.commands.on("exec", onCommandEmitted);
              this.commands.addCommands(commands);
            } else {
              this.off("change", onChange);
              this.off("changeSelection", onChangeSelection);
              this.renderer.off("afterRender", updateLineDirection);
              this.commands.off("exec", onCommandEmitted);
              this.commands.removeCommands(commands);
              clearTextLayer(this.renderer);
            }
            this.renderer.updateFull();
          }
        },
        rtl: {
          set: function(val) {
            this.session.$bidiHandler.$isRtl = val;
            if (val) {
              this.setOption("rtlText", false);
              this.renderer.on("afterRender", updateLineDirection);
              this.session.$bidiHandler.seenBidi = true;
            } else {
              this.renderer.off("afterRender", updateLineDirection);
              clearTextLayer(this.renderer);
            }
            this.renderer.updateFull();
          }
        }
      });
      function onChangeSelection(e, editor) {
        var lead = editor.getSelection().lead;
        if (editor.session.$bidiHandler.isRtlLine(lead.row)) {
          if (lead.column === 0) {
            if (editor.session.$bidiHandler.isMoveLeftOperation && lead.row > 0) {
              editor.getSelection().moveCursorTo(lead.row - 1, editor.session.getLine(lead.row - 1).length);
            } else {
              if (editor.getSelection().isEmpty())
                lead.column += 1;
              else
                lead.setPosition(lead.row, lead.column + 1);
            }
          }
        }
      }
      function onCommandEmitted(commadEvent) {
        commadEvent.editor.session.$bidiHandler.isMoveLeftOperation = /gotoleft|selectleft|backspace|removewordleft/.test(commadEvent.command.name);
      }
      function onChange(delta, editor) {
        var session = editor.session;
        session.$bidiHandler.currentRow = null;
        if (session.$bidiHandler.isRtlLine(delta.start.row) && delta.action === "insert" && delta.lines.length > 1) {
          for (var row = delta.start.row; row < delta.end.row; row++) {
            if (session.getLine(row + 1).charAt(0) !== session.$bidiHandler.RLE)
              session.doc.$lines[row + 1] = session.$bidiHandler.RLE + session.getLine(row + 1);
          }
        }
      }
      function updateLineDirection(e, renderer) {
        var session = renderer.session;
        var $bidiHandler = session.$bidiHandler;
        var cells = renderer.$textLayer.$lines.cells;
        var width = renderer.layerConfig.width - renderer.layerConfig.padding + "px";
        cells.forEach(function(cell) {
          var style = cell.element.style;
          if ($bidiHandler && $bidiHandler.isRtlLine(cell.row)) {
            style.direction = "rtl";
            style.textAlign = "right";
            style.width = width;
          } else {
            style.direction = "";
            style.textAlign = "";
            style.width = "";
          }
        });
      }
      function clearTextLayer(renderer) {
        var lines = renderer.$textLayer.$lines;
        lines.cells.forEach(clear);
        lines.cellCache.forEach(clear);
        function clear(cell) {
          var style = cell.element.style;
          style.direction = style.textAlign = style.width = "";
        }
      }
    });
    (function() {
      ace.require(["ace/ext/rtl"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-searchbox.js
var require_ext_searchbox = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-searchbox.js"(exports, module2) {
    ace.define("ace/ext/searchbox-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '\n\n/* ------------------------------------------------------------------------------------------\n * Editor Search Form\n * --------------------------------------------------------------------------------------- */\n.ace_search {\n    background-color: #ddd;\n    color: #666;\n    border: 1px solid #cbcbcb;\n    border-top: 0 none;\n    overflow: hidden;\n    margin: 0;\n    padding: 4px 6px 0 4px;\n    position: absolute;\n    top: 0;\n    z-index: 99;\n    white-space: normal;\n}\n.ace_search.left {\n    border-left: 0 none;\n    border-radius: 0px 0px 5px 0px;\n    left: 0;\n}\n.ace_search.right {\n    border-radius: 0px 0px 0px 5px;\n    border-right: 0 none;\n    right: 0;\n}\n\n.ace_search_form, .ace_replace_form {\n    margin: 0 20px 4px 0;\n    overflow: hidden;\n    line-height: 1.9;\n}\n.ace_replace_form {\n    margin-right: 0;\n}\n.ace_search_form.ace_nomatch {\n    outline: 1px solid red;\n}\n\n.ace_search_field {\n    border-radius: 3px 0 0 3px;\n    background-color: white;\n    color: black;\n    border: 1px solid #cbcbcb;\n    border-right: 0 none;\n    outline: 0;\n    padding: 0;\n    font-size: inherit;\n    margin: 0;\n    line-height: inherit;\n    padding: 0 6px;\n    min-width: 17em;\n    vertical-align: top;\n    min-height: 1.8em;\n    box-sizing: content-box;\n}\n.ace_searchbtn {\n    border: 1px solid #cbcbcb;\n    line-height: inherit;\n    display: inline-block;\n    padding: 0 6px;\n    background: #fff;\n    border-right: 0 none;\n    border-left: 1px solid #dcdcdc;\n    cursor: pointer;\n    margin: 0;\n    position: relative;\n    color: #666;\n}\n.ace_searchbtn:last-child {\n    border-radius: 0 3px 3px 0;\n    border-right: 1px solid #cbcbcb;\n}\n.ace_searchbtn:disabled {\n    background: none;\n    cursor: default;\n}\n.ace_searchbtn:hover {\n    background-color: #eef1f6;\n}\n.ace_searchbtn.prev, .ace_searchbtn.next {\n     padding: 0px 0.7em\n}\n.ace_searchbtn.prev:after, .ace_searchbtn.next:after {\n     content: "";\n     border: solid 2px #888;\n     width: 0.5em;\n     height: 0.5em;\n     border-width:  2px 0 0 2px;\n     display:inline-block;\n     transform: rotate(-45deg);\n}\n.ace_searchbtn.next:after {\n     border-width: 0 2px 2px 0 ;\n}\n.ace_searchbtn_close {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\n    border-radius: 50%;\n    border: 0 none;\n    color: #656565;\n    cursor: pointer;\n    font: 16px/16px Arial;\n    padding: 0;\n    height: 14px;\n    width: 14px;\n    top: 9px;\n    right: 7px;\n    position: absolute;\n}\n.ace_searchbtn_close:hover {\n    background-color: #656565;\n    background-position: 50% 100%;\n    color: white;\n}\n\n.ace_button {\n    margin-left: 2px;\n    cursor: pointer;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -o-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    overflow: hidden;\n    opacity: 0.7;\n    border: 1px solid rgba(100,100,100,0.23);\n    padding: 1px;\n    box-sizing:    border-box!important;\n    color: black;\n}\n\n.ace_button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_button:active {\n    background-color: #ddd;\n}\n\n.ace_button.checked {\n    border-color: #3399ff;\n    opacity:1;\n}\n\n.ace_search_options{\n    margin-bottom: 3px;\n    text-align: right;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -o-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    clear: both;\n}\n\n.ace_search_counter {\n    float: left;\n    font-family: arial;\n    padding: 0 8px;\n}';
    });
    ace.define("ace/ext/searchbox", ["require", "exports", "module", "ace/ext/searchbox", "ace/ext/searchbox", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/ext/searchbox-css", "ace/keyboard/hash_handler", "ace/lib/keys", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      var lang = require3("../lib/lang");
      var event = require3("../lib/event");
      var searchboxCss = require3("./searchbox-css");
      var HashHandler = require3("../keyboard/hash_handler").HashHandler;
      var keyUtil = require3("../lib/keys");
      var nls = require3("../config").nls;
      var MAX_COUNT = 999;
      dom.importCssString(searchboxCss, "ace_searchbox", false);
      var SearchBox = (
        /** @class */
        function() {
          function SearchBox2(editor, range, showReplaceForm) {
            this.activeInput;
            this.element = dom.buildDom([
              "div",
              { class: "ace_search right" },
              ["span", { action: "hide", class: "ace_searchbtn_close" }],
              [
                "div",
                { class: "ace_search_form" },
                ["input", { class: "ace_search_field", placeholder: nls("search-box.find.placeholder", "Search for"), spellcheck: "false" }],
                ["span", { action: "findPrev", class: "ace_searchbtn prev" }, "\u200B"],
                ["span", { action: "findNext", class: "ace_searchbtn next" }, "\u200B"],
                ["span", { action: "findAll", class: "ace_searchbtn", title: "Alt-Enter" }, nls("search-box.find-all.text", "All")]
              ],
              [
                "div",
                { class: "ace_replace_form" },
                ["input", { class: "ace_search_field", placeholder: nls("search-box.replace.placeholder", "Replace with"), spellcheck: "false" }],
                ["span", { action: "replaceAndFindNext", class: "ace_searchbtn" }, nls("search-box.replace-next.text", "Replace")],
                ["span", { action: "replaceAll", class: "ace_searchbtn" }, nls("search-box.replace-all.text", "All")]
              ],
              [
                "div",
                { class: "ace_search_options" },
                ["span", {
                  action: "toggleReplace",
                  class: "ace_button",
                  title: nls("search-box.toggle-replace.title", "Toggle Replace mode"),
                  style: "float:left;margin-top:-2px;padding:0 5px;"
                }, "+"],
                ["span", { class: "ace_search_counter" }],
                ["span", { action: "toggleRegexpMode", class: "ace_button", title: nls("search-box.toggle-regexp.title", "RegExp Search") }, ".*"],
                ["span", { action: "toggleCaseSensitive", class: "ace_button", title: nls("search-box.toggle-case.title", "CaseSensitive Search") }, "Aa"],
                ["span", { action: "toggleWholeWords", class: "ace_button", title: nls("search-box.toggle-whole-word.title", "Whole Word Search") }, "\\b"],
                ["span", { action: "searchInSelection", class: "ace_button", title: nls("search-box.toggle-in-selection.title", "Search In Selection") }, "S"]
              ]
            ]);
            this.setSession = this.setSession.bind(this);
            this.$onEditorInput = this.onEditorInput.bind(this);
            this.$init();
            this.setEditor(editor);
            dom.importCssString(searchboxCss, "ace_searchbox", editor.container);
            event.addListener(this.element, "touchstart", function(e) {
              e.stopPropagation();
            }, editor);
          }
          SearchBox2.prototype.setEditor = function(editor) {
            editor.searchBox = this;
            editor.renderer.scroller.appendChild(this.element);
            this.editor = editor;
          };
          SearchBox2.prototype.setSession = function(e) {
            this.searchRange = null;
            this.$syncOptions(true);
          };
          SearchBox2.prototype.onEditorInput = function() {
            this.find(false, false, true);
          };
          SearchBox2.prototype.$initElements = function(sb) {
            this.searchBox = sb.querySelector(".ace_search_form");
            this.replaceBox = sb.querySelector(".ace_replace_form");
            this.searchOption = sb.querySelector("[action=searchInSelection]");
            this.replaceOption = sb.querySelector("[action=toggleReplace]");
            this.regExpOption = sb.querySelector("[action=toggleRegexpMode]");
            this.caseSensitiveOption = sb.querySelector("[action=toggleCaseSensitive]");
            this.wholeWordOption = sb.querySelector("[action=toggleWholeWords]");
            this.searchInput = this.searchBox.querySelector(".ace_search_field");
            this.replaceInput = this.replaceBox.querySelector(".ace_search_field");
            this.searchCounter = sb.querySelector(".ace_search_counter");
          };
          SearchBox2.prototype.$init = function() {
            var sb = this.element;
            this.$initElements(sb);
            var _this = this;
            event.addListener(sb, "mousedown", function(e) {
              setTimeout(function() {
                _this.activeInput.focus();
              }, 0);
              event.stopPropagation(e);
            });
            event.addListener(sb, "click", function(e) {
              var t = e.target || e.srcElement;
              var action = t.getAttribute("action");
              if (action && _this[action])
                _this[action]();
              else if (_this.$searchBarKb.commands[action])
                _this.$searchBarKb.commands[action].exec(_this);
              event.stopPropagation(e);
            });
            event.addCommandKeyListener(sb, function(e, hashId, keyCode) {
              var keyString = keyUtil.keyCodeToString(keyCode);
              var command = _this.$searchBarKb.findKeyCommand(hashId, keyString);
              if (command && command.exec) {
                command.exec(_this);
                event.stopEvent(e);
              }
            });
            this.$onChange = lang.delayedCall(function() {
              _this.find(false, false);
            });
            event.addListener(this.searchInput, "input", function() {
              _this.$onChange.schedule(20);
            });
            event.addListener(this.searchInput, "focus", function() {
              _this.activeInput = _this.searchInput;
              _this.searchInput.value && _this.highlight();
            });
            event.addListener(this.replaceInput, "focus", function() {
              _this.activeInput = _this.replaceInput;
              _this.searchInput.value && _this.highlight();
            });
          };
          SearchBox2.prototype.setSearchRange = function(range) {
            this.searchRange = range;
            if (range) {
              this.searchRangeMarker = this.editor.session.addMarker(range, "ace_active-line");
            } else if (this.searchRangeMarker) {
              this.editor.session.removeMarker(this.searchRangeMarker);
              this.searchRangeMarker = null;
            }
          };
          SearchBox2.prototype.$syncOptions = function(preventScroll) {
            dom.setCssClass(this.replaceOption, "checked", this.searchRange);
            dom.setCssClass(this.searchOption, "checked", this.searchOption.checked);
            this.replaceOption.textContent = this.replaceOption.checked ? "-" : "+";
            dom.setCssClass(this.regExpOption, "checked", this.regExpOption.checked);
            dom.setCssClass(this.wholeWordOption, "checked", this.wholeWordOption.checked);
            dom.setCssClass(this.caseSensitiveOption, "checked", this.caseSensitiveOption.checked);
            var readOnly = this.editor.getReadOnly();
            this.replaceOption.style.display = readOnly ? "none" : "";
            this.replaceBox.style.display = this.replaceOption.checked && !readOnly ? "" : "none";
            this.find(false, false, preventScroll);
          };
          SearchBox2.prototype.highlight = function(re3) {
            this.editor.session.highlight(re3 || this.editor.$search.$options.re);
            this.editor.renderer.updateBackMarkers();
          };
          SearchBox2.prototype.find = function(skipCurrent, backwards, preventScroll) {
            if (!this.editor.session)
              return;
            var range = this.editor.find(this.searchInput.value, {
              skipCurrent,
              backwards,
              wrap: true,
              regExp: this.regExpOption.checked,
              caseSensitive: this.caseSensitiveOption.checked,
              wholeWord: this.wholeWordOption.checked,
              preventScroll,
              range: this.searchRange
            });
            var noMatch = !range && this.searchInput.value;
            dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
            this.editor._emit("findSearchBox", { match: !noMatch });
            this.highlight();
            this.updateCounter();
          };
          SearchBox2.prototype.updateCounter = function() {
            var editor = this.editor;
            var regex = editor.$search.$options.re;
            var supportsUnicodeFlag = regex.unicode;
            var all = 0;
            var before = 0;
            if (regex) {
              var value = this.searchRange ? editor.session.getTextRange(this.searchRange) : editor.getValue();
              if (editor.$search.$isMultilineSearch(editor.getLastSearchOptions())) {
                value = value.replace(/\r\n|\r|\n/g, "\n");
                editor.session.doc.$autoNewLine = "\n";
              }
              var offset = editor.session.doc.positionToIndex(editor.selection.anchor);
              if (this.searchRange)
                offset -= editor.session.doc.positionToIndex(this.searchRange.start);
              var last = regex.lastIndex = 0;
              var m;
              while (m = regex.exec(value)) {
                all++;
                last = m.index;
                if (last <= offset)
                  before++;
                if (all > MAX_COUNT)
                  break;
                if (!m[0]) {
                  regex.lastIndex = last += lang.skipEmptyMatch(value, last, supportsUnicodeFlag);
                  if (last >= value.length)
                    break;
                }
              }
            }
            this.searchCounter.textContent = nls("search-box.search-counter", "$0 of $1", [before, all > MAX_COUNT ? MAX_COUNT + "+" : all]);
          };
          SearchBox2.prototype.findNext = function() {
            this.find(true, false);
          };
          SearchBox2.prototype.findPrev = function() {
            this.find(true, true);
          };
          SearchBox2.prototype.findAll = function() {
            var range = this.editor.findAll(this.searchInput.value, {
              regExp: this.regExpOption.checked,
              caseSensitive: this.caseSensitiveOption.checked,
              wholeWord: this.wholeWordOption.checked
            });
            var noMatch = !range && this.searchInput.value;
            dom.setCssClass(this.searchBox, "ace_nomatch", noMatch);
            this.editor._emit("findSearchBox", { match: !noMatch });
            this.highlight();
            this.hide();
          };
          SearchBox2.prototype.replace = function() {
            if (!this.editor.getReadOnly())
              this.editor.replace(this.replaceInput.value);
          };
          SearchBox2.prototype.replaceAndFindNext = function() {
            if (!this.editor.getReadOnly()) {
              this.editor.replace(this.replaceInput.value);
              this.findNext();
            }
          };
          SearchBox2.prototype.replaceAll = function() {
            if (!this.editor.getReadOnly())
              this.editor.replaceAll(this.replaceInput.value);
          };
          SearchBox2.prototype.hide = function() {
            this.active = false;
            this.setSearchRange(null);
            this.editor.off("changeSession", this.setSession);
            this.editor.off("input", this.$onEditorInput);
            this.element.style.display = "none";
            this.editor.keyBinding.removeKeyboardHandler(this.$closeSearchBarKb);
            this.editor.focus();
          };
          SearchBox2.prototype.show = function(value, isReplace) {
            this.active = true;
            this.editor.on("changeSession", this.setSession);
            this.editor.on("input", this.$onEditorInput);
            this.element.style.display = "";
            this.replaceOption.checked = isReplace;
            if (this.editor.$search.$options.regExp)
              value = lang.escapeRegExp(value);
            if (value != void 0)
              this.searchInput.value = value;
            this.searchInput.focus();
            this.searchInput.select();
            this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb);
            this.$syncOptions(true);
          };
          SearchBox2.prototype.isFocused = function() {
            var el = document.activeElement;
            return el == this.searchInput || el == this.replaceInput;
          };
          return SearchBox2;
        }()
      );
      var $searchBarKb = new HashHandler();
      $searchBarKb.bindKeys({
        "Ctrl-f|Command-f": function(sb) {
          var isReplace = sb.isReplace = !sb.isReplace;
          sb.replaceBox.style.display = isReplace ? "" : "none";
          sb.replaceOption.checked = false;
          sb.$syncOptions();
          sb.searchInput.focus();
        },
        "Ctrl-H|Command-Option-F": function(sb) {
          if (sb.editor.getReadOnly())
            return;
          sb.replaceOption.checked = true;
          sb.$syncOptions();
          sb.replaceInput.focus();
        },
        "Ctrl-G|Command-G": function(sb) {
          sb.findNext();
        },
        "Ctrl-Shift-G|Command-Shift-G": function(sb) {
          sb.findPrev();
        },
        "esc": function(sb) {
          setTimeout(function() {
            sb.hide();
          });
        },
        "Return": function(sb) {
          if (sb.activeInput == sb.replaceInput)
            sb.replace();
          sb.findNext();
        },
        "Shift-Return": function(sb) {
          if (sb.activeInput == sb.replaceInput)
            sb.replace();
          sb.findPrev();
        },
        "Alt-Return": function(sb) {
          if (sb.activeInput == sb.replaceInput)
            sb.replaceAll();
          sb.findAll();
        },
        "Tab": function(sb) {
          (sb.activeInput == sb.replaceInput ? sb.searchInput : sb.replaceInput).focus();
        }
      });
      $searchBarKb.addCommands([{
        name: "toggleRegexpMode",
        bindKey: { win: "Alt-R|Alt-/", mac: "Ctrl-Alt-R|Ctrl-Alt-/" },
        exec: function(sb) {
          sb.regExpOption.checked = !sb.regExpOption.checked;
          sb.$syncOptions();
        }
      }, {
        name: "toggleCaseSensitive",
        bindKey: { win: "Alt-C|Alt-I", mac: "Ctrl-Alt-R|Ctrl-Alt-I" },
        exec: function(sb) {
          sb.caseSensitiveOption.checked = !sb.caseSensitiveOption.checked;
          sb.$syncOptions();
        }
      }, {
        name: "toggleWholeWords",
        bindKey: { win: "Alt-B|Alt-W", mac: "Ctrl-Alt-B|Ctrl-Alt-W" },
        exec: function(sb) {
          sb.wholeWordOption.checked = !sb.wholeWordOption.checked;
          sb.$syncOptions();
        }
      }, {
        name: "toggleReplace",
        exec: function(sb) {
          sb.replaceOption.checked = !sb.replaceOption.checked;
          sb.$syncOptions();
        }
      }, {
        name: "searchInSelection",
        exec: function(sb) {
          sb.searchOption.checked = !sb.searchRange;
          sb.setSearchRange(sb.searchOption.checked && sb.editor.getSelectionRange());
          sb.$syncOptions();
        }
      }]);
      var $closeSearchBarKb = new HashHandler([{
        bindKey: "Esc",
        name: "closeSearchBar",
        exec: function(editor) {
          editor.searchBox.hide();
        }
      }]);
      SearchBox.prototype.$searchBarKb = $searchBarKb;
      SearchBox.prototype.$closeSearchBarKb = $closeSearchBarKb;
      exports2.SearchBox = SearchBox;
      exports2.Search = function(editor, isReplace) {
        var sb = editor.searchBox || new SearchBox(editor);
        var range = editor.session.selection.getRange();
        var value = range.isMultiLine() ? "" : editor.session.getTextRange(range);
        sb.show(value, isReplace);
      };
    });
    (function() {
      ace.require(["ace/ext/searchbox"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-settings_menu.js
var require_ext_settings_menu = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-settings_menu.js"(exports, module2) {
    ace.define("ace/ext/menu_tools/settings_menu.css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = "#ace_settingsmenu, #kbshortcutmenu {\n    background-color: #F7F7F7;\n    color: black;\n    box-shadow: -5px 4px 5px rgba(126, 126, 126, 0.55);\n    padding: 1em 0.5em 2em 1em;\n    overflow: auto;\n    position: absolute;\n    margin: 0;\n    bottom: 0;\n    right: 0;\n    top: 0;\n    z-index: 9991;\n    cursor: default;\n}\n\n.ace_dark #ace_settingsmenu, .ace_dark #kbshortcutmenu {\n    box-shadow: -20px 10px 25px rgba(126, 126, 126, 0.25);\n    background-color: rgba(255, 255, 255, 0.6);\n    color: black;\n}\n\n.ace_optionsMenuEntry:hover {\n    background-color: rgba(100, 100, 100, 0.1);\n    transition: all 0.3s\n}\n\n.ace_closeButton {\n    background: rgba(245, 146, 146, 0.5);\n    border: 1px solid #F48A8A;\n    border-radius: 50%;\n    padding: 7px;\n    position: absolute;\n    right: -8px;\n    top: -8px;\n    z-index: 100000;\n}\n.ace_closeButton{\n    background: rgba(245, 146, 146, 0.9);\n}\n.ace_optionsMenuKey {\n    color: darkslateblue;\n    font-weight: bold;\n}\n.ace_optionsMenuCommand {\n    color: darkcyan;\n    font-weight: normal;\n}\n.ace_optionsMenuEntry input, .ace_optionsMenuEntry button {\n    vertical-align: middle;\n}\n\n.ace_optionsMenuEntry button[ace_selected_button=true] {\n    background: #e7e7e7;\n    box-shadow: 1px 0px 2px 0px #adadad inset;\n    border-color: #adadad;\n}\n.ace_optionsMenuEntry button {\n    background: white;\n    border: 1px solid lightgray;\n    margin: 0px;\n}\n.ace_optionsMenuEntry button:hover{\n    background: #f0f0f0;\n}";
    });
    ace.define("ace/ext/menu_tools/overlay_page", ["require", "exports", "module", "ace/ext/menu_tools/overlay_page", "ace/lib/dom", "ace/ext/menu_tools/settings_menu.css"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../../lib/dom");
      var cssText = require3("./settings_menu.css");
      dom.importCssString(cssText, "settings_menu.css", false);
      module3.exports.overlayPage = function overlayPage(editor, contentElement, callback) {
        var closer = document.createElement("div");
        var ignoreFocusOut = false;
        function documentEscListener(e) {
          if (e.keyCode === 27) {
            close();
          }
        }
        function close() {
          if (!closer)
            return;
          document.removeEventListener("keydown", documentEscListener);
          closer.parentNode.removeChild(closer);
          if (editor) {
            editor.focus();
          }
          closer = null;
          callback && callback();
        }
        function setIgnoreFocusOut(ignore) {
          ignoreFocusOut = ignore;
          if (ignore) {
            closer.style.pointerEvents = "none";
            contentElement.style.pointerEvents = "auto";
          }
        }
        closer.style.cssText = "margin: 0; padding: 0; position: fixed; top:0; bottom:0; left:0; right:0;z-index: 9990; " + (editor ? "background-color: rgba(0, 0, 0, 0.3);" : "");
        closer.addEventListener("click", function(e) {
          if (!ignoreFocusOut) {
            close();
          }
        });
        document.addEventListener("keydown", documentEscListener);
        contentElement.addEventListener("click", function(e) {
          e.stopPropagation();
        });
        closer.appendChild(contentElement);
        document.body.appendChild(closer);
        if (editor) {
          editor.blur();
        }
        return {
          close,
          setIgnoreFocusOut
        };
      };
    });
    ace.define("ace/ext/modelist", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var modes = [];
      function getModeForPath(path2) {
        var mode2 = modesByName.text;
        var fileName = path2.split(/[\/\\]/).pop();
        for (var i = 0; i < modes.length; i++) {
          if (modes[i].supportsFile(fileName)) {
            mode2 = modes[i];
            break;
          }
        }
        return mode2;
      }
      var Mode = (
        /** @class */
        function() {
          function Mode2(name2, caption, extensions) {
            this.name = name2;
            this.caption = caption;
            this.mode = "ace/mode/" + name2;
            this.extensions = extensions;
            var re3;
            if (/\^/.test(extensions)) {
              re3 = extensions.replace(/\|(\^)?/g, function(a, b2) {
                return "$|" + (b2 ? "^" : "^.*\\.");
              }) + "$";
            } else {
              re3 = "\\.(" + extensions + ")$";
            }
            this.extRe = new RegExp(re3, "gi");
          }
          Mode2.prototype.supportsFile = function(filename2) {
            return filename2.match(this.extRe);
          };
          return Mode2;
        }()
      );
      var supportedModes = {
        ABAP: ["abap"],
        ABC: ["abc"],
        ActionScript: ["as"],
        ADA: ["ada|adb"],
        Alda: ["alda"],
        Apache_Conf: ["^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd"],
        Apex: ["apex|cls|trigger|tgr"],
        AQL: ["aql"],
        AsciiDoc: ["asciidoc|adoc"],
        ASL: ["dsl|asl|asl.json"],
        Assembly_ARM32: ["s"],
        Assembly_x86: ["asm|a"],
        Astro: ["astro"],
        AutoHotKey: ["ahk"],
        Basic: ["bas|bak"],
        BatchFile: ["bat|cmd"],
        BibTeX: ["bib"],
        C_Cpp: ["cpp|c|cc|cxx|h|hh|hpp|ino"],
        C9Search: ["c9search_results"],
        Cirru: ["cirru|cr"],
        Clojure: ["clj|cljs"],
        Clue: ["clue"],
        Cobol: ["CBL|COB"],
        coffee: ["coffee|cf|cson|^Cakefile"],
        ColdFusion: ["cfm|cfc"],
        Crystal: ["cr"],
        CSharp: ["cs"],
        Csound_Document: ["csd"],
        Csound_Orchestra: ["orc"],
        Csound_Score: ["sco"],
        CSS: ["css"],
        CSV: ["csv"],
        Curly: ["curly"],
        Cuttlefish: ["conf"],
        D: ["d|di"],
        Dart: ["dart"],
        Diff: ["diff|patch"],
        Django: ["djt|html.djt|dj.html|djhtml"],
        Dockerfile: ["^Dockerfile"],
        Dot: ["dot"],
        Drools: ["drl"],
        Edifact: ["edi"],
        Eiffel: ["e|ge"],
        EJS: ["ejs"],
        Elixir: ["ex|exs"],
        Elm: ["elm"],
        Erlang: ["erl|hrl"],
        Flix: ["flix"],
        Forth: ["frt|fs|ldr|fth|4th"],
        Fortran: ["f|f90"],
        FSharp: ["fsi|fs|ml|mli|fsx|fsscript"],
        FSL: ["fsl"],
        FTL: ["ftl"],
        Gcode: ["gcode"],
        Gherkin: ["feature"],
        Gitignore: ["^.gitignore"],
        Glsl: ["glsl|frag|vert"],
        Gobstones: ["gbs"],
        golang: ["go"],
        GraphQLSchema: ["gql"],
        Groovy: ["groovy"],
        HAML: ["haml"],
        Handlebars: ["hbs|handlebars|tpl|mustache"],
        Haskell: ["hs"],
        Haskell_Cabal: ["cabal"],
        haXe: ["hx"],
        Hjson: ["hjson"],
        HTML: ["html|htm|xhtml|we|wpy"],
        HTML_Elixir: ["eex|html.eex"],
        HTML_Ruby: ["erb|rhtml|html.erb"],
        INI: ["ini|conf|cfg|prefs"],
        Io: ["io"],
        Ion: ["ion"],
        Jack: ["jack"],
        Jade: ["jade|pug"],
        Java: ["java"],
        JavaScript: ["js|jsm|cjs|mjs"],
        JEXL: ["jexl"],
        JSON: ["json"],
        JSON5: ["json5"],
        JSONiq: ["jq"],
        JSP: ["jsp"],
        JSSM: ["jssm|jssm_state"],
        JSX: ["jsx"],
        Julia: ["jl"],
        Kotlin: ["kt|kts"],
        LaTeX: ["tex|latex|ltx|bib"],
        Latte: ["latte"],
        LESS: ["less"],
        Liquid: ["liquid"],
        Lisp: ["lisp"],
        LiveScript: ["ls"],
        Log: ["log"],
        LogiQL: ["logic|lql"],
        Logtalk: ["lgt"],
        LSL: ["lsl"],
        Lua: ["lua"],
        LuaPage: ["lp"],
        Lucene: ["lucene"],
        Makefile: ["^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make"],
        Markdown: ["md|markdown"],
        Mask: ["mask"],
        MATLAB: ["matlab"],
        Maze: ["mz"],
        MediaWiki: ["wiki|mediawiki"],
        MEL: ["mel"],
        MIPS: ["s|asm"],
        MIXAL: ["mixal"],
        MUSHCode: ["mc|mush"],
        MySQL: ["mysql"],
        Nasal: ["nas"],
        Nginx: ["nginx|conf"],
        Nim: ["nim"],
        Nix: ["nix"],
        NSIS: ["nsi|nsh"],
        Nunjucks: ["nunjucks|nunjs|nj|njk"],
        ObjectiveC: ["m|mm"],
        OCaml: ["ml|mli"],
        Odin: ["odin"],
        PartiQL: ["partiql|pql"],
        Pascal: ["pas|p"],
        Perl: ["pl|pm"],
        pgSQL: ["pgsql"],
        PHP: ["php|inc|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module"],
        PHP_Laravel_blade: ["blade.php"],
        Pig: ["pig"],
        PLSQL: ["plsql"],
        Powershell: ["ps1"],
        Praat: ["praat|praatscript|psc|proc"],
        Prisma: ["prisma"],
        Prolog: ["plg|prolog"],
        Properties: ["properties"],
        Protobuf: ["proto"],
        PRQL: ["prql"],
        Puppet: ["epp|pp"],
        Python: ["py"],
        QML: ["qml"],
        R: ["r"],
        Raku: ["raku|rakumod|rakutest|p6|pl6|pm6"],
        Razor: ["cshtml|asp"],
        RDoc: ["Rd"],
        Red: ["red|reds"],
        RHTML: ["Rhtml"],
        Robot: ["robot|resource"],
        RST: ["rst"],
        Ruby: ["rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile"],
        Rust: ["rs"],
        SaC: ["sac"],
        SASS: ["sass"],
        SCAD: ["scad"],
        Scala: ["scala|sbt"],
        Scheme: ["scm|sm|rkt|oak|scheme"],
        Scrypt: ["scrypt"],
        SCSS: ["scss"],
        SH: ["sh|bash|^.bashrc"],
        SJS: ["sjs"],
        Slim: ["slim|skim"],
        Smarty: ["smarty|tpl"],
        Smithy: ["smithy"],
        snippets: ["snippets"],
        Soy_Template: ["soy"],
        Space: ["space"],
        SPARQL: ["rq"],
        SQL: ["sql"],
        SQLServer: ["sqlserver"],
        Stylus: ["styl|stylus"],
        SVG: ["svg"],
        Swift: ["swift"],
        Tcl: ["tcl"],
        Terraform: ["tf", "tfvars", "terragrunt"],
        Tex: ["tex"],
        Text: ["txt"],
        Textile: ["textile"],
        Toml: ["toml"],
        TSV: ["tsv"],
        TSX: ["tsx"],
        Turtle: ["ttl"],
        Twig: ["twig|swig"],
        Typescript: ["ts|mts|cts|typescript|str"],
        Vala: ["vala"],
        VBScript: ["vbs|vb"],
        Velocity: ["vm"],
        Verilog: ["v|vh|sv|svh"],
        VHDL: ["vhd|vhdl"],
        Visualforce: ["vfp|component|page"],
        Vue: ["vue"],
        Wollok: ["wlk|wpgm|wtest"],
        XML: ["xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml"],
        XQuery: ["xq"],
        YAML: ["yaml|yml"],
        Zeek: ["zeek|bro"],
        Zig: ["zig"]
      };
      var nameOverrides = {
        ObjectiveC: "Objective-C",
        CSharp: "C#",
        golang: "Go",
        C_Cpp: "C and C++",
        Csound_Document: "Csound Document",
        Csound_Orchestra: "Csound",
        Csound_Score: "Csound Score",
        coffee: "CoffeeScript",
        HTML_Ruby: "HTML (Ruby)",
        HTML_Elixir: "HTML (Elixir)",
        FTL: "FreeMarker",
        PHP_Laravel_blade: "PHP (Blade Template)",
        Perl6: "Perl 6",
        AutoHotKey: "AutoHotkey / AutoIt"
      };
      var modesByName = {};
      for (var name in supportedModes) {
        var data = supportedModes[name];
        var displayName = (nameOverrides[name] || name).replace(/_/g, " ");
        var filename = name.toLowerCase();
        var mode = new Mode(filename, displayName, data[0]);
        modesByName[filename] = mode;
        modes.push(mode);
      }
      exports2.getModeForPath = getModeForPath;
      exports2.modes = modes;
      exports2.modesByName = modesByName;
    });
    ace.define("ace/ext/themelist", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var themeData = [
        ["Chrome"],
        ["Clouds"],
        ["Crimson Editor"],
        ["Dawn"],
        ["Dreamweaver"],
        ["Eclipse"],
        ["GitHub Light Default"],
        ["GitHub (Legacy)", "github", "light"],
        ["IPlastic"],
        ["Solarized Light"],
        ["TextMate"],
        ["Tomorrow"],
        ["XCode"],
        ["Kuroir"],
        ["KatzenMilch"],
        ["SQL Server", "sqlserver", "light"],
        ["CloudEditor", "cloud_editor", "light"],
        ["Ambiance", "ambiance", "dark"],
        ["Chaos", "chaos", "dark"],
        ["Clouds Midnight", "clouds_midnight", "dark"],
        ["Dracula", "", "dark"],
        ["Cobalt", "cobalt", "dark"],
        ["Gruvbox", "gruvbox", "dark"],
        ["Green on Black", "gob", "dark"],
        ["idle Fingers", "idle_fingers", "dark"],
        ["krTheme", "kr_theme", "dark"],
        ["Merbivore", "merbivore", "dark"],
        ["Merbivore Soft", "merbivore_soft", "dark"],
        ["Mono Industrial", "mono_industrial", "dark"],
        ["Monokai", "monokai", "dark"],
        ["Nord Dark", "nord_dark", "dark"],
        ["One Dark", "one_dark", "dark"],
        ["Pastel on dark", "pastel_on_dark", "dark"],
        ["Solarized Dark", "solarized_dark", "dark"],
        ["Terminal", "terminal", "dark"],
        ["Tomorrow Night", "tomorrow_night", "dark"],
        ["Tomorrow Night Blue", "tomorrow_night_blue", "dark"],
        ["Tomorrow Night Bright", "tomorrow_night_bright", "dark"],
        ["Tomorrow Night 80s", "tomorrow_night_eighties", "dark"],
        ["Twilight", "twilight", "dark"],
        ["Vibrant Ink", "vibrant_ink", "dark"],
        ["GitHub Dark", "github_dark", "dark"],
        ["CloudEditor Dark", "cloud_editor_dark", "dark"]
      ];
      exports2.themesByName = {};
      exports2.themes = themeData.map(function(data) {
        var name = data[1] || data[0].replace(/ /g, "_").toLowerCase();
        var theme = {
          caption: data[0],
          theme: "ace/theme/" + name,
          isDark: data[2] == "dark",
          name
        };
        exports2.themesByName[name] = theme;
        return theme;
      });
    });
    ace.define("ace/ext/options", ["require", "exports", "module", "ace/ext/settings_menu", "ace/ext/menu_tools/overlay_page", "ace/lib/dom", "ace/lib/oop", "ace/config", "ace/lib/event_emitter", "ace/ext/modelist", "ace/ext/themelist"], function(require3, exports2, module3) {
      "use strict";
      require3("./menu_tools/overlay_page");
      var dom = require3("../lib/dom");
      var oop = require3("../lib/oop");
      var config = require3("../config");
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var buildDom = dom.buildDom;
      var modelist = require3("./modelist");
      var themelist = require3("./themelist");
      var themes = { Bright: [], Dark: [] };
      themelist.themes.forEach(function(x) {
        themes[x.isDark ? "Dark" : "Bright"].push({ caption: x.caption, value: x.theme });
      });
      var modes = modelist.modes.map(function(x) {
        return { caption: x.caption, value: x.mode };
      });
      var optionGroups = {
        Main: {
          Mode: {
            path: "mode",
            type: "select",
            items: modes
          },
          Theme: {
            path: "theme",
            type: "select",
            items: themes
          },
          "Keybinding": {
            type: "buttonBar",
            path: "keyboardHandler",
            items: [
              { caption: "Ace", value: null },
              { caption: "Vim", value: "ace/keyboard/vim" },
              { caption: "Emacs", value: "ace/keyboard/emacs" },
              { caption: "Sublime", value: "ace/keyboard/sublime" },
              { caption: "VSCode", value: "ace/keyboard/vscode" }
            ]
          },
          "Font Size": {
            path: "fontSize",
            type: "number",
            defaultValue: 12,
            defaults: [
              { caption: "12px", value: 12 },
              { caption: "24px", value: 24 }
            ]
          },
          "Soft Wrap": {
            type: "buttonBar",
            path: "wrap",
            items: [
              { caption: "Off", value: "off" },
              { caption: "View", value: "free" },
              { caption: "margin", value: "printMargin" },
              { caption: "40", value: "40" }
            ]
          },
          "Cursor Style": {
            path: "cursorStyle",
            items: [
              { caption: "Ace", value: "ace" },
              { caption: "Slim", value: "slim" },
              { caption: "Smooth", value: "smooth" },
              { caption: "Smooth And Slim", value: "smooth slim" },
              { caption: "Wide", value: "wide" }
            ]
          },
          "Folding": {
            path: "foldStyle",
            items: [
              { caption: "Manual", value: "manual" },
              { caption: "Mark begin", value: "markbegin" },
              { caption: "Mark begin and end", value: "markbeginend" }
            ]
          },
          "Soft Tabs": [{
            path: "useSoftTabs"
          }, {
            ariaLabel: "Tab Size",
            path: "tabSize",
            type: "number",
            values: [2, 3, 4, 8, 16]
          }],
          "Overscroll": {
            type: "buttonBar",
            path: "scrollPastEnd",
            items: [
              { caption: "None", value: 0 },
              { caption: "Half", value: 0.5 },
              { caption: "Full", value: 1 }
            ]
          }
        },
        More: {
          "Atomic soft tabs": {
            path: "navigateWithinSoftTabs"
          },
          "Enable Behaviours": {
            path: "behavioursEnabled"
          },
          "Wrap with quotes": {
            path: "wrapBehavioursEnabled"
          },
          "Enable Auto Indent": {
            path: "enableAutoIndent"
          },
          "Full Line Selection": {
            type: "checkbox",
            values: "text|line",
            path: "selectionStyle"
          },
          "Highlight Active Line": {
            path: "highlightActiveLine"
          },
          "Show Invisibles": {
            path: "showInvisibles"
          },
          "Show Indent Guides": {
            path: "displayIndentGuides"
          },
          "Highlight Indent Guides": {
            path: "highlightIndentGuides"
          },
          "Persistent HScrollbar": {
            path: "hScrollBarAlwaysVisible"
          },
          "Persistent VScrollbar": {
            path: "vScrollBarAlwaysVisible"
          },
          "Animate scrolling": {
            path: "animatedScroll"
          },
          "Show Gutter": {
            path: "showGutter"
          },
          "Show Line Numbers": {
            path: "showLineNumbers"
          },
          "Relative Line Numbers": {
            path: "relativeLineNumbers"
          },
          "Fixed Gutter Width": {
            path: "fixedWidthGutter"
          },
          "Show Print Margin": [{
            path: "showPrintMargin"
          }, {
            ariaLabel: "Print Margin",
            type: "number",
            path: "printMarginColumn"
          }],
          "Indented Soft Wrap": {
            path: "indentedSoftWrap"
          },
          "Highlight selected word": {
            path: "highlightSelectedWord"
          },
          "Fade Fold Widgets": {
            path: "fadeFoldWidgets"
          },
          "Use textarea for IME": {
            path: "useTextareaForIME"
          },
          "Merge Undo Deltas": {
            path: "mergeUndoDeltas",
            items: [
              { caption: "Always", value: "always" },
              { caption: "Never", value: "false" },
              { caption: "Timed", value: "true" }
            ]
          },
          "Elastic Tabstops": {
            path: "useElasticTabstops"
          },
          "Incremental Search": {
            path: "useIncrementalSearch"
          },
          "Read-only": {
            path: "readOnly"
          },
          "Copy without selection": {
            path: "copyWithEmptySelection"
          },
          "Live Autocompletion": {
            path: "enableLiveAutocompletion"
          },
          "Custom scrollbar": {
            path: "customScrollbar"
          },
          "Use SVG gutter icons": {
            path: "useSvgGutterIcons"
          },
          "Annotations for folded lines": {
            path: "showFoldedAnnotations"
          },
          "Keyboard Accessibility Mode": {
            path: "enableKeyboardAccessibility"
          },
          "Gutter tooltip follows mouse": {
            path: "tooltipFollowsMouse",
            defaultValue: true
          }
        }
      };
      var OptionPanel = (
        /** @class */
        function() {
          function OptionPanel2(editor, element) {
            this.editor = editor;
            this.container = element || document.createElement("div");
            this.groups = [];
            this.options = {};
          }
          OptionPanel2.prototype.add = function(config2) {
            if (config2.Main)
              oop.mixin(optionGroups.Main, config2.Main);
            if (config2.More)
              oop.mixin(optionGroups.More, config2.More);
          };
          OptionPanel2.prototype.render = function() {
            this.container.innerHTML = "";
            buildDom([
              "table",
              { role: "presentation", id: "controls" },
              this.renderOptionGroup(optionGroups.Main),
              ["tr", null, [
                "td",
                { colspan: 2 },
                [
                  "table",
                  { role: "presentation", id: "more-controls" },
                  this.renderOptionGroup(optionGroups.More)
                ]
              ]],
              ["tr", null, ["td", { colspan: 2 }, "version " + config.version]]
            ], this.container);
          };
          OptionPanel2.prototype.renderOptionGroup = function(group) {
            return Object.keys(group).map(function(key, i) {
              var item = group[key];
              if (!item.position)
                item.position = i / 1e4;
              if (!item.label)
                item.label = key;
              return item;
            }).sort(function(a, b2) {
              return a.position - b2.position;
            }).map(function(item) {
              return this.renderOption(item.label, item);
            }, this);
          };
          OptionPanel2.prototype.renderOptionControl = function(key, option) {
            var self2 = this;
            if (Array.isArray(option)) {
              return option.map(function(x) {
                return self2.renderOptionControl(key, x);
              });
            }
            var control;
            var value = self2.getOption(option);
            if (option.values && option.type != "checkbox") {
              if (typeof option.values == "string")
                option.values = option.values.split("|");
              option.items = option.values.map(function(v2) {
                return { value: v2, name: v2 };
              });
            }
            if (option.type == "buttonBar") {
              control = ["div", { role: "group", "aria-labelledby": option.path + "-label" }, option.items.map(function(item) {
                return ["button", {
                  value: item.value,
                  ace_selected_button: value == item.value,
                  "aria-pressed": value == item.value,
                  onclick: function() {
                    self2.setOption(option, item.value);
                    var nodes = this.parentNode.querySelectorAll("[ace_selected_button]");
                    for (var i = 0; i < nodes.length; i++) {
                      nodes[i].removeAttribute("ace_selected_button");
                      nodes[i].setAttribute("aria-pressed", false);
                    }
                    this.setAttribute("ace_selected_button", true);
                    this.setAttribute("aria-pressed", true);
                  }
                }, item.desc || item.caption || item.name];
              })];
            } else if (option.type == "number") {
              control = ["input", { type: "number", value: value || option.defaultValue, style: "width:3em", oninput: function() {
                self2.setOption(option, parseInt(this.value));
              } }];
              if (option.ariaLabel) {
                control[1]["aria-label"] = option.ariaLabel;
              } else {
                control[1].id = key;
              }
              if (option.defaults) {
                control = [control, option.defaults.map(function(item) {
                  return ["button", { onclick: function() {
                    var input = this.parentNode.firstChild;
                    input.value = item.value;
                    input.oninput();
                  } }, item.caption];
                })];
              }
            } else if (option.items) {
              var buildItems = function(items2) {
                return items2.map(function(item) {
                  return ["option", { value: item.value || item.name }, item.desc || item.caption || item.name];
                });
              };
              var items = Array.isArray(option.items) ? buildItems(option.items) : Object.keys(option.items).map(function(key2) {
                return ["optgroup", { "label": key2 }, buildItems(option.items[key2])];
              });
              control = ["select", { id: key, value, onchange: function() {
                self2.setOption(option, this.value);
              } }, items];
            } else {
              if (typeof option.values == "string")
                option.values = option.values.split("|");
              if (option.values)
                value = value == option.values[1];
              control = ["input", { type: "checkbox", id: key, checked: value || null, onchange: function() {
                var value2 = this.checked;
                if (option.values)
                  value2 = option.values[value2 ? 1 : 0];
                self2.setOption(option, value2);
              } }];
              if (option.type == "checkedNumber") {
                control = [control, []];
              }
            }
            return control;
          };
          OptionPanel2.prototype.renderOption = function(key, option) {
            if (option.path && !option.onchange && !this.editor.$options[option.path])
              return;
            var path2 = Array.isArray(option) ? option[0].path : option.path;
            this.options[path2] = option;
            var safeKey = "-" + path2;
            var safeId = path2 + "-label";
            var control = this.renderOptionControl(safeKey, option);
            return ["tr", { class: "ace_optionsMenuEntry" }, [
              "td",
              ["label", { for: safeKey, id: safeId }, key]
            ], ["td", control]];
          };
          OptionPanel2.prototype.setOption = function(option, value) {
            if (typeof option == "string")
              option = this.options[option];
            if (value == "false")
              value = false;
            if (value == "true")
              value = true;
            if (value == "null")
              value = null;
            if (value == "undefined")
              value = void 0;
            if (typeof value == "string" && parseFloat(value).toString() == value)
              value = parseFloat(value);
            if (option.onchange)
              option.onchange(value);
            else if (option.path)
              this.editor.setOption(option.path, value);
            this._signal("setOption", { name: option.path, value });
          };
          OptionPanel2.prototype.getOption = function(option) {
            if (option.getValue)
              return option.getValue();
            return this.editor.getOption(option.path);
          };
          return OptionPanel2;
        }()
      );
      oop.implement(OptionPanel.prototype, EventEmitter);
      exports2.OptionPanel = OptionPanel;
      exports2.optionGroups = optionGroups;
    });
    ace.define("ace/ext/settings_menu", ["require", "exports", "module", "ace/ext/options", "ace/ext/menu_tools/overlay_page", "ace/editor"], function(require3, exports2, module3) {
      "use strict";
      var OptionPanel = require3("./options").OptionPanel;
      var overlayPage = require3("./menu_tools/overlay_page").overlayPage;
      function showSettingsMenu(editor) {
        if (!document.getElementById("ace_settingsmenu")) {
          var options = new OptionPanel(editor);
          options.render();
          options.container.id = "ace_settingsmenu";
          overlayPage(editor, options.container);
          options.container.querySelector("select,input,button,checkbox").focus();
        }
      }
      module3.exports.init = function() {
        var Editor = require3("../editor").Editor;
        Editor.prototype.showSettingsMenu = function() {
          showSettingsMenu(this);
        };
      };
    });
    (function() {
      ace.require(["ace/ext/settings_menu"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-simple_tokenizer.js
var require_ext_simple_tokenizer = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-simple_tokenizer.js"(exports, module2) {
    ace.define("ace/mode/json_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("../lib/oop");
      var TextHighlightRules = require3("./text_highlight_rules").TextHighlightRules;
      var JsonHighlightRules = function() {
        this.$rules = {
          "start": [
            {
              token: "variable",
              // single line
              regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
            },
            {
              token: "string",
              // single line
              regex: '"',
              next: "string"
            },
            {
              token: "constant.numeric",
              // hex
              regex: "0[xX][0-9a-fA-F]+\\b"
            },
            {
              token: "constant.numeric",
              // float
              regex: "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
            },
            {
              token: "constant.language.boolean",
              regex: "(?:true|false)\\b"
            },
            {
              token: "text",
              // single quoted strings are not allowed
              regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
            },
            {
              token: "comment",
              // comments are not allowed, but who cares?
              regex: "\\/\\/.*$"
            },
            {
              token: "comment.start",
              // comments are not allowed, but who cares?
              regex: "\\/\\*",
              next: "comment"
            },
            {
              token: "paren.lparen",
              regex: "[[({]"
            },
            {
              token: "paren.rparen",
              regex: "[\\])}]"
            },
            {
              token: "punctuation.operator",
              regex: /[,]/
            },
            {
              token: "text",
              regex: "\\s+"
            }
          ],
          "string": [
            {
              token: "constant.language.escape",
              regex: /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
            },
            {
              token: "string",
              regex: '"|$',
              next: "start"
            },
            {
              defaultToken: "string"
            }
          ],
          "comment": [
            {
              token: "comment.end",
              // comments are not allowed, but who cares?
              regex: "\\*\\/",
              next: "start"
            },
            {
              defaultToken: "comment"
            }
          ]
        };
      };
      oop.inherits(JsonHighlightRules, TextHighlightRules);
      exports2.JsonHighlightRules = JsonHighlightRules;
    });
    ace.define("ace/ext/simple_tokenizer", ["require", "exports", "module", "ace/ext/simple_tokenizer", "ace/mode/json_highlight_rules", "ace/tokenizer", "ace/layer/text_util"], function(require3, exports2, module3) {
      "use strict";
      var Tokenizer = require3("../tokenizer").Tokenizer;
      var isTextToken = require3("../layer/text_util").isTextToken;
      var SimpleTokenizer = (
        /** @class */
        function() {
          function SimpleTokenizer2(content, tokenizer) {
            this._lines = content.split(/\r\n|\r|\n/);
            this._states = [];
            this._tokenizer = tokenizer;
          }
          SimpleTokenizer2.prototype.getTokens = function(row) {
            var line = this._lines[row];
            var previousState = this._states[row - 1];
            var data = this._tokenizer.getLineTokens(line, previousState);
            this._states[row] = data.state;
            return data.tokens;
          };
          SimpleTokenizer2.prototype.getLength = function() {
            return this._lines.length;
          };
          return SimpleTokenizer2;
        }()
      );
      function tokenize(content, highlightRules) {
        var tokenizer = new SimpleTokenizer(content, new Tokenizer(highlightRules.getRules()));
        var result = [];
        for (var lineIndex = 0; lineIndex < tokenizer.getLength(); lineIndex++) {
          var lineTokens = tokenizer.getTokens(lineIndex);
          result.push(lineTokens.map(function(token) {
            return {
              className: isTextToken(token.type) ? void 0 : "ace_" + token.type.replace(/\./g, " ace_"),
              value: token.value
            };
          }));
        }
        return result;
      }
      exports2.tokenize = tokenize;
    });
    (function() {
      ace.require(["ace/ext/simple_tokenizer"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-spellcheck.js
var require_ext_spellcheck = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-spellcheck.js"(exports, module2) {
    ace.define("ace/ext/spellcheck", ["require", "exports", "module", "ace/lib/event", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var event = require3("../lib/event");
      exports2.contextMenuHandler = function(e) {
        var host = e.target;
        var text = host.textInput.getElement();
        if (!host.selection.isEmpty())
          return;
        var c = host.getCursorPosition();
        var r = host.session.getWordRange(c.row, c.column);
        var w2 = host.session.getTextRange(r);
        host.session.tokenRe.lastIndex = 0;
        if (!host.session.tokenRe.test(w2))
          return;
        var PLACEHOLDER = "";
        var value = w2 + " " + PLACEHOLDER;
        text.value = value;
        text.setSelectionRange(w2.length, w2.length + 1);
        text.setSelectionRange(0, 0);
        text.setSelectionRange(0, w2.length);
        var afterKeydown = false;
        event.addListener(text, "keydown", function onKeydown() {
          event.removeListener(text, "keydown", onKeydown);
          afterKeydown = true;
        });
        host.textInput.setInputHandler(function(newVal) {
          if (newVal == value)
            return "";
          if (newVal.lastIndexOf(value, 0) === 0)
            return newVal.slice(value.length);
          if (newVal.substr(text.selectionEnd) == value)
            return newVal.slice(0, -value.length);
          if (newVal.slice(-2) == PLACEHOLDER) {
            var val = newVal.slice(0, -2);
            if (val.slice(-1) == " ") {
              if (afterKeydown)
                return val.substring(0, text.selectionEnd);
              val = val.slice(0, -1);
              host.session.replace(r, val);
              return "";
            }
          }
          return newVal;
        });
      };
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        spellcheck: {
          set: function(val) {
            var text = this.textInput.getElement();
            text.spellcheck = !!val;
            if (!val)
              this.removeListener("nativecontextmenu", exports2.contextMenuHandler);
            else
              this.on("nativecontextmenu", exports2.contextMenuHandler);
          },
          value: true
        }
      });
    });
    (function() {
      ace.require(["ace/ext/spellcheck"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-split.js
var require_ext_split = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-split.js"(exports, module2) {
    ace.define("ace/split", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/editor", "ace/virtual_renderer", "ace/edit_session"], function(require3, exports2, module3) {
      "use strict";
      var oop = require3("./lib/oop");
      var lang = require3("./lib/lang");
      var EventEmitter = require3("./lib/event_emitter").EventEmitter;
      var Editor = require3("./editor").Editor;
      var Renderer = require3("./virtual_renderer").VirtualRenderer;
      var EditSession = require3("./edit_session").EditSession;
      var Split;
      Split = function(container, theme, splits) {
        this.BELOW = 1;
        this.BESIDE = 0;
        this.$container = container;
        this.$theme = theme;
        this.$splits = 0;
        this.$editorCSS = "";
        this.$editors = [];
        this.$orientation = this.BESIDE;
        this.setSplits(splits || 1);
        this.$cEditor = this.$editors[0];
        this.on("focus", function(editor) {
          this.$cEditor = editor;
        }.bind(this));
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$createEditor = function() {
          var el = document.createElement("div");
          el.className = this.$editorCSS;
          el.style.cssText = "position: absolute; top:0px; bottom:0px";
          this.$container.appendChild(el);
          var editor = new Editor(new Renderer(el, this.$theme));
          editor.on("focus", function() {
            this._emit("focus", editor);
          }.bind(this));
          this.$editors.push(editor);
          editor.setFontSize(this.$fontSize);
          return editor;
        };
        this.setSplits = function(splits) {
          var editor;
          if (splits < 1) {
            throw "The number of splits have to be > 0!";
          }
          if (splits == this.$splits) {
            return;
          } else if (splits > this.$splits) {
            while (this.$splits < this.$editors.length && this.$splits < splits) {
              editor = this.$editors[this.$splits];
              this.$container.appendChild(editor.container);
              editor.setFontSize(this.$fontSize);
              this.$splits++;
            }
            while (this.$splits < splits) {
              this.$createEditor();
              this.$splits++;
            }
          } else {
            while (this.$splits > splits) {
              editor = this.$editors[this.$splits - 1];
              this.$container.removeChild(editor.container);
              this.$splits--;
            }
          }
          this.resize();
        };
        this.getSplits = function() {
          return this.$splits;
        };
        this.getEditor = function(idx) {
          return this.$editors[idx];
        };
        this.getCurrentEditor = function() {
          return this.$cEditor;
        };
        this.focus = function() {
          this.$cEditor.focus();
        };
        this.blur = function() {
          this.$cEditor.blur();
        };
        this.setTheme = function(theme) {
          this.$editors.forEach(function(editor) {
            editor.setTheme(theme);
          });
        };
        this.setKeyboardHandler = function(keybinding) {
          this.$editors.forEach(function(editor) {
            editor.setKeyboardHandler(keybinding);
          });
        };
        this.forEach = function(callback, scope) {
          this.$editors.forEach(callback, scope);
        };
        this.$fontSize = "";
        this.setFontSize = function(size) {
          this.$fontSize = size;
          this.forEach(function(editor) {
            editor.setFontSize(size);
          });
        };
        this.$cloneSession = function(session) {
          var s = new EditSession(session.getDocument(), session.getMode());
          var undoManager = session.getUndoManager();
          s.setUndoManager(undoManager);
          s.setTabSize(session.getTabSize());
          s.setUseSoftTabs(session.getUseSoftTabs());
          s.setOverwrite(session.getOverwrite());
          s.setBreakpoints(session.getBreakpoints());
          s.setUseWrapMode(session.getUseWrapMode());
          s.setUseWorker(session.getUseWorker());
          s.setWrapLimitRange(session.$wrapLimitRange.min, session.$wrapLimitRange.max);
          s.$foldData = session.$cloneFoldData();
          return s;
        };
        this.setSession = function(session, idx) {
          var editor;
          if (idx == null) {
            editor = this.$cEditor;
          } else {
            editor = this.$editors[idx];
          }
          var isUsed = this.$editors.some(function(editor2) {
            return editor2.session === session;
          });
          if (isUsed) {
            session = this.$cloneSession(session);
          }
          editor.setSession(session);
          return session;
        };
        this.getOrientation = function() {
          return this.$orientation;
        };
        this.setOrientation = function(orientation) {
          if (this.$orientation == orientation) {
            return;
          }
          this.$orientation = orientation;
          this.resize();
        };
        this.resize = function() {
          var width = this.$container.clientWidth;
          var height = this.$container.clientHeight;
          var editor;
          if (this.$orientation == this.BESIDE) {
            var editorWidth = width / this.$splits;
            for (var i = 0; i < this.$splits; i++) {
              editor = this.$editors[i];
              editor.container.style.width = editorWidth + "px";
              editor.container.style.top = "0px";
              editor.container.style.left = i * editorWidth + "px";
              editor.container.style.height = height + "px";
              editor.resize();
            }
          } else {
            var editorHeight = height / this.$splits;
            for (var i = 0; i < this.$splits; i++) {
              editor = this.$editors[i];
              editor.container.style.width = width + "px";
              editor.container.style.top = i * editorHeight + "px";
              editor.container.style.left = "0px";
              editor.container.style.height = editorHeight + "px";
              editor.resize();
            }
          }
        };
      }).call(Split.prototype);
      exports2.Split = Split;
    });
    ace.define("ace/ext/split", ["require", "exports", "module", "ace/ext/split", "ace/split"], function(require3, exports2, module3) {
      "use strict";
      module3.exports = require3("../split");
    });
    (function() {
      ace.require(["ace/ext/split"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-textarea.js
var require_ext_textarea = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-textarea.js"(exports, module2) {
    ace.define("ace/ext/textarea", ["require", "exports", "module", "ace/ext/textarea", "ace/lib/event", "ace/lib/useragent", "ace/ace"], function(require3, exports2, module3) {
      "use strict";
      var event = require3("../lib/event");
      var UA = require3("../lib/useragent");
      var ace4 = require3("../ace");
      module3.exports = exports2 = ace4;
      var getCSSProperty = function(element, container, property) {
        var ret = element.style[property];
        if (!ret) {
          if (window.getComputedStyle) {
            ret = window.getComputedStyle(element, "").getPropertyValue(property);
          } else {
            ret = element.currentStyle[property];
          }
        }
        if (!ret || ret == "auto" || ret == "intrinsic") {
          ret = container.style[property];
        }
        return ret;
      };
      function applyStyles(elm, styles) {
        for (var style in styles) {
          elm.style[style] = styles[style];
        }
      }
      function setupContainer(element, getValue) {
        if (element.type != "textarea") {
          throw new Error("Textarea required!");
        }
        var parentNode = element.parentNode;
        var container = document.createElement("div");
        var resizeEvent = function() {
          var style = "position:relative;";
          [
            "margin-top",
            "margin-left",
            "margin-right",
            "margin-bottom"
          ].forEach(function(item) {
            style += item + ":" + getCSSProperty(element, container, item) + ";";
          });
          var width = getCSSProperty(element, container, "width") || element.clientWidth + "px";
          var height = getCSSProperty(element, container, "height") || element.clientHeight + "px";
          style += "height:" + height + ";width:" + width + ";";
          style += "display:inline-block;";
          container.style.cssText = style;
        };
        event.addListener(window, "resize", resizeEvent);
        resizeEvent();
        parentNode.insertBefore(container, element.nextSibling);
        while (parentNode !== document) {
          if (parentNode.tagName.toUpperCase() === "FORM") {
            var oldSumit = parentNode.onsubmit;
            parentNode.onsubmit = function(evt) {
              element.value = getValue();
              if (oldSumit) {
                oldSumit.call(this, evt);
              }
            };
            break;
          }
          parentNode = parentNode.parentNode;
        }
        return container;
      }
      exports2.transformTextarea = function(element, options) {
        var isFocused = element.autofocus || document.activeElement == element;
        var session;
        var container = setupContainer(element, function() {
          return session.getValue();
        });
        element.style.display = "none";
        container.style.background = "white";
        var editorDiv = document.createElement("div");
        applyStyles(editorDiv, {
          top: "0px",
          left: "0px",
          right: "0px",
          bottom: "0px",
          border: "1px solid gray",
          position: "absolute"
        });
        container.appendChild(editorDiv);
        var settingOpener = document.createElement("div");
        applyStyles(settingOpener, {
          position: "absolute",
          right: "0px",
          bottom: "0px",
          cursor: "nw-resize",
          border: "solid 9px",
          borderColor: "lightblue gray gray #ceade6",
          zIndex: 101
        });
        var settingDiv = document.createElement("div");
        var settingDivStyles = {
          top: "0px",
          left: "20%",
          right: "0px",
          bottom: "0px",
          position: "absolute",
          padding: "5px",
          zIndex: 100,
          color: "white",
          display: "none",
          overflow: "auto",
          fontSize: "14px",
          boxShadow: "-5px 2px 3px gray"
        };
        if (!UA.isOldIE) {
          settingDivStyles.backgroundColor = "rgba(0, 0, 0, 0.6)";
        } else {
          settingDivStyles.backgroundColor = "#333";
        }
        applyStyles(settingDiv, settingDivStyles);
        container.appendChild(settingDiv);
        options = options || exports2.defaultOptions;
        var editor = ace4.edit(editorDiv);
        session = editor.getSession();
        session.setValue(element.value || element.innerHTML);
        if (isFocused)
          editor.focus();
        container.appendChild(settingOpener);
        setupApi(editor, editorDiv, settingDiv, ace4, options);
        setupSettingPanel(settingDiv, settingOpener, editor);
        var state = "";
        event.addListener(settingOpener, "mousemove", function(e) {
          var rect = this.getBoundingClientRect();
          var x = e.clientX - rect.left, y2 = e.clientY - rect.top;
          if (x + y2 < (rect.width + rect.height) / 2) {
            this.style.cursor = "pointer";
            state = "toggle";
          } else {
            state = "resize";
            this.style.cursor = "nw-resize";
          }
        });
        event.addListener(settingOpener, "mousedown", function(e) {
          e.preventDefault();
          if (state == "toggle") {
            editor.setDisplaySettings();
            return;
          }
          container.style.zIndex = "100000";
          var rect = container.getBoundingClientRect();
          var startX = rect.width + rect.left - e.clientX;
          var startY = rect.height + rect.top - e.clientY;
          event.capture(settingOpener, function(e2) {
            container.style.width = e2.clientX - rect.left + startX + "px";
            container.style.height = e2.clientY - rect.top + startY + "px";
            editor.resize();
          }, function() {
          });
        });
        return editor;
      };
      function setupApi(editor, editorDiv, settingDiv, ace5, options) {
        function toBool(value) {
          return value === "true" || value == true;
        }
        editor.setDisplaySettings = function(display) {
          if (display == null)
            display = settingDiv.style.display == "none";
          if (display) {
            settingDiv.style.display = "block";
            settingDiv.hideButton.focus();
            editor.on("focus", function onFocus() {
              editor.removeListener("focus", onFocus);
              settingDiv.style.display = "none";
            });
          } else {
            editor.focus();
          }
        };
        editor.$setOption = editor.setOption;
        editor.$getOption = editor.getOption;
        editor.setOption = function(key, value) {
          switch (key) {
            case "mode":
              editor.$setOption("mode", "ace/mode/" + value);
              break;
            case "theme":
              editor.$setOption("theme", "ace/theme/" + value);
              break;
            case "keybindings":
              switch (value) {
                case "vim":
                  editor.setKeyboardHandler("ace/keyboard/vim");
                  break;
                case "emacs":
                  editor.setKeyboardHandler("ace/keyboard/emacs");
                  break;
                default:
                  editor.setKeyboardHandler(null);
              }
              break;
            case "wrap":
            case "fontSize":
              editor.$setOption(key, value);
              break;
            default:
              editor.$setOption(key, toBool(value));
          }
        };
        editor.getOption = function(key) {
          switch (key) {
            case "mode":
              return editor.$getOption("mode").substr("ace/mode/".length);
              break;
            case "theme":
              return editor.$getOption("theme").substr("ace/theme/".length);
              break;
            case "keybindings":
              var value = editor.getKeyboardHandler();
              switch (value && value.$id) {
                case "ace/keyboard/vim":
                  return "vim";
                case "ace/keyboard/emacs":
                  return "emacs";
                default:
                  return "ace";
              }
              break;
            default:
              return editor.$getOption(key);
          }
        };
        editor.setOptions(options);
        return editor;
      }
      function setupSettingPanel(settingDiv, settingOpener, editor) {
        var BOOL = null;
        var desc = {
          mode: "Mode:",
          wrap: "Soft Wrap:",
          theme: "Theme:",
          fontSize: "Font Size:",
          showGutter: "Display Gutter:",
          keybindings: "Keyboard",
          showPrintMargin: "Show Print Margin:",
          useSoftTabs: "Use Soft Tabs:",
          showInvisibles: "Show Invisibles"
        };
        var optionValues = {
          mode: {
            text: "Plain",
            javascript: "JavaScript",
            xml: "XML",
            html: "HTML",
            css: "CSS",
            scss: "SCSS",
            python: "Python",
            php: "PHP",
            java: "Java",
            ruby: "Ruby",
            c_cpp: "C/C++",
            coffee: "CoffeeScript",
            json: "json",
            perl: "Perl",
            clojure: "Clojure",
            ocaml: "OCaml",
            csharp: "C#",
            haxe: "haXe",
            svg: "SVG",
            textile: "Textile",
            groovy: "Groovy",
            liquid: "Liquid",
            Scala: "Scala"
          },
          theme: {
            clouds: "Clouds",
            clouds_midnight: "Clouds Midnight",
            cobalt: "Cobalt",
            crimson_editor: "Crimson Editor",
            dawn: "Dawn",
            gob: "Green on Black",
            eclipse: "Eclipse",
            idle_fingers: "Idle Fingers",
            kr_theme: "Kr Theme",
            merbivore: "Merbivore",
            merbivore_soft: "Merbivore Soft",
            mono_industrial: "Mono Industrial",
            monokai: "Monokai",
            pastel_on_dark: "Pastel On Dark",
            solarized_dark: "Solarized Dark",
            solarized_light: "Solarized Light",
            textmate: "Textmate",
            twilight: "Twilight",
            vibrant_ink: "Vibrant Ink"
          },
          showGutter: BOOL,
          fontSize: {
            "10px": "10px",
            "11px": "11px",
            "12px": "12px",
            "14px": "14px",
            "16px": "16px"
          },
          wrap: {
            off: "Off",
            40: "40",
            80: "80",
            free: "Free"
          },
          keybindings: {
            ace: "ace",
            vim: "vim",
            emacs: "emacs"
          },
          showPrintMargin: BOOL,
          useSoftTabs: BOOL,
          showInvisibles: BOOL
        };
        var table = [];
        table.push("<table><tr><th>Setting</th><th>Value</th></tr>");
        function renderOption(builder, option2, obj, cValue) {
          if (!obj) {
            builder.push("<input type='checkbox' title='", option2, "' ", cValue + "" == "true" ? "checked='true'" : "", "'></input>");
            return;
          }
          builder.push("<select title='" + option2 + "'>");
          for (var value in obj) {
            builder.push("<option value='" + value + "' ");
            if (cValue == value) {
              builder.push(" selected ");
            }
            builder.push(">", obj[value], "</option>");
          }
          builder.push("</select>");
        }
        for (var option in exports2.defaultOptions) {
          table.push("<tr><td>", desc[option], "</td>");
          table.push("<td>");
          renderOption(table, option, optionValues[option], editor.getOption(option));
          table.push("</td></tr>");
        }
        table.push("</table>");
        settingDiv.innerHTML = table.join("");
        var onChange = function(e) {
          var select = e.currentTarget;
          editor.setOption(select.title, select.value);
        };
        var onClick = function(e) {
          var cb = e.currentTarget;
          editor.setOption(cb.title, cb.checked);
        };
        var selects = settingDiv.getElementsByTagName("select");
        for (var i = 0; i < selects.length; i++)
          selects[i].onchange = onChange;
        var cbs = settingDiv.getElementsByTagName("input");
        for (var i = 0; i < cbs.length; i++)
          cbs[i].onclick = onClick;
        var button = document.createElement("input");
        button.type = "button";
        button.value = "Hide";
        event.addListener(button, "click", function() {
          editor.setDisplaySettings(false);
        });
        settingDiv.appendChild(button);
        settingDiv.hideButton = button;
      }
      exports2.defaultOptions = {
        mode: "javascript",
        theme: "textmate",
        wrap: "off",
        fontSize: "12px",
        showGutter: "false",
        keybindings: "ace",
        showPrintMargin: "false",
        useSoftTabs: "true",
        showInvisibles: "false"
      };
    });
    (function() {
      ace.require(["ace/ext/textarea"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-themelist.js
var require_ext_themelist = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-themelist.js"(exports, module2) {
    ace.define("ace/ext/themelist", ["require", "exports", "module"], function(require3, exports2, module3) {
      "use strict";
      var themeData = [
        ["Chrome"],
        ["Clouds"],
        ["Crimson Editor"],
        ["Dawn"],
        ["Dreamweaver"],
        ["Eclipse"],
        ["GitHub Light Default"],
        ["GitHub (Legacy)", "github", "light"],
        ["IPlastic"],
        ["Solarized Light"],
        ["TextMate"],
        ["Tomorrow"],
        ["XCode"],
        ["Kuroir"],
        ["KatzenMilch"],
        ["SQL Server", "sqlserver", "light"],
        ["CloudEditor", "cloud_editor", "light"],
        ["Ambiance", "ambiance", "dark"],
        ["Chaos", "chaos", "dark"],
        ["Clouds Midnight", "clouds_midnight", "dark"],
        ["Dracula", "", "dark"],
        ["Cobalt", "cobalt", "dark"],
        ["Gruvbox", "gruvbox", "dark"],
        ["Green on Black", "gob", "dark"],
        ["idle Fingers", "idle_fingers", "dark"],
        ["krTheme", "kr_theme", "dark"],
        ["Merbivore", "merbivore", "dark"],
        ["Merbivore Soft", "merbivore_soft", "dark"],
        ["Mono Industrial", "mono_industrial", "dark"],
        ["Monokai", "monokai", "dark"],
        ["Nord Dark", "nord_dark", "dark"],
        ["One Dark", "one_dark", "dark"],
        ["Pastel on dark", "pastel_on_dark", "dark"],
        ["Solarized Dark", "solarized_dark", "dark"],
        ["Terminal", "terminal", "dark"],
        ["Tomorrow Night", "tomorrow_night", "dark"],
        ["Tomorrow Night Blue", "tomorrow_night_blue", "dark"],
        ["Tomorrow Night Bright", "tomorrow_night_bright", "dark"],
        ["Tomorrow Night 80s", "tomorrow_night_eighties", "dark"],
        ["Twilight", "twilight", "dark"],
        ["Vibrant Ink", "vibrant_ink", "dark"],
        ["GitHub Dark", "github_dark", "dark"],
        ["CloudEditor Dark", "cloud_editor_dark", "dark"]
      ];
      exports2.themesByName = {};
      exports2.themes = themeData.map(function(data) {
        var name = data[1] || data[0].replace(/ /g, "_").toLowerCase();
        var theme = {
          caption: data[0],
          theme: "ace/theme/" + name,
          isDark: data[2] == "dark",
          name
        };
        exports2.themesByName[name] = theme;
        return theme;
      });
    });
    (function() {
      ace.require(["ace/ext/themelist"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/ext-whitespace.js
var require_ext_whitespace = __commonJS({
  "node_modules/ace-builds/src-noconflict/ext-whitespace.js"(exports, module2) {
    ace.define("ace/ext/whitespace", ["require", "exports", "module", "ace/lib/lang"], function(require3, exports2, module3) {
      "use strict";
      var lang = require3("../lib/lang");
      exports2.$detectIndentation = function(lines, fallback) {
        var stats = [];
        var changes = [];
        var tabIndents = 0;
        var prevSpaces = 0;
        var max = Math.min(lines.length, 1e3);
        for (var i = 0; i < max; i++) {
          var line = lines[i];
          if (!/^\s*[^*+\-\s]/.test(line))
            continue;
          if (line[0] == "	") {
            tabIndents++;
            prevSpaces = -Number.MAX_VALUE;
          } else {
            var spaces = line.match(/^ */)[0].length;
            if (spaces && line[spaces] != "	") {
              var diff = spaces - prevSpaces;
              if (diff > 0 && !(prevSpaces % diff) && !(spaces % diff))
                changes[diff] = (changes[diff] || 0) + 1;
              stats[spaces] = (stats[spaces] || 0) + 1;
            }
            prevSpaces = spaces;
          }
          while (i < max && line[line.length - 1] == "\\")
            line = lines[i++];
        }
        function getScore(indent) {
          var score2 = 0;
          for (var i2 = indent; i2 < stats.length; i2 += indent)
            score2 += stats[i2] || 0;
          return score2;
        }
        var changesTotal = changes.reduce(function(a, b2) {
          return a + b2;
        }, 0);
        var first = { score: 0, length: 0 };
        var spaceIndents = 0;
        for (var i = 1; i < 12; i++) {
          var score = getScore(i);
          if (i == 1) {
            spaceIndents = score;
            score = stats[1] ? 0.9 : 0.8;
            if (!stats.length)
              score = 0;
          } else
            score /= spaceIndents;
          if (changes[i])
            score += changes[i] / changesTotal;
          if (score > first.score)
            first = { score, length: i };
        }
        if (first.score && first.score > 1.4)
          var tabLength = first.length;
        if (tabIndents > spaceIndents + 1) {
          if (tabLength == 1 || spaceIndents < tabIndents / 4 || first.score < 1.8)
            tabLength = void 0;
          return { ch: "	", length: tabLength };
        }
        if (spaceIndents > tabIndents + 1)
          return { ch: " ", length: tabLength };
      };
      exports2.detectIndentation = function(session) {
        var lines = session.getLines(0, 1e3);
        var indent = exports2.$detectIndentation(lines) || {};
        if (indent.ch)
          session.setUseSoftTabs(indent.ch == " ");
        if (indent.length)
          session.setTabSize(indent.length);
        return indent;
      };
      exports2.trimTrailingSpace = function(session, options) {
        var doc = session.getDocument();
        var lines = doc.getAllLines();
        var min2 = options && options.trimEmpty ? -1 : 0;
        var cursors = [], ci2 = -1;
        if (options && options.keepCursorPosition) {
          if (session.selection.rangeCount) {
            session.selection.rangeList.ranges.forEach(function(x, i2, ranges) {
              var next = ranges[i2 + 1];
              if (next && next.cursor.row == x.cursor.row)
                return;
              cursors.push(x.cursor);
            });
          } else {
            cursors.push(session.selection.getCursor());
          }
          ci2 = 0;
        }
        var cursorRow = cursors[ci2] && cursors[ci2].row;
        for (var i = 0, l = lines.length; i < l; i++) {
          var line = lines[i];
          var index = line.search(/\s+$/);
          if (i == cursorRow) {
            if (index < cursors[ci2].column && index > min2)
              index = cursors[ci2].column;
            ci2++;
            cursorRow = cursors[ci2] ? cursors[ci2].row : -1;
          }
          if (index > min2)
            doc.removeInLine(i, index, line.length);
        }
      };
      exports2.convertIndentation = function(session, ch, len) {
        var oldCh = session.getTabString()[0];
        var oldLen = session.getTabSize();
        if (!len)
          len = oldLen;
        if (!ch)
          ch = oldCh;
        var tab = ch == "	" ? ch : lang.stringRepeat(ch, len);
        var doc = session.doc;
        var lines = doc.getAllLines();
        var cache = {};
        var spaceCache = {};
        for (var i = 0, l = lines.length; i < l; i++) {
          var line = lines[i];
          var match = line.match(/^\s*/)[0];
          if (match) {
            var w2 = session.$getStringScreenWidth(match)[0];
            var tabCount = Math.floor(w2 / oldLen);
            var reminder = w2 % oldLen;
            var toInsert = cache[tabCount] || (cache[tabCount] = lang.stringRepeat(tab, tabCount));
            toInsert += spaceCache[reminder] || (spaceCache[reminder] = lang.stringRepeat(" ", reminder));
            if (toInsert != match) {
              doc.removeInLine(i, 0, match.length);
              doc.insertInLine({ row: i, column: 0 }, toInsert);
            }
          }
        }
        session.setTabSize(len);
        session.setUseSoftTabs(ch == " ");
      };
      exports2.$parseStringArg = function(text) {
        var indent = {};
        if (/t/.test(text))
          indent.ch = "	";
        else if (/s/.test(text))
          indent.ch = " ";
        var m = text.match(/\d+/);
        if (m)
          indent.length = parseInt(m[0], 10);
        return indent;
      };
      exports2.$parseArg = function(arg) {
        if (!arg)
          return {};
        if (typeof arg == "string")
          return exports2.$parseStringArg(arg);
        if (typeof arg.text == "string")
          return exports2.$parseStringArg(arg.text);
        return arg;
      };
      exports2.commands = [{
        name: "detectIndentation",
        description: "Detect indentation from content",
        exec: function(editor) {
          exports2.detectIndentation(editor.session);
        }
      }, {
        name: "trimTrailingSpace",
        description: "Trim trailing whitespace",
        exec: function(editor, args) {
          exports2.trimTrailingSpace(editor.session, args);
        }
      }, {
        name: "convertIndentation",
        description: "Convert indentation to ...",
        exec: function(editor, arg) {
          var indent = exports2.$parseArg(arg);
          exports2.convertIndentation(editor.session, indent.ch, indent.length);
        }
      }, {
        name: "setIndentation",
        description: "Set indentation",
        exec: function(editor, arg) {
          var indent = exports2.$parseArg(arg);
          indent.length && editor.session.setTabSize(indent.length);
          indent.ch && editor.session.setUseSoftTabs(indent.ch == " ");
        }
      }];
    });
    (function() {
      ace.require(["ace/ext/whitespace"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/keybinding-emacs.js
var require_keybinding_emacs = __commonJS({
  "node_modules/ace-builds/src-noconflict/keybinding-emacs.js"(exports, module2) {
    ace.define("ace/occur", ["require", "exports", "module", "ace/lib/oop", "ace/search", "ace/edit_session", "ace/search_highlight", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var oop = require3("./lib/oop");
      var Search = require3("./search").Search;
      var EditSession = require3("./edit_session").EditSession;
      var SearchHighlight = require3("./search_highlight").SearchHighlight;
      var Occur = (
        /** @class */
        function(_super) {
          __extends(Occur2, _super);
          function Occur2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          Occur2.prototype.enter = function(editor, options) {
            if (!options.needle)
              return false;
            var pos = editor.getCursorPosition();
            this.displayOccurContent(editor, options);
            var translatedPos = this.originalToOccurPosition(editor.session, pos);
            editor.moveCursorToPosition(translatedPos);
            return true;
          };
          Occur2.prototype.exit = function(editor, options) {
            var pos = options.translatePosition && editor.getCursorPosition();
            var translatedPos = pos && this.occurToOriginalPosition(editor.session, pos);
            this.displayOriginalContent(editor);
            if (translatedPos)
              editor.moveCursorToPosition(translatedPos);
            return true;
          };
          Occur2.prototype.highlight = function(sess, regexp) {
            var hl2 = sess.$occurHighlight = sess.$occurHighlight || sess.addDynamicMarker(new SearchHighlight(null, "ace_occur-highlight", "text"));
            hl2.setRegexp(regexp);
            sess._emit("changeBackMarker");
          };
          Occur2.prototype.displayOccurContent = function(editor, options) {
            this.$originalSession = editor.session;
            var found = this.matchingLines(editor.session, options);
            var lines = found.map(function(foundLine) {
              return foundLine.content;
            });
            var occurSession = new EditSession(lines.join("\n"));
            occurSession.$occur = this;
            occurSession.$occurMatchingLines = found;
            editor.setSession(occurSession);
            this.$useEmacsStyleLineStart = this.$originalSession.$useEmacsStyleLineStart;
            occurSession.$useEmacsStyleLineStart = this.$useEmacsStyleLineStart;
            this.highlight(occurSession, options.re);
            occurSession._emit("changeBackMarker");
          };
          Occur2.prototype.displayOriginalContent = function(editor) {
            editor.setSession(this.$originalSession);
            this.$originalSession.$useEmacsStyleLineStart = this.$useEmacsStyleLineStart;
          };
          Occur2.prototype.originalToOccurPosition = function(session, pos) {
            var lines = session.$occurMatchingLines;
            var nullPos = { row: 0, column: 0 };
            if (!lines)
              return nullPos;
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].row === pos.row)
                return { row: i, column: pos.column };
            }
            return nullPos;
          };
          Occur2.prototype.occurToOriginalPosition = function(session, pos) {
            var lines = session.$occurMatchingLines;
            if (!lines || !lines[pos.row])
              return pos;
            return { row: lines[pos.row].row, column: pos.column };
          };
          Occur2.prototype.matchingLines = function(session, options) {
            options = oop.mixin({}, options);
            if (!session || !options.needle)
              return [];
            var search = new Search();
            search.set(options);
            return search.findAll(session).reduce(function(lines, range) {
              var row = range.start.row;
              var last = lines[lines.length - 1];
              return last && last.row === row ? lines : lines.concat({ row, content: session.getLine(row) });
            }, []);
          };
          return Occur2;
        }(Search)
      );
      var dom = require3("./lib/dom");
      dom.importCssString(".ace_occur-highlight {\n    border-radius: 4px;\n    background-color: rgba(87, 255, 8, 0.25);\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n    box-shadow: 0 0 4px rgb(91, 255, 50);\n}\n.ace_dark .ace_occur-highlight {\n    background-color: rgb(80, 140, 85);\n    box-shadow: 0 0 4px rgb(60, 120, 70);\n}\n", "incremental-occur-highlighting", false);
      exports2.Occur = Occur;
    });
    ace.define("ace/commands/occur_commands", ["require", "exports", "module", "ace/config", "ace/occur", "ace/keyboard/hash_handler", "ace/lib/oop"], function(require3, exports2, module3) {
      var config = require3("../config"), Occur = require3("../occur").Occur;
      var occurStartCommand = {
        name: "occur",
        exec: function(editor, options) {
          var alreadyInOccur = !!editor.session.$occur;
          var occurSessionActive = new Occur().enter(editor, options);
          if (occurSessionActive && !alreadyInOccur)
            OccurKeyboardHandler.installIn(editor);
        },
        readOnly: true
      };
      var occurCommands = [{
        name: "occurexit",
        bindKey: "esc|Ctrl-G",
        exec: function(editor) {
          var occur = editor.session.$occur;
          if (!occur)
            return;
          occur.exit(editor, {});
          if (!editor.session.$occur)
            OccurKeyboardHandler.uninstallFrom(editor);
        },
        readOnly: true
      }, {
        name: "occuraccept",
        bindKey: "enter",
        exec: function(editor) {
          var occur = editor.session.$occur;
          if (!occur)
            return;
          occur.exit(editor, { translatePosition: true });
          if (!editor.session.$occur)
            OccurKeyboardHandler.uninstallFrom(editor);
        },
        readOnly: true
      }];
      var HashHandler = require3("../keyboard/hash_handler").HashHandler;
      var oop = require3("../lib/oop");
      function OccurKeyboardHandler() {
      }
      oop.inherits(OccurKeyboardHandler, HashHandler);
      (function() {
        this.isOccurHandler = true;
        this.attach = function(editor) {
          HashHandler.call(this, occurCommands, editor.commands.platform);
          this.$editor = editor;
        };
        var handleKeyboard$super = this.handleKeyboard;
        this.handleKeyboard = function(data, hashId, key, keyCode) {
          var cmd = handleKeyboard$super.call(this, data, hashId, key, keyCode);
          return cmd && cmd.command ? cmd : void 0;
        };
      }).call(OccurKeyboardHandler.prototype);
      OccurKeyboardHandler.installIn = function(editor) {
        var handler = new this();
        editor.keyBinding.addKeyboardHandler(handler);
        editor.commands.addCommands(occurCommands);
      };
      OccurKeyboardHandler.uninstallFrom = function(editor) {
        editor.commands.removeCommands(occurCommands);
        var handler = editor.getKeyboardHandler();
        if (handler.isOccurHandler)
          editor.keyBinding.removeKeyboardHandler(handler);
      };
      exports2.occurStartCommand = occurStartCommand;
    });
    ace.define("ace/commands/incremental_search_commands", ["require", "exports", "module", "ace/config", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/commands/occur_commands"], function(require3, exports2, module3) {
      var config = require3("../config");
      var oop = require3("../lib/oop");
      var HashHandler = require3("../keyboard/hash_handler").HashHandler;
      var occurStartCommand = require3("./occur_commands").occurStartCommand;
      exports2.iSearchStartCommands = [{
        name: "iSearch",
        bindKey: { win: "Ctrl-F", mac: "Command-F" },
        exec: function(editor, options) {
          config.loadModule(["core", "ace/incremental_search"], function(e) {
            var iSearch = e.iSearch = e.iSearch || new e.IncrementalSearch();
            iSearch.activate(editor, options.backwards);
            if (options.jumpToFirstMatch)
              iSearch.next(options);
          });
        },
        readOnly: true
      }, {
        name: "iSearchBackwards",
        exec: function(editor, jumpToNext) {
          editor.execCommand("iSearch", { backwards: true });
        },
        readOnly: true
      }, {
        name: "iSearchAndGo",
        bindKey: { win: "Ctrl-K", mac: "Command-G" },
        exec: function(editor, jumpToNext) {
          editor.execCommand("iSearch", { jumpToFirstMatch: true, useCurrentOrPrevSearch: true });
        },
        readOnly: true
      }, {
        name: "iSearchBackwardsAndGo",
        bindKey: { win: "Ctrl-Shift-K", mac: "Command-Shift-G" },
        exec: function(editor) {
          editor.execCommand("iSearch", { jumpToFirstMatch: true, backwards: true, useCurrentOrPrevSearch: true });
        },
        readOnly: true
      }];
      exports2.iSearchCommands = [{
        name: "restartSearch",
        bindKey: { win: "Ctrl-F", mac: "Command-F" },
        exec: function(iSearch) {
          iSearch.cancelSearch(true);
        }
      }, {
        name: "searchForward",
        bindKey: { win: "Ctrl-S|Ctrl-K", mac: "Ctrl-S|Command-G" },
        exec: function(iSearch, options) {
          options.useCurrentOrPrevSearch = true;
          iSearch.next(options);
        }
      }, {
        name: "searchBackward",
        bindKey: { win: "Ctrl-R|Ctrl-Shift-K", mac: "Ctrl-R|Command-Shift-G" },
        exec: function(iSearch, options) {
          options.useCurrentOrPrevSearch = true;
          options.backwards = true;
          iSearch.next(options);
        }
      }, {
        name: "extendSearchTerm",
        exec: function(iSearch, string) {
          iSearch.addString(string);
        }
      }, {
        name: "extendSearchTermSpace",
        bindKey: "space",
        exec: function(iSearch) {
          iSearch.addString(" ");
        }
      }, {
        name: "shrinkSearchTerm",
        bindKey: "backspace",
        exec: function(iSearch) {
          iSearch.removeChar();
        }
      }, {
        name: "confirmSearch",
        bindKey: "return",
        exec: function(iSearch) {
          iSearch.deactivate();
        }
      }, {
        name: "cancelSearch",
        bindKey: "esc|Ctrl-G",
        exec: function(iSearch) {
          iSearch.deactivate(true);
        }
      }, {
        name: "occurisearch",
        bindKey: "Ctrl-O",
        exec: function(iSearch) {
          var options = oop.mixin({}, iSearch.$options);
          iSearch.deactivate();
          occurStartCommand.exec(iSearch.$editor, options);
        }
      }, {
        name: "yankNextWord",
        bindKey: "Ctrl-w",
        exec: function(iSearch) {
          var ed = iSearch.$editor, range = ed.selection.getRangeOfMovements(function(sel) {
            sel.moveCursorWordRight();
          }), string = ed.session.getTextRange(range);
          iSearch.addString(string);
        }
      }, {
        name: "yankNextChar",
        bindKey: "Ctrl-Alt-y",
        exec: function(iSearch) {
          var ed = iSearch.$editor, range = ed.selection.getRangeOfMovements(function(sel) {
            sel.moveCursorRight();
          }), string = ed.session.getTextRange(range);
          iSearch.addString(string);
        }
      }, {
        name: "recenterTopBottom",
        bindKey: "Ctrl-l",
        exec: function(iSearch) {
          iSearch.$editor.execCommand("recenterTopBottom");
        }
      }, {
        name: "selectAllMatches",
        bindKey: "Ctrl-space",
        exec: function(iSearch) {
          var ed = iSearch.$editor, hl2 = ed.session.$isearchHighlight, ranges = hl2 && hl2.cache ? hl2.cache.reduce(function(ranges2, ea) {
            return ranges2.concat(ea ? ea : []);
          }, []) : [];
          iSearch.deactivate(false);
          ranges.forEach(ed.selection.addRange.bind(ed.selection));
        }
      }, {
        name: "searchAsRegExp",
        bindKey: "Alt-r",
        exec: function(iSearch) {
          iSearch.convertNeedleToRegExp();
        }
      }].map(function(cmd) {
        cmd.readOnly = true;
        cmd.isIncrementalSearchCommand = true;
        cmd.scrollIntoView = "animate-cursor";
        return cmd;
      });
      function IncrementalSearchKeyboardHandler(iSearch) {
        this.$iSearch = iSearch;
      }
      oop.inherits(IncrementalSearchKeyboardHandler, HashHandler);
      (function() {
        this.attach = function(editor) {
          var iSearch = this.$iSearch;
          HashHandler.call(this, exports2.iSearchCommands, editor.commands.platform);
          this.$commandExecHandler = editor.commands.on("exec", function(e) {
            if (!e.command.isIncrementalSearchCommand)
              return iSearch.deactivate();
            e.stopPropagation();
            e.preventDefault();
            var scrollTop = editor.session.getScrollTop();
            var result = e.command.exec(iSearch, e.args || {});
            editor.renderer.scrollCursorIntoView(null, 0.5);
            editor.renderer.animateScrolling(scrollTop);
            return result;
          });
        };
        this.detach = function(editor) {
          if (!this.$commandExecHandler)
            return;
          editor.commands.off("exec", this.$commandExecHandler);
          delete this.$commandExecHandler;
        };
        var handleKeyboard$super = this.handleKeyboard;
        this.handleKeyboard = function(data, hashId, key, keyCode) {
          if ((hashId === 1 || hashId === 8) && key === "v" || hashId === 1 && key === "y")
            return null;
          var cmd = handleKeyboard$super.call(this, data, hashId, key, keyCode);
          if (cmd && cmd.command) {
            return cmd;
          }
          if (hashId == -1) {
            var extendCmd = this.commands.extendSearchTerm;
            if (extendCmd) {
              return { command: extendCmd, args: key };
            }
          }
          return false;
        };
      }).call(IncrementalSearchKeyboardHandler.prototype);
      exports2.IncrementalSearchKeyboardHandler = IncrementalSearchKeyboardHandler;
    });
    ace.define("ace/incremental_search", ["require", "exports", "module", "ace/range", "ace/search", "ace/search_highlight", "ace/commands/incremental_search_commands", "ace/lib/dom", "ace/commands/command_manager", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        };
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var Range = require3("./range").Range;
      var Search = require3("./search").Search;
      var SearchHighlight = require3("./search_highlight").SearchHighlight;
      var iSearchCommandModule = require3("./commands/incremental_search_commands");
      var ISearchKbd = iSearchCommandModule.IncrementalSearchKeyboardHandler;
      function isRegExp(obj) {
        return obj instanceof RegExp;
      }
      function regExpToObject(re3) {
        var string = String(re3), start = string.indexOf("/"), flagStart = string.lastIndexOf("/");
        return {
          expression: string.slice(start + 1, flagStart),
          flags: string.slice(flagStart + 1)
        };
      }
      function stringToRegExp(string, flags) {
        try {
          return new RegExp(string, flags);
        } catch (e) {
          return string;
        }
      }
      function objectToRegExp(obj) {
        return stringToRegExp(obj.expression, obj.flags);
      }
      var IncrementalSearch = (
        /** @class */
        function(_super) {
          __extends(IncrementalSearch2, _super);
          function IncrementalSearch2() {
            var _this = _super.call(this) || this;
            _this.$options = { wrap: false, skipCurrent: false };
            _this.$keyboardHandler = new ISearchKbd(_this);
            return _this;
          }
          IncrementalSearch2.prototype.activate = function(editor, backwards) {
            this.$editor = editor;
            this.$startPos = this.$currentPos = editor.getCursorPosition();
            this.$options.needle = "";
            this.$options.backwards = backwards;
            editor.keyBinding.addKeyboardHandler(this.$keyboardHandler);
            this.$originalEditorOnPaste = editor.onPaste;
            editor.onPaste = this.onPaste.bind(this);
            this.$mousedownHandler = editor.on("mousedown", this.onMouseDown.bind(this));
            this.selectionFix(editor);
            this.statusMessage(true);
          };
          IncrementalSearch2.prototype.deactivate = function(reset) {
            this.cancelSearch(reset);
            var editor = this.$editor;
            editor.keyBinding.removeKeyboardHandler(this.$keyboardHandler);
            if (this.$mousedownHandler) {
              editor.off("mousedown", this.$mousedownHandler);
              delete this.$mousedownHandler;
            }
            editor.onPaste = this.$originalEditorOnPaste;
            this.message("");
          };
          IncrementalSearch2.prototype.selectionFix = function(editor) {
            if (editor.selection.isEmpty() && !editor.session.$emacsMark) {
              editor.clearSelection();
            }
          };
          IncrementalSearch2.prototype.highlight = function(regexp) {
            var sess = this.$editor.session, hl2 = sess.$isearchHighlight = sess.$isearchHighlight || sess.addDynamicMarker(new SearchHighlight(null, "ace_isearch-result", "text"));
            hl2.setRegexp(regexp);
            sess._emit("changeBackMarker");
          };
          IncrementalSearch2.prototype.cancelSearch = function(reset) {
            var e = this.$editor;
            this.$prevNeedle = this.$options.needle;
            this.$options.needle = "";
            if (reset) {
              e.moveCursorToPosition(this.$startPos);
              this.$currentPos = this.$startPos;
            } else {
              e.pushEmacsMark && e.pushEmacsMark(this.$startPos, false);
            }
            this.highlight(null);
            return Range.fromPoints(this.$currentPos, this.$currentPos);
          };
          IncrementalSearch2.prototype.highlightAndFindWithNeedle = function(moveToNext, needleUpdateFunc) {
            if (!this.$editor)
              return null;
            var options = this.$options;
            if (needleUpdateFunc) {
              options.needle = needleUpdateFunc.call(this, options.needle || "") || "";
            }
            if (options.needle.length === 0) {
              this.statusMessage(true);
              return this.cancelSearch(true);
            }
            options.start = this.$currentPos;
            var session = this.$editor.session, found = this.find(session), shouldSelect = this.$editor.emacsMark ? !!this.$editor.emacsMark() : !this.$editor.selection.isEmpty();
            if (found) {
              if (options.backwards)
                found = Range.fromPoints(found.end, found.start);
              this.$editor.selection.setRange(Range.fromPoints(shouldSelect ? this.$startPos : found.end, found.end));
              if (moveToNext)
                this.$currentPos = found.end;
              this.highlight(options.re);
            }
            this.statusMessage(found);
            return found;
          };
          IncrementalSearch2.prototype.addString = function(s) {
            return this.highlightAndFindWithNeedle(false, function(needle) {
              if (!isRegExp(needle))
                return needle + s;
              var reObj = regExpToObject(needle);
              reObj.expression += s;
              return objectToRegExp(reObj);
            });
          };
          IncrementalSearch2.prototype.removeChar = function(c) {
            return this.highlightAndFindWithNeedle(false, function(needle) {
              if (!isRegExp(needle))
                return needle.substring(0, needle.length - 1);
              var reObj = regExpToObject(needle);
              reObj.expression = reObj.expression.substring(0, reObj.expression.length - 1);
              return objectToRegExp(reObj);
            });
          };
          IncrementalSearch2.prototype.next = function(options) {
            options = options || {};
            this.$options.backwards = !!options.backwards;
            this.$currentPos = this.$editor.getCursorPosition();
            return this.highlightAndFindWithNeedle(true, function(needle) {
              return options.useCurrentOrPrevSearch && needle.length === 0 ? this.$prevNeedle || "" : needle;
            });
          };
          IncrementalSearch2.prototype.onMouseDown = function(evt) {
            this.deactivate();
            return true;
          };
          IncrementalSearch2.prototype.onPaste = function(text) {
            this.addString(text);
          };
          IncrementalSearch2.prototype.convertNeedleToRegExp = function() {
            return this.highlightAndFindWithNeedle(false, function(needle) {
              return isRegExp(needle) ? needle : stringToRegExp(needle, "ig");
            });
          };
          IncrementalSearch2.prototype.convertNeedleToString = function() {
            return this.highlightAndFindWithNeedle(false, function(needle) {
              return isRegExp(needle) ? regExpToObject(needle).expression : needle;
            });
          };
          IncrementalSearch2.prototype.statusMessage = function(found) {
            var options = this.$options, msg = "";
            msg += options.backwards ? "reverse-" : "";
            msg += "isearch: " + options.needle;
            msg += found ? "" : " (not found)";
            this.message(msg);
          };
          IncrementalSearch2.prototype.message = function(msg) {
            if (this.$editor.showCommandLine) {
              this.$editor.showCommandLine(msg);
              this.$editor.focus();
            }
          };
          return IncrementalSearch2;
        }(Search)
      );
      exports2.IncrementalSearch = IncrementalSearch;
      var dom = require3("./lib/dom");
      dom.importCssString("\n.ace_marker-layer .ace_isearch-result {\n  position: absolute;\n  z-index: 6;\n  box-sizing: border-box;\n}\ndiv.ace_isearch-result {\n  border-radius: 4px;\n  background-color: rgba(255, 200, 0, 0.5);\n  box-shadow: 0 0 4px rgb(255, 200, 0);\n}\n.ace_dark div.ace_isearch-result {\n  background-color: rgb(100, 110, 160);\n  box-shadow: 0 0 4px rgb(80, 90, 140);\n}", "incremental-search-highlighting", false);
      var commands = require3("./commands/command_manager");
      (function() {
        this.setupIncrementalSearch = function(editor, val) {
          if (this.usesIncrementalSearch == val)
            return;
          this.usesIncrementalSearch = val;
          var iSearchCommands = iSearchCommandModule.iSearchStartCommands;
          var method = val ? "addCommands" : "removeCommands";
          this[method](iSearchCommands);
        };
      }).call(commands.CommandManager.prototype);
      var Editor = require3("./editor").Editor;
      require3("./config").defineOptions(Editor.prototype, "editor", {
        useIncrementalSearch: {
          set: function(val) {
            this.keyBinding.$handlers.forEach(function(handler) {
              if (handler.setupIncrementalSearch) {
                handler.setupIncrementalSearch(this, val);
              }
            });
            this._emit("incrementalSearchSettingChanged", { isEnabled: val });
          }
        }
      });
    });
    ace.define("ace/keyboard/emacs", ["require", "exports", "module", "ace/lib/dom", "ace/incremental_search", "ace/commands/incremental_search_commands", "ace/keyboard/hash_handler", "ace/lib/keys"], function(require3, exports2, module3) {
      "use strict";
      var dom = require3("../lib/dom");
      require3("../incremental_search");
      var iSearchCommandModule = require3("../commands/incremental_search_commands");
      var HashHandler = require3("./hash_handler").HashHandler;
      exports2.handler = new HashHandler();
      exports2.handler.isEmacs = true;
      exports2.handler.$id = "ace/keyboard/emacs";
      dom.importCssString("\n.emacs-mode .ace_cursor{\n    border: 1px rgba(50,250,50,0.8) solid!important;\n    box-sizing: border-box!important;\n    background-color: rgba(0,250,0,0.9);\n    opacity: 0.5;\n}\n.emacs-mode .ace_hidden-cursors .ace_cursor{\n    opacity: 1;\n    background-color: transparent;\n}\n.emacs-mode .ace_overwrite-cursors .ace_cursor {\n    opacity: 1;\n    background-color: transparent;\n    border-width: 0 0 2px 2px !important;\n}\n.emacs-mode .ace_text-layer {\n    z-index: 4\n}\n.emacs-mode .ace_cursor-layer {\n    z-index: 2\n}", "emacsMode");
      var $formerLongWords;
      var $formerLineStart;
      exports2.handler.attach = function(editor) {
        $formerLongWords = editor.session.$selectLongWords;
        editor.session.$selectLongWords = true;
        $formerLineStart = editor.session.$useEmacsStyleLineStart;
        editor.session.$useEmacsStyleLineStart = true;
        editor.session.$emacsMark = null;
        editor.session.$emacsMarkRing = editor.session.$emacsMarkRing || [];
        editor.emacsMark = function() {
          return this.session.$emacsMark;
        };
        editor.setEmacsMark = function(p) {
          this.session.$emacsMark = p;
        };
        editor.pushEmacsMark = function(p, activate) {
          var prevMark = this.session.$emacsMark;
          if (prevMark)
            pushUnique(this.session.$emacsMarkRing, prevMark);
          if (!p || activate)
            this.setEmacsMark(p);
          else
            pushUnique(this.session.$emacsMarkRing, p);
        };
        editor.popEmacsMark = function() {
          var mark = this.emacsMark();
          if (mark) {
            this.setEmacsMark(null);
            return mark;
          }
          return this.session.$emacsMarkRing.pop();
        };
        editor.getLastEmacsMark = function(p) {
          return this.session.$emacsMark || this.session.$emacsMarkRing.slice(-1)[0];
        };
        editor.emacsMarkForSelection = function(replacement) {
          var sel = this.selection, multiRangeLength = this.multiSelect ? this.multiSelect.getAllRanges().length : 1, selIndex = sel.index || 0, markRing = this.session.$emacsMarkRing, markIndex = markRing.length - (multiRangeLength - selIndex), lastMark = markRing[markIndex] || sel.anchor;
          if (replacement) {
            markRing.splice(markIndex, 1, "row" in replacement && "column" in replacement ? replacement : void 0);
          }
          return lastMark;
        };
        editor.on("click", $resetMarkMode);
        editor.on("changeSession", $kbSessionChange);
        editor.renderer.$blockCursor = true;
        editor.setStyle("emacs-mode");
        editor.commands.addCommands(commands);
        exports2.handler.platform = editor.commands.platform;
        editor.$emacsModeHandler = this;
        editor.on("copy", this.onCopy);
        editor.on("paste", this.onPaste);
      };
      function pushUnique(ring, mark) {
        var last = ring[ring.length - 1];
        if (last && last.row === mark.row && last.column === mark.column) {
          return;
        }
        ring.push(mark);
      }
      exports2.handler.detach = function(editor) {
        editor.renderer.$blockCursor = false;
        editor.session.$selectLongWords = $formerLongWords;
        editor.session.$useEmacsStyleLineStart = $formerLineStart;
        editor.off("click", $resetMarkMode);
        editor.off("changeSession", $kbSessionChange);
        editor.unsetStyle("emacs-mode");
        editor.commands.removeCommands(commands);
        editor.off("copy", this.onCopy);
        editor.off("paste", this.onPaste);
        editor.$emacsModeHandler = null;
      };
      var $kbSessionChange = function(e) {
        if (e.oldSession) {
          e.oldSession.$selectLongWords = $formerLongWords;
          e.oldSession.$useEmacsStyleLineStart = $formerLineStart;
        }
        $formerLongWords = e.session.$selectLongWords;
        e.session.$selectLongWords = true;
        $formerLineStart = e.session.$useEmacsStyleLineStart;
        e.session.$useEmacsStyleLineStart = true;
        if (!e.session.hasOwnProperty("$emacsMark"))
          e.session.$emacsMark = null;
        if (!e.session.hasOwnProperty("$emacsMarkRing"))
          e.session.$emacsMarkRing = [];
      };
      var $resetMarkMode = function(e) {
        e.editor.session.$emacsMark = null;
      };
      var keys = require3("../lib/keys").KEY_MODS;
      var eMods = { C: "ctrl", S: "shift", M: "alt", CMD: "command" };
      var combinations = [
        "C-S-M-CMD",
        "S-M-CMD",
        "C-M-CMD",
        "C-S-CMD",
        "C-S-M",
        "M-CMD",
        "S-CMD",
        "S-M",
        "C-CMD",
        "C-M",
        "C-S",
        "CMD",
        "M",
        "S",
        "C"
      ];
      combinations.forEach(function(c) {
        var hashId = 0;
        c.split("-").forEach(function(c2) {
          hashId = hashId | keys[eMods[c2]];
        });
        eMods[hashId] = c.toLowerCase() + "-";
      });
      exports2.handler.onCopy = function(e, editor) {
        if (editor.$handlesEmacsOnCopy)
          return;
        editor.$handlesEmacsOnCopy = true;
        exports2.handler.commands.killRingSave.exec(editor);
        editor.$handlesEmacsOnCopy = false;
      };
      exports2.handler.onPaste = function(e, editor) {
        editor.pushEmacsMark(editor.getCursorPosition());
      };
      exports2.handler.bindKey = function(key, command) {
        if (typeof key == "object")
          key = key[this.platform];
        if (!key)
          return;
        var ckb = this.commandKeyBinding;
        key.split("|").forEach(function(keyPart) {
          keyPart = keyPart.toLowerCase();
          ckb[keyPart] = command;
          var keyParts = keyPart.split(" ").slice(0, -1);
          keyParts.reduce(function(keyMapKeys, keyPart2, i) {
            var prefix = keyMapKeys[i - 1] ? keyMapKeys[i - 1] + " " : "";
            return keyMapKeys.concat([prefix + keyPart2]);
          }, []).forEach(function(keyPart2) {
            if (!ckb[keyPart2])
              ckb[keyPart2] = "null";
          });
        }, this);
      };
      exports2.handler.getStatusText = function(editor, data) {
        var str = "";
        if (data.count)
          str += data.count;
        if (data.keyChain)
          str += " " + data.keyChain;
        return str;
      };
      exports2.handler.handleKeyboard = function(data, hashId, key, keyCode) {
        if (keyCode === -1)
          return void 0;
        var editor = data.editor;
        editor._signal("changeStatus");
        if (hashId == -1) {
          editor.pushEmacsMark();
          if (data.count) {
            var str = new Array(data.count + 1).join(key);
            data.count = null;
            return { command: "insertstring", args: str };
          }
        }
        var modifier = eMods[hashId];
        if (modifier == "c-" || data.count) {
          var count = parseInt(key[key.length - 1]);
          if (typeof count === "number" && !isNaN(count)) {
            data.count = Math.max(data.count, 0) || 0;
            data.count = 10 * data.count + count;
            return { command: "null" };
          }
        }
        if (modifier)
          key = modifier + key;
        if (data.keyChain)
          key = data.keyChain += " " + key;
        var command = this.commandKeyBinding[key];
        data.keyChain = command == "null" ? key : "";
        if (!command)
          return void 0;
        if (command === "null")
          return { command: "null" };
        if (command === "universalArgument") {
          data.count = -4;
          return { command: "null" };
        }
        var args;
        if (typeof command !== "string") {
          args = command.args;
          if (command.command)
            command = command.command;
          if (command === "goorselect") {
            command = editor.emacsMark() ? args[1] : args[0];
            args = null;
          }
        }
        if (typeof command === "string") {
          if (command === "insertstring" || command === "splitline" || command === "togglecomment") {
            editor.pushEmacsMark();
          }
          command = this.commands[command] || editor.commands.commands[command];
          if (!command)
            return void 0;
        }
        if (!command.readOnly && !command.isYank)
          data.lastCommand = null;
        if (!command.readOnly && editor.emacsMark())
          editor.setEmacsMark(null);
        if (data.count) {
          var count = data.count;
          data.count = 0;
          if (!command || !command.handlesCount) {
            return {
              args,
              command: {
                exec: function(editor2, args2) {
                  for (var i = 0; i < count; i++)
                    command.exec(editor2, args2);
                },
                multiSelectAction: command.multiSelectAction
              }
            };
          } else {
            if (!args)
              args = {};
            if (typeof args === "object")
              args.count = count;
          }
        }
        return { command, args };
      };
      exports2.emacsKeys = {
        "Up|C-p": { command: "goorselect", args: ["golineup", "selectup"] },
        "Down|C-n": { command: "goorselect", args: ["golinedown", "selectdown"] },
        "Left|C-b": { command: "goorselect", args: ["gotoleft", "selectleft"] },
        "Right|C-f": { command: "goorselect", args: ["gotoright", "selectright"] },
        "C-Left|M-b": { command: "goorselect", args: ["gotowordleft", "selectwordleft"] },
        "C-Right|M-f": { command: "goorselect", args: ["gotowordright", "selectwordright"] },
        "Home|C-a": { command: "goorselect", args: ["gotolinestart", "selecttolinestart"] },
        "End|C-e": { command: "goorselect", args: ["gotolineend", "selecttolineend"] },
        "C-Home|S-M-,": { command: "goorselect", args: ["gotostart", "selecttostart"] },
        "C-End|S-M-.": { command: "goorselect", args: ["gotoend", "selecttoend"] },
        "S-Up|S-C-p": "selectup",
        "S-Down|S-C-n": "selectdown",
        "S-Left|S-C-b": "selectleft",
        "S-Right|S-C-f": "selectright",
        "S-C-Left|S-M-b": "selectwordleft",
        "S-C-Right|S-M-f": "selectwordright",
        "S-Home|S-C-a": "selecttolinestart",
        "S-End|S-C-e": "selecttolineend",
        "S-C-Home": "selecttostart",
        "S-C-End": "selecttoend",
        "C-l": "recenterTopBottom",
        "M-s": "centerselection",
        "M-g": "gotoline",
        "C-x C-p": "selectall",
        "C-Down": { command: "goorselect", args: ["gotopagedown", "selectpagedown"] },
        "C-Up": { command: "goorselect", args: ["gotopageup", "selectpageup"] },
        "PageDown|C-v": { command: "goorselect", args: ["gotopagedown", "selectpagedown"] },
        "PageUp|M-v": { command: "goorselect", args: ["gotopageup", "selectpageup"] },
        "S-C-Down": "selectpagedown",
        "S-C-Up": "selectpageup",
        "C-s": "iSearch",
        "C-r": "iSearchBackwards",
        "M-C-s": "findnext",
        "M-C-r": "findprevious",
        "S-M-5": "replace",
        "Backspace": "backspace",
        "Delete|C-d": "del",
        "Return|C-m": { command: "insertstring", args: "\n" },
        // "newline"
        "C-o": "splitline",
        "M-d|C-Delete": { command: "killWord", args: "right" },
        "C-Backspace|M-Backspace|M-Delete": { command: "killWord", args: "left" },
        "C-k": "killLine",
        "C-y|S-Delete": "yank",
        "M-y": "yankRotate",
        "C-g": "keyboardQuit",
        "C-w|C-S-W": "killRegion",
        "M-w": "killRingSave",
        "C-Space": "setMark",
        "C-x C-x": "exchangePointAndMark",
        "C-t": "transposeletters",
        "M-u": "touppercase",
        // Doesn't work
        "M-l": "tolowercase",
        "M-/": "autocomplete",
        // Doesn't work
        "C-u": "universalArgument",
        "M-;": "togglecomment",
        "C-/|C-x u|S-C--|C-z": "undo",
        "S-C-/|S-C-x u|C--|S-C-z": "redo",
        // infinite undo?
        "C-x r": "selectRectangularRegion",
        "M-x": { command: "focusCommandLine", args: "M-x " }
      };
      exports2.handler.bindKeys(exports2.emacsKeys);
      exports2.handler.addCommands({
        recenterTopBottom: function(editor) {
          var renderer = editor.renderer;
          var pos = renderer.$cursorLayer.getPixelPosition();
          var h = renderer.$size.scrollerHeight - renderer.lineHeight;
          var scrollTop = renderer.scrollTop;
          if (Math.abs(pos.top - scrollTop) < 2) {
            scrollTop = pos.top - h;
          } else if (Math.abs(pos.top - scrollTop - h * 0.5) < 2) {
            scrollTop = pos.top;
          } else {
            scrollTop = pos.top - h * 0.5;
          }
          editor.session.setScrollTop(scrollTop);
        },
        selectRectangularRegion: function(editor) {
          editor.multiSelect.toggleBlockSelection();
        },
        setMark: {
          exec: function(editor, args) {
            if (args && args.count) {
              if (editor.inMultiSelectMode)
                editor.forEachSelection(moveToMark);
              else
                moveToMark();
              moveToMark();
              return;
            }
            var mark = editor.emacsMark(), ranges = editor.selection.getAllRanges(), rangePositions = ranges.map(function(r) {
              return { row: r.start.row, column: r.start.column };
            }), transientMarkModeActive = true, hasNoSelection = ranges.every(function(range) {
              return range.isEmpty();
            });
            if (transientMarkModeActive && (mark || !hasNoSelection)) {
              if (editor.inMultiSelectMode)
                editor.forEachSelection({ exec: editor.clearSelection.bind(editor) });
              else
                editor.clearSelection();
              if (mark)
                editor.pushEmacsMark(null);
              return;
            }
            if (!mark) {
              rangePositions.forEach(function(pos) {
                editor.pushEmacsMark(pos);
              });
              editor.setEmacsMark(rangePositions[rangePositions.length - 1]);
              return;
            }
            function moveToMark() {
              var mark2 = editor.popEmacsMark();
              mark2 && editor.moveCursorToPosition(mark2);
            }
          },
          readOnly: true,
          handlesCount: true
        },
        exchangePointAndMark: {
          exec: function exchangePointAndMark$exec(editor, args) {
            var sel = editor.selection;
            if (!args.count && !sel.isEmpty()) {
              sel.setSelectionRange(sel.getRange(), !sel.isBackwards());
              return;
            }
            if (args.count) {
              var pos = { row: sel.lead.row, column: sel.lead.column };
              sel.clearSelection();
              sel.moveCursorToPosition(editor.emacsMarkForSelection(pos));
            } else {
              sel.selectToPosition(editor.emacsMarkForSelection());
            }
          },
          readOnly: true,
          handlesCount: true,
          multiSelectAction: "forEach"
        },
        killWord: {
          exec: function(editor, dir) {
            editor.clearSelection();
            if (dir == "left")
              editor.selection.selectWordLeft();
            else
              editor.selection.selectWordRight();
            var range = editor.getSelectionRange();
            var text = editor.session.getTextRange(range);
            exports2.killRing.add(text);
            editor.session.remove(range);
            editor.clearSelection();
          },
          multiSelectAction: "forEach"
        },
        killLine: function(editor) {
          editor.pushEmacsMark(null);
          editor.clearSelection();
          var range = editor.getSelectionRange();
          var line = editor.session.getLine(range.start.row);
          range.end.column = line.length;
          line = line.substr(range.start.column);
          var foldLine = editor.session.getFoldLine(range.start.row);
          if (foldLine && range.end.row != foldLine.end.row) {
            range.end.row = foldLine.end.row;
            line = "x";
          }
          if (/^\s*$/.test(line)) {
            range.end.row++;
            line = editor.session.getLine(range.end.row);
            range.end.column = /^\s*$/.test(line) ? line.length : 0;
          }
          var text = editor.session.getTextRange(range);
          if (editor.prevOp.command == this)
            exports2.killRing.append(text);
          else
            exports2.killRing.add(text);
          editor.session.remove(range);
          editor.clearSelection();
        },
        yank: function(editor) {
          editor.onPaste(exports2.killRing.get() || "");
          editor.keyBinding.$data.lastCommand = "yank";
        },
        yankRotate: function(editor) {
          if (editor.keyBinding.$data.lastCommand != "yank")
            return;
          editor.undo();
          editor.session.$emacsMarkRing.pop();
          editor.onPaste(exports2.killRing.rotate());
          editor.keyBinding.$data.lastCommand = "yank";
        },
        killRegion: {
          exec: function(editor) {
            exports2.killRing.add(editor.getCopyText());
            editor.commands.byName.cut.exec(editor);
            editor.setEmacsMark(null);
          },
          readOnly: true,
          multiSelectAction: "forEach"
        },
        killRingSave: {
          exec: function(editor) {
            editor.$handlesEmacsOnCopy = true;
            var marks = editor.session.$emacsMarkRing.slice(), deselectedMarks = [];
            exports2.killRing.add(editor.getCopyText());
            setTimeout(function() {
              function deselect() {
                var sel = editor.selection, range = sel.getRange(), pos = sel.isBackwards() ? range.end : range.start;
                deselectedMarks.push({ row: pos.row, column: pos.column });
                sel.clearSelection();
              }
              editor.$handlesEmacsOnCopy = false;
              if (editor.inMultiSelectMode)
                editor.forEachSelection({ exec: deselect });
              else
                deselect();
              editor.setEmacsMark(null);
              editor.session.$emacsMarkRing = marks.concat(deselectedMarks.reverse());
            }, 0);
          },
          readOnly: true
        },
        keyboardQuit: function(editor) {
          editor.selection.clearSelection();
          editor.setEmacsMark(null);
          editor.keyBinding.$data.count = null;
        },
        focusCommandLine: function(editor, arg) {
          if (editor.showCommandLine)
            editor.showCommandLine(arg);
        }
      });
      exports2.handler.addCommands(iSearchCommandModule.iSearchStartCommands);
      var commands = exports2.handler.commands;
      commands.yank.isYank = true;
      commands.yankRotate.isYank = true;
      exports2.killRing = {
        $data: [],
        add: function(str) {
          str && this.$data.push(str);
          if (this.$data.length > 30)
            this.$data.shift();
        },
        append: function(str) {
          var idx = this.$data.length - 1;
          var text = this.$data[idx] || "";
          if (str)
            text += str;
          if (text)
            this.$data[idx] = text;
        },
        get: function(n) {
          n = n || 1;
          return this.$data.slice(this.$data.length - n, this.$data.length).reverse().join("\n");
        },
        pop: function() {
          if (this.$data.length > 1)
            this.$data.pop();
          return this.get();
        },
        rotate: function() {
          this.$data.unshift(this.$data.pop());
          return this.get();
        }
      };
    });
    (function() {
      ace.require(["ace/keyboard/emacs"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/keybinding-sublime.js
var require_keybinding_sublime = __commonJS({
  "node_modules/ace-builds/src-noconflict/keybinding-sublime.js"(exports, module2) {
    ace.define("ace/keyboard/sublime", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require3, exports2, module3) {
      "use strict";
      var HashHandler = require3("../keyboard/hash_handler").HashHandler;
      function moveBySubWords(editor, direction, extend) {
        var selection = editor.selection;
        var row = selection.lead.row;
        var column = selection.lead.column;
        var line = editor.session.getLine(row);
        if (!line[column + direction]) {
          var method = (extend ? "selectWord" : "moveCursorShortWord") + (direction == 1 ? "Right" : "Left");
          return editor.selection[method]();
        }
        if (direction == -1)
          column--;
        while (line[column]) {
          var type = getType(line[column]) + getType(line[column + direction]);
          column += direction;
          if (direction == 1) {
            if (type == "WW" && getType(line[column + 1]) == "w")
              break;
          } else {
            if (type == "wW") {
              if (getType(line[column - 1]) == "W") {
                column -= 1;
                break;
              } else {
                continue;
              }
            }
            if (type == "Ww")
              break;
          }
          if (/w[s_oW]|_[sWo]|o[s_wW]|s[W]|W[so]/.test(type))
            break;
        }
        if (direction == -1)
          column++;
        if (extend)
          editor.selection.moveCursorTo(row, column);
        else
          editor.selection.moveTo(row, column);
        function getType(x) {
          if (!x)
            return "-";
          if (/\s/.test(x))
            return "s";
          if (x == "_")
            return "_";
          if (x.toUpperCase() == x && x.toLowerCase() != x)
            return "W";
          if (x.toUpperCase() != x && x.toLowerCase() == x)
            return "w";
          return "o";
        }
      }
      exports2.handler = new HashHandler();
      exports2.handler.addCommands([{
        name: "find_all_under",
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          editor.findAll();
        },
        readOnly: true
      }, {
        name: "find_under",
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          editor.findNext();
        },
        readOnly: true
      }, {
        name: "find_under_prev",
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          editor.findPrevious();
        },
        readOnly: true
      }, {
        name: "find_under_expand",
        exec: function(editor) {
          editor.selectMore(1, false, true);
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "find_under_expand_skip",
        exec: function(editor) {
          editor.selectMore(1, true, true);
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "delete_to_hard_bol",
        exec: function(editor) {
          var pos = editor.selection.getCursor();
          editor.session.remove({
            start: { row: pos.row, column: 0 },
            end: pos
          });
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "delete_to_hard_eol",
        exec: function(editor) {
          var pos = editor.selection.getCursor();
          editor.session.remove({
            start: pos,
            end: { row: pos.row, column: Infinity }
          });
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "moveToWordStartLeft",
        exec: function(editor) {
          editor.selection.moveCursorLongWordLeft();
          editor.clearSelection();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "moveToWordEndRight",
        exec: function(editor) {
          editor.selection.moveCursorLongWordRight();
          editor.clearSelection();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "selectToWordStartLeft",
        exec: function(editor) {
          var sel = editor.selection;
          sel.$moveSelection(sel.moveCursorLongWordLeft);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "selectToWordEndRight",
        exec: function(editor) {
          var sel = editor.selection;
          sel.$moveSelection(sel.moveCursorLongWordRight);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "selectSubWordRight",
        exec: function(editor) {
          moveBySubWords(editor, 1, true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectSubWordLeft",
        exec: function(editor) {
          moveBySubWords(editor, -1, true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "moveSubWordRight",
        exec: function(editor) {
          moveBySubWords(editor, 1);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "moveSubWordLeft",
        exec: function(editor) {
          moveBySubWords(editor, -1);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }]);
      [
        {
          bindKey: { mac: "cmd-k cmd-backspace|cmd-backspace", win: "ctrl-shift-backspace|ctrl-k ctrl-backspace" },
          name: "removetolinestarthard"
        },
        {
          bindKey: { mac: "cmd-k cmd-k|cmd-delete|ctrl-k", win: "ctrl-shift-delete|ctrl-k ctrl-k" },
          name: "removetolineendhard"
        },
        {
          bindKey: { mac: "cmd-shift-d", win: "ctrl-shift-d" },
          name: "duplicateSelection"
        },
        {
          bindKey: { mac: "cmd-l", win: "ctrl-l" },
          name: "expandtoline"
        },
        {
          bindKey: { mac: "cmd-shift-a", win: "ctrl-shift-a" },
          name: "expandSelection",
          args: { to: "tag" }
        },
        {
          bindKey: { mac: "cmd-shift-j", win: "ctrl-shift-j" },
          name: "expandSelection",
          args: { to: "indentation" }
        },
        {
          bindKey: { mac: "ctrl-shift-m", win: "ctrl-shift-m" },
          name: "expandSelection",
          args: { to: "brackets" }
        },
        {
          bindKey: { mac: "cmd-shift-space", win: "ctrl-shift-space" },
          name: "expandSelection",
          args: { to: "scope" }
        },
        {
          bindKey: { mac: "ctrl-cmd-g", win: "alt-f3" },
          name: "find_all_under"
        },
        {
          bindKey: { mac: "alt-cmd-g", win: "ctrl-f3" },
          name: "find_under"
        },
        {
          bindKey: { mac: "shift-alt-cmd-g", win: "ctrl-shift-f3" },
          name: "find_under_prev"
        },
        {
          bindKey: { mac: "cmd-g", win: "f3" },
          name: "findnext"
        },
        {
          bindKey: { mac: "shift-cmd-g", win: "shift-f3" },
          name: "findprevious"
        },
        {
          bindKey: { mac: "cmd-d", win: "ctrl-d" },
          name: "find_under_expand"
        },
        {
          bindKey: { mac: "cmd-k cmd-d", win: "ctrl-k ctrl-d" },
          name: "find_under_expand_skip"
        },
        {
          bindKey: { mac: "cmd-alt-[", win: "ctrl-shift-[" },
          name: "toggleFoldWidget"
        },
        {
          bindKey: { mac: "cmd-alt-]", win: "ctrl-shift-]" },
          name: "unfold"
        },
        {
          bindKey: { mac: "cmd-k cmd-0|cmd-k cmd-j", win: "ctrl-k ctrl-0|ctrl-k ctrl-j" },
          name: "unfoldall"
        },
        {
          bindKey: { mac: "cmd-k cmd-1", win: "ctrl-k ctrl-1" },
          name: "foldOther",
          args: { level: 1 }
        },
        {
          bindKey: { win: "ctrl-left", mac: "alt-left" },
          name: "moveToWordStartLeft"
        },
        {
          bindKey: { win: "ctrl-right", mac: "alt-right" },
          name: "moveToWordEndRight"
        },
        {
          bindKey: { win: "ctrl-shift-left", mac: "alt-shift-left" },
          name: "selectToWordStartLeft"
        },
        {
          bindKey: { win: "ctrl-shift-right", mac: "alt-shift-right" },
          name: "selectToWordEndRight"
        },
        {
          bindKey: { mac: "ctrl-alt-shift-right|ctrl-shift-right", win: "alt-shift-right" },
          name: "selectSubWordRight"
        },
        {
          bindKey: { mac: "ctrl-alt-shift-left|ctrl-shift-left", win: "alt-shift-left" },
          name: "selectSubWordLeft"
        },
        {
          bindKey: { mac: "ctrl-alt-right|ctrl-right", win: "alt-right" },
          name: "moveSubWordRight"
        },
        {
          bindKey: { mac: "ctrl-alt-left|ctrl-left", win: "alt-left" },
          name: "moveSubWordLeft"
        },
        {
          bindKey: { mac: "ctrl-m", win: "ctrl-m" },
          name: "jumptomatching",
          args: { to: "brackets" }
        },
        {
          bindKey: { mac: "ctrl-f6", win: "ctrl-f6" },
          name: "goToNextError"
        },
        {
          bindKey: { mac: "ctrl-shift-f6", win: "ctrl-shift-f6" },
          name: "goToPreviousError"
        },
        {
          bindKey: { mac: "ctrl-o" },
          name: "splitline"
        },
        {
          bindKey: { mac: "ctrl-shift-w", win: "alt-shift-w" },
          name: "surrowndWithTag"
        },
        {
          bindKey: { mac: "cmd-alt-.", win: "alt-." },
          name: "close_tag"
        },
        {
          bindKey: { mac: "cmd-j", win: "ctrl-j" },
          name: "joinlines"
        },
        {
          bindKey: { mac: "ctrl--", win: "alt--" },
          name: "jumpBack"
        },
        {
          bindKey: { mac: "ctrl-shift--", win: "alt-shift--" },
          name: "jumpForward"
        },
        {
          bindKey: { mac: "cmd-k cmd-l", win: "ctrl-k ctrl-l" },
          name: "tolowercase"
        },
        {
          bindKey: { mac: "cmd-k cmd-u", win: "ctrl-k ctrl-u" },
          name: "touppercase"
        },
        {
          bindKey: { mac: "cmd-shift-v", win: "ctrl-shift-v" },
          name: "paste_and_indent"
        },
        {
          bindKey: { mac: "cmd-k cmd-v|cmd-alt-v", win: "ctrl-k ctrl-v" },
          name: "paste_from_history"
        },
        {
          bindKey: { mac: "cmd-shift-enter", win: "ctrl-shift-enter" },
          name: "addLineBefore"
        },
        {
          bindKey: { mac: "cmd-enter", win: "ctrl-enter" },
          name: "addLineAfter"
        },
        {
          bindKey: { mac: "ctrl-shift-k", win: "ctrl-shift-k" },
          name: "removeline"
        },
        {
          bindKey: { mac: "ctrl-alt-up", win: "ctrl-up" },
          name: "scrollup"
        },
        {
          bindKey: { mac: "ctrl-alt-down", win: "ctrl-down" },
          name: "scrolldown"
        },
        {
          bindKey: { mac: "cmd-a", win: "ctrl-a" },
          name: "selectall"
        },
        {
          bindKey: { linux: "alt-shift-down", mac: "ctrl-shift-down", win: "ctrl-alt-down" },
          name: "addCursorBelow"
        },
        {
          bindKey: { linux: "alt-shift-up", mac: "ctrl-shift-up", win: "ctrl-alt-up" },
          name: "addCursorAbove"
        },
        {
          bindKey: { mac: "cmd-k cmd-c|ctrl-l", win: "ctrl-k ctrl-c" },
          name: "centerselection"
        },
        {
          bindKey: { mac: "f5", win: "f9" },
          name: "sortlines"
        },
        {
          bindKey: { mac: "ctrl-f5", win: "ctrl-f9" },
          name: "sortlines",
          args: { caseSensitive: true }
        },
        {
          bindKey: { mac: "cmd-shift-l", win: "ctrl-shift-l" },
          name: "splitSelectionIntoLines"
        },
        {
          bindKey: { mac: "ctrl-cmd-down", win: "ctrl-shift-down" },
          name: "movelinesdown"
        },
        {
          bindKey: { mac: "ctrl-cmd-up", win: "ctrl-shift-up" },
          name: "movelinesup"
        },
        {
          bindKey: { mac: "alt-down", win: "alt-down" },
          name: "modifyNumberDown"
        },
        {
          bindKey: { mac: "alt-up", win: "alt-up" },
          name: "modifyNumberUp"
        },
        {
          bindKey: { mac: "cmd-/", win: "ctrl-/" },
          name: "togglecomment"
        },
        {
          bindKey: { mac: "cmd-alt-/", win: "ctrl-shift-/" },
          name: "toggleBlockComment"
        },
        {
          bindKey: { linux: "ctrl-alt-q", mac: "ctrl-q", win: "ctrl-q" },
          name: "togglerecording"
        },
        {
          bindKey: { linux: "ctrl-alt-shift-q", mac: "ctrl-shift-q", win: "ctrl-shift-q" },
          name: "replaymacro"
        },
        {
          bindKey: { mac: "ctrl-t", win: "ctrl-t" },
          name: "transpose"
        }
      ].forEach(function(binding) {
        var command = exports2.handler.commands[binding.name];
        if (command)
          command.bindKey = binding.bindKey;
        exports2.handler.bindKey(binding.bindKey, command || binding.name);
      });
    });
    (function() {
      ace.require(["ace/keyboard/sublime"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/keybinding-vim.js
var require_keybinding_vim = __commonJS({
  "node_modules/ace-builds/src-noconflict/keybinding-vim.js"(exports, module2) {
    ace.define("ace/ext/hardwrap", ["require", "exports", "module", "ace/range", "ace/editor", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var Range = require3("../range").Range;
      function hardWrap(editor, options) {
        var max = options.column || editor.getOption("printMarginColumn");
        var allowMerge = options.allowMerge != false;
        var row = Math.min(options.startRow, options.endRow);
        var endRow = Math.max(options.startRow, options.endRow);
        var session = editor.session;
        while (row <= endRow) {
          var line = session.getLine(row);
          if (line.length > max) {
            var space = findSpace(line, max, 5);
            if (space) {
              var indentation = /^\s*/.exec(line)[0];
              session.replace(new Range(row, space.start, row, space.end), "\n" + indentation);
            }
            endRow++;
          } else if (allowMerge && /\S/.test(line) && row != endRow) {
            var nextLine = session.getLine(row + 1);
            if (nextLine && /\S/.test(nextLine)) {
              var trimmedLine = line.replace(/\s+$/, "");
              var trimmedNextLine = nextLine.replace(/^\s+/, "");
              var mergedLine = trimmedLine + " " + trimmedNextLine;
              var space = findSpace(mergedLine, max, 5);
              if (space && space.start > trimmedLine.length || mergedLine.length < max) {
                var replaceRange = new Range(row, trimmedLine.length, row + 1, nextLine.length - trimmedNextLine.length);
                session.replace(replaceRange, " ");
                row--;
                endRow--;
              } else if (trimmedLine.length < line.length) {
                session.remove(new Range(row, trimmedLine.length, row, line.length));
              }
            }
          }
          row++;
        }
        function findSpace(line2, max2, min2) {
          if (line2.length < max2)
            return;
          var before = line2.slice(0, max2);
          var after = line2.slice(max2);
          var spaceAfter = /^(?:(\s+)|(\S+)(\s+))/.exec(after);
          var spaceBefore = /(?:(\s+)|(\s+)(\S+))$/.exec(before);
          var start = 0;
          var end = 0;
          if (spaceBefore && !spaceBefore[2]) {
            start = max2 - spaceBefore[1].length;
            end = max2;
          }
          if (spaceAfter && !spaceAfter[2]) {
            if (!start)
              start = max2;
            end = max2 + spaceAfter[1].length;
          }
          if (start) {
            return {
              start,
              end
            };
          }
          if (spaceBefore && spaceBefore[2] && spaceBefore.index > min2) {
            return {
              start: spaceBefore.index,
              end: spaceBefore.index + spaceBefore[2].length
            };
          }
          if (spaceAfter && spaceAfter[2]) {
            start = max2 + spaceAfter[2].length;
            return {
              start,
              end: start + spaceAfter[3].length
            };
          }
        }
      }
      function wrapAfterInput(e) {
        if (e.command.name == "insertstring" && /\S/.test(e.args)) {
          var editor = e.editor;
          var cursor = editor.selection.cursor;
          if (cursor.column <= editor.renderer.$printMarginColumn)
            return;
          var lastDelta = editor.session.$undoManager.$lastDelta;
          hardWrap(editor, {
            startRow: cursor.row,
            endRow: cursor.row,
            allowMerge: false
          });
          if (lastDelta != editor.session.$undoManager.$lastDelta)
            editor.session.markUndoGroup();
        }
      }
      var Editor = require3("../editor").Editor;
      require3("../config").defineOptions(Editor.prototype, "editor", {
        hardWrap: {
          set: function(val) {
            if (val) {
              this.commands.on("afterExec", wrapAfterInput);
            } else {
              this.commands.off("afterExec", wrapAfterInput);
            }
          },
          value: false
        }
      });
      exports2.hardWrap = hardWrap;
    });
    ace.define("ace/keyboard/vim", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/dom", "ace/lib/oop", "ace/lib/keys", "ace/lib/event", "ace/search", "ace/lib/useragent", "ace/search_highlight", "ace/commands/multi_select_commands", "ace/mode/text", "ace/ext/hardwrap", "ace/multi_select"], function(require3, exports2, module3) {
      "use strict";
      function log() {
        var d = "";
        function format(p2) {
          if (typeof p2 != "object")
            return p2 + "";
          if ("line" in p2) {
            return p2.line + ":" + p2.ch;
          }
          if ("anchor" in p2) {
            return format(p2.anchor) + "->" + format(p2.head);
          }
          if (Array.isArray(p2))
            return "[" + p2.map(function(x) {
              return format(x);
            }) + "]";
          return JSON.stringify(p2);
        }
        for (var i = 0; i < arguments.length; i++) {
          var p = arguments[i];
          var f = format(p);
          d += f + "  ";
        }
        console.log(d);
      }
      var Range = require3("../range").Range;
      var EventEmitter = require3("../lib/event_emitter").EventEmitter;
      var domLib = require3("../lib/dom");
      var oop = require3("../lib/oop");
      var KEYS = require3("../lib/keys");
      var event = require3("../lib/event");
      var Search = require3("../search").Search;
      var useragent = require3("../lib/useragent");
      var SearchHighlight = require3("../search_highlight").SearchHighlight;
      var multiSelectCommands = require3("../commands/multi_select_commands");
      var TextModeTokenRe = require3("../mode/text").Mode.prototype.tokenRe;
      var hardWrap = require3("../ext/hardwrap").hardWrap;
      require3("../multi_select");
      var CodeMirror = function(ace4) {
        this.ace = ace4;
        this.state = {};
        this.marks = {};
        this.options = {};
        this.$uid = 0;
        this.onChange = this.onChange.bind(this);
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);
        this.ace.on("change", this.onChange);
        this.ace.on("changeSelection", this.onSelectionChange);
        this.ace.on("beforeEndOperation", this.onBeforeEndOperation);
      };
      CodeMirror.Pos = function(line, ch) {
        if (!(this instanceof Pos))
          return new Pos(line, ch);
        this.line = line;
        this.ch = ch;
      };
      CodeMirror.defineOption = function(name, val, setter) {
      };
      CodeMirror.commands = {
        redo: function(cm) {
          cm.ace.redo();
        },
        undo: function(cm) {
          cm.ace.undo();
        },
        newlineAndIndent: function(cm) {
          cm.ace.insert("\n");
        },
        goLineLeft: function(cm) {
          cm.ace.selection.moveCursorLineStart();
        },
        goLineRight: function(cm) {
          cm.ace.selection.moveCursorLineEnd();
        }
      };
      CodeMirror.keyMap = {};
      CodeMirror.addClass = CodeMirror.rmClass = function() {
      };
      CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;
      CodeMirror.keyName = function(e) {
        var key = KEYS[e.keyCode] || e.key || "";
        if (key.length == 1)
          key = key.toUpperCase();
        key = event.getModifierString(e).replace(/(^|-)\w/g, function(m) {
          return m.toUpperCase();
        }) + key;
        return key;
      };
      CodeMirror.keyMap["default"] = function(key) {
        return function(cm) {
          var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];
          return cmd && cm.ace.execCommand(cmd) !== false;
        };
      };
      CodeMirror.lookupKey = function lookupKey2(key, map, handle) {
        if (!map)
          map = "default";
        if (typeof map == "string")
          map = CodeMirror.keyMap[map] || CodeMirror.keyMap["default"];
        var found = typeof map == "function" ? map(key) : map[key];
        if (found === false)
          return "nothing";
        if (found === "...")
          return "multi";
        if (found != null && handle(found))
          return "handled";
        if (map.fallthrough) {
          if (!Array.isArray(map.fallthrough))
            return lookupKey2(key, map.fallthrough, handle);
          for (var i = 0; i < map.fallthrough.length; i++) {
            var result = lookupKey2(key, map.fallthrough[i], handle);
            if (result)
              return result;
          }
        }
      };
      CodeMirror.findMatchingTag = function(cm, head) {
        return cm.findMatchingTag(head);
      };
      CodeMirror.findEnclosingTag = function(cm, head) {
      };
      CodeMirror.signal = function(o, name, e) {
        return o._signal(name, e);
      };
      CodeMirror.on = event.addListener;
      CodeMirror.off = event.removeListener;
      CodeMirror.isWordChar = function(ch) {
        if (ch < "\x7F")
          return /^\w$/.test(ch);
        TextModeTokenRe.lastIndex = 0;
        return TextModeTokenRe.test(ch);
      };
      (function() {
        oop.implement(CodeMirror.prototype, EventEmitter);
        this.destroy = function() {
          this.ace.off("change", this.onChange);
          this.ace.off("changeSelection", this.onSelectionChange);
          this.ace.off("beforeEndOperation", this.onBeforeEndOperation);
          this.removeOverlay();
        };
        this.virtualSelectionMode = function() {
          return this.ace.inVirtualSelectionMode && this.ace.selection.index;
        };
        this.onChange = function(delta) {
          if (this.$lineHandleChanges) {
            this.$lineHandleChanges.push(delta);
          }
          var change = { text: delta.action[0] == "i" ? delta.lines : [] };
          var curOp = this.curOp = this.curOp || {};
          if (!curOp.changeHandlers)
            curOp.changeHandlers = this._eventRegistry["change"] && this._eventRegistry["change"].slice();
          if (!curOp.lastChange) {
            curOp.lastChange = curOp.change = change;
          } else {
            curOp.lastChange.next = curOp.lastChange = change;
          }
          this.$updateMarkers(delta);
        };
        this.onSelectionChange = function() {
          var curOp = this.curOp = this.curOp || {};
          if (!curOp.cursorActivityHandlers)
            curOp.cursorActivityHandlers = this._eventRegistry["cursorActivity"] && this._eventRegistry["cursorActivity"].slice();
          this.curOp.cursorActivity = true;
          if (this.ace.inMultiSelectMode) {
            this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);
          }
        };
        this.operation = function(fn3, force) {
          if (!force && this.curOp || force && this.curOp && this.curOp.force) {
            return fn3();
          }
          if (force || !this.ace.curOp) {
            if (this.curOp)
              this.onBeforeEndOperation();
          }
          if (!this.ace.curOp) {
            var prevOp = this.ace.prevOp;
            this.ace.startOperation({
              command: { name: "vim", scrollIntoView: "cursor" }
            });
          }
          var curOp = this.curOp = this.curOp || {};
          this.curOp.force = force;
          var result = fn3();
          if (this.ace.curOp && this.ace.curOp.command.name == "vim") {
            if (this.state.dialog)
              this.ace.curOp.command.scrollIntoView = this.ace.curOp.vimDialogScroll;
            this.ace.endOperation();
            if (!curOp.cursorActivity && !curOp.lastChange && prevOp)
              this.ace.prevOp = prevOp;
          }
          if (force || !this.ace.curOp) {
            if (this.curOp)
              this.onBeforeEndOperation();
          }
          return result;
        };
        this.onBeforeEndOperation = function() {
          var op = this.curOp;
          if (op) {
            if (op.change) {
              this.signal("change", op.change, op);
            }
            if (op && op.cursorActivity) {
              this.signal("cursorActivity", null, op);
            }
            this.curOp = null;
          }
        };
        this.signal = function(eventName, e, handlers) {
          var listeners = handlers ? handlers[eventName + "Handlers"] : (this._eventRegistry || {})[eventName];
          if (!listeners)
            return;
          listeners = listeners.slice();
          for (var i = 0; i < listeners.length; i++)
            listeners[i](this, e);
        };
        this.firstLine = function() {
          return 0;
        };
        this.lastLine = function() {
          return this.ace.session.getLength() - 1;
        };
        this.lineCount = function() {
          return this.ace.session.getLength();
        };
        this.setCursor = function(line, ch) {
          if (typeof line === "object") {
            ch = line.ch;
            line = line.line;
          }
          var shouldScroll = !this.curOp && !this.ace.inVirtualSelectionMode;
          if (!this.ace.inVirtualSelectionMode)
            this.ace.exitMultiSelectMode();
          this.ace.session.unfold({ row: line, column: ch });
          this.ace.selection.moveTo(line, ch);
          if (shouldScroll) {
            this.ace.renderer.scrollCursorIntoView();
            this.ace.endOperation();
          }
        };
        this.getCursor = function(p) {
          var sel = this.ace.selection;
          var pos = p == "anchor" ? sel.isEmpty() ? sel.lead : sel.anchor : p == "head" || !p ? sel.lead : sel.getRange()[p];
          return toCmPos(pos);
        };
        this.listSelections = function(p) {
          var ranges = this.ace.multiSelect.rangeList.ranges;
          if (!ranges.length || this.ace.inVirtualSelectionMode)
            return [{ anchor: this.getCursor("anchor"), head: this.getCursor("head") }];
          return ranges.map(function(r) {
            return {
              anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),
              head: this.clipPos(toCmPos(r.cursor))
            };
          }, this);
        };
        this.setSelections = function(p, primIndex) {
          var sel = this.ace.multiSelect;
          var ranges = p.map(function(x) {
            var anchor = toAcePos(x.anchor);
            var head = toAcePos(x.head);
            var r = Range.comparePoints(anchor, head) < 0 ? new Range.fromPoints(anchor, head) : new Range.fromPoints(head, anchor);
            r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;
            return r;
          });
          if (this.ace.inVirtualSelectionMode) {
            this.ace.selection.fromOrientedRange(ranges[0]);
            return;
          }
          if (!primIndex) {
            ranges = ranges.reverse();
          } else if (ranges[primIndex]) {
            ranges.push(ranges.splice(primIndex, 1)[0]);
          }
          sel.toSingleRange(ranges[0].clone());
          var session = this.ace.session;
          for (var i = 0; i < ranges.length; i++) {
            var range = session.$clipRangeToDocument(ranges[i]);
            sel.addRange(range);
          }
        };
        this.setSelection = function(a, h, options2) {
          var sel = this.ace.selection;
          sel.moveTo(a.line, a.ch);
          sel.selectTo(h.line, h.ch);
          if (options2 && options2.origin == "*mouse") {
            this.onBeforeEndOperation();
          }
        };
        this.somethingSelected = function(p) {
          return !this.ace.selection.isEmpty();
        };
        this.clipPos = function(p) {
          var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);
          return toCmPos(pos);
        };
        this.foldCode = function(pos) {
          this.ace.session.$toggleFoldWidget(pos.line, {});
        };
        this.markText = function(cursor) {
          return { clear: function() {
          }, find: function() {
          } };
        };
        this.$updateMarkers = function(delta) {
          var isInsert = delta.action == "insert";
          var start = delta.start;
          var end = delta.end;
          var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
          var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
          if (isInsert)
            end = start;
          for (var i in this.marks) {
            var point = this.marks[i];
            var cmp = Range.comparePoints(point, start);
            if (cmp < 0) {
              continue;
            }
            if (cmp === 0) {
              if (isInsert) {
                if (!point.$insertRight) {
                  cmp = 1;
                } else if (point.bias == 1) {
                  cmp = 1;
                } else {
                  point.bias = -1;
                  continue;
                }
              }
            }
            var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);
            if (cmp2 > 0) {
              point.row += rowShift;
              point.column += point.row == end.row ? colShift : 0;
              continue;
            }
            if (!isInsert && cmp2 <= 0) {
              point.row = start.row;
              point.column = start.column;
              if (cmp2 === 0)
                point.bias = 1;
            }
          }
        };
        var Marker = function(cm, id, row, column) {
          this.cm = cm;
          this.id = id;
          this.row = row;
          this.column = column;
          cm.marks[this.id] = this;
        };
        Marker.prototype.clear = function() {
          delete this.cm.marks[this.id];
        };
        Marker.prototype.find = function() {
          return toCmPos(this);
        };
        this.setBookmark = function(cursor, options2) {
          var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);
          if (!options2 || !options2.insertLeft)
            bm.$insertRight = true;
          this.marks[bm.id] = bm;
          return bm;
        };
        this.moveH = function(increment, unit) {
          if (unit == "char") {
            var sel = this.ace.selection;
            sel.clearSelection();
            sel.moveCursorBy(0, increment);
          }
        };
        this.findPosV = function(start, amount, unit, goalColumn) {
          if (unit == "page") {
            var renderer = this.ace.renderer;
            var config = renderer.layerConfig;
            amount = amount * Math.floor(config.height / config.lineHeight);
            unit = "line";
          }
          if (unit == "line") {
            var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);
            if (goalColumn != null)
              screenPos.column = goalColumn;
            screenPos.row += amount;
            screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);
            var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);
            return toCmPos(pos);
          } else {
            debugger;
          }
        };
        this.charCoords = function(pos, mode) {
          if (mode == "div" || !mode) {
            var sc2 = this.ace.session.documentToScreenPosition(pos.line, pos.ch);
            return { left: sc2.column, top: sc2.row };
          }
          if (mode == "local") {
            var renderer = this.ace.renderer;
            var sc2 = this.ace.session.documentToScreenPosition(pos.line, pos.ch);
            var lh = renderer.layerConfig.lineHeight;
            var cw = renderer.layerConfig.characterWidth;
            var top = lh * sc2.row;
            return { left: sc2.column * cw, top, bottom: top + lh };
          }
        };
        this.coordsChar = function(pos, mode) {
          var renderer = this.ace.renderer;
          if (mode == "local") {
            var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));
            var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));
            var ch = renderer.session.screenToDocumentPosition(row, col);
            return toCmPos(ch);
          } else if (mode == "div") {
            throw "not implemented";
          }
        };
        this.getSearchCursor = function(query, pos, caseFold) {
          var caseSensitive = false;
          var isRegexp = false;
          if (query instanceof RegExp && !query.global) {
            caseSensitive = !query.ignoreCase;
            query = query.source;
            isRegexp = true;
          }
          if (query == "\\n") {
            query = "\n";
            isRegexp = false;
          }
          var search = new Search();
          if (pos.ch == void 0)
            pos.ch = Number.MAX_VALUE;
          var acePos = { row: pos.line, column: pos.ch };
          var cm = this;
          var last = null;
          return {
            findNext: function() {
              return this.find(false);
            },
            findPrevious: function() {
              return this.find(true);
            },
            find: function(back) {
              search.setOptions({
                needle: query,
                caseSensitive,
                wrap: false,
                backwards: back,
                regExp: isRegexp,
                start: last || acePos
              });
              var range = search.find(cm.ace.session);
              last = range;
              return last && [!last.isEmpty()];
            },
            from: function() {
              return last && toCmPos(last.start);
            },
            to: function() {
              return last && toCmPos(last.end);
            },
            replace: function(text) {
              if (last) {
                last.end = cm.ace.session.doc.replace(last, text);
              }
            }
          };
        };
        this.scrollTo = function(x, y2) {
          var renderer = this.ace.renderer;
          var config = renderer.layerConfig;
          var maxHeight = config.maxHeight;
          maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;
          if (y2 != null)
            this.ace.session.setScrollTop(Math.max(0, Math.min(y2, maxHeight)));
          if (x != null)
            this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));
        };
        this.scrollInfo = function() {
          return 0;
        };
        this.scrollIntoView = function(pos, margin) {
          if (pos) {
            var renderer = this.ace.renderer;
            var viewMargin = { "top": 0, "bottom": margin };
            renderer.scrollCursorIntoView(toAcePos(pos), renderer.lineHeight * 2 / renderer.$size.scrollerHeight, viewMargin);
          }
        };
        this.getLine = function(row) {
          return this.ace.session.getLine(row);
        };
        this.getRange = function(s, e) {
          return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));
        };
        this.replaceRange = function(text, s, e) {
          if (!e)
            e = s;
          var range = new Range(s.line, s.ch, e.line, e.ch);
          this.ace.session.$clipRangeToDocument(range);
          return this.ace.session.replace(range, text);
        };
        this.replaceSelection = this.replaceSelections = function(p) {
          var strings = Array.isArray(p) && p;
          var sel = this.ace.selection;
          if (this.ace.inVirtualSelectionMode) {
            this.ace.session.replace(sel.getRange(), strings ? p[0] || "" : p);
            return;
          }
          sel.inVirtualSelectionMode = true;
          var ranges = sel.rangeList.ranges;
          if (!ranges.length)
            ranges = [this.ace.multiSelect.getRange()];
          for (var i = ranges.length; i--; )
            this.ace.session.replace(ranges[i], strings ? p[i] || "" : p);
          sel.inVirtualSelectionMode = false;
        };
        this.getSelection = function() {
          return this.ace.getSelectedText();
        };
        this.getSelections = function() {
          return this.listSelections().map(function(x) {
            return this.getRange(x.anchor, x.head);
          }, this);
        };
        this.getInputField = function() {
          return this.ace.textInput.getElement();
        };
        this.getWrapperElement = function() {
          return this.ace.container;
        };
        var optMap = {
          indentWithTabs: "useSoftTabs",
          indentUnit: "tabSize",
          tabSize: "tabSize",
          firstLineNumber: "firstLineNumber",
          readOnly: "readOnly"
        };
        this.setOption = function(name, val) {
          this.state[name] = val;
          switch (name) {
            case "indentWithTabs":
              name = optMap[name];
              val = !val;
              break;
            case "keyMap":
              this.state.$keyMap = val;
              return;
              break;
            default:
              name = optMap[name];
          }
          if (name)
            this.ace.setOption(name, val);
        };
        this.getOption = function(name) {
          var val;
          var aceOpt = optMap[name];
          if (aceOpt)
            val = this.ace.getOption(aceOpt);
          switch (name) {
            case "indentWithTabs":
              name = optMap[name];
              return !val;
            case "keyMap":
              return this.state.$keyMap || "vim";
          }
          return aceOpt ? val : this.state[name];
        };
        this.toggleOverwrite = function(on3) {
          this.state.overwrite = on3;
          return this.ace.setOverwrite(on3);
        };
        this.addOverlay = function(o) {
          if (!this.$searchHighlight || !this.$searchHighlight.session) {
            var highlight = new SearchHighlight(null, "ace_highlight-marker", "text");
            var marker = this.ace.session.addDynamicMarker(highlight);
            highlight.id = marker.id;
            highlight.session = this.ace.session;
            highlight.destroy = function(o2) {
              highlight.session.off("change", highlight.updateOnChange);
              highlight.session.off("changeEditor", highlight.destroy);
              highlight.session.removeMarker(highlight.id);
              highlight.session = null;
            };
            highlight.updateOnChange = function(delta) {
              var row = delta.start.row;
              if (row == delta.end.row)
                highlight.cache[row] = void 0;
              else
                highlight.cache.splice(row, highlight.cache.length);
            };
            highlight.session.on("changeEditor", highlight.destroy);
            highlight.session.on("change", highlight.updateOnChange);
          }
          var re3 = new RegExp(o.query.source, "gmi");
          this.$searchHighlight = o.highlight = highlight;
          this.$searchHighlight.setRegexp(re3);
          this.ace.renderer.updateBackMarkers();
        };
        this.removeOverlay = function(o) {
          if (this.$searchHighlight && this.$searchHighlight.session) {
            this.$searchHighlight.destroy();
          }
        };
        this.getScrollInfo = function() {
          var renderer = this.ace.renderer;
          var config = renderer.layerConfig;
          return {
            left: renderer.scrollLeft,
            top: renderer.scrollTop,
            height: config.maxHeight,
            width: config.width,
            clientHeight: config.height,
            clientWidth: config.width
          };
        };
        this.getValue = function() {
          return this.ace.getValue();
        };
        this.setValue = function(v2) {
          return this.ace.setValue(v2, -1);
        };
        this.getTokenTypeAt = function(pos) {
          var token = this.ace.session.getTokenAt(pos.line, pos.ch);
          return token && /comment|string/.test(token.type) ? "string" : "";
        };
        this.findMatchingBracket = function(pos) {
          var m = this.ace.session.findMatchingBracket(toAcePos(pos));
          return { to: m && toCmPos(m) };
        };
        this.findMatchingTag = function(pos) {
          var m = this.ace.session.getMatchingTags(toAcePos(pos));
          if (!m)
            return;
          return {
            open: {
              from: toCmPos(m.openTag.start),
              to: toCmPos(m.openTag.end)
            },
            close: {
              from: toCmPos(m.closeTag.start),
              to: toCmPos(m.closeTag.end)
            }
          };
        };
        this.indentLine = function(line, method) {
          if (method === true)
            this.ace.session.indentRows(line, line, "	");
          else if (method === false)
            this.ace.session.outdentRows(new Range(line, 0, line, 0));
        };
        this.indexFromPos = function(pos) {
          return this.ace.session.doc.positionToIndex(toAcePos(pos));
        };
        this.posFromIndex = function(index) {
          return toCmPos(this.ace.session.doc.indexToPosition(index));
        };
        this.focus = function(index) {
          return this.ace.textInput.focus();
        };
        this.blur = function(index) {
          return this.ace.blur();
        };
        this.defaultTextHeight = function(index) {
          return this.ace.renderer.layerConfig.lineHeight;
        };
        this.scanForBracket = function(pos, dir, _2, options2) {
          var re3 = options2.bracketRegex.source;
          var tokenRe = /paren|text|operator|tag/;
          if (dir == 1) {
            var m = this.ace.session.$findClosingBracket(re3.slice(1, 2), toAcePos(pos), tokenRe);
          } else {
            var m = this.ace.session.$findOpeningBracket(re3.slice(-2, -1), { row: pos.line, column: pos.ch + 1 }, tokenRe);
            if (!m && options2.bracketRegex && options2.bracketRegex.test(this.getLine(pos.line)[pos.ch - 1])) {
              m = { row: pos.line, column: pos.ch - 1 };
            }
          }
          return m && { pos: toCmPos(m) };
        };
        this.refresh = function() {
          return this.ace.resize(true);
        };
        this.getMode = function() {
          return { name: this.getOption("mode") };
        };
        this.execCommand = function(name) {
          if (CodeMirror.commands.hasOwnProperty(name))
            return CodeMirror.commands[name](this);
          if (name == "indentAuto")
            return this.ace.execCommand("autoindent");
          console.log(name + " is not implemented");
        };
        this.getLineNumber = function(handle) {
          var deltas = this.$lineHandleChanges;
          if (!deltas)
            return null;
          var row = handle.row;
          for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.start.row != delta.end.row) {
              if (delta.action[0] == "i") {
                if (delta.start.row < row)
                  row += delta.end.row - delta.start.row;
              } else {
                if (delta.start.row < row) {
                  if (row < delta.end.row || row == delta.end.row && delta.start.column > 0) {
                    return null;
                  }
                  row -= delta.end.row - delta.start.row;
                }
              }
            }
          }
          return row;
        };
        this.getLineHandle = function(row) {
          if (!this.$lineHandleChanges)
            this.$lineHandleChanges = [];
          return { text: this.ace.session.getLine(row), row };
        };
        this.releaseLineHandles = function() {
          this.$lineHandleChanges = void 0;
        };
        this.getLastEditEnd = function() {
          var undoManager = this.ace.session.$undoManager;
          if (undoManager && undoManager.$lastDelta)
            return toCmPos(undoManager.$lastDelta.end);
        };
      }).call(CodeMirror.prototype);
      function toAcePos(cmPos) {
        return { row: cmPos.line, column: cmPos.ch };
      }
      function toCmPos(acePos) {
        return new Pos(acePos.row, acePos.column);
      }
      var StringStream = CodeMirror.StringStream = function(string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
      };
      StringStream.prototype = {
        eol: function() {
          return this.pos >= this.string.length;
        },
        sol: function() {
          return this.pos == this.lineStart;
        },
        peek: function() {
          return this.string.charAt(this.pos) || void 0;
        },
        next: function() {
          if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
        },
        eat: function(match) {
          var ch = this.string.charAt(this.pos);
          if (typeof match == "string")
            var ok = ch == match;
          else
            var ok = ch && (match.test ? match.test(ch) : match(ch));
          if (ok) {
            ++this.pos;
            return ch;
          }
        },
        eatWhile: function(match) {
          var start = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start;
        },
        eatSpace: function() {
          var start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
          return this.pos > start;
        },
        skipToEnd: function() {
          this.pos = this.string.length;
        },
        skipTo: function(ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        },
        backUp: function(n) {
          this.pos -= n;
        },
        column: function() {
          throw "not implemented";
        },
        indentation: function() {
          throw "not implemented";
        },
        match: function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false)
                this.pos += pattern.length;
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
              return null;
            if (match && consume !== false)
              this.pos += match[0].length;
            return match;
          }
        },
        current: function() {
          return this.string.slice(this.start, this.pos);
        },
        hideFirstChars: function(n, inner) {
          this.lineStart += n;
          try {
            return inner();
          } finally {
            this.lineStart -= n;
          }
        }
      };
      CodeMirror.defineExtension = function(name, fn3) {
        CodeMirror.prototype[name] = fn3;
      };
      domLib.importCssString(".normal-mode .ace_cursor{\n    border: none;\n    background-color: rgba(255,0,0,0.5);\n}\n.normal-mode .ace_hidden-cursors .ace_cursor{\n  background-color: transparent;\n  border: 1px solid red;\n  opacity: 0.7\n}\n.ace_dialog {\n  position: absolute;\n  left: 0; right: 0;\n  background: inherit;\n  z-index: 15;\n  padding: .1em .8em;\n  overflow: hidden;\n  color: inherit;\n}\n.ace_dialog-top {\n  border-bottom: 1px solid #444;\n  top: 0;\n}\n.ace_dialog-bottom {\n  border-top: 1px solid #444;\n  bottom: 0;\n}\n.ace_dialog input {\n  border: none;\n  outline: none;\n  background: transparent;\n  width: 20em;\n  color: inherit;\n  font-family: monospace;\n}", "vimMode", false);
      (function() {
        function dialogDiv(cm, template, bottom) {
          var wrap = cm.ace.container;
          var dialog;
          dialog = wrap.appendChild(document.createElement("div"));
          if (bottom)
            dialog.className = "ace_dialog ace_dialog-bottom";
          else
            dialog.className = "ace_dialog ace_dialog-top";
          if (typeof template == "string") {
            dialog.innerHTML = template;
          } else {
            dialog.appendChild(template);
          }
          return dialog;
        }
        function closeNotification(cm, newVal) {
          if (cm.state.currentNotificationClose)
            cm.state.currentNotificationClose();
          cm.state.currentNotificationClose = newVal;
        }
        CodeMirror.defineExtension("openDialog", function(template, callback, options2) {
          if (this.virtualSelectionMode())
            return;
          if (!options2)
            options2 = {};
          closeNotification(this, null);
          var dialog = dialogDiv(this, template, options2.bottom);
          var closed = false, me3 = this;
          this.state.dialog = dialog;
          function close(newVal) {
            if (typeof newVal == "string") {
              inp.value = newVal;
            } else {
              if (closed)
                return;
              if (newVal && newVal.type == "blur") {
                if (document.activeElement === inp)
                  return;
              }
              if (me3.state.dialog == dialog) {
                me3.state.dialog = null;
                me3.focus();
              }
              closed = true;
              dialog.remove();
              if (options2.onClose)
                options2.onClose(dialog);
              var cm = me3;
              if (cm.state.vim) {
                cm.state.vim.status = null;
                cm.ace._signal("changeStatus");
                cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);
              }
            }
          }
          var inp = dialog.getElementsByTagName("input")[0], button;
          if (inp) {
            if (options2.value) {
              inp.value = options2.value;
              if (options2.selectValueOnOpen !== false)
                inp.select();
            }
            if (options2.onInput)
              CodeMirror.on(inp, "input", function(e) {
                options2.onInput(e, inp.value, close);
              });
            if (options2.onKeyUp)
              CodeMirror.on(inp, "keyup", function(e) {
                options2.onKeyUp(e, inp.value, close);
              });
            CodeMirror.on(inp, "keydown", function(e) {
              if (options2 && options2.onKeyDown && options2.onKeyDown(e, inp.value, close)) {
                return;
              }
              if (e.keyCode == 13)
                callback(inp.value);
              if (e.keyCode == 27 || options2.closeOnEnter !== false && e.keyCode == 13) {
                CodeMirror.e_stop(e);
                close();
              }
            });
            if (options2.closeOnBlur !== false)
              CodeMirror.on(inp, "blur", close);
            inp.focus();
          } else if (button = dialog.getElementsByTagName("button")[0]) {
            CodeMirror.on(button, "click", function() {
              close();
              me3.focus();
            });
            if (options2.closeOnBlur !== false)
              CodeMirror.on(button, "blur", close);
            button.focus();
          }
          return close;
        });
        CodeMirror.defineExtension("openNotification", function(template, options2) {
          if (this.virtualSelectionMode())
            return;
          closeNotification(this, close);
          var dialog = dialogDiv(this, template, options2 && options2.bottom);
          var closed = false, doneTimer;
          var duration = options2 && typeof options2.duration !== "undefined" ? options2.duration : 5e3;
          function close() {
            if (closed)
              return;
            closed = true;
            clearTimeout(doneTimer);
            dialog.remove();
          }
          CodeMirror.on(dialog, "click", function(e) {
            CodeMirror.e_preventDefault(e);
            close();
          });
          if (duration)
            doneTimer = setTimeout(close, duration);
          return close;
        });
      })();
      var Pos = CodeMirror.Pos;
      function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {
        if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {
          var text = cm.getLine(curStart.line);
          var charCode = text.charCodeAt(curStart.ch);
          if (55296 <= charCode && charCode <= 55551) {
            curEnd.ch += 1;
          }
        }
        return { start: curStart, end: curEnd };
      }
      var defaultKeymap = [
        { keys: "<Left>", type: "keyToKey", toKeys: "h" },
        { keys: "<Right>", type: "keyToKey", toKeys: "l" },
        { keys: "<Up>", type: "keyToKey", toKeys: "k" },
        { keys: "<Down>", type: "keyToKey", toKeys: "j" },
        { keys: "g<Up>", type: "keyToKey", toKeys: "gk" },
        { keys: "g<Down>", type: "keyToKey", toKeys: "gj" },
        { keys: "<Space>", type: "keyToKey", toKeys: "l" },
        { keys: "<BS>", type: "keyToKey", toKeys: "h" },
        { keys: "<Del>", type: "keyToKey", toKeys: "x" },
        { keys: "<C-Space>", type: "keyToKey", toKeys: "W" },
        { keys: "<C-BS>", type: "keyToKey", toKeys: "B" },
        { keys: "<S-Space>", type: "keyToKey", toKeys: "w" },
        { keys: "<S-BS>", type: "keyToKey", toKeys: "b" },
        { keys: "<C-n>", type: "keyToKey", toKeys: "j" },
        { keys: "<C-p>", type: "keyToKey", toKeys: "k" },
        { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>" },
        { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>" },
        { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
        { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
        { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>" },
        // ipad keyboard sends C-Esc instead of C-[
        { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
        { keys: "s", type: "keyToKey", toKeys: "cl", context: "normal" },
        { keys: "s", type: "keyToKey", toKeys: "c", context: "visual" },
        { keys: "S", type: "keyToKey", toKeys: "cc", context: "normal" },
        { keys: "S", type: "keyToKey", toKeys: "VdO", context: "visual" },
        { keys: "<Home>", type: "keyToKey", toKeys: "0" },
        { keys: "<End>", type: "keyToKey", toKeys: "$" },
        { keys: "<PageUp>", type: "keyToKey", toKeys: "<C-b>" },
        { keys: "<PageDown>", type: "keyToKey", toKeys: "<C-f>" },
        { keys: "<CR>", type: "keyToKey", toKeys: "j^", context: "normal" },
        { keys: "<Ins>", type: "keyToKey", toKeys: "i", context: "normal" },
        { keys: "<Ins>", type: "action", action: "toggleOverwrite", context: "insert" },
        { keys: "H", type: "motion", motion: "moveToTopLine", motionArgs: { linewise: true, toJumplist: true } },
        { keys: "M", type: "motion", motion: "moveToMiddleLine", motionArgs: { linewise: true, toJumplist: true } },
        { keys: "L", type: "motion", motion: "moveToBottomLine", motionArgs: { linewise: true, toJumplist: true } },
        { keys: "h", type: "motion", motion: "moveByCharacters", motionArgs: { forward: false } },
        { keys: "l", type: "motion", motion: "moveByCharacters", motionArgs: { forward: true } },
        { keys: "j", type: "motion", motion: "moveByLines", motionArgs: { forward: true, linewise: true } },
        { keys: "k", type: "motion", motion: "moveByLines", motionArgs: { forward: false, linewise: true } },
        { keys: "gj", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: true } },
        { keys: "gk", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: false } },
        { keys: "w", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: false } },
        { keys: "W", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: false, bigWord: true } },
        { keys: "e", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: true, inclusive: true } },
        { keys: "E", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },
        { keys: "b", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false } },
        { keys: "B", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false, bigWord: true } },
        { keys: "ge", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: true, inclusive: true } },
        { keys: "gE", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },
        { keys: "{", type: "motion", motion: "moveByParagraph", motionArgs: { forward: false, toJumplist: true } },
        { keys: "}", type: "motion", motion: "moveByParagraph", motionArgs: { forward: true, toJumplist: true } },
        { keys: "(", type: "motion", motion: "moveBySentence", motionArgs: { forward: false } },
        { keys: ")", type: "motion", motion: "moveBySentence", motionArgs: { forward: true } },
        { keys: "<C-f>", type: "motion", motion: "moveByPage", motionArgs: { forward: true } },
        { keys: "<C-b>", type: "motion", motion: "moveByPage", motionArgs: { forward: false } },
        { keys: "<C-d>", type: "motion", motion: "moveByScroll", motionArgs: { forward: true, explicitRepeat: true } },
        { keys: "<C-u>", type: "motion", motion: "moveByScroll", motionArgs: { forward: false, explicitRepeat: true } },
        { keys: "gg", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },
        { keys: "G", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },
        { keys: "g$", type: "motion", motion: "moveToEndOfDisplayLine" },
        { keys: "g^", type: "motion", motion: "moveToStartOfDisplayLine" },
        { keys: "g0", type: "motion", motion: "moveToStartOfDisplayLine" },
        { keys: "0", type: "motion", motion: "moveToStartOfLine" },
        { keys: "^", type: "motion", motion: "moveToFirstNonWhiteSpaceCharacter" },
        { keys: "+", type: "motion", motion: "moveByLines", motionArgs: { forward: true, toFirstChar: true } },
        { keys: "-", type: "motion", motion: "moveByLines", motionArgs: { forward: false, toFirstChar: true } },
        { keys: "_", type: "motion", motion: "moveByLines", motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },
        { keys: "$", type: "motion", motion: "moveToEol", motionArgs: { inclusive: true } },
        { keys: "%", type: "motion", motion: "moveToMatchedSymbol", motionArgs: { inclusive: true, toJumplist: true } },
        { keys: "f<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: true, inclusive: true } },
        { keys: "F<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: false } },
        { keys: "t<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: true, inclusive: true } },
        { keys: "T<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: false } },
        { keys: ";", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: true } },
        { keys: ",", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: false } },
        { keys: "'<register>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: true, linewise: true } },
        { keys: "`<register>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: true } },
        { keys: "]`", type: "motion", motion: "jumpToMark", motionArgs: { forward: true } },
        { keys: "[`", type: "motion", motion: "jumpToMark", motionArgs: { forward: false } },
        { keys: "]'", type: "motion", motion: "jumpToMark", motionArgs: { forward: true, linewise: true } },
        { keys: "['", type: "motion", motion: "jumpToMark", motionArgs: { forward: false, linewise: true } },
        { keys: "]p", type: "action", action: "paste", isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },
        { keys: "[p", type: "action", action: "paste", isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },
        { keys: "]<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: true, toJumplist: true } },
        { keys: "[<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: false, toJumplist: true } },
        { keys: "|", type: "motion", motion: "moveToColumn" },
        { keys: "o", type: "motion", motion: "moveToOtherHighlightedEnd", context: "visual" },
        { keys: "O", type: "motion", motion: "moveToOtherHighlightedEnd", motionArgs: { sameLine: true }, context: "visual" },
        { keys: "d", type: "operator", operator: "delete" },
        { keys: "y", type: "operator", operator: "yank" },
        { keys: "c", type: "operator", operator: "change" },
        { keys: "=", type: "operator", operator: "indentAuto" },
        { keys: ">", type: "operator", operator: "indent", operatorArgs: { indentRight: true } },
        { keys: "<", type: "operator", operator: "indent", operatorArgs: { indentRight: false } },
        { keys: "g~", type: "operator", operator: "changeCase" },
        { keys: "gu", type: "operator", operator: "changeCase", operatorArgs: { toLower: true }, isEdit: true },
        { keys: "gU", type: "operator", operator: "changeCase", operatorArgs: { toLower: false }, isEdit: true },
        { keys: "n", type: "motion", motion: "findNext", motionArgs: { forward: true, toJumplist: true } },
        { keys: "N", type: "motion", motion: "findNext", motionArgs: { forward: false, toJumplist: true } },
        { keys: "gn", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: true } },
        { keys: "gN", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: false } },
        { keys: "gq", type: "operator", operator: "hardWrap" },
        { keys: "gw", type: "operator", operator: "hardWrap", operatorArgs: { keepCursor: true } },
        { keys: "x", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },
        { keys: "X", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },
        { keys: "D", type: "operatorMotion", operator: "delete", motion: "moveToEol", motionArgs: { inclusive: true }, context: "normal" },
        { keys: "D", type: "operator", operator: "delete", operatorArgs: { linewise: true }, context: "visual" },
        { keys: "Y", type: "operatorMotion", operator: "yank", motion: "expandToLine", motionArgs: { linewise: true }, context: "normal" },
        { keys: "Y", type: "operator", operator: "yank", operatorArgs: { linewise: true }, context: "visual" },
        { keys: "C", type: "operatorMotion", operator: "change", motion: "moveToEol", motionArgs: { inclusive: true }, context: "normal" },
        { keys: "C", type: "operator", operator: "change", operatorArgs: { linewise: true }, context: "visual" },
        { keys: "~", type: "operatorMotion", operator: "changeCase", motion: "moveByCharacters", motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: "normal" },
        { keys: "~", type: "operator", operator: "changeCase", context: "visual" },
        { keys: "<C-u>", type: "operatorMotion", operator: "delete", motion: "moveToStartOfLine", context: "insert" },
        { keys: "<C-w>", type: "operatorMotion", operator: "delete", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false }, context: "insert" },
        { keys: "<C-w>", type: "idle", context: "normal" },
        { keys: "<C-i>", type: "action", action: "jumpListWalk", actionArgs: { forward: true } },
        { keys: "<C-o>", type: "action", action: "jumpListWalk", actionArgs: { forward: false } },
        { keys: "<C-e>", type: "action", action: "scroll", actionArgs: { forward: true, linewise: true } },
        { keys: "<C-y>", type: "action", action: "scroll", actionArgs: { forward: false, linewise: true } },
        { keys: "a", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "charAfter" }, context: "normal" },
        { keys: "A", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "eol" }, context: "normal" },
        { keys: "A", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "endOfSelectedArea" }, context: "visual" },
        { keys: "i", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "inplace" }, context: "normal" },
        { keys: "gi", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "lastEdit" }, context: "normal" },
        { keys: "I", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "firstNonBlank" }, context: "normal" },
        { keys: "gI", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "bol" }, context: "normal" },
        { keys: "I", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "startOfSelectedArea" }, context: "visual" },
        { keys: "o", type: "action", action: "newLineAndEnterInsertMode", isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: "normal" },
        { keys: "O", type: "action", action: "newLineAndEnterInsertMode", isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: "normal" },
        { keys: "v", type: "action", action: "toggleVisualMode" },
        { keys: "V", type: "action", action: "toggleVisualMode", actionArgs: { linewise: true } },
        { keys: "<C-v>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: true } },
        { keys: "<C-q>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: true } },
        { keys: "gv", type: "action", action: "reselectLastSelection" },
        { keys: "J", type: "action", action: "joinLines", isEdit: true },
        { keys: "gJ", type: "action", action: "joinLines", actionArgs: { keepSpaces: true }, isEdit: true },
        { keys: "p", type: "action", action: "paste", isEdit: true, actionArgs: { after: true, isEdit: true } },
        { keys: "P", type: "action", action: "paste", isEdit: true, actionArgs: { after: false, isEdit: true } },
        { keys: "r<character>", type: "action", action: "replace", isEdit: true },
        { keys: "@<register>", type: "action", action: "replayMacro" },
        { keys: "q<register>", type: "action", action: "enterMacroRecordMode" },
        { keys: "R", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { replace: true }, context: "normal" },
        { keys: "R", type: "operator", operator: "change", operatorArgs: { linewise: true, fullLine: true }, context: "visual", exitVisualBlock: true },
        { keys: "u", type: "action", action: "undo", context: "normal" },
        { keys: "u", type: "operator", operator: "changeCase", operatorArgs: { toLower: true }, context: "visual", isEdit: true },
        { keys: "U", type: "operator", operator: "changeCase", operatorArgs: { toLower: false }, context: "visual", isEdit: true },
        { keys: "<C-r>", type: "action", action: "redo" },
        { keys: "m<register>", type: "action", action: "setMark" },
        { keys: '"<register>', type: "action", action: "setRegister" },
        { keys: "<C-r><register>", type: "action", action: "insertRegister", context: "insert", isEdit: true },
        { keys: "<C-o>", type: "action", action: "oneNormalCommand", context: "insert" },
        { keys: "zz", type: "action", action: "scrollToCursor", actionArgs: { position: "center" } },
        { keys: "z.", type: "action", action: "scrollToCursor", actionArgs: { position: "center" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
        { keys: "zt", type: "action", action: "scrollToCursor", actionArgs: { position: "top" } },
        { keys: "z<CR>", type: "action", action: "scrollToCursor", actionArgs: { position: "top" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
        { keys: "zb", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" } },
        { keys: "z-", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
        { keys: ".", type: "action", action: "repeatLastEdit" },
        { keys: "<C-a>", type: "action", action: "incrementNumberToken", isEdit: true, actionArgs: { increase: true, backtrack: false } },
        { keys: "<C-x>", type: "action", action: "incrementNumberToken", isEdit: true, actionArgs: { increase: false, backtrack: false } },
        { keys: "<C-t>", type: "action", action: "indent", actionArgs: { indentRight: true }, context: "insert" },
        { keys: "<C-d>", type: "action", action: "indent", actionArgs: { indentRight: false }, context: "insert" },
        { keys: "a<register>", type: "motion", motion: "textObjectManipulation" },
        { keys: "i<register>", type: "motion", motion: "textObjectManipulation", motionArgs: { textObjectInner: true } },
        { keys: "/", type: "search", searchArgs: { forward: true, querySrc: "prompt", toJumplist: true } },
        { keys: "?", type: "search", searchArgs: { forward: false, querySrc: "prompt", toJumplist: true } },
        { keys: "*", type: "search", searchArgs: { forward: true, querySrc: "wordUnderCursor", wholeWordOnly: true, toJumplist: true } },
        { keys: "#", type: "search", searchArgs: { forward: false, querySrc: "wordUnderCursor", wholeWordOnly: true, toJumplist: true } },
        { keys: "g*", type: "search", searchArgs: { forward: true, querySrc: "wordUnderCursor", toJumplist: true } },
        { keys: "g#", type: "search", searchArgs: { forward: false, querySrc: "wordUnderCursor", toJumplist: true } },
        { keys: ":", type: "ex" }
      ];
      var defaultKeymapLength = defaultKeymap.length;
      var defaultExCommandMap = [
        { name: "colorscheme", shortName: "colo" },
        { name: "map" },
        { name: "imap", shortName: "im" },
        { name: "nmap", shortName: "nm" },
        { name: "vmap", shortName: "vm" },
        { name: "omap", shortName: "om" },
        { name: "noremap", shortName: "no" },
        { name: "nnoremap", shortName: "nn" },
        { name: "vnoremap", shortName: "vn" },
        { name: "inoremap", shortName: "ino" },
        { name: "onoremap", shortName: "ono" },
        { name: "unmap" },
        { name: "mapclear", shortName: "mapc" },
        { name: "nmapclear", shortName: "nmapc" },
        { name: "vmapclear", shortName: "vmapc" },
        { name: "imapclear", shortName: "imapc" },
        { name: "omapclear", shortName: "omapc" },
        { name: "write", shortName: "w" },
        { name: "undo", shortName: "u" },
        { name: "redo", shortName: "red" },
        { name: "set", shortName: "se" },
        { name: "setlocal", shortName: "setl" },
        { name: "setglobal", shortName: "setg" },
        { name: "sort", shortName: "sor" },
        { name: "substitute", shortName: "s", possiblyAsync: true },
        { name: "startinsert", shortName: "start" },
        { name: "nohlsearch", shortName: "noh" },
        { name: "yank", shortName: "y" },
        { name: "delmarks", shortName: "delm" },
        { name: "registers", shortName: "reg", excludeFromCommandHistory: true },
        { name: "vglobal", shortName: "v" },
        { name: "delete", shortName: "d" },
        { name: "join", shortName: "j" },
        { name: "normal", shortName: "norm" },
        { name: "global", shortName: "g" }
      ];
      var langmap = parseLangmap("");
      function enterVimMode(cm) {
        cm.setOption("disableInput", true);
        cm.setOption("showCursorWhenSelecting", false);
        CodeMirror.signal(cm, "vim-mode-change", { mode: "normal" });
        cm.on("cursorActivity", onCursorActivity);
        maybeInitVimState(cm);
        CodeMirror.on(cm.getInputField(), "paste", getOnPasteFn(cm));
      }
      function leaveVimMode(cm) {
        cm.setOption("disableInput", false);
        cm.off("cursorActivity", onCursorActivity);
        CodeMirror.off(cm.getInputField(), "paste", getOnPasteFn(cm));
        cm.state.vim = null;
        if (highlightTimeout)
          clearTimeout(highlightTimeout);
      }
      function getOnPasteFn(cm) {
        var vim = cm.state.vim;
        if (!vim.onPasteFn) {
          vim.onPasteFn = function() {
            if (!vim.insertMode) {
              cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
              actions.enterInsertMode(cm, {}, vim);
            }
          };
        }
        return vim.onPasteFn;
      }
      var numberRegex = /[\d]/;
      var wordCharTest = [CodeMirror.isWordChar, function(ch) {
        return ch && !CodeMirror.isWordChar(ch) && !/\s/.test(ch);
      }], bigWordCharTest = [function(ch) {
        return /\S/.test(ch);
      }];
      var validMarks = ["<", ">"];
      var validRegisters = ["-", '"', ".", ":", "_", "/", "+"];
      var latinCharRegex = /^\w$/;
      var upperCaseChars;
      try {
        upperCaseChars = new RegExp("^[\\p{Lu}]$", "u");
      } catch (_2) {
        upperCaseChars = /^[A-Z]$/;
      }
      function isLine(cm, line) {
        return line >= cm.firstLine() && line <= cm.lastLine();
      }
      function isLowerCase(k2) {
        return /^[a-z]$/.test(k2);
      }
      function isMatchableSymbol(k2) {
        return "()[]{}".indexOf(k2) != -1;
      }
      function isNumber(k2) {
        return numberRegex.test(k2);
      }
      function isUpperCase(k2) {
        return upperCaseChars.test(k2);
      }
      function isWhiteSpaceString(k2) {
        return /^\s*$/.test(k2);
      }
      function isEndOfSentenceSymbol(k2) {
        return ".?!".indexOf(k2) != -1;
      }
      function inArray(val, arr) {
        for (var i = 0; i < arr.length; i++) {
          if (arr[i] == val) {
            return true;
          }
        }
        return false;
      }
      var options = {};
      function defineOption(name, defaultValue, type, aliases, callback) {
        if (defaultValue === void 0 && !callback) {
          throw Error("defaultValue is required unless callback is provided");
        }
        if (!type) {
          type = "string";
        }
        options[name] = {
          type,
          defaultValue,
          callback
        };
        if (aliases) {
          for (var i = 0; i < aliases.length; i++) {
            options[aliases[i]] = options[name];
          }
        }
        if (defaultValue) {
          setOption(name, defaultValue);
        }
      }
      function setOption(name, value, cm, cfg) {
        var option = options[name];
        cfg = cfg || {};
        var scope = cfg.scope;
        if (!option) {
          return new Error("Unknown option: " + name);
        }
        if (option.type == "boolean") {
          if (value && value !== true) {
            return new Error("Invalid argument: " + name + "=" + value);
          } else if (value !== false) {
            value = true;
          }
        }
        if (option.callback) {
          if (scope !== "local") {
            option.callback(value, void 0);
          }
          if (scope !== "global" && cm) {
            option.callback(value, cm);
          }
        } else {
          if (scope !== "local") {
            option.value = option.type == "boolean" ? !!value : value;
          }
          if (scope !== "global" && cm) {
            cm.state.vim.options[name] = { value };
          }
        }
      }
      function getOption(name, cm, cfg) {
        var option = options[name];
        cfg = cfg || {};
        var scope = cfg.scope;
        if (!option) {
          return new Error("Unknown option: " + name);
        }
        if (option.callback) {
          var local = cm && option.callback(void 0, cm);
          if (scope !== "global" && local !== void 0) {
            return local;
          }
          if (scope !== "local") {
            return option.callback();
          }
          return;
        } else {
          var local = scope !== "global" && (cm && cm.state.vim.options[name]);
          return (local || scope !== "local" && option || {}).value;
        }
      }
      defineOption("filetype", void 0, "string", ["ft"], function(name, cm) {
        if (cm === void 0) {
          return;
        }
        if (name === void 0) {
          var mode = cm.getOption("mode");
          return mode == "null" ? "" : mode;
        } else {
          var mode = name == "" ? "null" : name;
          cm.setOption("mode", mode);
        }
      });
      defineOption("textwidth", 80, "number", ["tw"], function(width, cm) {
        if (cm === void 0) {
          return;
        }
        if (width === void 0) {
          var value = cm.getOption("textwidth");
          return value;
        } else {
          var column = Math.round(width);
          if (column > 1) {
            cm.setOption("textwidth", column);
          }
        }
      });
      var createCircularJumpList = function() {
        var size = 100;
        var pointer = -1;
        var head = 0;
        var tail = 0;
        var buffer = new Array(size);
        function add(cm, oldCur, newCur) {
          var current = pointer % size;
          var curMark = buffer[current];
          function useNextSlot(cursor) {
            var next = ++pointer % size;
            var trashMark = buffer[next];
            if (trashMark) {
              trashMark.clear();
            }
            buffer[next] = cm.setBookmark(cursor);
          }
          if (curMark) {
            var markPos = curMark.find();
            if (markPos && !cursorEqual(markPos, oldCur)) {
              useNextSlot(oldCur);
            }
          } else {
            useNextSlot(oldCur);
          }
          useNextSlot(newCur);
          head = pointer;
          tail = pointer - size + 1;
          if (tail < 0) {
            tail = 0;
          }
        }
        function move(cm, offset) {
          pointer += offset;
          if (pointer > head) {
            pointer = head;
          } else if (pointer < tail) {
            pointer = tail;
          }
          var mark = buffer[(size + pointer) % size];
          if (mark && !mark.find()) {
            var inc = offset > 0 ? 1 : -1;
            var newCur;
            var oldCur = cm.getCursor();
            do {
              pointer += inc;
              mark = buffer[(size + pointer) % size];
              if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {
                break;
              }
            } while (pointer < head && pointer > tail);
          }
          return mark;
        }
        function find(cm, offset) {
          var oldPointer = pointer;
          var mark = move(cm, offset);
          pointer = oldPointer;
          return mark && mark.find();
        }
        return {
          cachedCursor: void 0,
          //used for # and * jumps
          add,
          find,
          move
        };
      };
      var createInsertModeChanges = function(c) {
        if (c) {
          return {
            changes: c.changes,
            expectCursorActivityForChange: c.expectCursorActivityForChange
          };
        }
        return {
          changes: [],
          expectCursorActivityForChange: false
        };
      };
      function MacroModeState() {
        this.latestRegister = void 0;
        this.isPlaying = false;
        this.isRecording = false;
        this.replaySearchQueries = [];
        this.onRecordingDone = void 0;
        this.lastInsertModeChanges = createInsertModeChanges();
      }
      MacroModeState.prototype = {
        exitMacroRecordMode: function() {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.onRecordingDone) {
            macroModeState.onRecordingDone();
          }
          macroModeState.onRecordingDone = void 0;
          macroModeState.isRecording = false;
        },
        enterMacroRecordMode: function(cm, registerName) {
          var register = vimGlobalState.registerController.getRegister(registerName);
          if (register) {
            register.clear();
            this.latestRegister = registerName;
            if (cm.openDialog) {
              var template = dom("span", { class: "cm-vim-message" }, "recording @" + registerName);
              this.onRecordingDone = cm.openDialog(template, null, { bottom: true });
            }
            this.isRecording = true;
          }
        }
      };
      function maybeInitVimState(cm) {
        if (!cm.state.vim) {
          cm.state.vim = {
            inputState: new InputState(),
            lastEditInputState: void 0,
            lastEditActionCommand: void 0,
            lastHPos: -1,
            lastHSPos: -1,
            lastMotion: null,
            marks: {},
            insertMode: false,
            insertModeReturn: false,
            insertModeRepeat: void 0,
            visualMode: false,
            visualLine: false,
            visualBlock: false,
            lastSelection: null,
            lastPastedText: null,
            sel: {},
            options: {},
            expectLiteralNext: false
          };
        }
        return cm.state.vim;
      }
      var vimGlobalState;
      function resetVimGlobalState() {
        vimGlobalState = {
          searchQuery: null,
          searchIsReversed: false,
          lastSubstituteReplacePart: void 0,
          jumpList: createCircularJumpList(),
          macroModeState: new MacroModeState(),
          lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: "" },
          registerController: new RegisterController({}),
          searchHistoryController: new HistoryController(),
          exCommandHistoryController: new HistoryController()
        };
        for (var optionName in options) {
          var option = options[optionName];
          option.value = option.defaultValue;
        }
      }
      var lastInsertModeKeyTimer;
      var vimApi = {
        enterVimMode,
        leaveVimMode,
        buildKeyMap: function() {
        },
        getRegisterController: function() {
          return vimGlobalState.registerController;
        },
        resetVimGlobalState_: resetVimGlobalState,
        getVimGlobalState_: function() {
          return vimGlobalState;
        },
        maybeInitVimState_: maybeInitVimState,
        suppressErrorLogging: false,
        InsertModeKey,
        map: function(lhs, rhs, ctx) {
          exCommandDispatcher.map(lhs, rhs, ctx);
        },
        unmap: function(lhs, ctx) {
          return exCommandDispatcher.unmap(lhs, ctx);
        },
        noremap: function(lhs, rhs, ctx) {
          exCommandDispatcher.map(lhs, rhs, ctx, true);
        },
        mapclear: function(ctx) {
          var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
          var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
          defaultKeymap = defaultKeymap.slice(actualLength - origLength);
          if (ctx) {
            for (var i = userKeymap.length - 1; i >= 0; i--) {
              var mapping = userKeymap[i];
              if (ctx !== mapping.context) {
                if (mapping.context) {
                  this._mapCommand(mapping);
                } else {
                  var contexts = ["normal", "insert", "visual"];
                  for (var j3 in contexts) {
                    if (contexts[j3] !== ctx) {
                      var newMapping = {};
                      for (var key in mapping) {
                        newMapping[key] = mapping[key];
                      }
                      newMapping.context = contexts[j3];
                      this._mapCommand(newMapping);
                    }
                  }
                }
              }
            }
          }
        },
        langmap: updateLangmap,
        vimKeyFromEvent,
        setOption,
        getOption,
        defineOption,
        defineEx: function(name, prefix, func) {
          if (!prefix) {
            prefix = name;
          } else if (name.indexOf(prefix) !== 0) {
            throw new Error('(Vim.defineEx) "' + prefix + '" is not a prefix of "' + name + '", command not registered');
          }
          exCommands[name] = func;
          exCommandDispatcher.commandMap_[prefix] = { name, shortName: prefix, type: "api" };
        },
        handleKey: function(cm, key, origin) {
          var command = this.findKey(cm, key, origin);
          if (typeof command === "function") {
            return command();
          }
        },
        multiSelectHandleKey,
        findKey: function(cm, key, origin) {
          var vim = maybeInitVimState(cm);
          function handleMacroRecording() {
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isRecording) {
              if (key == "q") {
                macroModeState.exitMacroRecordMode();
                clearInputState(cm);
                return true;
              }
              if (origin != "mapping") {
                logKey(macroModeState, key);
              }
            }
          }
          function handleEsc() {
            if (key == "<Esc>") {
              if (vim.visualMode) {
                exitVisualMode(cm);
              } else if (vim.insertMode) {
                exitInsertMode(cm);
              } else {
                return;
              }
              clearInputState(cm);
              return true;
            }
          }
          function handleKeyInsertMode() {
            if (handleEsc()) {
              return true;
            }
            vim.inputState.keyBuffer.push(key);
            var keys = vim.inputState.keyBuffer.join("");
            var keysAreChars = key.length == 1;
            var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, "insert");
            var changeQueue = vim.inputState.changeQueue;
            if (match.type == "none") {
              clearInputState(cm);
              return false;
            } else if (match.type == "partial") {
              if (match.expectLiteralNext)
                vim.expectLiteralNext = true;
              if (lastInsertModeKeyTimer) {
                window.clearTimeout(lastInsertModeKeyTimer);
              }
              lastInsertModeKeyTimer = keysAreChars && window.setTimeout(function() {
                if (vim.insertMode && vim.inputState.keyBuffer.length) {
                  clearInputState(cm);
                }
              }, getOption("insertModeEscKeysTimeout"));
              if (keysAreChars) {
                var selections = cm.listSelections();
                if (!changeQueue || changeQueue.removed.length != selections.length)
                  changeQueue = vim.inputState.changeQueue = new ChangeQueue();
                changeQueue.inserted += key;
                for (var i = 0; i < selections.length; i++) {
                  var from = cursorMin(selections[i].anchor, selections[i].head);
                  var to2 = cursorMax(selections[i].anchor, selections[i].head);
                  var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to2, 0, 1) : to2);
                  changeQueue.removed[i] = (changeQueue.removed[i] || "") + text;
                }
              }
              return !keysAreChars;
            }
            vim.expectLiteralNext = false;
            if (lastInsertModeKeyTimer) {
              window.clearTimeout(lastInsertModeKeyTimer);
            }
            if (match.command && changeQueue) {
              var selections = cm.listSelections();
              for (var i = 0; i < selections.length; i++) {
                var here = selections[i].head;
                cm.replaceRange(changeQueue.removed[i] || "", offsetCursor(here, 0, -changeQueue.inserted.length), here, "+input");
              }
              vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
            }
            if (!match.command)
              clearInputState(cm);
            return match.command;
          }
          function handleKeyNonInsertMode() {
            if (handleMacroRecording() || handleEsc()) {
              return true;
            }
            vim.inputState.keyBuffer.push(key);
            var keys = vim.inputState.keyBuffer.join("");
            if (/^[1-9]\d*$/.test(keys)) {
              return true;
            }
            var keysMatcher = /^(\d*)(.*)$/.exec(keys);
            if (!keysMatcher) {
              clearInputState(cm);
              return false;
            }
            var context = vim.visualMode ? "visual" : "normal";
            var mainKey = keysMatcher[2] || keysMatcher[1];
            if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {
              mainKey = vim.inputState.operatorShortcut;
            }
            var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);
            if (match.type == "none") {
              clearInputState(cm);
              return false;
            } else if (match.type == "partial") {
              if (match.expectLiteralNext)
                vim.expectLiteralNext = true;
              return true;
            } else if (match.type == "clear") {
              clearInputState(cm);
              return true;
            }
            vim.expectLiteralNext = false;
            vim.inputState.keyBuffer.length = 0;
            keysMatcher = /^(\d*)(.*)$/.exec(keys);
            if (keysMatcher[1] && keysMatcher[1] != "0") {
              vim.inputState.pushRepeatDigit(keysMatcher[1]);
            }
            return match.command;
          }
          var command;
          if (vim.insertMode) {
            command = handleKeyInsertMode();
          } else {
            command = handleKeyNonInsertMode();
          }
          if (command === false) {
            return !vim.insertMode && key.length === 1 ? function() {
              return true;
            } : void 0;
          } else if (command === true) {
            return function() {
              return true;
            };
          } else {
            return function() {
              if ((command.operator || command.isEdit) && cm.getOption("readOnly"))
                return;
              return cm.operation(function() {
                cm.curOp.isVimOp = true;
                try {
                  if (command.type == "keyToKey") {
                    doKeyToKey(cm, command.toKeys, command);
                  } else {
                    commandDispatcher.processCommand(cm, vim, command);
                  }
                } catch (e) {
                  cm.state.vim = void 0;
                  maybeInitVimState(cm);
                  if (!vimApi.suppressErrorLogging) {
                    console["log"](e);
                  }
                  throw e;
                }
                return true;
              });
            };
          }
        },
        handleEx: function(cm, input) {
          exCommandDispatcher.processCommand(cm, input);
        },
        defineMotion,
        defineAction,
        defineOperator,
        mapCommand,
        _mapCommand,
        defineRegister,
        exitVisualMode,
        exitInsertMode
      };
      var keyToKeyStack = [];
      var noremap = false;
      var virtualPrompt;
      function sendKeyToPrompt(key) {
        if (key[0] == "<") {
          var lowerKey = key.toLowerCase().slice(1, -1);
          var parts = lowerKey.split("-");
          lowerKey = parts.pop() || "";
          if (lowerKey == "lt")
            key = "<";
          else if (lowerKey == "space")
            key = " ";
          else if (lowerKey == "cr")
            key = "\n";
          else if (vimToCmKeyMap[lowerKey]) {
            var value = virtualPrompt.value;
            var event2 = {
              key: vimToCmKeyMap[lowerKey],
              target: {
                value,
                selectionEnd: value.length,
                selectionStart: value.length
              }
            };
            if (virtualPrompt.onKeyDown) {
              virtualPrompt.onKeyDown(event2, virtualPrompt.value, close);
            }
            if (virtualPrompt && virtualPrompt.onKeyUp) {
              virtualPrompt.onKeyUp(event2, virtualPrompt.value, close);
            }
            return;
          }
        }
        if (key == "\n") {
          var prompt2 = virtualPrompt;
          virtualPrompt = null;
          prompt2.onClose && prompt2.onClose(prompt2.value);
        } else {
          virtualPrompt.value = (virtualPrompt.value || "") + key;
        }
        function close(value2) {
          if (typeof value2 == "string") {
            virtualPrompt.value = value2;
          } else {
            virtualPrompt = null;
          }
        }
      }
      function doKeyToKey(cm, keys, fromKey) {
        var noremapBefore = noremap;
        if (fromKey) {
          if (keyToKeyStack.indexOf(fromKey) != -1)
            return;
          keyToKeyStack.push(fromKey);
          noremap = fromKey.noremap != false;
        }
        try {
          var vim = maybeInitVimState(cm);
          var keyRe = /<(?:[CSMA]-)*\w+>|./gi;
          var match;
          while (match = keyRe.exec(keys)) {
            var key = match[0];
            var wasInsert = vim.insertMode;
            if (virtualPrompt) {
              sendKeyToPrompt(key);
              continue;
            }
            var result = vimApi.handleKey(cm, key, "mapping");
            if (!result && wasInsert && vim.insertMode) {
              if (key[0] == "<") {
                var lowerKey = key.toLowerCase().slice(1, -1);
                var parts = lowerKey.split("-");
                lowerKey = parts.pop() || "";
                if (lowerKey == "lt")
                  key = "<";
                else if (lowerKey == "space")
                  key = " ";
                else if (lowerKey == "cr")
                  key = "\n";
                else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {
                  key = vimToCmKeyMap[lowerKey];
                  sendCmKey(cm, key);
                  continue;
                } else {
                  key = key[0];
                  keyRe.lastIndex = match.index + 1;
                }
              }
              cm.replaceSelection(key);
            }
          }
        } finally {
          keyToKeyStack.pop();
          noremap = keyToKeyStack.length ? noremapBefore : false;
          if (!keyToKeyStack.length && virtualPrompt) {
            var promptOptions = virtualPrompt;
            virtualPrompt = null;
            showPrompt(cm, promptOptions);
          }
        }
      }
      var specialKey = {
        Return: "CR",
        Backspace: "BS",
        "Delete": "Del",
        Escape: "Esc",
        Insert: "Ins",
        ArrowLeft: "Left",
        ArrowRight: "Right",
        ArrowUp: "Up",
        ArrowDown: "Down",
        Enter: "CR",
        " ": "Space"
      };
      var ignoredKeys = {
        Shift: 1,
        Alt: 1,
        Command: 1,
        Control: 1,
        CapsLock: 1,
        AltGraph: 1,
        Dead: 1,
        Unidentified: 1
      };
      var vimToCmKeyMap = {};
      "Left|Right|Up|Down|End|Home".split("|").concat(Object.keys(specialKey)).forEach(function(x) {
        vimToCmKeyMap[(specialKey[x] || "").toLowerCase()] = vimToCmKeyMap[x.toLowerCase()] = x;
      });
      function vimKeyFromEvent(e, vim) {
        var key = e.key;
        if (ignoredKeys[key])
          return;
        if (key.length > 1 && key[0] == "n") {
          key = key.replace("Numpad", "");
        }
        key = specialKey[key] || key;
        var name = "";
        if (e.ctrlKey) {
          name += "C-";
        }
        if (e.altKey) {
          name += "A-";
        }
        if (e.metaKey) {
          name += "M-";
        }
        if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {
          name = name.slice(2);
        }
        if ((name || key.length > 1) && e.shiftKey) {
          name += "S-";
        }
        if (vim && !vim.expectLiteralNext && key.length == 1) {
          if (langmap.keymap && key in langmap.keymap) {
            if (langmap.remapCtrl != false || !name)
              key = langmap.keymap[key];
          } else if (key.charCodeAt(0) > 255) {
            var code = e.code && e.code.slice(-1) || "";
            if (!e.shiftKey)
              code = code.toLowerCase();
            if (code)
              key = code;
          }
        }
        name += key;
        if (name.length > 1) {
          name = "<" + name + ">";
        }
        return name;
      }
      ;
      function updateLangmap(langmapString, remapCtrl) {
        if (langmap.string !== langmapString) {
          langmap = parseLangmap(langmapString);
        }
        langmap.remapCtrl = remapCtrl;
      }
      function parseLangmap(langmapString) {
        var keymap = {};
        if (!langmapString)
          return { keymap, string: "" };
        function getEscaped(list) {
          return list.split(/\\?(.)/).filter(Boolean);
        }
        langmapString.split(/((?:[^\\,]|\\.)+),/).map(function(part) {
          if (!part)
            return;
          var semicolon = part.split(/((?:[^\\;]|\\.)+);/);
          if (semicolon.length == 3) {
            var from = getEscaped(semicolon[1]);
            var to2 = getEscaped(semicolon[2]);
            if (from.length !== to2.length)
              return;
            for (var i = 0; i < from.length; ++i)
              keymap[from[i]] = to2[i];
          } else if (semicolon.length == 1) {
            var pairs = getEscaped(part);
            if (pairs.length % 2 !== 0)
              return;
            for (var i = 0; i < pairs.length; i += 2)
              keymap[pairs[i]] = pairs[i + 1];
          }
        });
        return { keymap, string: langmapString };
      }
      defineOption("langmap", void 0, "string", ["lmap"], function(name, cm) {
        if (name === void 0) {
          return langmap.string;
        } else {
          updateLangmap(name);
        }
      });
      function InputState() {
        this.prefixRepeat = [];
        this.motionRepeat = [];
        this.operator = null;
        this.operatorArgs = null;
        this.motion = null;
        this.motionArgs = null;
        this.keyBuffer = [];
        this.registerName = null;
        this.changeQueue = null;
      }
      InputState.prototype.pushRepeatDigit = function(n) {
        if (!this.operator) {
          this.prefixRepeat = this.prefixRepeat.concat(n);
        } else {
          this.motionRepeat = this.motionRepeat.concat(n);
        }
      };
      InputState.prototype.getRepeat = function() {
        var repeat = 0;
        if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
          repeat = 1;
          if (this.prefixRepeat.length > 0) {
            repeat *= parseInt(this.prefixRepeat.join(""), 10);
          }
          if (this.motionRepeat.length > 0) {
            repeat *= parseInt(this.motionRepeat.join(""), 10);
          }
        }
        return repeat;
      };
      function clearInputState(cm, reason) {
        cm.state.vim.inputState = new InputState();
        cm.state.vim.expectLiteralNext = false;
        CodeMirror.signal(cm, "vim-command-done", reason);
      }
      function ChangeQueue() {
        this.removed = [];
        this.inserted = "";
      }
      function Register(text, linewise, blockwise) {
        this.clear();
        this.keyBuffer = [text || ""];
        this.insertModeChanges = [];
        this.searchQueries = [];
        this.linewise = !!linewise;
        this.blockwise = !!blockwise;
      }
      Register.prototype = {
        setText: function(text, linewise, blockwise) {
          this.keyBuffer = [text || ""];
          this.linewise = !!linewise;
          this.blockwise = !!blockwise;
        },
        pushText: function(text, linewise) {
          if (linewise) {
            if (!this.linewise) {
              this.keyBuffer.push("\n");
            }
            this.linewise = true;
          }
          this.keyBuffer.push(text);
        },
        pushInsertModeChanges: function(changes) {
          this.insertModeChanges.push(createInsertModeChanges(changes));
        },
        pushSearchQuery: function(query) {
          this.searchQueries.push(query);
        },
        clear: function() {
          this.keyBuffer = [];
          this.insertModeChanges = [];
          this.searchQueries = [];
          this.linewise = false;
        },
        toString: function() {
          return this.keyBuffer.join("");
        }
      };
      function defineRegister(name, register) {
        var registers = vimGlobalState.registerController.registers;
        if (!name || name.length != 1) {
          throw Error("Register name must be 1 character");
        }
        registers[name] = register;
        validRegisters.push(name);
      }
      function RegisterController(registers) {
        this.registers = registers;
        this.unnamedRegister = registers['"'] = new Register();
        registers["."] = new Register();
        registers[":"] = new Register();
        registers["/"] = new Register();
        registers["+"] = new Register();
      }
      RegisterController.prototype = {
        pushText: function(registerName, operator, text, linewise, blockwise) {
          if (registerName === "_")
            return;
          if (linewise && text.charAt(text.length - 1) !== "\n") {
            text += "\n";
          }
          var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;
          if (!register) {
            switch (operator) {
              case "yank":
                this.registers["0"] = new Register(text, linewise, blockwise);
                break;
              case "delete":
              case "change":
                if (text.indexOf("\n") == -1) {
                  this.registers["-"] = new Register(text, linewise);
                } else {
                  this.shiftNumericRegisters_();
                  this.registers["1"] = new Register(text, linewise);
                }
                break;
            }
            this.unnamedRegister.setText(text, linewise, blockwise);
            return;
          }
          var append = isUpperCase(registerName);
          if (append) {
            register.pushText(text, linewise);
          } else {
            register.setText(text, linewise, blockwise);
          }
          if (registerName === "+" && typeof navigator !== "undefined" && typeof navigator.clipboard !== "undefined" && typeof navigator.clipboard.readText === "function") {
            navigator.clipboard.writeText(text);
          }
          this.unnamedRegister.setText(register.toString(), linewise);
        },
        getRegister: function(name) {
          if (!this.isValidRegister(name)) {
            return this.unnamedRegister;
          }
          name = name.toLowerCase();
          if (!this.registers[name]) {
            this.registers[name] = new Register();
          }
          return this.registers[name];
        },
        isValidRegister: function(name) {
          return name && (inArray(name, validRegisters) || latinCharRegex.test(name));
        },
        shiftNumericRegisters_: function() {
          for (var i = 9; i >= 2; i--) {
            this.registers[i] = this.getRegister("" + (i - 1));
          }
        }
      };
      function HistoryController() {
        this.historyBuffer = [];
        this.iterator = 0;
        this.initialPrefix = null;
      }
      HistoryController.prototype = {
        nextMatch: function(input, up) {
          var historyBuffer = this.historyBuffer;
          var dir = up ? -1 : 1;
          if (this.initialPrefix === null)
            this.initialPrefix = input;
          for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {
            var element = historyBuffer[i];
            for (var j3 = 0; j3 <= element.length; j3++) {
              if (this.initialPrefix == element.substring(0, j3)) {
                this.iterator = i;
                return element;
              }
            }
          }
          if (i >= historyBuffer.length) {
            this.iterator = historyBuffer.length;
            return this.initialPrefix;
          }
          if (i < 0)
            return input;
        },
        pushInput: function(input) {
          var index = this.historyBuffer.indexOf(input);
          if (index > -1)
            this.historyBuffer.splice(index, 1);
          if (input.length)
            this.historyBuffer.push(input);
        },
        reset: function() {
          this.initialPrefix = null;
          this.iterator = this.historyBuffer.length;
        }
      };
      var commandDispatcher = {
        matchCommand: function(keys, keyMap, inputState, context) {
          var matches = commandMatches(keys, keyMap, context, inputState);
          if (!matches.full && !matches.partial) {
            return { type: "none" };
          } else if (!matches.full && matches.partial) {
            return {
              type: "partial",
              expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == "<character>"
              // langmap literal logic
            };
          }
          var bestMatch;
          for (var i = 0; i < matches.full.length; i++) {
            var match = matches.full[i];
            if (!bestMatch) {
              bestMatch = match;
            }
          }
          if (bestMatch.keys.slice(-11) == "<character>" || bestMatch.keys.slice(-10) == "<register>") {
            var character = lastChar(keys);
            if (!character || character.length > 1)
              return { type: "clear" };
            inputState.selectedCharacter = character;
          }
          return { type: "full", command: bestMatch };
        },
        processCommand: function(cm, vim, command) {
          vim.inputState.repeatOverride = command.repeatOverride;
          switch (command.type) {
            case "motion":
              this.processMotion(cm, vim, command);
              break;
            case "operator":
              this.processOperator(cm, vim, command);
              break;
            case "operatorMotion":
              this.processOperatorMotion(cm, vim, command);
              break;
            case "action":
              this.processAction(cm, vim, command);
              break;
            case "search":
              this.processSearch(cm, vim, command);
              break;
            case "ex":
            case "keyToEx":
              this.processEx(cm, vim, command);
              break;
            default:
              break;
          }
        },
        processMotion: function(cm, vim, command) {
          vim.inputState.motion = command.motion;
          vim.inputState.motionArgs = copyArgs(command.motionArgs);
          this.evalInput(cm, vim);
        },
        processOperator: function(cm, vim, command) {
          var inputState = vim.inputState;
          if (inputState.operator) {
            if (inputState.operator == command.operator) {
              inputState.motion = "expandToLine";
              inputState.motionArgs = { linewise: true };
              this.evalInput(cm, vim);
              return;
            } else {
              clearInputState(cm);
            }
          }
          inputState.operator = command.operator;
          inputState.operatorArgs = copyArgs(command.operatorArgs);
          if (command.keys.length > 1) {
            inputState.operatorShortcut = command.keys;
          }
          if (command.exitVisualBlock) {
            vim.visualBlock = false;
            updateCmSelection(cm);
          }
          if (vim.visualMode) {
            this.evalInput(cm, vim);
          }
        },
        processOperatorMotion: function(cm, vim, command) {
          var visualMode = vim.visualMode;
          var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
          if (operatorMotionArgs) {
            if (visualMode && operatorMotionArgs.visualLine) {
              vim.visualLine = true;
            }
          }
          this.processOperator(cm, vim, command);
          if (!visualMode) {
            this.processMotion(cm, vim, command);
          }
        },
        processAction: function(cm, vim, command) {
          var inputState = vim.inputState;
          var repeat = inputState.getRepeat();
          var repeatIsExplicit = !!repeat;
          var actionArgs = copyArgs(command.actionArgs) || {};
          if (inputState.selectedCharacter) {
            actionArgs.selectedCharacter = inputState.selectedCharacter;
          }
          if (command.operator) {
            this.processOperator(cm, vim, command);
          }
          if (command.motion) {
            this.processMotion(cm, vim, command);
          }
          if (command.motion || command.operator) {
            this.evalInput(cm, vim);
          }
          actionArgs.repeat = repeat || 1;
          actionArgs.repeatIsExplicit = repeatIsExplicit;
          actionArgs.registerName = inputState.registerName;
          clearInputState(cm);
          vim.lastMotion = null;
          if (command.isEdit) {
            this.recordLastEdit(vim, inputState, command);
          }
          actions[command.action](cm, actionArgs, vim);
        },
        processSearch: function(cm, vim, command) {
          if (!cm.getSearchCursor) {
            return;
          }
          var forward = command.searchArgs.forward;
          var wholeWordOnly = command.searchArgs.wholeWordOnly;
          getSearchState(cm).setReversed(!forward);
          var promptPrefix = forward ? "/" : "?";
          var originalQuery = getSearchState(cm).getQuery();
          var originalScrollPos = cm.getScrollInfo();
          function handleQuery(query2, ignoreCase, smartCase) {
            vimGlobalState.searchHistoryController.pushInput(query2);
            vimGlobalState.searchHistoryController.reset();
            try {
              updateSearchQuery(cm, query2, ignoreCase, smartCase);
            } catch (e) {
              showConfirm(cm, "Invalid regex: " + query2);
              clearInputState(cm);
              return;
            }
            commandDispatcher.processMotion(cm, vim, {
              type: "motion",
              motion: "findNext",
              motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }
            });
          }
          function onPromptClose(query2) {
            handleQuery(
              query2,
              true,
              true
              /** smartCase */
            );
            var macroModeState2 = vimGlobalState.macroModeState;
            if (macroModeState2.isRecording) {
              logSearchQuery(macroModeState2, query2);
            }
          }
          function onPromptKeyUp(e, query2, close) {
            var keyName = vimKeyFromEvent(e), up, offset;
            if (keyName == "<Up>" || keyName == "<Down>") {
              up = keyName == "<Up>" ? true : false;
              offset = e.target ? e.target.selectionEnd : 0;
              query2 = vimGlobalState.searchHistoryController.nextMatch(query2, up) || "";
              close(query2);
              if (offset && e.target)
                e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
            } else if (keyName && keyName != "<Left>" && keyName != "<Right>") {
              vimGlobalState.searchHistoryController.reset();
            }
            var parsedQuery;
            try {
              parsedQuery = updateSearchQuery(
                cm,
                query2,
                true,
                true
                /** smartCase */
              );
            } catch (e2) {
            }
            if (parsedQuery) {
              cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
            } else {
              clearSearchHighlight(cm);
              cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            }
          }
          function onPromptKeyDown(e, query2, close) {
            var keyName = vimKeyFromEvent(e);
            if (keyName == "<Esc>" || keyName == "<C-c>" || keyName == "<C-[>" || keyName == "<BS>" && query2 == "") {
              vimGlobalState.searchHistoryController.pushInput(query2);
              vimGlobalState.searchHistoryController.reset();
              updateSearchQuery(cm, originalQuery);
              clearSearchHighlight(cm);
              cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
              CodeMirror.e_stop(e);
              clearInputState(cm);
              close();
              cm.focus();
            } else if (keyName == "<Up>" || keyName == "<Down>") {
              CodeMirror.e_stop(e);
            } else if (keyName == "<C-u>") {
              CodeMirror.e_stop(e);
              close("");
            }
          }
          switch (command.searchArgs.querySrc) {
            case "prompt":
              var macroModeState = vimGlobalState.macroModeState;
              if (macroModeState.isPlaying) {
                var query = macroModeState.replaySearchQueries.shift();
                handleQuery(
                  query,
                  true,
                  false
                  /** smartCase */
                );
              } else {
                showPrompt(cm, {
                  onClose: onPromptClose,
                  prefix: promptPrefix,
                  desc: "(JavaScript regexp)",
                  onKeyUp: onPromptKeyUp,
                  onKeyDown: onPromptKeyDown
                });
              }
              break;
            case "wordUnderCursor":
              var word = expandWordUnderCursor(cm, { noSymbol: true });
              var isKeyword = true;
              if (!word) {
                word = expandWordUnderCursor(cm, { noSymbol: false });
                isKeyword = false;
              }
              if (!word) {
                showConfirm(cm, "No word under cursor");
                clearInputState(cm);
                return;
              }
              var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);
              if (isKeyword && wholeWordOnly) {
                query = "\\b" + query + "\\b";
              } else {
                query = escapeRegex(query);
              }
              vimGlobalState.jumpList.cachedCursor = cm.getCursor();
              cm.setCursor(word.start);
              handleQuery(
                query,
                true,
                false
                /** smartCase */
              );
              break;
          }
        },
        processEx: function(cm, vim, command) {
          function onPromptClose(input) {
            vimGlobalState.exCommandHistoryController.pushInput(input);
            vimGlobalState.exCommandHistoryController.reset();
            exCommandDispatcher.processCommand(cm, input);
            if (cm.state.vim)
              clearInputState(cm);
          }
          function onPromptKeyDown(e, input, close) {
            var keyName = vimKeyFromEvent(e), up, offset;
            if (keyName == "<Esc>" || keyName == "<C-c>" || keyName == "<C-[>" || keyName == "<BS>" && input == "") {
              vimGlobalState.exCommandHistoryController.pushInput(input);
              vimGlobalState.exCommandHistoryController.reset();
              CodeMirror.e_stop(e);
              clearInputState(cm);
              close();
              cm.focus();
            }
            if (keyName == "<Up>" || keyName == "<Down>") {
              CodeMirror.e_stop(e);
              up = keyName == "<Up>" ? true : false;
              offset = e.target ? e.target.selectionEnd : 0;
              input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || "";
              close(input);
              if (offset && e.target)
                e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
            } else if (keyName == "<C-u>") {
              CodeMirror.e_stop(e);
              close("");
            } else if (keyName && keyName != "<Left>" && keyName != "<Right>") {
              vimGlobalState.exCommandHistoryController.reset();
            }
          }
          if (command.type == "keyToEx") {
            exCommandDispatcher.processCommand(cm, command.exArgs.input);
          } else {
            if (vim.visualMode) {
              showPrompt(cm, {
                onClose: onPromptClose,
                prefix: ":",
                value: "'<,'>",
                onKeyDown: onPromptKeyDown,
                selectValueOnOpen: false
              });
            } else {
              showPrompt(cm, {
                onClose: onPromptClose,
                prefix: ":",
                onKeyDown: onPromptKeyDown
              });
            }
          }
        },
        evalInput: function(cm, vim) {
          var inputState = vim.inputState;
          var motion = inputState.motion;
          var motionArgs = inputState.motionArgs || {};
          var operator = inputState.operator;
          var operatorArgs = inputState.operatorArgs || {};
          var registerName = inputState.registerName;
          var sel = vim.sel;
          var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor("head"));
          var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor("anchor"));
          var oldHead = copyCursor(origHead);
          var oldAnchor = copyCursor(origAnchor);
          var newHead, newAnchor;
          var repeat;
          if (operator) {
            this.recordLastEdit(vim, inputState);
          }
          if (inputState.repeatOverride !== void 0) {
            repeat = inputState.repeatOverride;
          } else {
            repeat = inputState.getRepeat();
          }
          if (repeat > 0 && motionArgs.explicitRepeat) {
            motionArgs.repeatIsExplicit = true;
          } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {
            repeat = 1;
            motionArgs.repeatIsExplicit = false;
          }
          if (inputState.selectedCharacter) {
            motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;
          }
          motionArgs.repeat = repeat;
          clearInputState(cm);
          if (motion) {
            var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);
            vim.lastMotion = motions[motion];
            if (!motionResult) {
              return;
            }
            if (motionArgs.toJumplist) {
              if (!operator && cm.ace.curOp != null)
                cm.ace.curOp.command.scrollIntoView = "center-animate";
              var jumpList = vimGlobalState.jumpList;
              var cachedCursor = jumpList.cachedCursor;
              if (cachedCursor) {
                recordJumpPosition(cm, cachedCursor, motionResult);
                delete jumpList.cachedCursor;
              } else {
                recordJumpPosition(cm, origHead, motionResult);
              }
            }
            if (motionResult instanceof Array) {
              newAnchor = motionResult[0];
              newHead = motionResult[1];
            } else {
              newHead = motionResult;
            }
            if (!newHead) {
              newHead = copyCursor(origHead);
            }
            if (vim.visualMode) {
              if (!(vim.visualBlock && newHead.ch === Infinity)) {
                newHead = clipCursorToContent(cm, newHead, oldHead);
              }
              if (newAnchor) {
                newAnchor = clipCursorToContent(cm, newAnchor);
              }
              newAnchor = newAnchor || oldAnchor;
              sel.anchor = newAnchor;
              sel.head = newHead;
              updateCmSelection(cm);
              updateMark(cm, vim, "<", cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);
              updateMark(cm, vim, ">", cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);
            } else if (!operator) {
              if (cm.ace.curOp)
                cm.ace.curOp.vimDialogScroll = "center-animate";
              newHead = clipCursorToContent(cm, newHead, oldHead);
              cm.setCursor(newHead.line, newHead.ch);
            }
          }
          if (operator) {
            if (operatorArgs.lastSel) {
              newAnchor = oldAnchor;
              var lastSel = operatorArgs.lastSel;
              var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
              var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
              if (lastSel.visualLine) {
                newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
              } else if (lastSel.visualBlock) {
                newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
              } else if (lastSel.head.line == lastSel.anchor.line) {
                newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);
              } else {
                newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
              }
              vim.visualMode = true;
              vim.visualLine = lastSel.visualLine;
              vim.visualBlock = lastSel.visualBlock;
              sel = vim.sel = {
                anchor: newAnchor,
                head: newHead
              };
              updateCmSelection(cm);
            } else if (vim.visualMode) {
              operatorArgs.lastSel = {
                anchor: copyCursor(sel.anchor),
                head: copyCursor(sel.head),
                visualBlock: vim.visualBlock,
                visualLine: vim.visualLine
              };
            }
            var curStart, curEnd, linewise, mode;
            var cmSel;
            if (vim.visualMode) {
              curStart = cursorMin(sel.head, sel.anchor);
              curEnd = cursorMax(sel.head, sel.anchor);
              linewise = vim.visualLine || operatorArgs.linewise;
              mode = vim.visualBlock ? "block" : linewise ? "line" : "char";
              var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
              cmSel = makeCmSelection(cm, {
                anchor: newPositions.start,
                head: newPositions.end
              }, mode);
              if (linewise) {
                var ranges = cmSel.ranges;
                if (mode == "block") {
                  for (var i = 0; i < ranges.length; i++) {
                    ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
                  }
                } else if (mode == "line") {
                  ranges[0].head = new Pos(ranges[0].head.line + 1, 0);
                }
              }
            } else {
              curStart = copyCursor(newAnchor || oldAnchor);
              curEnd = copyCursor(newHead || oldHead);
              if (cursorIsBefore(curEnd, curStart)) {
                var tmp = curStart;
                curStart = curEnd;
                curEnd = tmp;
              }
              linewise = motionArgs.linewise || operatorArgs.linewise;
              if (linewise) {
                expandSelectionToLine(cm, curStart, curEnd);
              } else if (motionArgs.forward) {
                clipToLine(cm, curStart, curEnd);
              }
              mode = "char";
              var exclusive = !motionArgs.inclusive || linewise;
              var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
              cmSel = makeCmSelection(cm, {
                anchor: newPositions.start,
                head: newPositions.end
              }, mode, exclusive);
            }
            cm.setSelections(cmSel.ranges, cmSel.primary);
            vim.lastMotion = null;
            operatorArgs.repeat = repeat;
            operatorArgs.registerName = registerName;
            operatorArgs.linewise = linewise;
            var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
            if (vim.visualMode) {
              exitVisualMode(cm, operatorMoveTo != null);
            }
            if (operatorMoveTo) {
              cm.setCursor(operatorMoveTo);
            }
          }
        },
        recordLastEdit: function(vim, inputState, actionCommand) {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isPlaying) {
            return;
          }
          vim.lastEditInputState = inputState;
          vim.lastEditActionCommand = actionCommand;
          macroModeState.lastInsertModeChanges.changes = [];
          macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
          macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
        }
      };
      var motions = {
        moveToTopLine: function(cm, _head, motionArgs) {
          var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;
          return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
        },
        moveToMiddleLine: function(cm) {
          var range = getUserVisibleLines(cm);
          var line = Math.floor((range.top + range.bottom) * 0.5);
          return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
        },
        moveToBottomLine: function(cm, _head, motionArgs) {
          var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;
          return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
        },
        expandToLine: function(_cm, head, motionArgs) {
          var cur = head;
          return new Pos(cur.line + motionArgs.repeat - 1, Infinity);
        },
        findNext: function(cm, _head, motionArgs) {
          var state = getSearchState(cm);
          var query = state.getQuery();
          if (!query) {
            return;
          }
          var prev = !motionArgs.forward;
          prev = state.isReversed() ? !prev : prev;
          highlightSearchMatches(cm, query);
          return findNext(cm, prev, query, motionArgs.repeat);
        },
        findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {
          var state = getSearchState(cm);
          var query = state.getQuery();
          if (!query) {
            return;
          }
          var prev = !motionArgs.forward;
          prev = state.isReversed() ? !prev : prev;
          var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);
          if (!next) {
            return;
          }
          if (prevInputState.operator) {
            return next;
          }
          var from = next[0];
          var to2 = new Pos(next[1].line, next[1].ch - 1);
          if (vim.visualMode) {
            if (vim.visualLine || vim.visualBlock) {
              vim.visualLine = false;
              vim.visualBlock = false;
              CodeMirror.signal(cm, "vim-mode-change", { mode: "visual", subMode: "" });
            }
            var anchor = vim.sel.anchor;
            if (anchor) {
              if (state.isReversed()) {
                if (motionArgs.forward) {
                  return [anchor, from];
                }
                return [anchor, to2];
              } else {
                if (motionArgs.forward) {
                  return [anchor, to2];
                }
                return [anchor, from];
              }
            }
          } else {
            vim.visualMode = true;
            vim.visualLine = false;
            vim.visualBlock = false;
            CodeMirror.signal(cm, "vim-mode-change", { mode: "visual", subMode: "" });
          }
          return prev ? [to2, from] : [from, to2];
        },
        goToMark: function(cm, _head, motionArgs, vim) {
          var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
          if (pos) {
            return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
          }
          return null;
        },
        moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {
          if (vim.visualBlock && motionArgs.sameLine) {
            var sel = vim.sel;
            return [
              clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),
              clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))
            ];
          } else {
            return [vim.sel.head, vim.sel.anchor];
          }
        },
        jumpToMark: function(cm, head, motionArgs, vim) {
          var best = head;
          for (var i = 0; i < motionArgs.repeat; i++) {
            var cursor = best;
            for (var key in vim.marks) {
              if (!isLowerCase(key)) {
                continue;
              }
              var mark = vim.marks[key].find();
              var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);
              if (isWrongDirection) {
                continue;
              }
              if (motionArgs.linewise && mark.line == cursor.line) {
                continue;
              }
              var equal = cursorEqual(cursor, best);
              var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);
              if (equal || between) {
                best = mark;
              }
            }
          }
          if (motionArgs.linewise) {
            best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
          }
          return best;
        },
        moveByCharacters: function(_cm, head, motionArgs) {
          var cur = head;
          var repeat = motionArgs.repeat;
          var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
          return new Pos(cur.line, ch);
        },
        moveByLines: function(cm, head, motionArgs, vim) {
          var cur = head;
          var endCh = cur.ch;
          switch (vim.lastMotion) {
            case this.moveByLines:
            case this.moveByDisplayLines:
            case this.moveByScroll:
            case this.moveToColumn:
            case this.moveToEol:
              endCh = vim.lastHPos;
              break;
            default:
              vim.lastHPos = endCh;
          }
          var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);
          var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
          var first = cm.firstLine();
          var last = cm.lastLine();
          if (line < first && cur.line == first) {
            return this.moveToStartOfLine(cm, head, motionArgs, vim);
          } else if (line > last && cur.line == last) {
            return moveToEol(cm, head, motionArgs, vim, true);
          }
          var fold = cm.ace.session.getFoldLine(line);
          if (fold) {
            if (motionArgs.forward) {
              if (line > fold.start.row)
                line = fold.end.row + 1;
            } else {
              line = fold.start.row;
            }
          }
          if (motionArgs.toFirstChar) {
            endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));
            vim.lastHPos = endCh;
          }
          vim.lastHSPos = cm.charCoords(new Pos(line, endCh), "div").left;
          return new Pos(line, endCh);
        },
        moveByDisplayLines: function(cm, head, motionArgs, vim) {
          var cur = head;
          switch (vim.lastMotion) {
            case this.moveByDisplayLines:
            case this.moveByScroll:
            case this.moveByLines:
            case this.moveToColumn:
            case this.moveToEol:
              break;
            default:
              vim.lastHSPos = cm.charCoords(cur, "div").left;
          }
          var repeat = motionArgs.repeat;
          var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, "line", vim.lastHSPos);
          if (res.hitSide) {
            if (motionArgs.forward) {
              var lastCharCoords = cm.charCoords(res, "div");
              var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };
              var res = cm.coordsChar(goalCoords, "div");
            } else {
              var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), "div");
              resCoords.left = vim.lastHSPos;
              res = cm.coordsChar(resCoords, "div");
            }
          }
          vim.lastHPos = res.ch;
          return res;
        },
        moveByPage: function(cm, head, motionArgs) {
          var curStart = head;
          var repeat = motionArgs.repeat;
          return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, "page");
        },
        moveByParagraph: function(cm, head, motionArgs) {
          var dir = motionArgs.forward ? 1 : -1;
          return findParagraph(cm, head, motionArgs.repeat, dir);
        },
        moveBySentence: function(cm, head, motionArgs) {
          var dir = motionArgs.forward ? 1 : -1;
          return findSentence(cm, head, motionArgs.repeat, dir);
        },
        moveByScroll: function(cm, head, motionArgs, vim) {
          var scrollbox = cm.getScrollInfo();
          var curEnd = null;
          var repeat = motionArgs.repeat;
          if (!repeat) {
            repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
          }
          var orig = cm.charCoords(head, "local");
          motionArgs.repeat = repeat;
          curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
          if (!curEnd) {
            return null;
          }
          var dest = cm.charCoords(curEnd, "local");
          cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
          return curEnd;
        },
        moveByWords: function(cm, head, motionArgs) {
          return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);
        },
        moveTillCharacter: function(cm, head, motionArgs) {
          var repeat = motionArgs.repeat;
          var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head);
          var increment = motionArgs.forward ? -1 : 1;
          recordLastCharacterSearch(increment, motionArgs);
          if (!curEnd)
            return null;
          curEnd.ch += increment;
          return curEnd;
        },
        moveToCharacter: function(cm, head, motionArgs) {
          var repeat = motionArgs.repeat;
          recordLastCharacterSearch(0, motionArgs);
          return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head) || head;
        },
        moveToSymbol: function(cm, head, motionArgs) {
          var repeat = motionArgs.repeat;
          return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
        },
        moveToColumn: function(cm, head, motionArgs, vim) {
          var repeat = motionArgs.repeat;
          vim.lastHPos = repeat - 1;
          vim.lastHSPos = cm.charCoords(head, "div").left;
          return moveToColumn(cm, repeat);
        },
        moveToEol: function(cm, head, motionArgs, vim) {
          return moveToEol(cm, head, motionArgs, vim, false);
        },
        moveToFirstNonWhiteSpaceCharacter: function(cm, head) {
          var cursor = head;
          return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
        },
        moveToMatchedSymbol: function(cm, head) {
          var cursor = head;
          var line = cursor.line;
          var ch = cursor.ch;
          var lineText = cm.getLine(line);
          var symbol;
          for (; ch < lineText.length; ch++) {
            symbol = lineText.charAt(ch);
            if (symbol && isMatchableSymbol(symbol)) {
              var style = cm.getTokenTypeAt(new Pos(line, ch + 1));
              if (style !== "string" && style !== "comment") {
                break;
              }
            }
          }
          if (ch < lineText.length) {
            var re3 = /[<>]/.test(lineText[ch]) ? /[(){}[\]<>]/ : /[(){}[\]]/;
            var matched = cm.findMatchingBracket(new Pos(line, ch + 1), { bracketRegex: re3 });
            return matched.to;
          } else {
            return cursor;
          }
        },
        moveToStartOfLine: function(_cm, head) {
          return new Pos(head.line, 0);
        },
        moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {
          var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
          if (motionArgs.repeatIsExplicit) {
            lineNum = motionArgs.repeat - cm.getOption("firstLineNumber");
          }
          return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
        },
        moveToStartOfDisplayLine: function(cm) {
          cm.execCommand("goLineLeft");
          return cm.getCursor();
        },
        moveToEndOfDisplayLine: function(cm) {
          cm.execCommand("goLineRight");
          var head = cm.getCursor();
          if (head.sticky == "before")
            head.ch--;
          return head;
        },
        textObjectManipulation: function(cm, head, motionArgs, vim) {
          var mirroredPairs = {
            "(": ")",
            ")": "(",
            "{": "}",
            "}": "{",
            "[": "]",
            "]": "[",
            "<": ">",
            ">": "<"
          };
          var selfPaired = { "'": true, '"': true, "`": true };
          var character = motionArgs.selectedCharacter;
          if (character == "b") {
            character = "(";
          } else if (character == "B") {
            character = "{";
          }
          var inclusive = !motionArgs.textObjectInner;
          var tmp, move;
          if (mirroredPairs[character]) {
            move = true;
            tmp = selectCompanionObject(cm, head, character, inclusive);
            if (!tmp) {
              var sc2 = cm.getSearchCursor(new RegExp("\\" + character, "g"), head);
              if (sc2.find()) {
                tmp = selectCompanionObject(cm, sc2.from(), character, inclusive);
              }
            }
          } else if (selfPaired[character]) {
            move = true;
            tmp = findBeginningAndEnd(cm, head, character, inclusive);
          } else if (character === "W" || character === "w") {
            var repeat = motionArgs.repeat || 1;
            while (repeat-- > 0) {
              var repeated = expandWordUnderCursor(cm, {
                inclusive,
                innerWord: !inclusive,
                bigWord: character === "W",
                noSymbol: character === "W",
                multiline: true
              }, tmp && tmp.end);
              if (repeated) {
                if (!tmp)
                  tmp = repeated;
                tmp.end = repeated.end;
              }
            }
          } else if (character === "p") {
            tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
            motionArgs.linewise = true;
            if (vim.visualMode) {
              if (!vim.visualLine) {
                vim.visualLine = true;
              }
            } else {
              var operatorArgs = vim.inputState.operatorArgs;
              if (operatorArgs) {
                operatorArgs.linewise = true;
              }
              tmp.end.line--;
            }
          } else if (character === "t") {
            tmp = expandTagUnderCursor(cm, head, inclusive);
          } else if (character === "s") {
            var content = cm.getLine(head.line);
            if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {
              head.ch -= 1;
            }
            var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);
            var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);
            if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {
              start = { line: start.line, ch: start.ch + 1 };
            }
            tmp = { start, end };
          }
          if (!tmp) {
            return null;
          }
          if (!cm.state.vim.visualMode) {
            return [tmp.start, tmp.end];
          } else {
            return expandSelection(cm, tmp.start, tmp.end, move);
          }
        },
        repeatLastCharacterSearch: function(cm, head, motionArgs) {
          var lastSearch = vimGlobalState.lastCharacterSearch;
          var repeat = motionArgs.repeat;
          var forward = motionArgs.forward === lastSearch.forward;
          var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
          cm.moveH(-increment, "char");
          motionArgs.inclusive = forward ? true : false;
          var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
          if (!curEnd) {
            cm.moveH(increment, "char");
            return head;
          }
          curEnd.ch += increment;
          return curEnd;
        }
      };
      function defineMotion(name, fn3) {
        motions[name] = fn3;
      }
      function fillArray(val, times) {
        var arr = [];
        for (var i = 0; i < times; i++) {
          arr.push(val);
        }
        return arr;
      }
      var operators = {
        change: function(cm, args, ranges) {
          var finalHead, text;
          var vim = cm.state.vim;
          var anchor = ranges[0].anchor, head = ranges[0].head;
          if (!vim.visualMode) {
            text = cm.getRange(anchor, head);
            var lastState = vim.lastEditInputState || {};
            if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
              var match = /\s+$/.exec(text);
              if (match && lastState.motionArgs && lastState.motionArgs.forward) {
                head = offsetCursor(head, 0, -match[0].length);
                text = text.slice(0, -match[0].length);
              }
            }
            if (args.linewise) {
              anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));
              if (head.line > anchor.line) {
                head = new Pos(head.line - 1, Number.MAX_VALUE);
              }
            }
            cm.replaceRange("", anchor, head);
            finalHead = anchor;
          } else if (args.fullLine) {
            head.ch = Number.MAX_VALUE;
            head.line--;
            cm.setSelection(anchor, head);
            text = cm.getSelection();
            cm.replaceSelection("");
            finalHead = anchor;
          } else {
            text = cm.getSelection();
            var replacement = fillArray("", ranges.length);
            cm.replaceSelections(replacement);
            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
          }
          vimGlobalState.registerController.pushText(args.registerName, "change", text, args.linewise, ranges.length > 1);
          actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);
        },
        "delete": function(cm, args, ranges) {
          var finalHead, text;
          var vim = cm.state.vim;
          if (!vim.visualBlock) {
            var anchor = ranges[0].anchor, head = ranges[0].head;
            if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {
              if (anchor.line == cm.firstLine()) {
                anchor.ch = 0;
              } else {
                anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
              }
            }
            text = cm.getRange(anchor, head);
            cm.replaceRange("", anchor, head);
            finalHead = anchor;
            if (args.linewise) {
              finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
            }
          } else {
            text = cm.getSelection();
            var replacement = fillArray("", ranges.length);
            cm.replaceSelections(replacement);
            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
          }
          vimGlobalState.registerController.pushText(args.registerName, "delete", text, args.linewise, vim.visualBlock);
          return clipCursorToContent(cm, finalHead);
        },
        indent: function(cm, args, ranges) {
          var vim = cm.state.vim;
          var repeat = vim.visualMode ? args.repeat : 1;
          if (vim.visualBlock) {
            var tabSize = cm.getOption("tabSize");
            var indent = cm.getOption("indentWithTabs") ? "	" : " ".repeat(tabSize);
            var cursor;
            for (var i = ranges.length - 1; i >= 0; i--) {
              cursor = cursorMin(ranges[i].anchor, ranges[i].head);
              if (args.indentRight) {
                cm.replaceRange(indent.repeat(repeat), cursor, cursor);
              } else {
                var text = cm.getLine(cursor.line);
                var end = 0;
                for (var j3 = 0; j3 < repeat; j3++) {
                  var ch = text[cursor.ch + end];
                  if (ch == "	") {
                    end++;
                  } else if (ch == " ") {
                    end++;
                    for (var k2 = 1; k2 < indent.length; k2++) {
                      ch = text[cursor.ch + end];
                      if (ch !== " ")
                        break;
                      end++;
                    }
                  } else {
                    break;
                  }
                }
                cm.replaceRange("", cursor, offsetCursor(cursor, 0, end));
              }
            }
            return cursor;
          } else if (cm.indentMore) {
            for (var j3 = 0; j3 < repeat; j3++) {
              if (args.indentRight)
                cm.indentMore();
              else
                cm.indentLess();
            }
          } else {
            var startLine = ranges[0].anchor.line;
            var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;
            if (args.linewise) {
              endLine--;
            }
            for (var i = startLine; i <= endLine; i++) {
              for (var j3 = 0; j3 < repeat; j3++) {
                cm.indentLine(i, args.indentRight);
              }
            }
          }
          return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
        },
        indentAuto: function(cm, _args, ranges) {
          cm.execCommand("indentAuto");
          return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
        },
        hardWrap: function(cm, operatorArgs, ranges, oldAnchor, newHead) {
          if (!cm.hardWrap)
            return;
          var from = ranges[0].anchor.line;
          var to2 = ranges[0].head.line;
          if (operatorArgs.linewise)
            to2--;
          var endRow = cm.hardWrap({ from, to: to2 });
          if (endRow > from && operatorArgs.linewise)
            endRow--;
          return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);
        },
        changeCase: function(cm, args, ranges, oldAnchor, newHead) {
          var selections = cm.getSelections();
          var swapped = [];
          var toLower = args.toLower;
          for (var j3 = 0; j3 < selections.length; j3++) {
            var toSwap = selections[j3];
            var text = "";
            if (toLower === true) {
              text = toSwap.toLowerCase();
            } else if (toLower === false) {
              text = toSwap.toUpperCase();
            } else {
              for (var i = 0; i < toSwap.length; i++) {
                var character = toSwap.charAt(i);
                text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();
              }
            }
            swapped.push(text);
          }
          cm.replaceSelections(swapped);
          if (args.shouldMoveCursor) {
            return newHead;
          } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
            return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
          } else if (args.linewise) {
            return oldAnchor;
          } else {
            return cursorMin(ranges[0].anchor, ranges[0].head);
          }
        },
        yank: function(cm, args, ranges, oldAnchor) {
          var vim = cm.state.vim;
          var text = cm.getSelection();
          var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;
          vimGlobalState.registerController.pushText(args.registerName, "yank", text, args.linewise, vim.visualBlock);
          return endPos;
        }
      };
      function defineOperator(name, fn3) {
        operators[name] = fn3;
      }
      var actions = {
        jumpListWalk: function(cm, actionArgs, vim) {
          if (vim.visualMode) {
            return;
          }
          var repeat = actionArgs.repeat;
          var forward = actionArgs.forward;
          var jumpList = vimGlobalState.jumpList;
          var mark = jumpList.move(cm, forward ? repeat : -repeat);
          var markPos = mark ? mark.find() : void 0;
          markPos = markPos ? markPos : cm.getCursor();
          cm.setCursor(markPos);
          cm.ace.curOp.command.scrollIntoView = "center-animate";
        },
        scroll: function(cm, actionArgs, vim) {
          if (vim.visualMode) {
            return;
          }
          var repeat = actionArgs.repeat || 1;
          var lineHeight = cm.defaultTextHeight();
          var top = cm.getScrollInfo().top;
          var delta = lineHeight * repeat;
          var newPos = actionArgs.forward ? top + delta : top - delta;
          var cursor = copyCursor(cm.getCursor());
          var cursorCoords = cm.charCoords(cursor, "local");
          if (actionArgs.forward) {
            if (newPos > cursorCoords.top) {
              cursor.line += (newPos - cursorCoords.top) / lineHeight;
              cursor.line = Math.ceil(cursor.line);
              cm.setCursor(cursor);
              cursorCoords = cm.charCoords(cursor, "local");
              cm.scrollTo(null, cursorCoords.top);
            } else {
              cm.scrollTo(null, newPos);
            }
          } else {
            var newBottom = newPos + cm.getScrollInfo().clientHeight;
            if (newBottom < cursorCoords.bottom) {
              cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
              cursor.line = Math.floor(cursor.line);
              cm.setCursor(cursor);
              cursorCoords = cm.charCoords(cursor, "local");
              cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
            } else {
              cm.scrollTo(null, newPos);
            }
          }
        },
        scrollToCursor: function(cm, actionArgs) {
          var lineNum = cm.getCursor().line;
          var charCoords = cm.charCoords(new Pos(lineNum, 0), "local");
          var height = cm.getScrollInfo().clientHeight;
          var y2 = charCoords.top;
          switch (actionArgs.position) {
            case "center":
              y2 = charCoords.bottom - height / 2;
              break;
            case "bottom":
              var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);
              var lineLastCharCoords = cm.charCoords(lineLastCharPos, "local");
              var lineHeight = lineLastCharCoords.bottom - y2;
              y2 = y2 - height + lineHeight;
              break;
          }
          cm.scrollTo(null, y2);
        },
        replayMacro: function(cm, actionArgs, vim) {
          var registerName = actionArgs.selectedCharacter;
          var repeat = actionArgs.repeat;
          var macroModeState = vimGlobalState.macroModeState;
          if (registerName == "@") {
            registerName = macroModeState.latestRegister;
          } else {
            macroModeState.latestRegister = registerName;
          }
          while (repeat--) {
            executeMacroRegister(cm, vim, macroModeState, registerName);
          }
        },
        enterMacroRecordMode: function(cm, actionArgs) {
          var macroModeState = vimGlobalState.macroModeState;
          var registerName = actionArgs.selectedCharacter;
          if (vimGlobalState.registerController.isValidRegister(registerName)) {
            macroModeState.enterMacroRecordMode(cm, registerName);
          }
        },
        toggleOverwrite: function(cm) {
          if (!cm.state.overwrite) {
            cm.toggleOverwrite(true);
            cm.setOption("keyMap", "vim-replace");
            CodeMirror.signal(cm, "vim-mode-change", { mode: "replace" });
          } else {
            cm.toggleOverwrite(false);
            cm.setOption("keyMap", "vim-insert");
            CodeMirror.signal(cm, "vim-mode-change", { mode: "insert" });
          }
        },
        enterInsertMode: function(cm, actionArgs, vim) {
          if (cm.getOption("readOnly")) {
            return;
          }
          vim.insertMode = true;
          vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
          var insertAt = actionArgs ? actionArgs.insertAt : null;
          var sel = vim.sel;
          var head = actionArgs.head || cm.getCursor("head");
          var height = cm.listSelections().length;
          if (insertAt == "eol") {
            head = new Pos(head.line, lineLength(cm, head.line));
          } else if (insertAt == "bol") {
            head = new Pos(head.line, 0);
          } else if (insertAt == "charAfter") {
            var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));
            head = newPosition.end;
          } else if (insertAt == "firstNonBlank") {
            var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));
            head = newPosition.end;
          } else if (insertAt == "startOfSelectedArea") {
            if (!vim.visualMode)
              return;
            if (!vim.visualBlock) {
              if (sel.head.line < sel.anchor.line) {
                head = sel.head;
              } else {
                head = new Pos(sel.anchor.line, 0);
              }
            } else {
              head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));
              height = Math.abs(sel.head.line - sel.anchor.line) + 1;
            }
          } else if (insertAt == "endOfSelectedArea") {
            if (!vim.visualMode)
              return;
            if (!vim.visualBlock) {
              if (sel.head.line >= sel.anchor.line) {
                head = offsetCursor(sel.head, 0, 1);
              } else {
                head = new Pos(sel.anchor.line, 0);
              }
            } else {
              head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);
              height = Math.abs(sel.head.line - sel.anchor.line) + 1;
            }
          } else if (insertAt == "inplace") {
            if (vim.visualMode) {
              return;
            }
          } else if (insertAt == "lastEdit") {
            head = getLastEditPos(cm) || head;
          }
          cm.setOption("disableInput", false);
          if (actionArgs && actionArgs.replace) {
            cm.toggleOverwrite(true);
            cm.setOption("keyMap", "vim-replace");
            CodeMirror.signal(cm, "vim-mode-change", { mode: "replace" });
          } else {
            cm.toggleOverwrite(false);
            cm.setOption("keyMap", "vim-insert");
            CodeMirror.signal(cm, "vim-mode-change", { mode: "insert" });
          }
          if (!vimGlobalState.macroModeState.isPlaying) {
            cm.on("change", onChange);
            if (vim.insertEnd)
              vim.insertEnd.clear();
            vim.insertEnd = cm.setBookmark(head, { insertLeft: true });
            CodeMirror.on(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
          }
          if (vim.visualMode) {
            exitVisualMode(cm);
          }
          selectForInsert(cm, head, height);
        },
        toggleVisualMode: function(cm, actionArgs, vim) {
          var repeat = actionArgs.repeat;
          var anchor = cm.getCursor();
          var head;
          if (!vim.visualMode) {
            vim.visualMode = true;
            vim.visualLine = !!actionArgs.linewise;
            vim.visualBlock = !!actionArgs.blockwise;
            head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));
            var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);
            vim.sel = {
              anchor: newPosition.start,
              head: newPosition.end
            };
            CodeMirror.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : "" });
            updateCmSelection(cm);
            updateMark(cm, vim, "<", cursorMin(anchor, head));
            updateMark(cm, vim, ">", cursorMax(anchor, head));
          } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {
            vim.visualLine = !!actionArgs.linewise;
            vim.visualBlock = !!actionArgs.blockwise;
            CodeMirror.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : "" });
            updateCmSelection(cm);
          } else {
            exitVisualMode(cm);
          }
        },
        reselectLastSelection: function(cm, _actionArgs, vim) {
          var lastSelection = vim.lastSelection;
          if (vim.visualMode) {
            updateLastSelection(cm, vim);
          }
          if (lastSelection) {
            var anchor = lastSelection.anchorMark.find();
            var head = lastSelection.headMark.find();
            if (!anchor || !head) {
              return;
            }
            vim.sel = {
              anchor,
              head
            };
            vim.visualMode = true;
            vim.visualLine = lastSelection.visualLine;
            vim.visualBlock = lastSelection.visualBlock;
            updateCmSelection(cm);
            updateMark(cm, vim, "<", cursorMin(anchor, head));
            updateMark(cm, vim, ">", cursorMax(anchor, head));
            CodeMirror.signal(cm, "vim-mode-change", {
              mode: "visual",
              subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""
            });
          }
        },
        joinLines: function(cm, actionArgs, vim) {
          var curStart, curEnd;
          if (vim.visualMode) {
            curStart = cm.getCursor("anchor");
            curEnd = cm.getCursor("head");
            if (cursorIsBefore(curEnd, curStart)) {
              var tmp = curEnd;
              curEnd = curStart;
              curStart = tmp;
            }
            curEnd.ch = lineLength(cm, curEnd.line) - 1;
          } else {
            var repeat = Math.max(actionArgs.repeat, 2);
            curStart = cm.getCursor();
            curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));
          }
          var finalCh = 0;
          for (var i = curStart.line; i < curEnd.line; i++) {
            finalCh = lineLength(cm, curStart.line);
            var text = "";
            var nextStartCh = 0;
            if (!actionArgs.keepSpaces) {
              var nextLine = cm.getLine(curStart.line + 1);
              nextStartCh = nextLine.search(/\S/);
              if (nextStartCh == -1) {
                nextStartCh = nextLine.length;
              } else {
                text = " ";
              }
            }
            cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));
          }
          var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));
          if (vim.visualMode) {
            exitVisualMode(cm, false);
          }
          cm.setCursor(curFinalPos);
        },
        newLineAndEnterInsertMode: function(cm, actionArgs, vim) {
          vim.insertMode = true;
          var insertAt = copyCursor(cm.getCursor());
          if (insertAt.line === cm.firstLine() && !actionArgs.after) {
            cm.replaceRange("\n", new Pos(cm.firstLine(), 0));
            cm.setCursor(cm.firstLine(), 0);
          } else {
            insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;
            insertAt.ch = lineLength(cm, insertAt.line);
            cm.setCursor(insertAt);
            var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;
            newlineFn(cm);
          }
          this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
        },
        paste: function(cm, actionArgs, vim) {
          var _this = this;
          var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);
          var fallback = function() {
            var text = register.toString();
            _this.continuePaste(cm, actionArgs, vim, text, register);
          };
          if (actionArgs.registerName === "+" && typeof navigator !== "undefined" && typeof navigator.clipboard !== "undefined" && typeof navigator.clipboard.readText === "function") {
            navigator.clipboard.readText().then(function(value) {
              _this.continuePaste(cm, actionArgs, vim, value, register);
            }, function() {
              fallback();
            });
          } else {
            fallback();
          }
        },
        continuePaste: function(cm, actionArgs, vim, text, register) {
          var cur = copyCursor(cm.getCursor());
          if (!text) {
            return;
          }
          if (actionArgs.matchIndent) {
            var tabSize = cm.getOption("tabSize");
            var whitespaceLength = function(str) {
              var tabs = str.split("	").length - 1;
              var spaces = str.split(" ").length - 1;
              return tabs * tabSize + spaces * 1;
            };
            var currentLine = cm.getLine(cm.getCursor().line);
            var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
            var chompedText = text.replace(/\n$/, "");
            var wasChomped = text !== chompedText;
            var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
            var text = chompedText.replace(/^\s*/gm, function(wspace) {
              var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
              if (newIndent < 0) {
                return "";
              } else if (cm.getOption("indentWithTabs")) {
                var quotient = Math.floor(newIndent / tabSize);
                return Array(quotient + 1).join("	");
              } else {
                return Array(newIndent + 1).join(" ");
              }
            });
            text += wasChomped ? "\n" : "";
          }
          if (actionArgs.repeat > 1) {
            var text = Array(actionArgs.repeat + 1).join(text);
          }
          var linewise = register.linewise;
          var blockwise = register.blockwise;
          if (blockwise) {
            text = text.split("\n");
            if (linewise) {
              text.pop();
            }
            for (var i = 0; i < text.length; i++) {
              text[i] = text[i] == "" ? " " : text[i];
            }
            cur.ch += actionArgs.after ? 1 : 0;
            cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
          } else if (linewise) {
            if (vim.visualMode) {
              text = vim.visualLine ? text.slice(0, -1) : "\n" + text.slice(0, text.length - 1) + "\n";
            } else if (actionArgs.after) {
              text = "\n" + text.slice(0, text.length - 1);
              cur.ch = lineLength(cm, cur.line);
            } else {
              cur.ch = 0;
            }
          } else {
            cur.ch += actionArgs.after ? 1 : 0;
          }
          var curPosFinal;
          if (vim.visualMode) {
            vim.lastPastedText = text;
            var lastSelectionCurEnd;
            var selectedArea = getSelectedAreaRange(cm, vim);
            var selectionStart = selectedArea[0];
            var selectionEnd = selectedArea[1];
            var selectedText = cm.getSelection();
            var selections = cm.listSelections();
            var emptyStrings = new Array(selections.length).join("1").split("1");
            if (vim.lastSelection) {
              lastSelectionCurEnd = vim.lastSelection.headMark.find();
            }
            vimGlobalState.registerController.unnamedRegister.setText(selectedText);
            if (blockwise) {
              cm.replaceSelections(emptyStrings);
              selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);
              cm.setCursor(selectionStart);
              selectBlock(cm, selectionEnd);
              cm.replaceSelections(text);
              curPosFinal = selectionStart;
            } else if (vim.visualBlock) {
              cm.replaceSelections(emptyStrings);
              cm.setCursor(selectionStart);
              cm.replaceRange(text, selectionStart, selectionStart);
              curPosFinal = selectionStart;
            } else {
              cm.replaceRange(text, selectionStart, selectionEnd);
              curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
            }
            if (lastSelectionCurEnd) {
              vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
            }
            if (linewise) {
              curPosFinal.ch = 0;
            }
          } else {
            if (blockwise) {
              cm.setCursor(cur);
              for (var i = 0; i < text.length; i++) {
                var line = cur.line + i;
                if (line > cm.lastLine()) {
                  cm.replaceRange("\n", new Pos(line, 0));
                }
                var lastCh = lineLength(cm, line);
                if (lastCh < cur.ch) {
                  extendLineToColumn(cm, line, cur.ch);
                }
              }
              cm.setCursor(cur);
              selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));
              cm.replaceSelections(text);
              curPosFinal = cur;
            } else {
              cm.replaceRange(text, cur);
              if (linewise) {
                var line = actionArgs.after ? cur.line + 1 : cur.line;
                curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
              } else {
                curPosFinal = copyCursor(cur);
                if (!/\n/.test(text)) {
                  curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);
                }
              }
            }
          }
          if (vim.visualMode) {
            exitVisualMode(cm, false);
          }
          cm.setCursor(curPosFinal);
        },
        undo: function(cm, actionArgs) {
          cm.operation(function() {
            repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();
            cm.setCursor(clipCursorToContent(cm, cm.getCursor("start")));
          });
        },
        redo: function(cm, actionArgs) {
          repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();
        },
        setRegister: function(_cm, actionArgs, vim) {
          vim.inputState.registerName = actionArgs.selectedCharacter;
        },
        insertRegister: function(cm, actionArgs, vim) {
          var registerName = actionArgs.selectedCharacter;
          var register = vimGlobalState.registerController.getRegister(registerName);
          var text = register && register.toString();
          if (text) {
            cm.replaceSelection(text);
          }
        },
        oneNormalCommand: function(cm, actionArgs, vim) {
          exitInsertMode(cm, true);
          vim.insertModeReturn = true;
          CodeMirror.on(cm, "vim-command-done", function handler() {
            if (vim.visualMode)
              return;
            if (vim.insertModeReturn) {
              vim.insertModeReturn = false;
              if (!vim.insertMode) {
                actions.enterInsertMode(cm, {}, vim);
              }
            }
            CodeMirror.off(cm, "vim-command-done", handler);
          });
        },
        setMark: function(cm, actionArgs, vim) {
          var markName = actionArgs.selectedCharacter;
          updateMark(cm, vim, markName, cm.getCursor());
        },
        replace: function(cm, actionArgs, vim) {
          var replaceWith = actionArgs.selectedCharacter;
          var curStart = cm.getCursor();
          var replaceTo;
          var curEnd;
          var selections = cm.listSelections();
          if (vim.visualMode) {
            curStart = cm.getCursor("start");
            curEnd = cm.getCursor("end");
          } else {
            var line = cm.getLine(curStart.line);
            replaceTo = curStart.ch + actionArgs.repeat;
            if (replaceTo > line.length) {
              replaceTo = line.length;
            }
            curEnd = new Pos(curStart.line, replaceTo);
          }
          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);
          curStart = newPositions.start;
          curEnd = newPositions.end;
          if (replaceWith == "\n") {
            if (!vim.visualMode)
              cm.replaceRange("", curStart, curEnd);
            (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);
          } else {
            var replaceWithStr = cm.getRange(curStart, curEnd);
            replaceWithStr = replaceWithStr.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, replaceWith);
            replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
            if (vim.visualBlock) {
              var spaces = new Array(cm.getOption("tabSize") + 1).join(" ");
              replaceWithStr = cm.getSelection();
              replaceWithStr = replaceWithStr.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, replaceWith);
              replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split("\n");
              cm.replaceSelections(replaceWithStr);
            } else {
              cm.replaceRange(replaceWithStr, curStart, curEnd);
            }
            if (vim.visualMode) {
              curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;
              cm.setCursor(curStart);
              exitVisualMode(cm, false);
            } else {
              cm.setCursor(offsetCursor(curEnd, 0, -1));
            }
          }
        },
        incrementNumberToken: function(cm, actionArgs) {
          var cur = cm.getCursor();
          var lineStr = cm.getLine(cur.line);
          var re3 = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
          var match;
          var start;
          var end;
          var numberStr;
          while ((match = re3.exec(lineStr)) !== null) {
            start = match.index;
            end = start + match[0].length;
            if (cur.ch < end)
              break;
          }
          if (!actionArgs.backtrack && end <= cur.ch)
            return;
          if (match) {
            var baseStr = match[2] || match[4];
            var digits = match[3] || match[5];
            var increment = actionArgs.increase ? 1 : -1;
            var base = { "0b": 2, "0": 8, "": 10, "0x": 16 }[baseStr.toLowerCase()];
            var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;
            numberStr = number.toString(base);
            var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join("0") : "";
            if (numberStr.charAt(0) === "-") {
              numberStr = "-" + baseStr + zeroPadding + numberStr.substr(1);
            } else {
              numberStr = baseStr + zeroPadding + numberStr;
            }
            var from = new Pos(cur.line, start);
            var to2 = new Pos(cur.line, end);
            cm.replaceRange(numberStr, from, to2);
          } else {
            return;
          }
          cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));
        },
        repeatLastEdit: function(cm, actionArgs, vim) {
          var lastEditInputState = vim.lastEditInputState;
          if (!lastEditInputState) {
            return;
          }
          var repeat = actionArgs.repeat;
          if (repeat && actionArgs.repeatIsExplicit) {
            vim.lastEditInputState.repeatOverride = repeat;
          } else {
            repeat = vim.lastEditInputState.repeatOverride || repeat;
          }
          repeatLastEdit(
            cm,
            vim,
            repeat,
            false
            /** repeatForInsert */
          );
        },
        indent: function(cm, actionArgs) {
          cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
        },
        exitInsertMode
      };
      function defineAction(name, fn3) {
        actions[name] = fn3;
      }
      function clipCursorToContent(cm, cur, oldCur) {
        var vim = cm.state.vim;
        var includeLineBreak = vim.insertMode || vim.visualMode;
        var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());
        var text = cm.getLine(line);
        var maxCh = text.length - 1 + Number(!!includeLineBreak);
        var ch = Math.min(Math.max(0, cur.ch), maxCh);
        var charCode = text.charCodeAt(ch);
        if (56320 <= charCode && charCode <= 57343) {
          var direction = 1;
          if (oldCur && oldCur.line == line && oldCur.ch > ch) {
            direction = -1;
          }
          ch += direction;
          if (ch > maxCh)
            ch -= 2;
        }
        return new Pos(line, ch);
      }
      function copyArgs(args) {
        var ret = {};
        for (var prop in args) {
          if (args.hasOwnProperty(prop)) {
            ret[prop] = args[prop];
          }
        }
        return ret;
      }
      function offsetCursor(cur, offsetLine, offsetCh) {
        if (typeof offsetLine === "object") {
          offsetCh = offsetLine.ch;
          offsetLine = offsetLine.line;
        }
        return new Pos(cur.line + offsetLine, cur.ch + offsetCh);
      }
      function commandMatches(keys, keyMap, context, inputState) {
        if (inputState.operator)
          context = "operatorPending";
        var match, partial = [], full = [];
        var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;
        for (var i = startIndex; i < keyMap.length; i++) {
          var command = keyMap[i];
          if (context == "insert" && command.context != "insert" || command.context && command.context != context || inputState.operator && command.type == "action" || !(match = commandMatch(keys, command.keys))) {
            continue;
          }
          if (match == "partial") {
            partial.push(command);
          }
          if (match == "full") {
            full.push(command);
          }
        }
        return {
          partial: partial.length && partial,
          full: full.length && full
        };
      }
      function commandMatch(pressed, mapped) {
        var isLastCharacter = mapped.slice(-11) == "<character>";
        var isLastRegister = mapped.slice(-10) == "<register>";
        if (isLastCharacter || isLastRegister) {
          var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);
          var pressedPrefix = pressed.slice(0, prefixLen);
          var mappedPrefix = mapped.slice(0, prefixLen);
          return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? "full" : mappedPrefix.indexOf(pressedPrefix) == 0 ? "partial" : false;
        } else {
          return pressed == mapped ? "full" : mapped.indexOf(pressed) == 0 ? "partial" : false;
        }
      }
      function lastChar(keys) {
        var match = /^.*(<[^>]+>)$/.exec(keys);
        var selectedCharacter = match ? match[1] : keys.slice(-1);
        if (selectedCharacter.length > 1) {
          switch (selectedCharacter) {
            case "<CR>":
              selectedCharacter = "\n";
              break;
            case "<Space>":
              selectedCharacter = " ";
              break;
            default:
              selectedCharacter = "";
              break;
          }
        }
        return selectedCharacter;
      }
      function repeatFn(cm, fn3, repeat) {
        return function() {
          for (var i = 0; i < repeat; i++) {
            fn3(cm);
          }
        };
      }
      function copyCursor(cur) {
        return new Pos(cur.line, cur.ch);
      }
      function cursorEqual(cur1, cur2) {
        return cur1.ch == cur2.ch && cur1.line == cur2.line;
      }
      function cursorIsBefore(cur1, cur2) {
        if (cur1.line < cur2.line) {
          return true;
        }
        if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
          return true;
        }
        return false;
      }
      function cursorMin(cur1, cur2) {
        if (arguments.length > 2) {
          cur2 = cursorMin.apply(void 0, Array.prototype.slice.call(arguments, 1));
        }
        return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
      }
      function cursorMax(cur1, cur2) {
        if (arguments.length > 2) {
          cur2 = cursorMax.apply(void 0, Array.prototype.slice.call(arguments, 1));
        }
        return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
      }
      function cursorIsBetween(cur1, cur2, cur3) {
        var cur1before2 = cursorIsBefore(cur1, cur2);
        var cur2before3 = cursorIsBefore(cur2, cur3);
        return cur1before2 && cur2before3;
      }
      function lineLength(cm, lineNum) {
        return cm.getLine(lineNum).length;
      }
      function trim(s) {
        if (s.trim) {
          return s.trim();
        }
        return s.replace(/^\s+|\s+$/g, "");
      }
      function escapeRegex(s) {
        return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
      }
      function extendLineToColumn(cm, lineNum, column) {
        var endCh = lineLength(cm, lineNum);
        var spaces = new Array(column - endCh + 1).join(" ");
        cm.setCursor(new Pos(lineNum, endCh));
        cm.replaceRange(spaces, cm.getCursor());
      }
      function selectBlock(cm, selectionEnd) {
        var selections = [], ranges = cm.listSelections();
        var head = copyCursor(cm.clipPos(selectionEnd));
        var isClipped = !cursorEqual(selectionEnd, head);
        var curHead = cm.getCursor("head");
        var primIndex = getIndex(ranges, curHead);
        var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
        var max = ranges.length - 1;
        var index = max - primIndex > primIndex ? max : 0;
        var base = ranges[index].anchor;
        var firstLine = Math.min(base.line, head.line);
        var lastLine = Math.max(base.line, head.line);
        var baseCh = base.ch, headCh = head.ch;
        var dir = ranges[index].head.ch - baseCh;
        var newDir = headCh - baseCh;
        if (dir > 0 && newDir <= 0) {
          baseCh++;
          if (!isClipped) {
            headCh--;
          }
        } else if (dir < 0 && newDir >= 0) {
          baseCh--;
          if (!wasClipped) {
            headCh++;
          }
        } else if (dir < 0 && newDir == -1) {
          baseCh--;
          headCh++;
        }
        for (var line = firstLine; line <= lastLine; line++) {
          var range = { anchor: new Pos(line, baseCh), head: new Pos(line, headCh) };
          selections.push(range);
        }
        cm.setSelections(selections);
        selectionEnd.ch = headCh;
        base.ch = baseCh;
        return base;
      }
      function selectForInsert(cm, head, height) {
        var sel = [];
        for (var i = 0; i < height; i++) {
          var lineHead = offsetCursor(head, i, 0);
          sel.push({ anchor: lineHead, head: lineHead });
        }
        cm.setSelections(sel, 0);
      }
      function getIndex(ranges, cursor, end) {
        for (var i = 0; i < ranges.length; i++) {
          var atAnchor = end != "head" && cursorEqual(ranges[i].anchor, cursor);
          var atHead = end != "anchor" && cursorEqual(ranges[i].head, cursor);
          if (atAnchor || atHead) {
            return i;
          }
        }
        return -1;
      }
      function getSelectedAreaRange(cm, vim) {
        var lastSelection = vim.lastSelection;
        var getCurrentSelectedAreaRange = function() {
          var selections = cm.listSelections();
          var start = selections[0];
          var end = selections[selections.length - 1];
          var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
          var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
          return [selectionStart, selectionEnd];
        };
        var getLastSelectedAreaRange = function() {
          var selectionStart = cm.getCursor();
          var selectionEnd = cm.getCursor();
          var block = lastSelection.visualBlock;
          if (block) {
            var width = block.width;
            var height = block.height;
            selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);
            var selections = [];
            for (var i = selectionStart.line; i < selectionEnd.line; i++) {
              var anchor = new Pos(i, selectionStart.ch);
              var head = new Pos(i, selectionEnd.ch);
              var range = { anchor, head };
              selections.push(range);
            }
            cm.setSelections(selections);
          } else {
            var start = lastSelection.anchorMark.find();
            var end = lastSelection.headMark.find();
            var line = end.line - start.line;
            var ch = end.ch - start.ch;
            selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };
            if (lastSelection.visualLine) {
              selectionStart = new Pos(selectionStart.line, 0);
              selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
            }
            cm.setSelection(selectionStart, selectionEnd);
          }
          return [selectionStart, selectionEnd];
        };
        if (!vim.visualMode) {
          return getLastSelectedAreaRange();
        } else {
          return getCurrentSelectedAreaRange();
        }
      }
      function updateLastSelection(cm, vim) {
        var anchor = vim.sel.anchor;
        var head = vim.sel.head;
        if (vim.lastPastedText) {
          head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
          vim.lastPastedText = null;
        }
        vim.lastSelection = {
          "anchorMark": cm.setBookmark(anchor),
          "headMark": cm.setBookmark(head),
          "anchor": copyCursor(anchor),
          "head": copyCursor(head),
          "visualMode": vim.visualMode,
          "visualLine": vim.visualLine,
          "visualBlock": vim.visualBlock
        };
      }
      function expandSelection(cm, start, end, move) {
        var sel = cm.state.vim.sel;
        var head = move ? start : sel.head;
        var anchor = move ? start : sel.anchor;
        var tmp;
        if (cursorIsBefore(end, start)) {
          tmp = end;
          end = start;
          start = tmp;
        }
        if (cursorIsBefore(head, anchor)) {
          head = cursorMin(start, head);
          anchor = cursorMax(anchor, end);
        } else {
          anchor = cursorMin(start, anchor);
          head = cursorMax(head, end);
          head = offsetCursor(head, 0, -1);
          if (head.ch == -1 && head.line != cm.firstLine()) {
            head = new Pos(head.line - 1, lineLength(cm, head.line - 1));
          }
        }
        return [anchor, head];
      }
      function updateCmSelection(cm, sel, mode) {
        var vim = cm.state.vim;
        sel = sel || vim.sel;
        var mode = mode || vim.visualLine ? "line" : vim.visualBlock ? "block" : "char";
        var cmSel = makeCmSelection(cm, sel, mode);
        cm.setSelections(cmSel.ranges, cmSel.primary);
      }
      function makeCmSelection(cm, sel, mode, exclusive) {
        var head = copyCursor(sel.head);
        var anchor = copyCursor(sel.anchor);
        if (mode == "char") {
          var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
          var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
          head = offsetCursor(sel.head, 0, headOffset);
          anchor = offsetCursor(sel.anchor, 0, anchorOffset);
          return {
            ranges: [{ anchor, head }],
            primary: 0
          };
        } else if (mode == "line") {
          if (!cursorIsBefore(sel.head, sel.anchor)) {
            anchor.ch = 0;
            var lastLine = cm.lastLine();
            if (head.line > lastLine) {
              head.line = lastLine;
            }
            head.ch = lineLength(cm, head.line);
          } else {
            head.ch = 0;
            anchor.ch = lineLength(cm, anchor.line);
          }
          return {
            ranges: [{ anchor, head }],
            primary: 0
          };
        } else if (mode == "block") {
          var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;
          if (fromCh < toCh) {
            toCh += 1;
          } else {
            fromCh += 1;
          }
          ;
          var height = bottom - top + 1;
          var primary = head.line == top ? 0 : height - 1;
          var ranges = [];
          for (var i = 0; i < height; i++) {
            ranges.push({
              anchor: new Pos(top + i, fromCh),
              head: new Pos(top + i, toCh)
            });
          }
          return {
            ranges,
            primary
          };
        }
      }
      function getHead(cm) {
        var cur = cm.getCursor("head");
        if (cm.getSelection().length == 1) {
          cur = cursorMin(cur, cm.getCursor("anchor"));
        }
        return cur;
      }
      function exitVisualMode(cm, moveHead) {
        var vim = cm.state.vim;
        if (moveHead !== false) {
          cm.setCursor(clipCursorToContent(cm, vim.sel.head));
        }
        updateLastSelection(cm, vim);
        vim.visualMode = false;
        vim.visualLine = false;
        vim.visualBlock = false;
        if (!vim.insertMode)
          CodeMirror.signal(cm, "vim-mode-change", { mode: "normal" });
      }
      function clipToLine(cm, curStart, curEnd) {
        var selection = cm.getRange(curStart, curEnd);
        if (/\n\s*$/.test(selection)) {
          var lines = selection.split("\n");
          lines.pop();
          var line;
          for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
            curEnd.line--;
            curEnd.ch = 0;
          }
          if (line) {
            curEnd.line--;
            curEnd.ch = lineLength(cm, curEnd.line);
          } else {
            curEnd.ch = 0;
          }
        }
      }
      function expandSelectionToLine(_cm, curStart, curEnd) {
        curStart.ch = 0;
        curEnd.ch = 0;
        curEnd.line++;
      }
      function findFirstNonWhiteSpaceCharacter(text) {
        if (!text) {
          return 0;
        }
        var firstNonWS = text.search(/\S/);
        return firstNonWS == -1 ? text.length : firstNonWS;
      }
      function expandWordUnderCursor(cm, _a2, cursor) {
        var inclusive = _a2.inclusive, innerWord = _a2.innerWord, bigWord = _a2.bigWord, noSymbol = _a2.noSymbol, multiline = _a2.multiline;
        var cur = cursor || getHead(cm);
        var line = cm.getLine(cur.line);
        var endLine = line;
        var startLineNumber = cur.line;
        var endLineNumber = startLineNumber;
        var idx = cur.ch;
        var wordOnNextLine;
        var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];
        if (innerWord && /\s/.test(line.charAt(idx))) {
          test = function(ch) {
            return /\s/.test(ch);
          };
        } else {
          while (!test(line.charAt(idx))) {
            idx++;
            if (idx >= line.length) {
              if (!multiline)
                return null;
              idx--;
              wordOnNextLine = findWord(cm, cur, true, bigWord, true);
              break;
            }
          }
          if (bigWord) {
            test = bigWordCharTest[0];
          } else {
            test = wordCharTest[0];
            if (!test(line.charAt(idx))) {
              test = wordCharTest[1];
            }
          }
        }
        var end = idx, start = idx;
        while (test(line.charAt(start)) && start >= 0) {
          start--;
        }
        start++;
        if (wordOnNextLine) {
          end = wordOnNextLine.to;
          endLineNumber = wordOnNextLine.line;
          endLine = cm.getLine(endLineNumber);
          if (!endLine && end == 0)
            end++;
        } else {
          while (test(line.charAt(end)) && end < line.length) {
            end++;
          }
        }
        if (inclusive) {
          var wordEnd = end;
          var startsWithSpace = cur.ch <= start && /\s/.test(line.charAt(cur.ch));
          if (!startsWithSpace) {
            while (/\s/.test(endLine.charAt(end)) && end < endLine.length) {
              end++;
            }
          }
          if (wordEnd == end || startsWithSpace) {
            var wordStart = start;
            while (/\s/.test(line.charAt(start - 1)) && start > 0) {
              start--;
            }
            if (!start && !startsWithSpace) {
              start = wordStart;
            }
          }
        }
        return { start: new Pos(startLineNumber, start), end: new Pos(endLineNumber, end) };
      }
      function expandTagUnderCursor(cm, head, inclusive) {
        var cur = head;
        if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {
          return { start: cur, end: cur };
        }
        var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);
        if (!tags || !tags.open || !tags.close) {
          return { start: cur, end: cur };
        }
        if (inclusive) {
          return { start: tags.open.from, end: tags.close.to };
        }
        return { start: tags.open.to, end: tags.close.from };
      }
      function recordJumpPosition(cm, oldCur, newCur) {
        if (!cursorEqual(oldCur, newCur)) {
          vimGlobalState.jumpList.add(cm, oldCur, newCur);
        }
      }
      function recordLastCharacterSearch(increment, args) {
        vimGlobalState.lastCharacterSearch.increment = increment;
        vimGlobalState.lastCharacterSearch.forward = args.forward;
        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
      }
      var symbolToMode = {
        "(": "bracket",
        ")": "bracket",
        "{": "bracket",
        "}": "bracket",
        "[": "section",
        "]": "section",
        "*": "comment",
        "/": "comment",
        "m": "method",
        "M": "method",
        "#": "preprocess"
      };
      var findSymbolModes = {
        bracket: {
          isComplete: function(state) {
            if (state.nextCh === state.symb) {
              state.depth++;
              if (state.depth >= 1)
                return true;
            } else if (state.nextCh === state.reverseSymb) {
              state.depth--;
            }
            return false;
          }
        },
        section: {
          init: function(state) {
            state.curMoveThrough = true;
            state.symb = (state.forward ? "]" : "[") === state.symb ? "{" : "}";
          },
          isComplete: function(state) {
            return state.index === 0 && state.nextCh === state.symb;
          }
        },
        comment: {
          isComplete: function(state) {
            var found = state.lastCh === "*" && state.nextCh === "/";
            state.lastCh = state.nextCh;
            return found;
          }
        },
        method: {
          init: function(state) {
            state.symb = state.symb === "m" ? "{" : "}";
            state.reverseSymb = state.symb === "{" ? "}" : "{";
          },
          isComplete: function(state) {
            if (state.nextCh === state.symb)
              return true;
            return false;
          }
        },
        preprocess: {
          init: function(state) {
            state.index = 0;
          },
          isComplete: function(state) {
            if (state.nextCh === "#") {
              var token = state.lineText.match(/^#(\w+)/)[1];
              if (token === "endif") {
                if (state.forward && state.depth === 0) {
                  return true;
                }
                state.depth++;
              } else if (token === "if") {
                if (!state.forward && state.depth === 0) {
                  return true;
                }
                state.depth--;
              }
              if (token === "else" && state.depth === 0)
                return true;
            }
            return false;
          }
        }
      };
      function findSymbol(cm, repeat, forward, symb) {
        var cur = copyCursor(cm.getCursor());
        var increment = forward ? 1 : -1;
        var endLine = forward ? cm.lineCount() : -1;
        var curCh = cur.ch;
        var line = cur.line;
        var lineText = cm.getLine(line);
        var state = {
          lineText,
          nextCh: lineText.charAt(curCh),
          lastCh: null,
          index: curCh,
          symb,
          reverseSymb: (forward ? { ")": "(", "}": "{" } : { "(": ")", "{": "}" })[symb],
          forward,
          depth: 0,
          curMoveThrough: false
        };
        var mode = symbolToMode[symb];
        if (!mode)
          return cur;
        var init = findSymbolModes[mode].init;
        var isComplete = findSymbolModes[mode].isComplete;
        if (init) {
          init(state);
        }
        while (line !== endLine && repeat) {
          state.index += increment;
          state.nextCh = state.lineText.charAt(state.index);
          if (!state.nextCh) {
            line += increment;
            state.lineText = cm.getLine(line) || "";
            if (increment > 0) {
              state.index = 0;
            } else {
              var lineLen = state.lineText.length;
              state.index = lineLen > 0 ? lineLen - 1 : 0;
            }
            state.nextCh = state.lineText.charAt(state.index);
          }
          if (isComplete(state)) {
            cur.line = line;
            cur.ch = state.index;
            repeat--;
          }
        }
        if (state.nextCh || state.curMoveThrough) {
          return new Pos(line, state.index);
        }
        return cur;
      }
      function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
        var lineNum = cur.line;
        var pos = cur.ch;
        var line = cm.getLine(lineNum);
        var dir = forward ? 1 : -1;
        var charTests = bigWord ? bigWordCharTest : wordCharTest;
        if (emptyLineIsWord && line == "") {
          lineNum += dir;
          line = cm.getLine(lineNum);
          if (!isLine(cm, lineNum)) {
            return null;
          }
          pos = forward ? 0 : line.length;
        }
        while (true) {
          if (emptyLineIsWord && line == "") {
            return { from: 0, to: 0, line: lineNum };
          }
          var stop = dir > 0 ? line.length : -1;
          var wordStart = stop, wordEnd = stop;
          while (pos != stop) {
            var foundWord = false;
            for (var i = 0; i < charTests.length && !foundWord; ++i) {
              if (charTests[i](line.charAt(pos))) {
                wordStart = pos;
                while (pos != stop && charTests[i](line.charAt(pos))) {
                  pos += dir;
                }
                wordEnd = pos;
                foundWord = wordStart != wordEnd;
                if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {
                  continue;
                } else {
                  return {
                    from: Math.min(wordStart, wordEnd + 1),
                    to: Math.max(wordStart, wordEnd),
                    line: lineNum
                  };
                }
              }
            }
            if (!foundWord) {
              pos += dir;
            }
          }
          lineNum += dir;
          if (!isLine(cm, lineNum)) {
            return null;
          }
          line = cm.getLine(lineNum);
          pos = dir > 0 ? 0 : line.length;
        }
      }
      function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
        var curStart = copyCursor(cur);
        var words = [];
        if (forward && !wordEnd || !forward && wordEnd) {
          repeat++;
        }
        var emptyLineIsWord = !(forward && wordEnd);
        for (var i = 0; i < repeat; i++) {
          var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
          if (!word) {
            var eodCh = lineLength(cm, cm.lastLine());
            words.push(forward ? { line: cm.lastLine(), from: eodCh, to: eodCh } : { line: 0, from: 0, to: 0 });
            break;
          }
          words.push(word);
          cur = new Pos(word.line, forward ? word.to - 1 : word.from);
        }
        var shortCircuit = words.length != repeat;
        var firstWord = words[0];
        var lastWord = words.pop();
        if (forward && !wordEnd) {
          if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
            lastWord = words.pop();
          }
          return new Pos(lastWord.line, lastWord.from);
        } else if (forward && wordEnd) {
          return new Pos(lastWord.line, lastWord.to - 1);
        } else if (!forward && wordEnd) {
          if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
            lastWord = words.pop();
          }
          return new Pos(lastWord.line, lastWord.to);
        } else {
          return new Pos(lastWord.line, lastWord.from);
        }
      }
      function moveToEol(cm, head, motionArgs, vim, keepHPos) {
        var cur = head;
        var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);
        var end = cm.clipPos(retval);
        end.ch--;
        if (!keepHPos) {
          vim.lastHPos = Infinity;
          vim.lastHSPos = cm.charCoords(end, "div").left;
        }
        return retval;
      }
      function moveToCharacter(cm, repeat, forward, character, head) {
        var cur = head || cm.getCursor();
        var start = cur.ch;
        var idx;
        for (var i = 0; i < repeat; i++) {
          var line = cm.getLine(cur.line);
          idx = charIdxInLine(start, line, character, forward, true);
          if (idx == -1) {
            return null;
          }
          start = idx;
        }
        return new Pos(cm.getCursor().line, idx);
      }
      function moveToColumn(cm, repeat) {
        var line = cm.getCursor().line;
        return clipCursorToContent(cm, new Pos(line, repeat - 1));
      }
      function updateMark(cm, vim, markName, pos) {
        if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {
          return;
        }
        if (vim.marks[markName]) {
          vim.marks[markName].clear();
        }
        vim.marks[markName] = cm.setBookmark(pos);
      }
      function charIdxInLine(start, line, character, forward, includeChar) {
        var idx;
        if (forward) {
          idx = line.indexOf(character, start + 1);
          if (idx != -1 && !includeChar) {
            idx -= 1;
          }
        } else {
          idx = line.lastIndexOf(character, start - 1);
          if (idx != -1 && !includeChar) {
            idx += 1;
          }
        }
        return idx;
      }
      function findParagraph(cm, head, repeat, dir, inclusive) {
        var line = head.line;
        var min2 = cm.firstLine();
        var max = cm.lastLine();
        var start, end, i = line;
        function isEmpty(i2) {
          return !/\S/.test(cm.getLine(i2));
        }
        function isBoundary(i2, dir2, any) {
          if (any) {
            return isEmpty(i2) != isEmpty(i2 + dir2);
          }
          return !isEmpty(i2) && isEmpty(i2 + dir2);
        }
        function skipFold(i2) {
          dir = dir > 0 ? 1 : -1;
          var foldLine = cm.ace.session.getFoldLine(i2);
          if (foldLine) {
            if (i2 + dir > foldLine.start.row && i2 + dir < foldLine.end.row)
              dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i2;
          }
        }
        if (dir) {
          while (min2 <= i && i <= max && repeat > 0) {
            skipFold(i);
            if (isBoundary(i, dir)) {
              repeat--;
            }
            i += dir;
          }
          return new Pos(i, 0);
        }
        var vim = cm.state.vim;
        if (vim.visualLine && isBoundary(line, 1, true)) {
          var anchor = vim.sel.anchor;
          if (isBoundary(anchor.line, -1, true)) {
            if (!inclusive || anchor.line != line) {
              line += 1;
            }
          }
        }
        var startState = isEmpty(line);
        for (i = line; i <= max && repeat; i++) {
          if (isBoundary(i, 1, true)) {
            if (!inclusive || isEmpty(i) != startState) {
              repeat--;
            }
          }
        }
        end = new Pos(i, 0);
        if (i > max && !startState) {
          startState = true;
        } else {
          inclusive = false;
        }
        for (i = line; i > min2; i--) {
          if (!inclusive || isEmpty(i) == startState || i == line) {
            if (isBoundary(i, -1, true)) {
              break;
            }
          }
        }
        start = new Pos(i, 0);
        return { start, end };
      }
      function getSentence(cm, cur, repeat, dir, inclusive) {
        function nextChar(curr) {
          if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {
            curr.line = null;
          } else {
            curr.pos += curr.dir;
          }
        }
        function forward(cm2, ln3, pos, dir2) {
          var line = cm2.getLine(ln3);
          var curr = {
            line,
            ln: ln3,
            pos,
            dir: dir2
          };
          if (curr.line === "") {
            return { ln: curr.ln, pos: curr.pos };
          }
          var lastSentencePos = curr.pos;
          nextChar(curr);
          while (curr.line !== null) {
            lastSentencePos = curr.pos;
            if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
              if (!inclusive) {
                return { ln: curr.ln, pos: curr.pos + 1 };
              } else {
                nextChar(curr);
                while (curr.line !== null) {
                  if (isWhiteSpaceString(curr.line[curr.pos])) {
                    lastSentencePos = curr.pos;
                    nextChar(curr);
                  } else {
                    break;
                  }
                }
                return { ln: curr.ln, pos: lastSentencePos + 1 };
              }
            }
            nextChar(curr);
          }
          return { ln: curr.ln, pos: lastSentencePos + 1 };
        }
        function reverse(cm2, ln3, pos, dir2) {
          var line = cm2.getLine(ln3);
          var curr = {
            line,
            ln: ln3,
            pos,
            dir: dir2
          };
          if (curr.line === "") {
            return { ln: curr.ln, pos: curr.pos };
          }
          var lastSentencePos = curr.pos;
          nextChar(curr);
          while (curr.line !== null) {
            if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {
              lastSentencePos = curr.pos;
            } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
              if (!inclusive) {
                return { ln: curr.ln, pos: lastSentencePos };
              } else {
                if (isWhiteSpaceString(curr.line[curr.pos + 1])) {
                  return { ln: curr.ln, pos: curr.pos + 1 };
                } else {
                  return { ln: curr.ln, pos: lastSentencePos };
                }
              }
            }
            nextChar(curr);
          }
          curr.line = line;
          if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {
            return { ln: curr.ln, pos: curr.pos };
          } else {
            return { ln: curr.ln, pos: lastSentencePos };
          }
        }
        var curr_index = {
          ln: cur.line,
          pos: cur.ch
        };
        while (repeat > 0) {
          if (dir < 0) {
            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
          } else {
            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
          }
          repeat--;
        }
        return new Pos(curr_index.ln, curr_index.pos);
      }
      function findSentence(cm, cur, repeat, dir) {
        function nextChar(cm2, idx) {
          if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
            idx.ln += idx.dir;
            if (!isLine(cm2, idx.ln)) {
              idx.line = null;
              idx.ln = null;
              idx.pos = null;
              return;
            }
            idx.line = cm2.getLine(idx.ln);
            idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;
          } else {
            idx.pos += idx.dir;
          }
        }
        function forward(cm2, ln3, pos, dir2) {
          var line = cm2.getLine(ln3);
          var stop = line === "";
          var curr = {
            line,
            ln: ln3,
            pos,
            dir: dir2
          };
          var last_valid = {
            ln: curr.ln,
            pos: curr.pos
          };
          var skip_empty_lines = curr.line === "";
          nextChar(cm2, curr);
          while (curr.line !== null) {
            last_valid.ln = curr.ln;
            last_valid.pos = curr.pos;
            if (curr.line === "" && !skip_empty_lines) {
              return { ln: curr.ln, pos: curr.pos };
            } else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
              return { ln: curr.ln, pos: curr.pos };
            } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
              stop = true;
            }
            nextChar(cm2, curr);
          }
          var line = cm2.getLine(last_valid.ln);
          last_valid.pos = 0;
          for (var i = line.length - 1; i >= 0; --i) {
            if (!isWhiteSpaceString(line[i])) {
              last_valid.pos = i;
              break;
            }
          }
          return last_valid;
        }
        function reverse(cm2, ln3, pos, dir2) {
          var line = cm2.getLine(ln3);
          var curr = {
            line,
            ln: ln3,
            pos,
            dir: dir2
          };
          var last_valid = {
            ln: curr.ln,
            pos: null
          };
          var skip_empty_lines = curr.line === "";
          nextChar(cm2, curr);
          while (curr.line !== null) {
            if (curr.line === "" && !skip_empty_lines) {
              if (last_valid.pos !== null) {
                return last_valid;
              } else {
                return { ln: curr.ln, pos: curr.pos };
              }
            } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
              return last_valid;
            } else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
              skip_empty_lines = false;
              last_valid = { ln: curr.ln, pos: curr.pos };
            }
            nextChar(cm2, curr);
          }
          var line = cm2.getLine(last_valid.ln);
          last_valid.pos = 0;
          for (var i = 0; i < line.length; ++i) {
            if (!isWhiteSpaceString(line[i])) {
              last_valid.pos = i;
              break;
            }
          }
          return last_valid;
        }
        var curr_index = {
          ln: cur.line,
          pos: cur.ch
        };
        while (repeat > 0) {
          if (dir < 0) {
            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
          } else {
            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
          }
          repeat--;
        }
        return new Pos(curr_index.ln, curr_index.pos);
      }
      function selectCompanionObject(cm, head, symb, inclusive) {
        var cur = head, start, end;
        var bracketRegexp = {
          "(": /[()]/,
          ")": /[()]/,
          "[": /[[\]]/,
          "]": /[[\]]/,
          "{": /[{}]/,
          "}": /[{}]/,
          "<": /[<>]/,
          ">": /[<>]/
        }[symb];
        var openSym = {
          "(": "(",
          ")": "(",
          "[": "[",
          "]": "[",
          "{": "{",
          "}": "{",
          "<": "<",
          ">": "<"
        }[symb];
        var curChar = cm.getLine(cur.line).charAt(cur.ch);
        var offset = curChar === openSym ? 1 : 0;
        start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, void 0, { "bracketRegex": bracketRegexp });
        end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, void 0, { "bracketRegex": bracketRegexp });
        if (!start || !end)
          return null;
        start = start.pos;
        end = end.pos;
        if (start.line == end.line && start.ch > end.ch || start.line > end.line) {
          var tmp = start;
          start = end;
          end = tmp;
        }
        if (inclusive) {
          end.ch += 1;
        } else {
          start.ch += 1;
        }
        return { start, end };
      }
      function findBeginningAndEnd(cm, head, symb, inclusive) {
        var cur = copyCursor(head);
        var line = cm.getLine(cur.line);
        var chars = line.split("");
        var start, end, i, len;
        var firstIndex = chars.indexOf(symb);
        if (cur.ch < firstIndex) {
          cur.ch = firstIndex;
        } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
          var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));
          var stringBefore = /string/.test(cm.getTokenTypeAt(head));
          var isStringStart = stringAfter && !stringBefore;
          if (!isStringStart) {
            end = cur.ch;
            --cur.ch;
          }
        }
        if (chars[cur.ch] == symb && !end) {
          start = cur.ch + 1;
        } else {
          for (i = cur.ch; i > -1 && !start; i--) {
            if (chars[i] == symb) {
              start = i + 1;
            }
          }
        }
        if (start && !end) {
          for (i = start, len = chars.length; i < len && !end; i++) {
            if (chars[i] == symb) {
              end = i;
            }
          }
        }
        if (!start || !end) {
          return { start: cur, end: cur };
        }
        if (inclusive) {
          --start;
          ++end;
        }
        return {
          start: new Pos(cur.line, start),
          end: new Pos(cur.line, end)
        };
      }
      defineOption("pcre", true, "boolean");
      function SearchState() {
      }
      SearchState.prototype = {
        getQuery: function() {
          return vimGlobalState.query;
        },
        setQuery: function(query) {
          vimGlobalState.query = query;
        },
        getOverlay: function() {
          return this.searchOverlay;
        },
        setOverlay: function(overlay) {
          this.searchOverlay = overlay;
        },
        isReversed: function() {
          return vimGlobalState.isReversed;
        },
        setReversed: function(reversed) {
          vimGlobalState.isReversed = reversed;
        },
        getScrollbarAnnotate: function() {
          return this.annotate;
        },
        setScrollbarAnnotate: function(annotate) {
          this.annotate = annotate;
        }
      };
      function getSearchState(cm) {
        var vim = cm.state.vim;
        return vim.searchState_ || (vim.searchState_ = new SearchState());
      }
      function splitBySlash(argString) {
        return splitBySeparator(argString, "/");
      }
      function findUnescapedSlashes(argString) {
        return findUnescapedSeparators(argString, "/");
      }
      function splitBySeparator(argString, separator) {
        var slashes = findUnescapedSeparators(argString, separator) || [];
        if (!slashes.length)
          return [];
        var tokens = [];
        if (slashes[0] !== 0)
          return;
        for (var i = 0; i < slashes.length; i++) {
          if (typeof slashes[i] == "number")
            tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));
        }
        return tokens;
      }
      function findUnescapedSeparators(str, separator) {
        if (!separator)
          separator = "/";
        var escapeNextChar = false;
        var slashes = [];
        for (var i = 0; i < str.length; i++) {
          var c = str.charAt(i);
          if (!escapeNextChar && c == separator) {
            slashes.push(i);
          }
          escapeNextChar = !escapeNextChar && c == "\\";
        }
        return slashes;
      }
      function translateRegex(str) {
        var specials = "|(){";
        var unescape = "}";
        var escapeNextChar = false;
        var out = [];
        for (var i = -1; i < str.length; i++) {
          var c = str.charAt(i) || "";
          var n = str.charAt(i + 1) || "";
          var specialComesNext = n && specials.indexOf(n) != -1;
          if (escapeNextChar) {
            if (c !== "\\" || !specialComesNext) {
              out.push(c);
            }
            escapeNextChar = false;
          } else {
            if (c === "\\") {
              escapeNextChar = true;
              if (n && unescape.indexOf(n) != -1) {
                specialComesNext = true;
              }
              if (!specialComesNext || n === "\\") {
                out.push(c);
              }
            } else {
              out.push(c);
              if (specialComesNext && n !== "\\") {
                out.push("\\");
              }
            }
          }
        }
        return out.join("");
      }
      var charUnescapes = { "\\n": "\n", "\\r": "\r", "\\t": "	" };
      function translateRegexReplace(str) {
        var escapeNextChar = false;
        var out = [];
        for (var i = -1; i < str.length; i++) {
          var c = str.charAt(i) || "";
          var n = str.charAt(i + 1) || "";
          if (charUnescapes[c + n]) {
            out.push(charUnescapes[c + n]);
            i++;
          } else if (escapeNextChar) {
            out.push(c);
            escapeNextChar = false;
          } else {
            if (c === "\\") {
              escapeNextChar = true;
              if (isNumber(n) || n === "$") {
                out.push("$");
              } else if (n !== "/" && n !== "\\") {
                out.push("\\");
              }
            } else {
              if (c === "$") {
                out.push("$");
              }
              out.push(c);
              if (n === "/") {
                out.push("\\");
              }
            }
          }
        }
        return out.join("");
      }
      var unescapes = { "\\/": "/", "\\\\": "\\", "\\n": "\n", "\\r": "\r", "\\t": "	", "\\&": "&" };
      function unescapeRegexReplace(str) {
        var stream = new CodeMirror.StringStream(str);
        var output = [];
        while (!stream.eol()) {
          while (stream.peek() && stream.peek() != "\\") {
            output.push(stream.next());
          }
          var matched = false;
          for (var matcher in unescapes) {
            if (stream.match(matcher, true)) {
              matched = true;
              output.push(unescapes[matcher]);
              break;
            }
          }
          if (!matched) {
            output.push(stream.next());
          }
        }
        return output.join("");
      }
      function parseQuery(query, ignoreCase, smartCase) {
        var lastSearchRegister = vimGlobalState.registerController.getRegister("/");
        lastSearchRegister.setText(query);
        if (query instanceof RegExp) {
          return query;
        }
        var slashes = findUnescapedSlashes(query);
        var regexPart;
        var forceIgnoreCase;
        if (!slashes.length) {
          regexPart = query;
        } else {
          regexPart = query.substring(0, slashes[0]);
          var flagsPart = query.substring(slashes[0]);
          forceIgnoreCase = flagsPart.indexOf("i") != -1;
        }
        if (!regexPart) {
          return null;
        }
        if (!getOption("pcre")) {
          regexPart = translateRegex(regexPart);
        }
        if (smartCase) {
          ignoreCase = /^[^A-Z]*$/.test(regexPart);
        }
        var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? "im" : "m");
        return regexp;
      }
      function dom(n) {
        if (typeof n === "string")
          n = document.createElement(n);
        for (var a, i = 1; i < arguments.length; i++) {
          if (!(a = arguments[i]))
            continue;
          if (typeof a !== "object")
            a = document.createTextNode(a);
          if (a.nodeType)
            n.appendChild(a);
          else
            for (var key in a) {
              if (!Object.prototype.hasOwnProperty.call(a, key))
                continue;
              if (key[0] === "$")
                n.style[key.slice(1)] = a[key];
              else
                n.setAttribute(key, a[key]);
            }
        }
        return n;
      }
      function showConfirm(cm, template) {
        var pre = dom("div", { $color: "red", $whiteSpace: "pre", class: "cm-vim-message" }, template);
        if (cm.openNotification) {
          cm.openNotification(pre, { bottom: true, duration: 5e3 });
        } else {
          alert(pre.innerText);
        }
      }
      function makePrompt(prefix, desc) {
        return dom("div", { $display: "flex" }, dom("span", { $fontFamily: "monospace", $whiteSpace: "pre", $flex: 1 }, prefix, dom("input", {
          type: "text",
          autocorrect: "off",
          autocapitalize: "off",
          spellcheck: "false",
          $width: "100%"
        })), desc && dom("span", { $color: "#888" }, desc));
      }
      function showPrompt(cm, options2) {
        if (keyToKeyStack.length) {
          if (!options2.value)
            options2.value = "";
          virtualPrompt = options2;
          return;
        }
        var template = makePrompt(options2.prefix, options2.desc);
        if (cm.openDialog) {
          cm.openDialog(template, options2.onClose, {
            onKeyDown: options2.onKeyDown,
            onKeyUp: options2.onKeyUp,
            bottom: true,
            selectValueOnOpen: false,
            value: options2.value
          });
        } else {
          var shortText = "";
          if (typeof options2.prefix != "string" && options2.prefix)
            shortText += options2.prefix.textContent;
          if (options2.desc)
            shortText += " " + options2.desc;
          options2.onClose(prompt(shortText, ""));
        }
      }
      function regexEqual(r1, r2) {
        if (r1 instanceof RegExp && r2 instanceof RegExp) {
          var props = ["global", "multiline", "ignoreCase", "source"];
          for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (r1[prop] !== r2[prop]) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
        if (!rawQuery) {
          return;
        }
        var state = getSearchState(cm);
        var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
        if (!query) {
          return;
        }
        highlightSearchMatches(cm, query);
        if (regexEqual(query, state.getQuery())) {
          return query;
        }
        state.setQuery(query);
        return query;
      }
      function searchOverlay(query) {
        if (query.source.charAt(0) == "^") {
          var matchSol = true;
        }
        return {
          token: function(stream) {
            if (matchSol && !stream.sol()) {
              stream.skipToEnd();
              return;
            }
            var match = stream.match(query, false);
            if (match) {
              if (match[0].length == 0) {
                stream.next();
                return "searching";
              }
              if (!stream.sol()) {
                stream.backUp(1);
                if (!query.exec(stream.next() + match[0])) {
                  stream.next();
                  return null;
                }
              }
              stream.match(query);
              return "searching";
            }
            while (!stream.eol()) {
              stream.next();
              if (stream.match(query, false))
                break;
            }
          },
          query
        };
      }
      var highlightTimeout = 0;
      function highlightSearchMatches(cm, query) {
        clearTimeout(highlightTimeout);
        var searchState = getSearchState(cm);
        searchState.highlightTimeout = highlightTimeout;
        highlightTimeout = setTimeout(function() {
          if (!cm.state.vim)
            return;
          var searchState2 = getSearchState(cm);
          searchState2.highlightTimeout = null;
          var overlay = searchState2.getOverlay();
          if (!overlay || query != overlay.query) {
            if (overlay) {
              cm.removeOverlay(overlay);
            }
            overlay = searchOverlay(query);
            cm.addOverlay(overlay);
            if (cm.showMatchesOnScrollbar) {
              if (searchState2.getScrollbarAnnotate()) {
                searchState2.getScrollbarAnnotate().clear();
              }
              searchState2.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
            }
            searchState2.setOverlay(overlay);
          }
        }, 50);
      }
      function findNext(cm, prev, query, repeat) {
        if (repeat === void 0) {
          repeat = 1;
        }
        return cm.operation(function() {
          var pos = cm.getCursor();
          var cursor = cm.getSearchCursor(query, pos);
          for (var i = 0; i < repeat; i++) {
            var found = cursor.find(prev);
            if (i == 0 && found && cursorEqual(cursor.from(), pos)) {
              var lastEndPos = prev ? cursor.from() : cursor.to();
              found = cursor.find(prev);
              if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {
                if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)
                  found = cursor.find(prev);
              }
            }
            if (!found) {
              cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
              if (!cursor.find(prev)) {
                return;
              }
            }
          }
          return cursor.from();
        });
      }
      function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {
        if (repeat === void 0) {
          repeat = 1;
        }
        return cm.operation(function() {
          var pos = cm.getCursor();
          var cursor = cm.getSearchCursor(query, pos);
          var found = cursor.find(!prev);
          if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {
            cursor.find(!prev);
          }
          for (var i = 0; i < repeat; i++) {
            found = cursor.find(prev);
            if (!found) {
              cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
              if (!cursor.find(prev)) {
                return;
              }
            }
          }
          return [cursor.from(), cursor.to()];
        });
      }
      function clearSearchHighlight(cm) {
        var state = getSearchState(cm);
        if (state.highlightTimeout) {
          clearTimeout(state.highlightTimeout);
          state.highlightTimeout = null;
        }
        cm.removeOverlay(getSearchState(cm).getOverlay());
        state.setOverlay(null);
        if (state.getScrollbarAnnotate()) {
          state.getScrollbarAnnotate().clear();
          state.setScrollbarAnnotate(null);
        }
      }
      function isInRange(pos, start, end) {
        if (typeof pos != "number") {
          pos = pos.line;
        }
        if (start instanceof Array) {
          return inArray(pos, start);
        } else {
          if (typeof end == "number") {
            return pos >= start && pos <= end;
          } else {
            return pos == start;
          }
        }
      }
      function getUserVisibleLines(cm) {
        var renderer = cm.ace.renderer;
        return {
          top: renderer.getFirstFullyVisibleRow(),
          bottom: renderer.getLastFullyVisibleRow()
        };
      }
      function getMarkPos(cm, vim, markName) {
        if (markName == "'" || markName == "`") {
          return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);
        } else if (markName == ".") {
          return getLastEditPos(cm);
        }
        var mark = vim.marks[markName];
        return mark && mark.find();
      }
      function getLastEditPos(cm) {
        if (cm.getLastEditEnd) {
          return cm.getLastEditEnd();
        }
        var done = cm.doc.history.done;
        for (var i = done.length; i--; ) {
          if (done[i].changes) {
            return copyCursor(done[i].changes[0].to);
          }
        }
      }
      var ExCommandDispatcher = function() {
        this.buildCommandMap_();
      };
      ExCommandDispatcher.prototype = {
        processCommand: function(cm, input, opt_params) {
          var that = this;
          cm.operation(function() {
            cm.curOp.isVimOp = true;
            that._processCommand(cm, input, opt_params);
          });
        },
        _processCommand: function(cm, input, opt_params) {
          var vim = cm.state.vim;
          var commandHistoryRegister = vimGlobalState.registerController.getRegister(":");
          var previousCommand = commandHistoryRegister.toString();
          var inputStream = new CodeMirror.StringStream(input);
          commandHistoryRegister.setText(input);
          var params = opt_params || {};
          params.input = input;
          try {
            this.parseInput_(cm, inputStream, params);
          } catch (e) {
            showConfirm(cm, e.toString());
            throw e;
          }
          if (vim.visualMode) {
            exitVisualMode(cm);
          }
          var command;
          var commandName;
          if (!params.commandName) {
            if (params.line !== void 0) {
              commandName = "move";
            }
          } else {
            command = this.matchCommand_(params.commandName);
            if (command) {
              commandName = command.name;
              if (command.excludeFromCommandHistory) {
                commandHistoryRegister.setText(previousCommand);
              }
              this.parseCommandArgs_(inputStream, params, command);
              if (command.type == "exToKey") {
                doKeyToKey(cm, command.toKeys, command);
                return;
              } else if (command.type == "exToEx") {
                this.processCommand(cm, command.toInput);
                return;
              }
            }
          }
          if (!commandName) {
            showConfirm(cm, 'Not an editor command ":' + input + '"');
            return;
          }
          try {
            exCommands[commandName](cm, params);
            if ((!command || !command.possiblyAsync) && params.callback) {
              params.callback();
            }
          } catch (e) {
            showConfirm(cm, e.toString());
            throw e;
          }
        },
        parseInput_: function(cm, inputStream, result) {
          inputStream.eatWhile(":");
          if (inputStream.eat("%")) {
            result.line = cm.firstLine();
            result.lineEnd = cm.lastLine();
          } else {
            result.line = this.parseLineSpec_(cm, inputStream);
            if (result.line !== void 0 && inputStream.eat(",")) {
              result.lineEnd = this.parseLineSpec_(cm, inputStream);
            }
          }
          if (result.line == void 0) {
            if (cm.state.vim.visualMode) {
              var pos = getMarkPos(cm, cm.state.vim, "<");
              result.selectionLine = pos && pos.line;
              pos = getMarkPos(cm, cm.state.vim, ">");
              result.selectionLineEnd = pos && pos.line;
            } else {
              result.selectionLine = cm.getCursor().line;
            }
          } else {
            result.selectionLine = result.line;
            result.selectionLineEnd = result.lineEnd;
          }
          var commandMatch2 = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
          if (commandMatch2) {
            result.commandName = commandMatch2[1];
          } else {
            result.commandName = inputStream.match(/.*/)[0];
          }
          return result;
        },
        parseLineSpec_: function(cm, inputStream) {
          var numberMatch = inputStream.match(/^(\d+)/);
          if (numberMatch) {
            return parseInt(numberMatch[1], 10) - 1;
          }
          switch (inputStream.next()) {
            case ".":
              return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
            case "$":
              return this.parseLineSpecOffset_(inputStream, cm.lastLine());
            case "'":
              var markName = inputStream.next();
              var markPos = getMarkPos(cm, cm.state.vim, markName);
              if (!markPos)
                throw new Error("Mark not set");
              return this.parseLineSpecOffset_(inputStream, markPos.line);
            case "-":
            case "+":
              inputStream.backUp(1);
              return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
            default:
              inputStream.backUp(1);
              return void 0;
          }
        },
        parseLineSpecOffset_: function(inputStream, line) {
          var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
          if (offsetMatch) {
            var offset = parseInt(offsetMatch[2], 10);
            if (offsetMatch[1] == "-") {
              line -= offset;
            } else {
              line += offset;
            }
          }
          return line;
        },
        parseCommandArgs_: function(inputStream, params, command) {
          if (inputStream.eol()) {
            return;
          }
          params.argString = inputStream.match(/.*/)[0];
          var delim = command.argDelimiter || /\s+/;
          var args = trim(params.argString).split(delim);
          if (args.length && args[0]) {
            params.args = args;
          }
        },
        matchCommand_: function(commandName) {
          for (var i = commandName.length; i > 0; i--) {
            var prefix = commandName.substring(0, i);
            if (this.commandMap_[prefix]) {
              var command = this.commandMap_[prefix];
              if (command.name.indexOf(commandName) === 0) {
                return command;
              }
            }
          }
          return null;
        },
        buildCommandMap_: function() {
          this.commandMap_ = {};
          for (var i = 0; i < defaultExCommandMap.length; i++) {
            var command = defaultExCommandMap[i];
            var key = command.shortName || command.name;
            this.commandMap_[key] = command;
          }
        },
        map: function(lhs, rhs, ctx, noremap2) {
          if (lhs != ":" && lhs.charAt(0) == ":") {
            if (ctx) {
              throw Error("Mode not supported for ex mappings");
            }
            var commandName = lhs.substring(1);
            if (rhs != ":" && rhs.charAt(0) == ":") {
              this.commandMap_[commandName] = {
                name: commandName,
                type: "exToEx",
                toInput: rhs.substring(1),
                user: true
              };
            } else {
              this.commandMap_[commandName] = {
                name: commandName,
                type: "exToKey",
                toKeys: rhs,
                user: true
              };
            }
          } else {
            var mapping = {
              keys: lhs,
              type: "keyToKey",
              toKeys: rhs,
              noremap: !!noremap2
            };
            if (ctx) {
              mapping.context = ctx;
            }
            defaultKeymap.unshift(mapping);
          }
        },
        unmap: function(lhs, ctx) {
          if (lhs != ":" && lhs.charAt(0) == ":") {
            if (ctx) {
              throw Error("Mode not supported for ex mappings");
            }
            var commandName = lhs.substring(1);
            if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
              delete this.commandMap_[commandName];
              return true;
            }
          } else {
            var keys = lhs;
            for (var i = 0; i < defaultKeymap.length; i++) {
              if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {
                defaultKeymap.splice(i, 1);
                return true;
              }
            }
          }
        }
      };
      var exCommands = {
        colorscheme: function(cm, params) {
          if (!params.args || params.args.length < 1) {
            showConfirm(cm, cm.getOption("theme"));
            return;
          }
          cm.setOption("theme", params.args[0]);
        },
        map: function(cm, params, ctx, defaultOnly) {
          var mapArgs = params.args;
          if (!mapArgs || mapArgs.length < 2) {
            if (cm) {
              showConfirm(cm, "Invalid mapping: " + params.input);
            }
            return;
          }
          exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);
        },
        imap: function(cm, params) {
          this.map(cm, params, "insert");
        },
        nmap: function(cm, params) {
          this.map(cm, params, "normal");
        },
        vmap: function(cm, params) {
          this.map(cm, params, "visual");
        },
        omap: function(cm, params) {
          this.map(cm, params, "operatorPending");
        },
        noremap: function(cm, params) {
          this.map(cm, params, void 0, true);
        },
        inoremap: function(cm, params) {
          this.map(cm, params, "insert", true);
        },
        nnoremap: function(cm, params) {
          this.map(cm, params, "normal", true);
        },
        vnoremap: function(cm, params) {
          this.map(cm, params, "visual", true);
        },
        onoremap: function(cm, params) {
          this.map(cm, params, "operatorPending", true);
        },
        unmap: function(cm, params, ctx) {
          var mapArgs = params.args;
          if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {
            if (cm) {
              showConfirm(cm, "No such mapping: " + params.input);
            }
          }
        },
        mapclear: function(cm, params) {
          vimApi.mapclear();
        },
        imapclear: function(cm, params) {
          vimApi.mapclear("insert");
        },
        nmapclear: function(cm, params) {
          vimApi.mapclear("normal");
        },
        vmapclear: function(cm, params) {
          vimApi.mapclear("visual");
        },
        omapclear: function(cm, params) {
          vimApi.mapclear("operatorPending");
        },
        move: function(cm, params) {
          commandDispatcher.processCommand(cm, cm.state.vim, {
            type: "motion",
            motion: "moveToLineOrEdgeOfDocument",
            motionArgs: {
              forward: false,
              explicitRepeat: true,
              linewise: true
            },
            repeatOverride: params.line + 1
          });
        },
        set: function(cm, params) {
          var setArgs = params.args;
          var setCfg = params.setCfg || {};
          if (!setArgs || setArgs.length < 1) {
            if (cm) {
              showConfirm(cm, "Invalid mapping: " + params.input);
            }
            return;
          }
          var expr = setArgs[0].split("=");
          var optionName = expr[0];
          var value = expr[1];
          var forceGet = false;
          var forceToggle = false;
          if (optionName.charAt(optionName.length - 1) == "?") {
            if (value) {
              throw Error("Trailing characters: " + params.argString);
            }
            optionName = optionName.substring(0, optionName.length - 1);
            forceGet = true;
          } else if (optionName.charAt(optionName.length - 1) == "!") {
            optionName = optionName.substring(0, optionName.length - 1);
            forceToggle = true;
          }
          if (value === void 0 && optionName.substring(0, 2) == "no") {
            optionName = optionName.substring(2);
            value = false;
          }
          var optionIsBoolean = options[optionName] && options[optionName].type == "boolean";
          if (optionIsBoolean) {
            if (forceToggle) {
              value = !getOption(optionName, cm, setCfg);
            } else if (value == void 0) {
              value = true;
            }
          }
          if (!optionIsBoolean && value === void 0 || forceGet) {
            var oldValue = getOption(optionName, cm, setCfg);
            if (oldValue instanceof Error) {
              showConfirm(cm, oldValue.message);
            } else if (oldValue === true || oldValue === false) {
              showConfirm(cm, " " + (oldValue ? "" : "no") + optionName);
            } else {
              showConfirm(cm, "  " + optionName + "=" + oldValue);
            }
          } else {
            var setOptionReturn = setOption(optionName, value, cm, setCfg);
            if (setOptionReturn instanceof Error) {
              showConfirm(cm, setOptionReturn.message);
            }
          }
        },
        setlocal: function(cm, params) {
          params.setCfg = { scope: "local" };
          this.set(cm, params);
        },
        setglobal: function(cm, params) {
          params.setCfg = { scope: "global" };
          this.set(cm, params);
        },
        registers: function(cm, params) {
          var regArgs = params.args;
          var registers = vimGlobalState.registerController.registers;
          var regInfo = "----------Registers----------\n\n";
          if (!regArgs) {
            for (var registerName in registers) {
              var text = registers[registerName].toString();
              if (text.length) {
                regInfo += '"' + registerName + "    " + text + "\n";
              }
            }
          } else {
            var registerName;
            regArgs = regArgs.join("");
            for (var i = 0; i < regArgs.length; i++) {
              registerName = regArgs.charAt(i);
              if (!vimGlobalState.registerController.isValidRegister(registerName)) {
                continue;
              }
              var register = registers[registerName] || new Register();
              regInfo += '"' + registerName + "    " + register.toString() + "\n";
            }
          }
          showConfirm(cm, regInfo);
        },
        sort: function(cm, params) {
          var reverse, ignoreCase, unique, number, pattern;
          function parseArgs() {
            if (params.argString) {
              var args = new CodeMirror.StringStream(params.argString);
              if (args.eat("!")) {
                reverse = true;
              }
              if (args.eol()) {
                return;
              }
              if (!args.eatSpace()) {
                return "Invalid arguments";
              }
              var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
              if (!opts && !args.eol()) {
                return "Invalid arguments";
              }
              if (opts[1]) {
                ignoreCase = opts[1].indexOf("i") != -1;
                unique = opts[1].indexOf("u") != -1;
                var decimal = opts[1].indexOf("d") != -1 || opts[1].indexOf("n") != -1 && 1;
                var hex = opts[1].indexOf("x") != -1 && 1;
                var octal = opts[1].indexOf("o") != -1 && 1;
                if (decimal + hex + octal > 1) {
                  return "Invalid arguments";
                }
                number = decimal && "decimal" || hex && "hex" || octal && "octal";
              }
              if (opts[2]) {
                pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? "i" : "");
              }
            }
          }
          var err = parseArgs();
          if (err) {
            showConfirm(cm, err + ": " + params.argString);
            return;
          }
          var lineStart = params.line || cm.firstLine();
          var lineEnd = params.lineEnd || params.line || cm.lastLine();
          if (lineStart == lineEnd) {
            return;
          }
          var curStart = new Pos(lineStart, 0);
          var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));
          var text = cm.getRange(curStart, curEnd).split("\n");
          var numberRegex2 = pattern ? pattern : number == "decimal" ? /(-?)([\d]+)/ : number == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : number == "octal" ? /([0-7]+)/ : null;
          var radix = number == "decimal" ? 10 : number == "hex" ? 16 : number == "octal" ? 8 : null;
          var numPart = [], textPart = [];
          if (number || pattern) {
            for (var i = 0; i < text.length; i++) {
              var matchPart = pattern ? text[i].match(pattern) : null;
              if (matchPart && matchPart[0] != "") {
                numPart.push(matchPart);
              } else if (!pattern && numberRegex2.exec(text[i])) {
                numPart.push(text[i]);
              } else {
                textPart.push(text[i]);
              }
            }
          } else {
            textPart = text;
          }
          function compareFn(a, b2) {
            if (reverse) {
              var tmp;
              tmp = a;
              a = b2;
              b2 = tmp;
            }
            if (ignoreCase) {
              a = a.toLowerCase();
              b2 = b2.toLowerCase();
            }
            var anum = number && numberRegex2.exec(a);
            var bnum = number && numberRegex2.exec(b2);
            if (!anum) {
              return a < b2 ? -1 : 1;
            }
            anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
            bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
            return anum - bnum;
          }
          function comparePatternFn(a, b2) {
            if (reverse) {
              var tmp;
              tmp = a;
              a = b2;
              b2 = tmp;
            }
            if (ignoreCase) {
              a[0] = a[0].toLowerCase();
              b2[0] = b2[0].toLowerCase();
            }
            return a[0] < b2[0] ? -1 : 1;
          }
          numPart.sort(pattern ? comparePatternFn : compareFn);
          if (pattern) {
            for (var i = 0; i < numPart.length; i++) {
              numPart[i] = numPart[i].input;
            }
          } else if (!number) {
            textPart.sort(compareFn);
          }
          text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);
          if (unique) {
            var textOld = text;
            var lastLine;
            text = [];
            for (var i = 0; i < textOld.length; i++) {
              if (textOld[i] != lastLine) {
                text.push(textOld[i]);
              }
              lastLine = textOld[i];
            }
          }
          cm.replaceRange(text.join("\n"), curStart, curEnd);
        },
        vglobal: function(cm, params) {
          this.global(cm, params);
        },
        normal: function(cm, params) {
          var argString = params.argString;
          if (argString && argString[0] == "!") {
            argString = argString.slice(1);
            noremap = true;
          }
          argString = argString.trimStart();
          if (!argString) {
            showConfirm(cm, "Argument is required.");
            return;
          }
          var line = params.line;
          if (typeof line == "number") {
            var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;
            for (var i = line; i <= lineEnd; i++) {
              cm.setCursor(i, 0);
              doKeyToKey(cm, params.argString.trimStart());
              if (cm.state.vim.insertMode) {
                exitInsertMode(cm, true);
              }
            }
          } else {
            doKeyToKey(cm, params.argString.trimStart());
            if (cm.state.vim.insertMode) {
              exitInsertMode(cm, true);
            }
          }
        },
        global: function(cm, params) {
          var argString = params.argString;
          if (!argString) {
            showConfirm(cm, "Regular Expression missing from global");
            return;
          }
          var inverted = params.commandName[0] === "v";
          if (argString[0] === "!" && params.commandName[0] === "g") {
            inverted = true;
            argString = argString.slice(1);
          }
          var lineStart = params.line !== void 0 ? params.line : cm.firstLine();
          var lineEnd = params.lineEnd || params.line || cm.lastLine();
          var tokens = splitBySlash(argString);
          var regexPart = argString, cmd;
          if (tokens.length) {
            regexPart = tokens[0];
            cmd = tokens.slice(1, tokens.length).join("/");
          }
          if (regexPart) {
            try {
              updateSearchQuery(
                cm,
                regexPart,
                true,
                true
                /** smartCase */
              );
            } catch (e) {
              showConfirm(cm, "Invalid regex: " + regexPart);
              return;
            }
          }
          var query = getSearchState(cm).getQuery();
          var matchedLines = [];
          for (var i = lineStart; i <= lineEnd; i++) {
            var line = cm.getLine(i);
            var matched = query.test(line);
            if (matched !== inverted) {
              matchedLines.push(cmd ? cm.getLineHandle(i) : line);
            }
          }
          if (!cmd) {
            showConfirm(cm, matchedLines.join("\n"));
            return;
          }
          var index = 0;
          var nextCommand = function() {
            if (index < matchedLines.length) {
              var lineHandle = matchedLines[index++];
              var lineNum = cm.getLineNumber(lineHandle);
              if (lineNum == null) {
                nextCommand();
                return;
              }
              var command = lineNum + 1 + cmd;
              exCommandDispatcher.processCommand(cm, command, {
                callback: nextCommand
              });
            } else if (cm.releaseLineHandles) {
              cm.releaseLineHandles();
            }
          };
          nextCommand();
        },
        substitute: function(cm, params) {
          if (!cm.getSearchCursor) {
            throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
          }
          var argString = params.argString;
          var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
          var regexPart, replacePart = "", trailing, flagsPart, count;
          var confirm2 = false;
          var global2 = false;
          if (tokens.length) {
            regexPart = tokens[0];
            if (getOption("pcre") && regexPart !== "") {
              regexPart = new RegExp(regexPart).source;
            }
            replacePart = tokens[1];
            if (replacePart !== void 0) {
              if (getOption("pcre")) {
                replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g, "$1$$&"));
              } else {
                replacePart = translateRegexReplace(replacePart);
              }
              vimGlobalState.lastSubstituteReplacePart = replacePart;
            }
            trailing = tokens[2] ? tokens[2].split(" ") : [];
          } else {
            if (argString && argString.length) {
              showConfirm(cm, "Substitutions should be of the form :s/pattern/replace/");
              return;
            }
          }
          if (trailing) {
            flagsPart = trailing[0];
            count = parseInt(trailing[1]);
            if (flagsPart) {
              if (flagsPart.indexOf("c") != -1) {
                confirm2 = true;
              }
              if (flagsPart.indexOf("g") != -1) {
                global2 = true;
              }
              if (getOption("pcre")) {
                regexPart = regexPart + "/" + flagsPart;
              } else {
                regexPart = regexPart.replace(/\//g, "\\/") + "/" + flagsPart;
              }
            }
          }
          if (regexPart) {
            try {
              updateSearchQuery(
                cm,
                regexPart,
                true,
                true
                /** smartCase */
              );
            } catch (e) {
              showConfirm(cm, "Invalid regex: " + regexPart);
              return;
            }
          }
          replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
          if (replacePart === void 0) {
            showConfirm(cm, "No previous substitute regular expression");
            return;
          }
          var state = getSearchState(cm);
          var query = state.getQuery();
          var lineStart = params.line !== void 0 ? params.line : cm.getCursor().line;
          var lineEnd = params.lineEnd || lineStart;
          if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
            lineEnd = Infinity;
          }
          if (count) {
            lineStart = lineEnd;
            lineEnd = lineStart + count - 1;
          }
          var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));
          var cursor = cm.getSearchCursor(query, startPos);
          doReplace(cm, confirm2, global2, lineStart, lineEnd, cursor, query, replacePart, params.callback);
        },
        startinsert: function(cm, params) {
          doKeyToKey(cm, params.argString == "!" ? "A" : "i", {});
        },
        redo: CodeMirror.commands.redo,
        undo: CodeMirror.commands.undo,
        write: function(cm) {
          if (CodeMirror.commands.save) {
            CodeMirror.commands.save(cm);
          } else if (cm.save) {
            cm.save();
          }
        },
        nohlsearch: function(cm) {
          clearSearchHighlight(cm);
        },
        yank: function(cm) {
          var cur = copyCursor(cm.getCursor());
          var line = cur.line;
          var lineText = cm.getLine(line);
          vimGlobalState.registerController.pushText("0", "yank", lineText, true, true);
        },
        delete: function(cm, params) {
          var line = params.selectionLine;
          var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;
          operators.delete(cm, { linewise: true }, [
            {
              anchor: new Pos(line, 0),
              head: new Pos(lineEnd + 1, 0)
            }
          ]);
        },
        join: function(cm, params) {
          var line = params.selectionLine;
          var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;
          cm.setCursor(new Pos(line, 0));
          actions.joinLines(cm, { repeat: lineEnd - line }, cm.state.vim);
        },
        delmarks: function(cm, params) {
          if (!params.argString || !trim(params.argString)) {
            showConfirm(cm, "Argument required");
            return;
          }
          var state = cm.state.vim;
          var stream = new CodeMirror.StringStream(trim(params.argString));
          while (!stream.eol()) {
            stream.eatSpace();
            var count = stream.pos;
            if (!stream.match(/[a-zA-Z]/, false)) {
              showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
              return;
            }
            var sym = stream.next();
            if (stream.match("-", true)) {
              if (!stream.match(/[a-zA-Z]/, false)) {
                showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
                return;
              }
              var startMark = sym;
              var finishMark = stream.next();
              if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {
                var start = startMark.charCodeAt(0);
                var finish = finishMark.charCodeAt(0);
                if (start >= finish) {
                  showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
                  return;
                }
                for (var j3 = 0; j3 <= finish - start; j3++) {
                  var mark = String.fromCharCode(start + j3);
                  delete state.marks[mark];
                }
              } else {
                showConfirm(cm, "Invalid argument: " + startMark + "-");
                return;
              }
            } else {
              delete state.marks[sym];
            }
          }
        }
      };
      var exCommandDispatcher = new ExCommandDispatcher();
      function doReplace(cm, confirm2, global2, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {
        cm.state.vim.exMode = true;
        var done = false;
        var lastPos, modifiedLineNumber, joined;
        function replaceAll() {
          cm.operation(function() {
            while (!done) {
              replace();
              next();
            }
            stop();
          });
        }
        function replace() {
          var text = cm.getRange(searchCursor.from(), searchCursor.to());
          var newText = text.replace(query, replaceWith);
          var unmodifiedLineNumber = searchCursor.to().line;
          searchCursor.replace(newText);
          modifiedLineNumber = searchCursor.to().line;
          lineEnd += modifiedLineNumber - unmodifiedLineNumber;
          joined = modifiedLineNumber < unmodifiedLineNumber;
        }
        function findNextValidMatch() {
          var lastMatchTo = lastPos && copyCursor(searchCursor.to());
          var match = searchCursor.findNext();
          if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {
            match = searchCursor.findNext();
          }
          return match;
        }
        function next() {
          while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {
            if (!global2 && searchCursor.from().line == modifiedLineNumber && !joined) {
              continue;
            }
            cm.scrollIntoView(searchCursor.from(), 30);
            cm.setSelection(searchCursor.from(), searchCursor.to());
            lastPos = searchCursor.from();
            done = false;
            return;
          }
          done = true;
        }
        function stop(close) {
          if (close) {
            close();
          }
          cm.focus();
          if (lastPos) {
            cm.setCursor(lastPos);
            var vim = cm.state.vim;
            vim.exMode = false;
            vim.lastHPos = vim.lastHSPos = lastPos.ch;
          }
          if (callback) {
            callback();
          }
        }
        function onPromptKeyDown(e, _value, close) {
          CodeMirror.e_stop(e);
          var keyName = vimKeyFromEvent(e);
          switch (keyName) {
            case "y":
              replace();
              next();
              break;
            case "n":
              next();
              break;
            case "a":
              var savedCallback = callback;
              callback = void 0;
              cm.operation(replaceAll);
              callback = savedCallback;
              break;
            case "l":
              replace();
            case "q":
            case "<Esc>":
            case "<C-c>":
            case "<C-[>":
              stop(close);
              break;
          }
          if (done) {
            stop(close);
          }
          return true;
        }
        next();
        if (done) {
          showConfirm(cm, "No matches for " + query.source);
          return;
        }
        if (!confirm2) {
          replaceAll();
          if (callback) {
            callback();
          }
          return;
        }
        showPrompt(cm, {
          prefix: dom("span", "replace with ", dom("strong", replaceWith), " (y/n/a/q/l)"),
          onKeyDown: onPromptKeyDown
        });
      }
      function exitInsertMode(cm, keepCursor) {
        var vim = cm.state.vim;
        var macroModeState = vimGlobalState.macroModeState;
        var insertModeChangeRegister = vimGlobalState.registerController.getRegister(".");
        var isPlaying = macroModeState.isPlaying;
        var lastChange = macroModeState.lastInsertModeChanges;
        if (!isPlaying) {
          cm.off("change", onChange);
          if (vim.insertEnd)
            vim.insertEnd.clear();
          vim.insertEnd = null;
          CodeMirror.off(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
        }
        if (!isPlaying && vim.insertModeRepeat > 1) {
          repeatLastEdit(
            cm,
            vim,
            vim.insertModeRepeat - 1,
            true
            /** repeatForInsert */
          );
          vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
        }
        delete vim.insertModeRepeat;
        vim.insertMode = false;
        if (!keepCursor) {
          cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);
        }
        cm.setOption("keyMap", "vim");
        cm.setOption("disableInput", true);
        cm.toggleOverwrite(false);
        insertModeChangeRegister.setText(lastChange.changes.join(""));
        CodeMirror.signal(cm, "vim-mode-change", { mode: "normal" });
        if (macroModeState.isRecording) {
          logInsertModeChange(macroModeState);
        }
      }
      function _mapCommand(command) {
        defaultKeymap.unshift(command);
      }
      function mapCommand(keys, type, name, args, extra) {
        var command = { keys, type };
        command[type] = name;
        command[type + "Args"] = args;
        for (var key in extra)
          command[key] = extra[key];
        _mapCommand(command);
      }
      defineOption("insertModeEscKeysTimeout", 200, "number");
      function executeMacroRegister(cm, vim, macroModeState, registerName) {
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (registerName == ":") {
          if (register.keyBuffer[0]) {
            exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
          }
          macroModeState.isPlaying = false;
          return;
        }
        var keyBuffer = register.keyBuffer;
        var imc = 0;
        macroModeState.isPlaying = true;
        macroModeState.replaySearchQueries = register.searchQueries.slice(0);
        for (var i = 0; i < keyBuffer.length; i++) {
          var text = keyBuffer[i];
          var match, key;
          while (text) {
            match = /<\w+-.+?>|<\w+>|./.exec(text);
            key = match[0];
            text = text.substring(match.index + key.length);
            vimApi.handleKey(cm, key, "macro");
            if (vim.insertMode) {
              var changes = register.insertModeChanges[imc++].changes;
              vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;
              repeatInsertModeChanges(cm, changes, 1);
              exitInsertMode(cm);
            }
          }
        }
        macroModeState.isPlaying = false;
      }
      function logKey(macroModeState, key) {
        if (macroModeState.isPlaying) {
          return;
        }
        var registerName = macroModeState.latestRegister;
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register) {
          register.pushText(key);
        }
      }
      function logInsertModeChange(macroModeState) {
        if (macroModeState.isPlaying) {
          return;
        }
        var registerName = macroModeState.latestRegister;
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register && register.pushInsertModeChanges) {
          register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
        }
      }
      function logSearchQuery(macroModeState, query) {
        if (macroModeState.isPlaying) {
          return;
        }
        var registerName = macroModeState.latestRegister;
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register && register.pushSearchQuery) {
          register.pushSearchQuery(query);
        }
      }
      function onChange(cm, changeObj) {
        var macroModeState = vimGlobalState.macroModeState;
        var lastChange = macroModeState.lastInsertModeChanges;
        if (!macroModeState.isPlaying) {
          var vim = cm.state.vim;
          while (changeObj) {
            lastChange.expectCursorActivityForChange = true;
            if (lastChange.ignoreCount > 1) {
              lastChange.ignoreCount--;
            } else if (changeObj.origin == "+input" || changeObj.origin == "paste" || changeObj.origin === void 0) {
              var selectionCount = cm.listSelections().length;
              if (selectionCount > 1)
                lastChange.ignoreCount = selectionCount;
              var text = changeObj.text.join("\n");
              if (lastChange.maybeReset) {
                lastChange.changes = [];
                lastChange.maybeReset = false;
              }
              if (text) {
                if (cm.state.overwrite && !/\n/.test(text)) {
                  lastChange.changes.push([text]);
                } else {
                  if (text.length > 1) {
                    var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();
                    var cursor = cm.getCursor();
                    if (insertEnd && insertEnd.line == cursor.line) {
                      var offset = insertEnd.ch - cursor.ch;
                      if (offset > 0 && offset < text.length) {
                        lastChange.changes.push([text, offset]);
                        text = "";
                      }
                    }
                  }
                  if (text)
                    lastChange.changes.push(text);
                }
              }
            }
            changeObj = changeObj.next;
          }
        }
      }
      function onCursorActivity(cm) {
        var vim = cm.state.vim;
        if (vim.insertMode) {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isPlaying) {
            return;
          }
          var lastChange = macroModeState.lastInsertModeChanges;
          if (lastChange.expectCursorActivityForChange) {
            lastChange.expectCursorActivityForChange = false;
          } else {
            lastChange.maybeReset = true;
            if (vim.insertEnd)
              vim.insertEnd.clear();
            vim.insertEnd = cm.setBookmark(cm.getCursor(), { insertLeft: true });
          }
        } else if (!cm.curOp.isVimOp) {
          handleExternalSelection(cm, vim);
        }
      }
      function handleExternalSelection(cm, vim, keepHPos) {
        var anchor = cm.getCursor("anchor");
        var head = cm.getCursor("head");
        if (vim.visualMode && !cm.somethingSelected()) {
          exitVisualMode(cm, false);
        } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {
          vim.visualMode = true;
          vim.visualLine = false;
          CodeMirror.signal(cm, "vim-mode-change", { mode: "visual" });
        }
        if (vim.visualMode) {
          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
          head = offsetCursor(head, 0, headOffset);
          anchor = offsetCursor(anchor, 0, anchorOffset);
          vim.sel = {
            anchor,
            head
          };
          updateMark(cm, vim, "<", cursorMin(head, anchor));
          updateMark(cm, vim, ">", cursorMax(head, anchor));
        } else if (!vim.insertMode && !keepHPos) {
          vim.lastHPos = cm.getCursor().ch;
        }
      }
      function InsertModeKey(keyName, e) {
        this.keyName = keyName;
        this.key = e.key;
        this.ctrlKey = e.ctrlKey;
        this.altKey = e.altKey;
        this.metaKey = e.metaKey;
        this.shiftKey = e.shiftKey;
      }
      function onKeyEventTargetKeyDown(e) {
        var macroModeState = vimGlobalState.macroModeState;
        var lastChange = macroModeState.lastInsertModeChanges;
        var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;
        if (!keyName) {
          return;
        }
        if (keyName.indexOf("Delete") != -1 || keyName.indexOf("Backspace") != -1) {
          if (lastChange.maybeReset) {
            lastChange.changes = [];
            lastChange.maybeReset = false;
          }
          lastChange.changes.push(new InsertModeKey(keyName, e));
        }
      }
      function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
        var macroModeState = vimGlobalState.macroModeState;
        macroModeState.isPlaying = true;
        var isAction = !!vim.lastEditActionCommand;
        var cachedInputState = vim.inputState;
        function repeatCommand() {
          if (isAction) {
            commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
          } else {
            commandDispatcher.evalInput(cm, vim);
          }
        }
        function repeatInsert(repeat2) {
          if (macroModeState.lastInsertModeChanges.changes.length > 0) {
            repeat2 = !vim.lastEditActionCommand ? 1 : repeat2;
            var changeObject = macroModeState.lastInsertModeChanges;
            repeatInsertModeChanges(cm, changeObject.changes, repeat2);
          }
        }
        vim.inputState = vim.lastEditInputState;
        if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {
          for (var i = 0; i < repeat; i++) {
            repeatCommand();
            repeatInsert(1);
          }
        } else {
          if (!repeatForInsert) {
            repeatCommand();
          }
          repeatInsert(repeat);
        }
        vim.inputState = cachedInputState;
        if (vim.insertMode && !repeatForInsert) {
          exitInsertMode(cm);
        }
        macroModeState.isPlaying = false;
      }
      function sendCmKey(cm, key) {
        CodeMirror.lookupKey(key, "vim-insert", function keyHandler(binding) {
          if (typeof binding == "string") {
            CodeMirror.commands[binding](cm);
          } else {
            binding(cm);
          }
          return true;
        });
      }
      function repeatInsertModeChanges(cm, changes, repeat) {
        var head = cm.getCursor("head");
        var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
        if (visualBlock) {
          selectForInsert(cm, head, visualBlock + 1);
          repeat = cm.listSelections().length;
          cm.setCursor(head);
        }
        for (var i = 0; i < repeat; i++) {
          if (visualBlock) {
            cm.setCursor(offsetCursor(head, i, 0));
          }
          for (var j3 = 0; j3 < changes.length; j3++) {
            var change = changes[j3];
            if (change instanceof InsertModeKey) {
              sendCmKey(cm, change.keyName, change);
            } else if (typeof change == "string") {
              cm.replaceSelection(change);
            } else {
              var start = cm.getCursor();
              var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));
              cm.replaceRange(change[0], start, change[1] ? start : end);
              cm.setCursor(end);
            }
          }
        }
        if (visualBlock) {
          cm.setCursor(offsetCursor(head, 0, 1));
        }
      }
      CodeMirror.Vim = vimApi;
      var specialKeyAce = {
        "return": "CR",
        backspace: "BS",
        "delete": "Del",
        esc: "Esc",
        left: "Left",
        right: "Right",
        up: "Up",
        down: "Down",
        space: "Space",
        insert: "Ins",
        home: "Home",
        end: "End",
        pageup: "PageUp",
        pagedown: "PageDown",
        enter: "CR"
      };
      function lookupKey(hashId, key, e, vim) {
        if (key.length > 1 && key[0] == "n") {
          key = key.replace("numpad", "");
        }
        key = specialKeyAce[key] || key;
        var name = "";
        if (e.ctrlKey) {
          name += "C-";
        }
        if (e.altKey) {
          name += "A-";
        }
        if ((name || key.length > 1) && e.shiftKey) {
          name += "S-";
        }
        if (vim && !vim.expectLiteralNext && key.length == 1) {
          if (langmap.keymap && key in langmap.keymap) {
            if (langmap.remapCtrl !== false || !name)
              key = langmap.keymap[key];
          } else if (key.charCodeAt(0) > 255) {
            var code = e.code && e.code.slice(-1) || "";
            if (!e.shiftKey)
              code = code.toLowerCase();
            if (code)
              key = code;
          }
        }
        name += key;
        if (name.length > 1) {
          name = "<" + name + ">";
        }
        return name;
      }
      var handleKey = vimApi.handleKey.bind(vimApi);
      vimApi.handleKey = function(cm, key, origin) {
        return cm.operation(function() {
          return handleKey(cm, key, origin);
        }, true);
      };
      function cloneVimState(state) {
        var n = new state.constructor();
        Object.keys(state).forEach(function(key) {
          if (key == "insertEnd")
            return;
          var o = state[key];
          if (Array.isArray(o))
            o = o.slice();
          else if (o && typeof o == "object" && o.constructor != Object)
            o = cloneVimState(o);
          n[key] = o;
        });
        if (state.sel) {
          n.sel = {
            head: state.sel.head && copyCursor(state.sel.head),
            anchor: state.sel.anchor && copyCursor(state.sel.anchor)
          };
        }
        return n;
      }
      function multiSelectHandleKey(cm, key, origin) {
        var isHandled = false;
        var vim = vimApi.maybeInitVimState_(cm);
        var visualBlock = vim.visualBlock || vim.wasInVisualBlock;
        var wasMultiselect = cm.ace.inMultiSelectMode;
        if (vim.wasInVisualBlock && !wasMultiselect) {
          vim.wasInVisualBlock = false;
        } else if (wasMultiselect && vim.visualBlock) {
          vim.wasInVisualBlock = true;
        }
        if (key == "<Esc>" && !vim.insertMode && !vim.visualMode && wasMultiselect) {
          cm.ace.exitMultiSelectMode();
        } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {
          isHandled = vimApi.handleKey(cm, key, origin);
        } else {
          var old = cloneVimState(vim);
          var changeQueueList = vim.inputState.changeQueueList || [];
          cm.operation(function() {
            cm.curOp.isVimOp = true;
            var index = 0;
            cm.ace.forEachSelection(function() {
              var sel = cm.ace.selection;
              cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;
              cm.state.vim.inputState.changeQueue = changeQueueList[index];
              var head = cm.getCursor("head");
              var anchor = cm.getCursor("anchor");
              var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
              var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
              head = offsetCursor(head, 0, headOffset);
              anchor = offsetCursor(anchor, 0, anchorOffset);
              cm.state.vim.sel.head = head;
              cm.state.vim.sel.anchor = anchor;
              isHandled = handleKey(cm, key, origin);
              sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;
              if (cm.ace.inVirtualSelectionMode) {
                changeQueueList[index] = cm.state.vim.inputState.changeQueue;
              }
              if (cm.virtualSelectionMode()) {
                cm.state.vim = cloneVimState(old);
              }
              index++;
            });
            if (cm.curOp.cursorActivity && !isHandled)
              cm.curOp.cursorActivity = false;
            vim.status = cm.state.vim.status;
            cm.state.vim = vim;
            vim.inputState.changeQueueList = changeQueueList;
            vim.inputState.changeQueue = null;
          }, true);
        }
        if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {
          handleExternalSelection(cm, vim, true);
        }
        return isHandled;
      }
      resetVimGlobalState();
      exports2.CodeMirror = CodeMirror;
      var getVim = vimApi.maybeInitVimState_;
      exports2.handler = {
        $id: "ace/keyboard/vim",
        drawCursor: function(element, pixelPos, config, sel, session) {
          var vim = this.state.vim || {};
          var w2 = config.characterWidth;
          var h = config.lineHeight;
          var top = pixelPos.top;
          var left = pixelPos.left;
          if (!vim.insertMode) {
            var isbackwards = !sel.cursor ? session.selection.isBackwards() || session.selection.isEmpty() : Range.comparePoints(sel.cursor, sel.start) <= 0;
            if (!isbackwards && left > w2)
              left -= w2;
          }
          if (!vim.insertMode && vim.status) {
            h = h / 2;
            top += h;
          }
          domLib.translate(element, left, top);
          domLib.setStyle(element.style, "width", w2 + "px");
          domLib.setStyle(element.style, "height", h + "px");
        },
        $getDirectionForHighlight: function(editor) {
          var cm = editor.state.cm;
          var vim = getVim(cm);
          if (!vim.insertMode) {
            return editor.session.selection.isBackwards() || editor.session.selection.isEmpty();
          }
        },
        handleKeyboard: function(data, hashId, key, keyCode, e) {
          var editor = data.editor;
          var cm = editor.state.cm;
          var vim = getVim(cm);
          if (keyCode == -1)
            return;
          if (!vim.insertMode) {
            if (hashId == -1) {
              if (key.charCodeAt(0) > 255) {
                if (data.inputKey) {
                  key = data.inputKey;
                  if (key && data.inputHash == 4)
                    key = key.toUpperCase();
                }
              }
              data.inputChar = key;
            } else if (hashId == 4 || hashId == 0) {
              if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {
                key = data.inputChar;
                hashId = -1;
              } else {
                data.inputChar = null;
                data.inputKey = key;
                data.inputHash = hashId;
              }
            } else {
              data.inputChar = data.inputKey = null;
            }
          }
          if (cm.state.overwrite && vim.insertMode && key == "backspace" && hashId == 0) {
            return { command: "gotoleft" };
          }
          if (key == "c" && hashId == 1) {
            if (!useragent.isMac && editor.getCopyText()) {
              editor.once("copy", function() {
                if (vim.insertMode)
                  editor.selection.clearSelection();
                else
                  cm.operation(function() {
                    exitVisualMode(cm);
                  });
              });
              return { command: "null", passEvent: true };
            }
          }
          if (key == "esc" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {
            var searchState = getSearchState(cm);
            var overlay = searchState.getOverlay();
            if (overlay)
              cm.removeOverlay(overlay);
          }
          if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {
            var insertMode = vim.insertMode;
            var name = lookupKey(hashId, key, e || {}, vim);
            if (vim.status == null)
              vim.status = "";
            var isHandled = multiSelectHandleKey(cm, name, "user");
            vim = getVim(cm);
            if (isHandled && vim.status != null)
              vim.status += name;
            else if (vim.status == null)
              vim.status = "";
            cm._signal("changeStatus");
            if (!isHandled && (hashId != -1 || insertMode))
              return;
            return { command: "null", passEvent: !isHandled };
          }
        },
        attach: function(editor) {
          if (!editor.state)
            editor.state = {};
          var cm = new CodeMirror(editor);
          editor.state.cm = cm;
          editor.$vimModeHandler = this;
          enterVimMode(cm);
          getVim(cm).status = null;
          cm.on("vim-command-done", function() {
            if (cm.virtualSelectionMode())
              return;
            getVim(cm).status = null;
            cm.ace._signal("changeStatus");
            cm.ace.session.markUndoGroup();
          });
          cm.on("changeStatus", function() {
            cm.ace.renderer.updateCursor();
            cm.ace._signal("changeStatus");
          });
          cm.on("vim-mode-change", function() {
            if (cm.virtualSelectionMode())
              return;
            updateInputMode();
            cm._signal("changeStatus");
          });
          function updateInputMode() {
            var isIntsert = getVim(cm).insertMode;
            cm.ace.renderer.setStyle("normal-mode", !isIntsert);
            editor.textInput.setCommandMode(!isIntsert);
            editor.renderer.$keepTextAreaAtCursor = isIntsert;
            editor.renderer.$blockCursor = !isIntsert;
          }
          updateInputMode();
          editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);
        },
        detach: function(editor) {
          var cm = editor.state.cm;
          leaveVimMode(cm);
          cm.destroy();
          editor.state.cm = null;
          editor.$vimModeHandler = null;
          editor.renderer.$cursorLayer.drawCursor = null;
          editor.renderer.setStyle("normal-mode", false);
          editor.textInput.setCommandMode(false);
          editor.renderer.$keepTextAreaAtCursor = true;
        },
        getStatusText: function(editor) {
          var cm = editor.state.cm;
          var vim = getVim(cm);
          if (vim.insertMode)
            return "INSERT";
          var status = "";
          if (vim.visualMode) {
            status += "VISUAL";
            if (vim.visualLine)
              status += " LINE";
            if (vim.visualBlock)
              status += " BLOCK";
          }
          if (vim.status)
            status += (status ? " " : "") + vim.status;
          return status;
        }
      };
      vimApi.defineOption({
        name: "wrap",
        set: function(value, cm) {
          if (cm) {
            cm.ace.setOption("wrap", value);
          }
        },
        type: "boolean"
      }, false);
      vimApi.defineEx("write", "w", function() {
        console.log(":write is not implemented");
      });
      defaultKeymap.push({ keys: "zc", type: "action", action: "fold", actionArgs: { open: false } }, { keys: "zC", type: "action", action: "fold", actionArgs: { open: false, all: true } }, { keys: "zo", type: "action", action: "fold", actionArgs: { open: true } }, { keys: "zO", type: "action", action: "fold", actionArgs: { open: true, all: true } }, { keys: "za", type: "action", action: "fold", actionArgs: { toggle: true } }, { keys: "zA", type: "action", action: "fold", actionArgs: { toggle: true, all: true } }, { keys: "zf", type: "action", action: "fold", actionArgs: { open: true, all: true } }, { keys: "zd", type: "action", action: "fold", actionArgs: { open: true, all: true } }, { keys: "<C-A-k>", type: "action", action: "aceCommand", actionArgs: { name: "addCursorAbove" } }, { keys: "<C-A-j>", type: "action", action: "aceCommand", actionArgs: { name: "addCursorBelow" } }, { keys: "<C-A-S-k>", type: "action", action: "aceCommand", actionArgs: { name: "addCursorAboveSkipCurrent" } }, { keys: "<C-A-S-j>", type: "action", action: "aceCommand", actionArgs: { name: "addCursorBelowSkipCurrent" } }, { keys: "<C-A-h>", type: "action", action: "aceCommand", actionArgs: { name: "selectMoreBefore" } }, { keys: "<C-A-l>", type: "action", action: "aceCommand", actionArgs: { name: "selectMoreAfter" } }, { keys: "<C-A-S-h>", type: "action", action: "aceCommand", actionArgs: { name: "selectNextBefore" } }, { keys: "<C-A-S-l>", type: "action", action: "aceCommand", actionArgs: { name: "selectNextAfter" } });
      defaultKeymap.push({
        keys: "gq",
        type: "operator",
        operator: "hardWrap"
      });
      vimApi.defineOperator("hardWrap", function(cm, operatorArgs, ranges, oldAnchor, newHead) {
        var anchor = ranges[0].anchor.line;
        var head = ranges[0].head.line;
        if (operatorArgs.linewise)
          head--;
        hardWrap(cm.ace, { startRow: anchor, endRow: head });
        return Pos(head, 0);
      });
      defineOption("textwidth", void 0, "number", ["tw"], function(width, cm) {
        if (cm === void 0) {
          return;
        }
        if (width === void 0) {
          var value = cm.ace.getOption("printMarginColumn");
          return value;
        } else {
          var column = Math.round(width);
          if (column > 1) {
            cm.ace.setOption("printMarginColumn", column);
          }
        }
      });
      actions.aceCommand = function(cm, actionArgs, vim) {
        cm.vimCmd = actionArgs;
        if (cm.ace.inVirtualSelectionMode)
          cm.ace.on("beforeEndOperation", delayedExecAceCommand);
        else
          delayedExecAceCommand(null, cm.ace);
      };
      function delayedExecAceCommand(op, ace4) {
        ace4.off("beforeEndOperation", delayedExecAceCommand);
        var cmd = ace4.state.cm.vimCmd;
        if (cmd) {
          ace4.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);
        }
        ace4.curOp = ace4.prevOp;
      }
      actions.fold = function(cm, actionArgs, vim) {
        cm.ace.execCommand([
          "toggleFoldWidget",
          "toggleFoldWidget",
          "foldOther",
          "unfoldall"
        ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);
      };
      defaultKeymapLength = defaultKeymap.length;
      exports2.handler.defaultKeymap = defaultKeymap;
      exports2.handler.actions = actions;
      exports2.Vim = vimApi;
    });
    (function() {
      ace.require(["ace/keyboard/vim"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/keybinding-vscode.js
var require_keybinding_vscode = __commonJS({
  "node_modules/ace-builds/src-noconflict/keybinding-vscode.js"(exports, module2) {
    ace.define("ace/keyboard/vscode", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/config"], function(require3, exports2, module3) {
      "use strict";
      var HashHandler = require3("../keyboard/hash_handler").HashHandler;
      var config = require3("../config");
      exports2.handler = new HashHandler();
      exports2.handler.$id = "ace/keyboard/vscode";
      exports2.handler.addCommands([{
        name: "toggleWordWrap",
        exec: function(editor) {
          var wrapUsed = editor.session.getUseWrapMode();
          editor.session.setUseWrapMode(!wrapUsed);
        },
        readOnly: true
      }, {
        name: "navigateToLastEditLocation",
        exec: function(editor) {
          var lastDelta = editor.session.getUndoManager().$lastDelta;
          var range = lastDelta.action == "remove" ? lastDelta.start : lastDelta.end;
          editor.moveCursorTo(range.row, range.column);
          editor.clearSelection();
        }
      }, {
        name: "replaceAll",
        exec: function(editor) {
          if (!editor.searchBox) {
            config.loadModule("ace/ext/searchbox", function(e) {
              e.Search(editor, true);
            });
          } else {
            if (editor.searchBox.active === true && editor.searchBox.replaceOption.checked === true) {
              editor.searchBox.replaceAll();
            }
          }
        }
      }, {
        name: "replaceOne",
        exec: function(editor) {
          if (!editor.searchBox) {
            config.loadModule("ace/ext/searchbox", function(e) {
              e.Search(editor, true);
            });
          } else {
            if (editor.searchBox.active === true && editor.searchBox.replaceOption.checked === true) {
              editor.searchBox.replace();
            }
          }
        }
      }, {
        name: "selectAllMatches",
        exec: function(editor) {
          if (!editor.searchBox) {
            config.loadModule("ace/ext/searchbox", function(e) {
              e.Search(editor, false);
            });
          } else {
            if (editor.searchBox.active === true) {
              editor.searchBox.findAll();
            }
          }
        }
      }, {
        name: "toggleFindCaseSensitive",
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor, false);
            var sb = editor.searchBox;
            sb.caseSensitiveOption.checked = !sb.caseSensitiveOption.checked;
            sb.$syncOptions();
          });
        }
      }, {
        name: "toggleFindInSelection",
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor, false);
            var sb = editor.searchBox;
            sb.searchOption.checked = !sb.searchRange;
            sb.setSearchRange(sb.searchOption.checked && sb.editor.getSelectionRange());
            sb.$syncOptions();
          });
        }
      }, {
        name: "toggleFindRegex",
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor, false);
            var sb = editor.searchBox;
            sb.regExpOption.checked = !sb.regExpOption.checked;
            sb.$syncOptions();
          });
        }
      }, {
        name: "toggleFindWholeWord",
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor, false);
            var sb = editor.searchBox;
            sb.wholeWordOption.checked = !sb.wholeWordOption.checked;
            sb.$syncOptions();
          });
        }
      }, {
        name: "removeSecondaryCursors",
        exec: function(editor) {
          var ranges = editor.selection.ranges;
          if (ranges && ranges.length > 1)
            editor.selection.toSingleRange(ranges[ranges.length - 1]);
          else
            editor.selection.clearSelection();
        }
      }]);
      [
        {
          bindKey: { mac: "Ctrl-G", win: "Ctrl-G" },
          name: "gotoline"
        },
        {
          bindKey: { mac: "Command-Shift-L|Command-F2", win: "Ctrl-Shift-L|Ctrl-F2" },
          name: "findAll"
        },
        {
          bindKey: { mac: "Shift-F8|Shift-Option-F8", win: "Shift-F8|Shift-Alt-F8" },
          name: "goToPreviousError"
        },
        {
          bindKey: { mac: "F8|Option-F8", win: "F8|Alt-F8" },
          name: "goToNextError"
        },
        {
          bindKey: { mac: "Command-Shift-P|F1", win: "Ctrl-Shift-P|F1" },
          name: "openCommandPalette"
        },
        {
          bindKey: { mac: "Shift-Option-Up", win: "Alt-Shift-Up" },
          name: "copylinesup"
        },
        {
          bindKey: { mac: "Shift-Option-Down", win: "Alt-Shift-Down" },
          name: "copylinesdown"
        },
        {
          bindKey: { mac: "Command-Shift-K", win: "Ctrl-Shift-K" },
          name: "removeline"
        },
        {
          bindKey: { mac: "Command-Enter", win: "Ctrl-Enter" },
          name: "addLineAfter"
        },
        {
          bindKey: { mac: "Command-Shift-Enter", win: "Ctrl-Shift-Enter" },
          name: "addLineBefore"
        },
        {
          bindKey: { mac: "Command-Shift-\\", win: "Ctrl-Shift-\\" },
          name: "jumptomatching"
        },
        {
          bindKey: { mac: "Command-]", win: "Ctrl-]" },
          name: "blockindent"
        },
        {
          bindKey: { mac: "Command-[", win: "Ctrl-[" },
          name: "blockoutdent"
        },
        {
          bindKey: { mac: "Ctrl-PageDown", win: "Alt-PageDown" },
          name: "pagedown"
        },
        {
          bindKey: { mac: "Ctrl-PageUp", win: "Alt-PageUp" },
          name: "pageup"
        },
        {
          bindKey: { mac: "Shift-Option-A", win: "Shift-Alt-A" },
          name: "toggleBlockComment"
        },
        {
          bindKey: { mac: "Option-Z", win: "Alt-Z" },
          name: "toggleWordWrap"
        },
        {
          bindKey: { mac: "Command-G", win: "F3|Ctrl-K Ctrl-D" },
          name: "findnext"
        },
        {
          bindKey: { mac: "Command-Shift-G", win: "Shift-F3" },
          name: "findprevious"
        },
        {
          bindKey: { mac: "Option-Enter", win: "Alt-Enter" },
          name: "selectAllMatches"
        },
        {
          bindKey: { mac: "Command-D", win: "Ctrl-D" },
          name: "selectMoreAfter"
        },
        {
          bindKey: { mac: "Command-K Command-D", win: "Ctrl-K Ctrl-D" },
          name: "selectOrFindNext"
        },
        {
          bindKey: { mac: "Shift-Option-I", win: "Shift-Alt-I" },
          name: "splitSelectionIntoLines"
        },
        {
          bindKey: { mac: "Command-K M", win: "Ctrl-K M" },
          name: "modeSelect"
        },
        {
          bindKey: { mac: "Command-Option-[", win: "Ctrl-Shift-[" },
          name: "toggleFoldWidget"
        },
        {
          bindKey: { mac: "Command-Option-]", win: "Ctrl-Shift-]" },
          name: "toggleFoldWidget"
        },
        {
          bindKey: { mac: "Command-K Command-0", win: "Ctrl-K Ctrl-0" },
          name: "foldall"
        },
        {
          bindKey: { mac: "Command-K Command-J", win: "Ctrl-K Ctrl-J" },
          name: "unfoldall"
        },
        {
          bindKey: { mac: "Command-K Command-1", win: "Ctrl-K Ctrl-1" },
          name: "foldOther"
        },
        {
          bindKey: { mac: "Command-K Command-Q", win: "Ctrl-K Ctrl-Q" },
          name: "navigateToLastEditLocation"
        },
        {
          bindKey: { mac: "Command-K Command-R|Command-K Command-S", win: "Ctrl-K Ctrl-R|Ctrl-K Ctrl-S" },
          name: "showKeyboardShortcuts"
        },
        {
          bindKey: { mac: "Command-K Command-X", win: "Ctrl-K Ctrl-X" },
          name: "trimTrailingSpace"
        },
        {
          bindKey: { mac: "Shift-Down|Command-Shift-Down", win: "Shift-Down|Ctrl-Shift-Down" },
          name: "selectdown"
        },
        {
          bindKey: { mac: "Shift-Up|Command-Shift-Up", win: "Shift-Up|Ctrl-Shift-Up" },
          name: "selectup"
        },
        {
          bindKey: { mac: "Command-Alt-Enter", win: "Ctrl-Alt-Enter" },
          name: "replaceAll"
        },
        {
          bindKey: { mac: "Command-Shift-1", win: "Ctrl-Shift-1" },
          name: "replaceOne"
        },
        {
          bindKey: { mac: "Option-C", win: "Alt-C" },
          name: "toggleFindCaseSensitive"
        },
        {
          bindKey: { mac: "Option-L", win: "Alt-L" },
          name: "toggleFindInSelection"
        },
        {
          bindKey: { mac: "Option-R", win: "Alt-R" },
          name: "toggleFindRegex"
        },
        {
          bindKey: { mac: "Option-W", win: "Alt-W" },
          name: "toggleFindWholeWord"
        },
        {
          bindKey: { mac: "Command-L", win: "Ctrl-L" },
          name: "expandtoline"
        },
        {
          bindKey: { mac: "Shift-Esc", win: "Shift-Esc" },
          name: "removeSecondaryCursors"
        }
      ].forEach(function(binding) {
        var command = exports2.handler.commands[binding.name];
        if (command)
          command.bindKey = binding.bindKey;
        exports2.handler.bindKey(binding.bindKey, command || binding.name);
      });
    });
    (function() {
      ace.require(["ace/keyboard/vscode"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// src/lib/ace-colorpicker.js
var require_ace_colorpicker = __commonJS({
  "src/lib/ace-colorpicker.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2["ace-colorpicker"] = factory();
    })(exports, function() {
      "use strict";
      function format(obj, type) {
        var defaultColor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "rgba(0, 0, 0, 0)";
        if (Array.isArray(obj)) {
          obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }
        if (type == "hex") {
          return hex(obj);
        } else if (type == "rgb") {
          return rgb(obj, defaultColor);
        } else if (type == "hsl") {
          return hsl(obj);
        }
        return obj;
      }
      function hex(obj) {
        if (Array.isArray(obj)) {
          obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }
        var r = obj.r.toString(16);
        if (obj.r < 16) r = "0" + r;
        var g3 = obj.g.toString(16);
        if (obj.g < 16) g3 = "0" + g3;
        var b2 = obj.b.toString(16);
        if (obj.b < 16) b2 = "0" + b2;
        var alphaValue = "";
        if (obj.a < 1) {
          var alpha = Math.floor(obj.a * 255);
          var alphaValue = alpha.toString(16);
          if (alpha < 16) alphaValue = "0" + alphaValue;
        }
        return "#" + r + g3 + b2 + alphaValue;
      }
      function rgb(obj) {
        var defaultColor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "rgba(0, 0, 0, 0)";
        if (Array.isArray(obj)) {
          obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }
        if (typeof obj == "undefined") {
          return void 0;
        }
        if (obj.a == 1 || typeof obj.a == "undefined") {
          if (isNaN(obj.r)) {
            return defaultColor;
          }
          return "rgb(" + obj.r + "," + obj.g + "," + obj.b + ")";
        } else {
          return "rgba(" + obj.r + "," + obj.g + "," + obj.b + "," + obj.a + ")";
        }
      }
      function hsl(obj) {
        if (Array.isArray(obj)) {
          obj = { r: obj[0], g: obj[1], b: obj[2], a: obj[3] };
        }
        if (obj.a == 1 || typeof obj.a == "undefined") {
          return "hsl(" + obj.h + "," + obj.s + "%," + obj.l + "%)";
        } else {
          return "hsla(" + obj.h + "," + obj.s + "%," + obj.l + "%," + obj.a + ")";
        }
      }
      var formatter = {
        format,
        rgb,
        hsl,
        hex
      };
      function round(n, k2) {
        k2 = typeof k2 == "undefined" ? 1 : k2;
        return Math.round(n * k2) / k2;
      }
      function degreeToRadian(angle) {
        return angle * Math.PI / 180;
      }
      function radianToDegree(radian2) {
        var angle = radian2 * 180 / Math.PI;
        if (angle < 0) {
          angle = 360 + angle;
        }
        return angle;
      }
      function getXInCircle(angle, radius) {
        var centerX = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        return centerX + radius * Math.cos(degreeToRadian(angle));
      }
      function getYInCircle(angle, radius) {
        var centerY = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        return centerY + radius * Math.sin(degreeToRadian(angle));
      }
      function getXYInCircle(angle, radius) {
        var centerX = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var centerY = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        return {
          x: getXInCircle(angle, radius, centerX),
          y: getYInCircle(angle, radius, centerY)
        };
      }
      function caculateAngle(rx, ry) {
        return radianToDegree(Math.atan2(ry, rx));
      }
      var math = {
        round,
        radianToDegree,
        degreeToRadian,
        getXInCircle,
        getYInCircle,
        caculateAngle
      };
      var color_names = { aliceblue: "rgb(240, 248, 255)", antiquewhite: "rgb(250, 235, 215)", aqua: "rgb(0, 255, 255)", aquamarine: "rgb(127, 255, 212)", azure: "rgb(240, 255, 255)", beige: "rgb(245, 245, 220)", bisque: "rgb(255, 228, 196)", black: "rgb(0, 0, 0)", blanchedalmond: "rgb(255, 235, 205)", blue: "rgb(0, 0, 255)", blueviolet: "rgb(138, 43, 226)", brown: "rgb(165, 42, 42)", burlywood: "rgb(222, 184, 135)", cadetblue: "rgb(95, 158, 160)", chartreuse: "rgb(127, 255, 0)", chocolate: "rgb(210, 105, 30)", coral: "rgb(255, 127, 80)", cornflowerblue: "rgb(100, 149, 237)", cornsilk: "rgb(255, 248, 220)", crimson: "rgb(237, 20, 61)", cyan: "rgb(0, 255, 255)", darkblue: "rgb(0, 0, 139)", darkcyan: "rgb(0, 139, 139)", darkgoldenrod: "rgb(184, 134, 11)", darkgray: "rgb(169, 169, 169)", darkgrey: "rgb(169, 169, 169)", darkgreen: "rgb(0, 100, 0)", darkkhaki: "rgb(189, 183, 107)", darkmagenta: "rgb(139, 0, 139)", darkolivegreen: "rgb(85, 107, 47)", darkorange: "rgb(255, 140, 0)", darkorchid: "rgb(153, 50, 204)", darkred: "rgb(139, 0, 0)", darksalmon: "rgb(233, 150, 122)", darkseagreen: "rgb(143, 188, 143)", darkslateblue: "rgb(72, 61, 139)", darkslategray: "rgb(47, 79, 79)", darkslategrey: "rgb(47, 79, 79)", darkturquoise: "rgb(0, 206, 209)", darkviolet: "rgb(148, 0, 211)", deeppink: "rgb(255, 20, 147)", deepskyblue: "rgb(0, 191, 255)", dimgray: "rgb(105, 105, 105)", dimgrey: "rgb(105, 105, 105)", dodgerblue: "rgb(30, 144, 255)", firebrick: "rgb(178, 34, 34)", floralwhite: "rgb(255, 250, 240)", forestgreen: "rgb(34, 139, 34)", fuchsia: "rgb(255, 0, 255)", gainsboro: "rgb(220, 220, 220)", ghostwhite: "rgb(248, 248, 255)", gold: "rgb(255, 215, 0)", goldenrod: "rgb(218, 165, 32)", gray: "rgb(128, 128, 128)", grey: "rgb(128, 128, 128)", green: "rgb(0, 128, 0)", greenyellow: "rgb(173, 255, 47)", honeydew: "rgb(240, 255, 240)", hotpink: "rgb(255, 105, 180)", indianred: "rgb(205, 92, 92)", indigo: "rgb(75, 0, 130)", ivory: "rgb(255, 255, 240)", khaki: "rgb(240, 230, 140)", lavender: "rgb(230, 230, 250)", lavenderblush: "rgb(255, 240, 245)", lawngreen: "rgb(124, 252, 0)", lemonchiffon: "rgb(255, 250, 205)", lightblue: "rgb(173, 216, 230)", lightcoral: "rgb(240, 128, 128)", lightcyan: "rgb(224, 255, 255)", lightgoldenrodyellow: "rgb(250, 250, 210)", lightgreen: "rgb(144, 238, 144)", lightgray: "rgb(211, 211, 211)", lightgrey: "rgb(211, 211, 211)", lightpink: "rgb(255, 182, 193)", lightsalmon: "rgb(255, 160, 122)", lightseagreen: "rgb(32, 178, 170)", lightskyblue: "rgb(135, 206, 250)", lightslategray: "rgb(119, 136, 153)", lightslategrey: "rgb(119, 136, 153)", lightsteelblue: "rgb(176, 196, 222)", lightyellow: "rgb(255, 255, 224)", lime: "rgb(0, 255, 0)", limegreen: "rgb(50, 205, 50)", linen: "rgb(250, 240, 230)", magenta: "rgb(255, 0, 255)", maroon: "rgb(128, 0, 0)", mediumaquamarine: "rgb(102, 205, 170)", mediumblue: "rgb(0, 0, 205)", mediumorchid: "rgb(186, 85, 211)", mediumpurple: "rgb(147, 112, 219)", mediumseagreen: "rgb(60, 179, 113)", mediumslateblue: "rgb(123, 104, 238)", mediumspringgreen: "rgb(0, 250, 154)", mediumturquoise: "rgb(72, 209, 204)", mediumvioletred: "rgb(199, 21, 133)", midnightblue: "rgb(25, 25, 112)", mintcream: "rgb(245, 255, 250)", mistyrose: "rgb(255, 228, 225)", moccasin: "rgb(255, 228, 181)", navajowhite: "rgb(255, 222, 173)", navy: "rgb(0, 0, 128)", oldlace: "rgb(253, 245, 230)", olive: "rgb(128, 128, 0)", olivedrab: "rgb(107, 142, 35)", orange: "rgb(255, 165, 0)", orangered: "rgb(255, 69, 0)", orchid: "rgb(218, 112, 214)", palegoldenrod: "rgb(238, 232, 170)", palegreen: "rgb(152, 251, 152)", paleturquoise: "rgb(175, 238, 238)", palevioletred: "rgb(219, 112, 147)", papayawhip: "rgb(255, 239, 213)", peachpuff: "rgb(255, 218, 185)", peru: "rgb(205, 133, 63)", pink: "rgb(255, 192, 203)", plum: "rgb(221, 160, 221)", powderblue: "rgb(176, 224, 230)", purple: "rgb(128, 0, 128)", rebeccapurple: "rgb(102, 51, 153)", red: "rgb(255, 0, 0)", rosybrown: "rgb(188, 143, 143)", royalblue: "rgb(65, 105, 225)", saddlebrown: "rgb(139, 69, 19)", salmon: "rgb(250, 128, 114)", sandybrown: "rgb(244, 164, 96)", seagreen: "rgb(46, 139, 87)", seashell: "rgb(255, 245, 238)", sienna: "rgb(160, 82, 45)", silver: "rgb(192, 192, 192)", skyblue: "rgb(135, 206, 235)", slateblue: "rgb(106, 90, 205)", slategray: "rgb(112, 128, 144)", slategrey: "rgb(112, 128, 144)", snow: "rgb(255, 250, 250)", springgreen: "rgb(0, 255, 127)", steelblue: "rgb(70, 130, 180)", tan: "rgb(210, 180, 140)", teal: "rgb(0, 128, 128)", thistle: "rgb(216, 191, 216)", tomato: "rgb(255, 99, 71)", turquoise: "rgb(64, 224, 208)", violet: "rgb(238, 130, 238)", wheat: "rgb(245, 222, 179)", white: "rgb(255, 255, 255)", whitesmoke: "rgb(245, 245, 245)", yellow: "rgb(255, 255, 0)", yellowgreen: "rgb(154, 205, 50)", transparent: "rgba(0, 0, 0, 0)" };
      function isColorName(name) {
        return !!color_names[name];
      }
      function getColorByName(name) {
        return color_names[name];
      }
      var ColorNames = {
        isColorName,
        getColorByName
      };
      function HUEtoRGB(p, q3, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q3 - p) * 6 * t;
        if (t < 1 / 2) return q3;
        if (t < 2 / 3) return p + (q3 - p) * (2 / 3 - t) * 6;
        return p;
      }
      function HSLtoHSV(h, s, l) {
        if (arguments.length == 1) {
          var _arguments$ = arguments[0], h = _arguments$.h, s = _arguments$.s, l = _arguments$.l;
        }
        var rgb2 = HSLtoRGB(h, s, l);
        return RGBtoHSV(rgb2.r, rgb2.g, rgb2.b);
      }
      function HSLtoRGB(h, s, l) {
        if (arguments.length == 1) {
          var _arguments$2 = arguments[0], h = _arguments$2.h, s = _arguments$2.s, l = _arguments$2.l;
        }
        var r, g3, b2;
        h /= 360;
        s /= 100;
        l /= 100;
        if (s == 0) {
          r = g3 = b2 = l;
        } else {
          var q3 = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q3;
          r = HUEtoRGB(p, q3, h + 1 / 3);
          g3 = HUEtoRGB(p, q3, h);
          b2 = HUEtoRGB(p, q3, h - 1 / 3);
        }
        return { r: round(r * 255), g: round(g3 * 255), b: round(b2 * 255) };
      }
      var fromHSL = {
        HUEtoRGB,
        HSLtoHSV,
        HSLtoRGB
      };
      var classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      var createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var defineProperty = function(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      };
      var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source2 = arguments[i];
          for (var key in source2) {
            if (Object.prototype.hasOwnProperty.call(source2, key)) {
              target[key] = source2[key];
            }
          }
        }
        return target;
      };
      var get = function get2(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === void 0) {
          var parent = Object.getPrototypeOf(object);
          if (parent === null) {
            return void 0;
          } else {
            return get2(parent, property, receiver);
          }
        } else if ("value" in desc) {
          return desc.value;
        } else {
          var getter = desc.get;
          if (getter === void 0) {
            return void 0;
          }
          return getter.call(receiver);
        }
      };
      var inherits = function(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      };
      var possibleConstructorReturn = function(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      };
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n3 = true;
          var _d = false;
          var _e3 = void 0;
          try {
            for (var _i2 = arr[Symbol.iterator](), _s2; !(_n3 = (_s2 = _i2.next()).done); _n3 = true) {
              _arr.push(_s2.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e3 = err;
          } finally {
            try {
              if (!_n3 && _i2["return"]) _i2["return"]();
            } finally {
              if (_d) throw _e3;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toArray = function(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
      };
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var color_regexp = /(#(?:[\da-f]{8})|#(?:[\da-f]{3}){1,2}|rgb\((?:\s*\d{1,3},\s*){2}\d{1,3}\s*\)|rgba\((?:\s*\d{1,3},\s*){3}\d*\.?\d+\s*\)|hsl\(\s*\d{1,3}(?:,\s*\d{1,3}%){2}\s*\)|hsla\(\s*\d{1,3}(?:,\s*\d{1,3}%){2},\s*\d*\.?\d+\s*\)|([\w_\-]+))/gi;
      var color_split = ",";
      function matches(str) {
        var matches2 = str.match(color_regexp);
        var result = [];
        if (!matches2) {
          return result;
        }
        for (var i = 0, len = matches2.length; i < len; i++) {
          if (matches2[i].indexOf("#") > -1 || matches2[i].indexOf("rgb") > -1 || matches2[i].indexOf("hsl") > -1) {
            result.push({ color: matches2[i] });
          } else {
            var nameColor = ColorNames.getColorByName(matches2[i]);
            if (nameColor) {
              result.push({ color: matches2[i], nameColor });
            }
          }
        }
        var pos = { next: 0 };
        result.forEach(function(item) {
          var startIndex = str.indexOf(item.color, pos.next);
          item.startIndex = startIndex;
          item.endIndex = startIndex + item.color.length;
          pos.next = item.endIndex;
        });
        return result;
      }
      function convertMatches(str) {
        var m = matches(str);
        m.forEach(function(it3, index2) {
          str = str.replace(it3.color, "@" + index2);
        });
        return { str, matches: m };
      }
      function convertMatchesArray(str) {
        var splitStr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
        var ret = convertMatches(str);
        return ret.str.split(splitStr).map(function(it3, index2) {
          it3 = trim(it3);
          if (ret.matches[index2]) {
            it3 = it3.replace("@" + index2, ret.matches[index2].color);
          }
          return it3;
        });
      }
      function reverseMatches(str, matches2) {
        matches2.forEach(function(it3, index2) {
          str = str.replace("@" + index2, it3.color);
        });
        return str;
      }
      function trim(str) {
        return str.replace(/^\s+|\s+$/g, "");
      }
      function parse(str) {
        if (typeof str == "string") {
          if (ColorNames.isColorName(str)) {
            str = ColorNames.getColorByName(str);
          }
          if (str.indexOf("rgb(") > -1) {
            var arr = str.replace("rgb(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              arr[i] = parseInt(trim(arr[i]), 10);
            }
            var obj = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: 1 };
            obj = Object.assign(obj, RGBtoHSL(obj));
            return obj;
          } else if (str.indexOf("rgba(") > -1) {
            var arr = str.replace("rgba(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              if (len - 1 == i) {
                arr[i] = parseFloat(trim(arr[i]));
              } else {
                arr[i] = parseInt(trim(arr[i]), 10);
              }
            }
            var obj = { type: "rgb", r: arr[0], g: arr[1], b: arr[2], a: arr[3] };
            obj = Object.assign(obj, RGBtoHSL(obj));
            return obj;
          } else if (str.indexOf("hsl(") > -1) {
            var arr = str.replace("hsl(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              arr[i] = parseFloat(trim(arr[i]));
            }
            var obj = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: 1 };
            obj = Object.assign(obj, HSLtoRGB(obj));
            return obj;
          } else if (str.indexOf("hsla(") > -1) {
            var arr = str.replace("hsla(", "").replace(")", "").split(",");
            for (var i = 0, len = arr.length; i < len; i++) {
              if (len - 1 == i) {
                arr[i] = parseFloat(trim(arr[i]));
              } else {
                arr[i] = parseInt(trim(arr[i]), 10);
              }
            }
            var obj = { type: "hsl", h: arr[0], s: arr[1], l: arr[2], a: arr[3] };
            obj = Object.assign(obj, HSLtoRGB(obj));
            return obj;
          } else if (str.indexOf("#") == 0) {
            str = str.replace("#", "");
            var arr = [];
            var a = 1;
            if (str.length == 3) {
              for (var i = 0, len = str.length; i < len; i++) {
                var char = str.substr(i, 1);
                arr.push(parseInt(char + char, 16));
              }
            } else if (str.length === 8) {
              for (var i = 0, len = str.length; i < len; i += 2) {
                arr.push(parseInt(str.substr(i, 2), 16));
              }
              a = arr.pop() / 255;
            } else {
              for (var i = 0, len = str.length; i < len; i += 2) {
                arr.push(parseInt(str.substr(i, 2), 16));
              }
            }
            var obj = { type: "hex", r: arr[0], g: arr[1], b: arr[2], a };
            obj = Object.assign(obj, RGBtoHSL(obj));
            return obj;
          }
        } else if (typeof str == "number") {
          if (0 <= str && str <= 16777215) {
            var r = (str & 16711680) >> 16;
            var g3 = (str & 65280) >> 8;
            var b2 = (str & 255) >> 0;
            var obj = { type: "hex", r, g: g3, b: b2, a: 1 };
            obj = Object.assign(obj, RGBtoHSL(obj));
            return obj;
          } else if (0 <= str && str <= 4294967295) {
            var _r2 = (str & 4278190080) >> 24;
            var _g = (str & 16711680) >> 16;
            var _b = (str & 65280) >> 8;
            var _a2 = (str & 255) / 255;
            var obj = { type: "hex", r: _r2, g: _g, b: _b, a: _a2 };
            obj = Object.assign(obj, RGBtoHSL(obj));
            return obj;
          }
        }
        return str;
      }
      function parseGradient(colors) {
        if (typeof colors == "string") {
          colors = convertMatchesArray(colors);
        }
        colors = colors.map(function(it3) {
          if (typeof it3 == "string") {
            var ret = convertMatches(it3);
            var arr = trim(ret.str).split(" ");
            if (arr[1]) {
              if (arr[1].includes("%")) {
                arr[1] = parseFloat(arr[1].replace(/%/, "")) / 100;
              } else {
                arr[1] = parseFloat(arr[1]);
              }
            } else {
              arr[1] = "*";
            }
            arr[0] = reverseMatches(arr[0], ret.matches);
            return arr;
          } else if (Array.isArray(it3)) {
            if (!it3[1]) {
              it3[1] = "*";
            } else if (typeof it3[1] == "string") {
              if (it3[1].includes("%")) {
                it3[1] = parseFloat(it3[1].replace(/%/, "")) / 100;
              } else {
                it3[1] = +it3[1];
              }
            }
            return [].concat(toConsumableArray(it3));
          }
        });
        var count = colors.filter(function(it3) {
          return it3[1] === "*";
        }).length;
        if (count > 0) {
          var sum = colors.filter(function(it3) {
            return it3[1] != "*" && it3[1] != 1;
          }).map(function(it3) {
            return it3[1];
          }).reduce(function(total, cur) {
            return total + cur;
          }, 0);
          var dist = (1 - sum) / count;
          colors.forEach(function(it3, index2) {
            if (it3[1] == "*" && index2 > 0) {
              if (colors.length - 1 == index2) {
              } else {
                it3[1] = dist;
              }
            }
          });
        }
        return colors;
      }
      var parser = {
        matches,
        convertMatches,
        convertMatchesArray,
        reverseMatches,
        parse,
        parseGradient,
        trim,
        color_regexp,
        color_split
      };
      function RGBtoHSV(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$ = arguments[0], r = _arguments$.r, g3 = _arguments$.g, b2 = _arguments$.b;
        }
        var R1 = r / 255;
        var G1 = g3 / 255;
        var B1 = b2 / 255;
        var MaxC = Math.max(R1, G1, B1);
        var MinC = Math.min(R1, G1, B1);
        var DeltaC = MaxC - MinC;
        var H3 = 0;
        if (DeltaC == 0) {
          H3 = 0;
        } else if (MaxC == R1) {
          H3 = 60 * ((G1 - B1) / DeltaC % 6);
        } else if (MaxC == G1) {
          H3 = 60 * ((B1 - R1) / DeltaC + 2);
        } else if (MaxC == B1) {
          H3 = 60 * ((R1 - G1) / DeltaC + 4);
        }
        if (H3 < 0) {
          H3 = 360 + H3;
        }
        var S3 = 0;
        if (MaxC == 0) S3 = 0;
        else S3 = DeltaC / MaxC;
        var V2 = MaxC;
        return { h: H3, s: S3, v: V2 };
      }
      function RGBtoCMYK(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$2 = arguments[0], r = _arguments$2.r, g3 = _arguments$2.g, b2 = _arguments$2.b;
        }
        var R1 = r / 255;
        var G1 = g3 / 255;
        var B1 = b2 / 255;
        var K2 = 1 - Math.max(R1, G1, B1);
        var C = (1 - R1 - K2) / (1 - K2);
        var M3 = (1 - G1 - K2) / (1 - K2);
        var Y3 = (1 - B1 - K2) / (1 - K2);
        return { c: C, m: M3, y: Y3, k: K2 };
      }
      function RGBtoHSL(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$3 = arguments[0], r = _arguments$3.r, g3 = _arguments$3.g, b2 = _arguments$3.b;
        }
        r /= 255, g3 /= 255, b2 /= 255;
        var max2 = Math.max(r, g3, b2), min2 = Math.min(r, g3, b2);
        var h, s, l = (max2 + min2) / 2;
        if (max2 == min2) {
          h = s = 0;
        } else {
          var d = max2 - min2;
          s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
          switch (max2) {
            case r:
              h = (g3 - b2) / d + (g3 < b2 ? 6 : 0);
              break;
            case g3:
              h = (b2 - r) / d + 2;
              break;
            case b2:
              h = (r - g3) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h: round(h * 360), s: round(s * 100), l: round(l * 100) };
      }
      function c(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$4 = arguments[0], r = _arguments$4.r, g3 = _arguments$4.g, b2 = _arguments$4.b;
        }
        return gray((r + g3 + b2) / 3 > 90 ? 0 : 255);
      }
      function gray(gray2) {
        return { r: gray2, g: gray2, b: gray2 };
      }
      function RGBtoSimpleGray(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$5 = arguments[0], r = _arguments$5.r, g3 = _arguments$5.g, b2 = _arguments$5.b;
        }
        return gray(Math.ceil((r + g3 + b2) / 3));
      }
      function RGBtoGray(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$6 = arguments[0], r = _arguments$6.r, g3 = _arguments$6.g, b2 = _arguments$6.b;
        }
        return gray(RGBtoYCrCb(r, g3, b2).y);
      }
      function brightness(r, g3, b2) {
        return Math.ceil(r * 0.2126 + g3 * 0.7152 + b2 * 0.0722);
      }
      function RGBtoYCrCb(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$7 = arguments[0], r = _arguments$7.r, g3 = _arguments$7.g, b2 = _arguments$7.b;
        }
        var Y3 = brightness(r, g3, b2);
        var Cb = 0.564 * (b2 - Y3);
        var Cr2 = 0.713 * (r - Y3);
        return { y: Y3, cr: Cr2, cb: Cb };
      }
      function PivotRGB(n) {
        var point = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.04045;
        return (n > point ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) * 100;
      }
      function RGBtoXYZ(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$8 = arguments[0], r = _arguments$8.r, g3 = _arguments$8.g, b2 = _arguments$8.b;
        }
        var R2 = r / 255;
        var G3 = g3 / 255;
        var B2 = b2 / 255;
        R2 = PivotRGB(R2);
        G3 = PivotRGB(G3);
        B2 = PivotRGB(B2);
        var x = R2 * 0.4124 + G3 * 0.3576 + B2 * 0.1805;
        var y2 = R2 * 0.2126 + G3 * 0.7152 + B2 * 0.0722;
        var z3 = R2 * 0.0193 + G3 * 0.1192 + B2 * 0.9505;
        return { x, y: y2, z: z3 };
      }
      function RGBtoLAB(r, g3, b2) {
        if (arguments.length == 1) {
          var _arguments$9 = arguments[0], r = _arguments$9.r, g3 = _arguments$9.g, b2 = _arguments$9.b;
        }
        return XYZtoLAB(RGBtoXYZ(r, g3, b2));
      }
      var fromRGB = {
        RGBtoCMYK,
        RGBtoGray,
        RGBtoHSL,
        RGBtoHSV,
        RGBtoLAB,
        RGBtoSimpleGray,
        RGBtoXYZ,
        RGBtoYCrCb,
        c,
        brightness,
        gray
      };
      function CMYKtoRGB(c2, m, y2, k2) {
        if (arguments.length == 1) {
          var _arguments$ = arguments[0], c2 = _arguments$.c, m = _arguments$.m, y2 = _arguments$.y, k2 = _arguments$.k;
        }
        var R2 = 255 * (1 - c2) * (1 - k2);
        var G3 = 255 * (1 - m) * (1 - k2);
        var B2 = 255 * (1 - y2) * (1 - k2);
        return { r: R2, g: G3, b: B2 };
      }
      var fromCMYK = {
        CMYKtoRGB
      };
      function ReverseXyz(n) {
        return Math.pow(n, 3) > 8856e-6 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
      }
      function ReverseRGB(n) {
        return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
      }
      function XYZtoRGB(x, y2, z3) {
        if (arguments.length == 1) {
          var _arguments$ = arguments[0], x = _arguments$.x, y2 = _arguments$.y, z3 = _arguments$.z;
        }
        var X3 = x / 100;
        var Y3 = y2 / 100;
        var Z3 = z3 / 100;
        var R2 = X3 * 3.2406 + Y3 * -1.5372 + Z3 * -0.4986;
        var G3 = X3 * -0.9689 + Y3 * 1.8758 + Z3 * 0.0415;
        var B2 = X3 * 0.0557 + Y3 * -0.204 + Z3 * 1.057;
        R2 = ReverseRGB(R2);
        G3 = ReverseRGB(G3);
        B2 = ReverseRGB(B2);
        var r = round(R2 * 255);
        var g3 = round(G3 * 255);
        var b2 = round(B2 * 255);
        return { r, g: g3, b: b2 };
      }
      function LABtoXYZ(l, a, b2) {
        if (arguments.length == 1) {
          var _arguments$2 = arguments[0], l = _arguments$2.l, a = _arguments$2.a, b2 = _arguments$2.b;
        }
        var Y3 = (l + 16) / 116;
        var X3 = a / 500 + Y3;
        var Z3 = Y3 - b2 / 200;
        Y3 = ReverseXyz(Y3);
        X3 = ReverseXyz(X3);
        Z3 = ReverseXyz(Z3);
        var x = X3 * 95.047;
        var y2 = Y3 * 100;
        var z3 = Z3 * 108.883;
        return { x, y: y2, z: z3 };
      }
      function LABtoRGB(l, a, b2) {
        if (arguments.length == 1) {
          var _arguments$4 = arguments[0], l = _arguments$4.l, a = _arguments$4.a, b2 = _arguments$4.b;
        }
        return XYZtoRGB(LABtoXYZ(l, a, b2));
      }
      var fromLAB = {
        XYZtoRGB,
        LABtoRGB,
        LABtoXYZ
      };
      function HSVtoRGB(h, s, v2) {
        if (arguments.length == 1) {
          var _arguments$ = arguments[0], h = _arguments$.h, s = _arguments$.s, v2 = _arguments$.v;
        }
        var H3 = h;
        var S3 = s;
        var V2 = v2;
        if (H3 >= 360) {
          H3 = 0;
        }
        var C = S3 * V2;
        var X3 = C * (1 - Math.abs(H3 / 60 % 2 - 1));
        var m = V2 - C;
        var temp = [];
        if (0 <= H3 && H3 < 60) {
          temp = [C, X3, 0];
        } else if (60 <= H3 && H3 < 120) {
          temp = [X3, C, 0];
        } else if (120 <= H3 && H3 < 180) {
          temp = [0, C, X3];
        } else if (180 <= H3 && H3 < 240) {
          temp = [0, X3, C];
        } else if (240 <= H3 && H3 < 300) {
          temp = [X3, 0, C];
        } else if (300 <= H3 && H3 < 360) {
          temp = [C, 0, X3];
        }
        return {
          r: round((temp[0] + m) * 255),
          g: round((temp[1] + m) * 255),
          b: round((temp[2] + m) * 255)
        };
      }
      function HSVtoHSL(h, s, v2) {
        if (arguments.length == 1) {
          var _arguments$2 = arguments[0], h = _arguments$2.h, s = _arguments$2.s, v2 = _arguments$2.v;
        }
        var rgb2 = HSVtoRGB(h, s, v2);
        return RGBtoHSL(rgb2.r, rgb2.g, rgb2.b);
      }
      var fromHSV = {
        HSVtoHSL,
        HSVtoRGB
      };
      function YCrCbtoRGB(y2, cr2, cb, bit) {
        if (arguments.length == 1) {
          var _arguments$ = arguments[0], y2 = _arguments$.y, cr2 = _arguments$.cr, cb = _arguments$.cb, bit = _arguments$.bit;
          bit = bit || 0;
        }
        var R2 = y2 + 1.402 * (cr2 - bit);
        var G3 = y2 - 0.344 * (cb - bit) - 0.714 * (cr2 - bit);
        var B2 = y2 + 1.772 * (cb - bit);
        return { r: Math.ceil(R2), g: Math.ceil(G3), b: Math.ceil(B2) };
      }
      var fromYCrCb = {
        YCrCbtoRGB
      };
      function interpolateRGB(startColor, endColor) {
        var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.5;
        var exportFormat = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "hex";
        var obj = {
          r: round(startColor.r + (endColor.r - startColor.r) * t),
          g: round(startColor.g + (endColor.g - startColor.g) * t),
          b: round(startColor.b + (endColor.b - startColor.b) * t),
          a: round(startColor.a + (endColor.a - startColor.a) * t, 100)
        };
        return format(obj, obj.a < 1 ? "rgb" : exportFormat);
      }
      function scale(scale2) {
        var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        if (!scale2) return [];
        if (typeof scale2 === "string") {
          scale2 = convertMatchesArray(scale2);
        }
        scale2 = scale2 || [];
        var len = scale2.length;
        var colors = [];
        for (var i = 0; i < len - 1; i++) {
          for (var index2 = 0; index2 < count; index2++) {
            colors.push(blend(scale2[i], scale2[i + 1], index2 / count));
          }
        }
        return colors;
      }
      function blend(startColor, endColor) {
        var ratio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.5;
        var format$$1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "hex";
        var s = parse(startColor);
        var e = parse(endColor);
        return interpolateRGB(s, e, ratio, format$$1);
      }
      function mix(startcolor, endColor) {
        var ratio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.5;
        var format$$1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "hex";
        return blend(startcolor, endColor, ratio, format$$1);
      }
      function contrast(c$$1) {
        c$$1 = parse(c$$1);
        return (Math.round(c$$1.r * 299) + Math.round(c$$1.g * 587) + Math.round(c$$1.b * 114)) / 1e3;
      }
      function contrastColor(c$$1) {
        return contrast(c$$1) >= 128 ? "black" : "white";
      }
      function gradient(colors) {
        var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
        colors = parseGradient(colors);
        var newColors = [];
        var maxCount = count - (colors.length - 1);
        var allCount = maxCount;
        for (var i = 1, len = colors.length; i < len; i++) {
          var startColor = colors[i - 1][0];
          var endColor = colors[i][0];
          var rate = i == 1 ? colors[i][1] : colors[i][1] - colors[i - 1][1];
          var colorCount = i == colors.length - 1 ? allCount : Math.floor(rate * maxCount);
          newColors = newColors.concat(scale([startColor, endColor], colorCount), [endColor]);
          allCount -= colorCount;
        }
        return newColors;
      }
      function scaleHSV(color2) {
        var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "h";
        var count = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 9;
        var exportFormat = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rgb";
        var min2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var max2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
        var dist = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 100;
        var colorObj = parse(color2);
        var hsv = RGBtoHSV(colorObj);
        var unit = (max2 - min2) * dist / count;
        var results = [];
        for (var i = 1; i <= count; i++) {
          hsv[target] = Math.abs((dist - unit * i) / dist);
          results.push(format(HSVtoRGB(hsv), exportFormat));
        }
        return results;
      }
      function scaleH(color2) {
        var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9;
        var exportFormat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "rgb";
        var min2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var max2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 360;
        return scaleHSV(color2, "h", count, exportFormat, min2, max2, 1);
      }
      function scaleS(color2) {
        var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9;
        var exportFormat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "rgb";
        var min2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var max2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
        return scaleHSV(color2, "s", count, exportFormat, min2, max2, 100);
      }
      function scaleV(color2) {
        var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9;
        var exportFormat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "rgb";
        var min2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var max2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
        return scaleHSV(color2, "v", count, exportFormat, min2, max2, 100);
      }
      scale.parula = function(count) {
        return scale(["#352a87", "#0f5cdd", "#00b5a6", "#ffc337", "#fdff00"], count);
      };
      scale.jet = function(count) {
        return scale(["#00008f", "#0020ff", "#00ffff", "#51ff77", "#fdff00", "#ff0000", "#800000"], count);
      };
      scale.hsv = function(count) {
        return scale(["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff", "#ff0000"], count);
      };
      scale.hot = function(count) {
        return scale(["#0b0000", "#ff0000", "#ffff00", "#ffffff"], count);
      };
      scale.pink = function(count) {
        return scale(["#1e0000", "#bd7b7b", "#e7e5b2", "#ffffff"], count);
      };
      scale.bone = function(count) {
        return scale(["#000000", "#4a4a68", "#a6c6c6", "#ffffff"], count);
      };
      scale.copper = function(count) {
        return scale(["#000000", "#3d2618", "#9d623e", "#ffa167", "#ffc77f"], count);
      };
      var mixin = {
        interpolateRGB,
        blend,
        mix,
        scale,
        contrast,
        contrastColor,
        gradient,
        scaleHSV,
        scaleH,
        scaleS,
        scaleV
      };
      function array_equals(v1, v2) {
        if (v1.length !== v2.length) return false;
        for (var i = 0, len = v1.length; i < len; ++i) {
          if (v1[i] !== v2[i]) return false;
        }
        return true;
      }
      function euclidean(v1, v2) {
        var total = 0;
        for (var i = 0, len = v1.length; i < len; i++) {
          total += Math.pow(v2[i] - v1[i], 2);
        }
        return Math.sqrt(total);
      }
      function manhattan(v1, v2) {
        var total = 0;
        for (var i = 0, len = v1.length; i < len; i++) {
          total += Math.abs(v2[i] - v1[i]);
        }
        return total;
      }
      function max(v1, v2) {
        var max2 = 0;
        for (var i = 0, len = v1.length; i < len; i++) {
          max2 = Math.max(max2, Math.abs(v2[i] - v1[i]));
        }
        return max2;
      }
      var distances = {
        euclidean,
        manhattan,
        max
      };
      var create_random_number = {
        linear: function linear(num, count) {
          var centeroids = [];
          var start = Math.round(Math.random() * num);
          var dist = Math.floor(num / count);
          do {
            centeroids.push(start);
            start = (start + dist) % num;
          } while (centeroids.length < count);
          return centeroids;
        },
        shuffle: function shuffle(num, count) {
          var centeroids = [];
          while (centeroids.length < count) {
            var index2 = Math.round(Math.random() * num);
            if (centeroids.indexOf(index2) == -1) {
              centeroids.push(index2);
            }
          }
          return centeroids;
        }
      };
      function randomCentroids(points, k2) {
        var method = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "linear";
        var centeroids = create_random_number[method](points.length, k2);
        return centeroids.map(function(i) {
          return points[i];
        });
      }
      function closestCenteroid(point, centeroids, distance) {
        var min2 = Infinity, kIndex = 0;
        centeroids.forEach(function(center, i) {
          var dist = distance(point, center);
          if (dist < min2) {
            min2 = dist;
            kIndex = i;
          }
        });
        return kIndex;
      }
      function getCenteroid(assigned) {
        if (!assigned.length) return [];
        var centeroid = new Array(assigned[0].length);
        for (var i = 0, len = centeroid.length; i < len; i++) {
          centeroid[i] = 0;
        }
        for (var index2 = 0, len = assigned.length; index2 < len; index2++) {
          var it3 = assigned[index2];
          var last = index2 + 1;
          for (var j3 = 0, jLen = it3.length; j3 < jLen; j3++) {
            centeroid[j3] += (it3[j3] - centeroid[j3]) / last;
          }
        }
        centeroid = centeroid.map(function(it4) {
          return Math.floor(it4);
        });
        return centeroid;
      }
      function unique_array(arrays) {
        return arrays;
        var set = {};
        var count = arrays.length;
        var it3 = null;
        while (count--) {
          it3 = arrays[count];
          set[JSON.stringify(it3)] = it3;
        }
        return Object.values(set);
      }
      function splitK(k2, points, centeroids, distance) {
        var assignment = new Array(k2);
        for (var i = 0; i < k2; i++) {
          assignment[i] = [];
        }
        for (var idx = 0, pointLength = points.length; idx < pointLength; idx++) {
          var point = points[idx];
          var index2 = closestCenteroid(point, centeroids, distance);
          assignment[index2].push(point);
        }
        return assignment;
      }
      function setNewCenteroid(k2, points, assignment, centeroids, movement, randomFunction) {
        for (var i = 0; i < k2; i++) {
          var assigned = assignment[i];
          var centeroid = centeroids[i];
          var newCenteroid = new Array(centeroid.length);
          if (assigned.length > 0) {
            newCenteroid = getCenteroid(assigned);
          } else {
            var idx = Math.floor(randomFunction() * points.length);
            newCenteroid = points[idx];
          }
          if (array_equals(newCenteroid, centeroid)) {
            movement = false;
          } else {
            movement = true;
          }
          centeroids[i] = newCenteroid;
        }
        return movement;
      }
      function kmeans(points, k2, distanceFunction) {
        var period = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10;
        var initialRandom = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "linear";
        points = unique_array(points);
        k2 = k2 || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));
        var distance = distanceFunction || "euclidean";
        if (typeof distance == "string") {
          distance = distances[distance];
        }
        var rng_seed = 0;
        var random = function random2() {
          rng_seed = (rng_seed * 9301 + 49297) % 233280;
          return rng_seed / 233280;
        };
        var centeroids = randomCentroids(points, k2, initialRandom);
        var movement = true;
        var iterations = 0;
        while (movement) {
          var assignment = splitK(k2, points, centeroids, distance);
          movement = setNewCenteroid(k2, points, assignment, centeroids, false, random);
          iterations++;
          if (iterations % period == 0) {
            break;
          }
        }
        return centeroids;
      }
      function each(len, callback) {
        for (var i = 0; i < len; i += 4) {
          callback(i);
        }
      }
      function pack(bitmap, callback) {
        each(bitmap.pixels.length, function(i) {
          callback(bitmap.pixels, i);
        });
      }
      var Canvas = {
        create: function create(width, height) {
          var canvas = document.createElement("canvas");
          canvas.width = width || 0;
          canvas.height = height || 0;
          return canvas;
        },
        drawPixels: function drawPixels(bitmap) {
          var canvas = this.create(bitmap.width, bitmap.height);
          var context = canvas.getContext("2d");
          var imagedata = context.getImageData(0, 0, canvas.width, canvas.height);
          imagedata.data.set(bitmap.pixels);
          context.putImageData(imagedata, 0, 0);
          return canvas;
        },
        createHistogram: function createHistogram(width, height, histogram2, callback) {
          var opt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : { black: true, red: false, green: false, blue: false };
          var canvas = this.create(width, height);
          var context = canvas.getContext("2d");
          context.clearRect(0, 0, width, height);
          context.fillStyle = "white";
          context.fillRect(0, 0, width, height);
          context.globalAlpha = 0.7;
          var omit = { black: false };
          if (opt.black) {
            omit.black = false;
          } else {
            omit.black = true;
          }
          if (opt.red) {
            omit.red = false;
          } else {
            omit.red = true;
          }
          if (opt.green) {
            omit.green = false;
          } else {
            omit.green = true;
          }
          if (opt.blue) {
            omit.blue = false;
          } else {
            omit.blue = true;
          }
          Object.keys(histogram2).forEach(function(color2) {
            if (!omit[color2]) {
              var array = histogram2[color2];
              var ymax = Math.max.apply(Math, array);
              var unitWith = width / array.length;
              context.fillStyle = color2;
              array.forEach(function(it3, index2) {
                var currentHeight = height * (it3 / ymax);
                var x = index2 * unitWith;
                context.fillRect(x, height - currentHeight, unitWith, currentHeight);
              });
            }
          });
          if (typeof callback == "function") callback(canvas);
        },
        getHistogram: function getHistogram(bitmap) {
          var black = new Array(256);
          var red = new Array(256);
          var green = new Array(256);
          var blue = new Array(256);
          for (var i = 0; i < 256; i++) {
            black[i] = 0;
            red[i] = 0;
            green[i] = 0;
            blue[i] = 0;
          }
          pack(bitmap, function(pixels, i2) {
            var grayIndex = Math.round(Color$1.brightness(pixels[i2], pixels[i2 + 1], pixels[i2 + 2]));
            black[grayIndex]++;
            red[pixels[i2]]++;
            green[pixels[i2 + 1]]++;
            blue[pixels[i2 + 2]]++;
          });
          return { black, red, green, blue };
        },
        getBitmap: function getBitmap2(bitmap, area) {
          var canvas = this.drawPixels(bitmap);
          var context = canvas.getContext("2d");
          var pixels = context.getImageData(area.x || 0, area.y || 0, area.width || canvas.width, area.height || canvas.height).data;
          return { pixels, width: area.width, height: area.height };
        },
        putBitmap: function putBitmap2(bitmap, subBitmap, area) {
          var canvas = this.drawPixels(bitmap);
          var subCanvas = this.drawPixels(subBitmap);
          var context = canvas.getContext("2d");
          context.drawImage(subCanvas, area.x, area.y);
          bitmap.pixels = context.getImageData(0, 0, bitmap.width, bitmap.height).data;
          return bitmap;
        }
      };
      var ImageLoader = function() {
        function ImageLoader2(url) {
          var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          classCallCheck(this, ImageLoader2);
          this.isLoaded = false;
          this.imageUrl = url;
          this.opt = opt;
          this.initialize();
        }
        createClass(ImageLoader2, [{
          key: "initialize",
          value: function initialize() {
            this.canvas = this.createCanvas();
            this.context = this.canvas.getContext("2d");
          }
        }, {
          key: "createCanvas",
          value: function createCanvas() {
            return document.createElement("canvas");
          }
        }, {
          key: "load",
          value: function load(callback) {
            this.loadImage(callback);
          }
        }, {
          key: "loadImage",
          value: function loadImage(callback) {
            var _this = this;
            var ctx = this.context;
            this.newImage = new Image();
            var img = this.newImage;
            img.onload = function() {
              var ratio = img.height / img.width;
              if (_this.opt.canvasWidth && _this.opt.canvasHeight) {
                _this.canvas.width = _this.opt.canvasWidth;
                _this.canvas.height = _this.opt.canvasHeight;
              } else {
                _this.canvas.width = _this.opt.maxWidth ? _this.opt.maxWidth : img.width;
                _this.canvas.height = _this.canvas.width * ratio;
              }
              ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, _this.canvas.width, _this.canvas.height);
              _this.isLoaded = true;
              callback && callback();
            };
            this.getImageUrl(function(url) {
              img.src = url;
            });
          }
        }, {
          key: "load",
          value: function load(callback) {
            var _this2 = this;
            this.newImage = new Image();
            var img = this.newImage;
            img.onload = function() {
              _this2.isLoaded = true;
              callback && callback();
            };
            this.getImageUrl(function(url) {
              img.src = url;
            });
          }
        }, {
          key: "getImageUrl",
          value: function getImageUrl(callback) {
            if (typeof this.imageUrl == "string") {
              return callback(this.imageUrl);
            } else if (this.imageUrl instanceof Blob) {
              var reader = new FileReader();
              reader.onload = function(ev) {
                callback(ev.target.result);
              };
              reader.readAsDataURL(this.imageUrl);
            }
          }
        }, {
          key: "getRGBA",
          value: function getRGBA(r, g3, b2, a) {
            return [r, g3, b2, a];
          }
        }, {
          key: "toArray",
          value: function toArray$$1(filter2, callback) {
            var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var imagedata = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            var width = imagedata.width;
            var height = imagedata.height;
            var pixels = new Uint8ClampedArray(imagedata.data);
            var bitmap = { pixels, width, height };
            if (!filter2) {
              filter2 = /* @__PURE__ */ function() {
                return function(bitmap2, done) {
                  done(bitmap2);
                };
              }();
            }
            filter2(bitmap, function(newBitmap) {
              var tmpCanvas = Canvas.drawPixels(newBitmap);
              if (opt.returnTo == "canvas") {
                callback(tmpCanvas);
              } else {
                callback(tmpCanvas.toDataURL(opt.outputFormat || "image/png"));
              }
            }, opt);
          }
        }, {
          key: "toHistogram",
          value: function toHistogram(opt) {
            var imagedata = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            var width = imagedata.width;
            var height = imagedata.height;
            var pixels = new Uint8ClampedArray(imagedata.data);
            var bitmap = { pixels, width, height };
            return Canvas.getHistogram(bitmap);
          }
        }, {
          key: "toRGB",
          value: function toRGB() {
            var imagedata = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            var rgba = imagedata.data;
            var results = [];
            for (var i = 0, len = rgba.length; i < len; i += 4) {
              results[results.length] = [rgba[i + 0], rgba[i + 1], rgba[i + 2], rgba[i + 3]];
            }
            return results;
          }
        }]);
        return ImageLoader2;
      }();
      var CONSTANT = {
        identity: function identity2() {
          return [1, 0, 0, 0, 1, 0, 0, 0, 1];
        },
        stretching: function stretching(k2) {
          return [k2, 0, 0, 0, 1, 0, 0, 0, 1];
        },
        squeezing: function squeezing(k2) {
          return [k2, 0, 0, 0, 1 / k2, 0, 0, 0, 1];
        },
        scale: function scale2() {
          var sx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
          var sy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          sx = sx || sx === 0 ? sx : 1;
          sy = sy || sy === 0 ? sy : 1;
          return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
        },
        scaleX: function scaleX(sx) {
          return this.scale(sx);
        },
        scaleY: function scaleY(sy) {
          return this.scale(1, sy);
        },
        translate: function translate(tx, ty) {
          return [1, 0, tx, 0, 1, ty, 0, 0, 1];
        },
        rotate: function rotate2(angle) {
          var r = this.radian(angle);
          return [Math.cos(r), -Math.sin(r), 0, Math.sin(r), Math.cos(r), 0, 0, 0, 1];
        },
        rotate90: function rotate90() {
          return [0, -1, 0, 1, 0, 0, 0, 0, 1];
        },
        rotate180: function rotate180() {
          return [-1, 0, 0, 0, -1, 0, 0, 0, 1];
        },
        rotate270: function rotate270() {
          return [0, 1, 0, -1, 0, 0, 0, 0, 1];
        },
        radian: function radian2(degree) {
          return degree * Math.PI / 180;
        },
        skew: function skew(degreeX, degreeY) {
          var radianX = this.radian(degreeX);
          var radianY = this.radian(degreeY);
          return [1, Math.tan(radianX), 0, Math.tan(radianY), 1, 0, 0, 0, 1];
        },
        skewX: function skewX(degreeX) {
          var radianX = this.radian(degreeX);
          return [1, Math.tan(radianX), 0, 0, 1, 0, 0, 0, 1];
        },
        skewY: function skewY(degreeY) {
          var radianY = this.radian(degreeY);
          return [1, 0, 0, Math.tan(radianY), 1, 0, 0, 0, 1];
        },
        shear1: function shear1(angle) {
          return [1, -Math.tan(this.radian(angle) / 2), 0, 0, 1, 0, 0, 0, 1];
        },
        shear2: function shear2(angle) {
          return [1, 0, 0, Math.sin(this.radian(angle)), 1, 0, 0, 0, 1];
        }
      };
      var Matrix = {
        CONSTANT,
        radian: function radian2(angle) {
          return CONSTANT.radian(angle);
        },
        multiply: function multiply(A2, C) {
          return [A2[0] * C[0] + A2[1] * C[1] + A2[2] * C[2], A2[3] * C[0] + A2[4] * C[1] + A2[5] * C[2], A2[6] * C[0] + A2[7] * C[1] + A2[8] * C[2]];
        },
        identity: function identity2(B2) {
          return this.multiply(CONSTANT.identity(), B2);
        },
        translate: function translate(x, y2, B2) {
          return this.multiply(CONSTANT.translate(x, y2), B2);
        },
        rotate: function rotate2(angle, B2) {
          return this.multiply(CONSTANT.rotate(angle), B2);
        },
        shear1: function shear1(angle, B2) {
          return this.multiply(CONSTANT.shear1(angle), B2);
        },
        shear2: function shear2(angle, B2) {
          return this.multiply(CONSTANT.shear2(angle), B2);
        },
        rotateShear: function rotateShear(angle, B2) {
          var arr = B2;
          arr = this.shear1(angle, arr);
          arr = this.shear2(angle, arr);
          arr = this.shear1(angle, arr);
          return arr;
        }
      };
      function crop() {
        var startX = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var startY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var width = arguments[2];
        var height = arguments[3];
        var newBitmap = createBitmap(width * height * 4, width, height);
        return function(bitmap, done) {
          for (var y2 = startY, realY = 0; y2 < height; y2++, realY++) {
            for (var x = startX, realX = 0; x < width; x++, realX++) {
              newBitmap.pixels[realY * width * realX] = bitmap.pixels[y2 * width * x];
            }
          }
          done(newBitmap);
        };
      }
      function resize(dstWidth, dstHeight) {
        return function(bitmap, done) {
          var c2 = Canvas.drawPixels(bitmap);
          var context = c2.getContext("2d");
          c2.width = dstWidth;
          c2.height = dstHeight;
          done({
            pixels: new Uint8ClampedArray(context.getImageData(0, 0, dstWidth, dstHeight).data),
            width: dstWidth,
            height: dstHeight
          });
        };
      }
      function flipV() {
        return function(bitmap, done) {
          var width = bitmap.width;
          var height = bitmap.height;
          var isCenter = height % 2 == 1 ? 1 : 0;
          var halfHeight = isCenter ? Math.floor(height / 2) : height / 2;
          for (var y2 = 0; y2 < halfHeight; y2++) {
            for (var x = 0; x < width; x++) {
              var startIndex = y2 * width + x << 2;
              var endIndex = (height - 1 - y2) * width + x << 2;
              swapColor(bitmap.pixels, startIndex, endIndex);
            }
          }
          done(bitmap);
        };
      }
      function flipH() {
        return function(bitmap, done) {
          var width = bitmap.width;
          var height = bitmap.height;
          var isCenter = width % 2 == 1 ? 1 : 0;
          var halfWidth = isCenter ? Math.floor(width / 2) : width / 2;
          for (var y2 = 0; y2 < height; y2++) {
            for (var x = 0; x < halfWidth; x++) {
              var startIndex = y2 * width + x << 2;
              var endIndex = y2 * width + (width - 1 - x) << 2;
              swapColor(bitmap.pixels, startIndex, endIndex);
            }
          }
          done(bitmap);
        };
      }
      function rotateDegree(angle) {
        var cx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "center";
        var cy = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "center";
        return function(bitmap, done) {
          var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var newBitmap = createBitmap(bitmap.pixels.length, bitmap.width, bitmap.height);
          var width = bitmap.width;
          var height = bitmap.height;
          if (cx == "center") {
            cx = Math.floor(width / 2);
          }
          if (cy == "center") {
            cy = Math.floor(height / 2);
          }
          var translateMatrix = Matrix.CONSTANT.translate(-cx, -cy);
          var translateMatrix2 = Matrix.CONSTANT.translate(cx, cy);
          var shear1Matrix = Matrix.CONSTANT.shear1(angle);
          var shear2Matrix = Matrix.CONSTANT.shear2(angle);
          packXY(function(pixels, i, x, y2) {
            var arr = Matrix.multiply(translateMatrix, [x, y2, 1]);
            arr = Matrix.multiply(shear1Matrix, arr).map(Math.round);
            arr = Matrix.multiply(shear2Matrix, arr).map(Math.round);
            arr = Matrix.multiply(shear1Matrix, arr).map(Math.round);
            arr = Matrix.multiply(translateMatrix2, arr);
            var _arr = arr, _arr2 = slicedToArray(_arr, 2), x1 = _arr2[0], y1 = _arr2[1];
            if (x1 < 0) return;
            if (y1 < 0) return;
            if (x1 > width - 1) return;
            if (y1 > height - 1) return;
            var endIndex = y1 * width + x1 << 2;
            fillPixelColor(pixels, endIndex, bitmap.pixels, i);
          })(newBitmap, function() {
            done(newBitmap);
          }, opt);
        };
      }
      function rotate() {
        var degree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        degree = parseParamNumber(degree);
        degree = degree % 360;
        return function(bitmap, done) {
          var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (degree == 0) return bitmap;
          if (degree == 90 || degree == 270) {
            var newBitmap = createBitmap(bitmap.pixels.length, bitmap.height, bitmap.width);
          } else if (degree == 180) {
            var newBitmap = createBitmap(bitmap.pixels.length, bitmap.width, bitmap.height);
          } else {
            return rotateDegree(degree)(bitmap, done, opt);
          }
          packXY(function(pixels, i, x, y2) {
            if (degree == 90) {
              var endIndex = x * newBitmap.width + (newBitmap.width - 1 - y2) << 2;
            } else if (degree == 270) {
              var endIndex = (newBitmap.height - 1 - x) * newBitmap.width + y2 << 2;
            } else if (degree == 180) {
              var endIndex = (newBitmap.height - 1 - y2) * newBitmap.width + (newBitmap.width - 1 - x) << 2;
            }
            fillPixelColor(newBitmap.pixels, endIndex, bitmap.pixels, i);
          })(bitmap, function() {
            done(newBitmap);
          }, opt);
        };
      }
      function histogram$1() {
        var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "gray";
        var points = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var $realPoints = [];
        for (var i = 0; i < points.length - 1; i++) {
          var sp = points[i];
          var ep = points[i + 1];
          var distX = ep[0] - sp[0];
          var distY = ep[1] - sp[1];
          var rate = distY / distX;
          for (var realIndex = 0, start = sp[0]; realIndex < distX; realIndex++, start++) {
            $realPoints[start] = sp[1] + realIndex * rate;
          }
        }
        $realPoints[255] = 255;
        if (type === "red") {
          return pixel(function() {
            $r = $realPoints[$r];
          }, {}, { $realPoints });
        } else if (type === "green") {
          return pixel(function() {
            $g = $realPoints[$g];
          }, {}, { $realPoints });
        } else if (type === "blue") {
          return pixel(function() {
            $b = $realPoints[$b];
          }, {}, { $realPoints });
        } else {
          return pixel(function() {
            var l = Color.RGBtoYCrCb($r, $g, $b);
            var c2 = Color.YCrCbtoRGB(clamp($realPoints[clamp(l.y)]), l.cr, l.cb, 0);
            $r = c2.r;
            $g = c2.g;
            $b = c2.b;
          }, {}, { $realPoints });
        }
      }
      var image$1 = {
        crop,
        resize,
        flipH,
        flipV,
        rotate,
        rotateDegree,
        histogram: histogram$1,
        "rotate-degree": rotateDegree
      };
      function bitonal(darkColor, lightColor) {
        var threshold2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100;
        var $darkColor = Color$1.parse(darkColor);
        var $lightColor = Color$1.parse(lightColor);
        var $threshold = threshold2;
        return pixel("\n        const thresholdColor = ( $r + $g + $b ) <= $threshold ? $darkColor : $lightColor\n\n        $r = thresholdColor.r\n        $g = thresholdColor.g \n        $b = thresholdColor.b \n    ", {
          $threshold
        }, {
          $darkColor,
          $lightColor
        });
      }
      function brightness$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        amount = parseParamNumber(amount);
        var $C = Math.floor(255 * (amount / 100));
        return pixel("\n        $r += $C \n        $g += $C \n        $b += $C \n    ", { $C });
      }
      function brownie() {
        var $matrix = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, 0, 0, 0, 1];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function clip() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        amount = parseParamNumber(amount);
        var $C = Math.abs(amount) * 2.55;
        return pixel("\n\n        $r = ($r > 255 - $C) ? 255 : 0\n        $g = ($g > 255 - $C) ? 255 : 0\n        $b = ($b > 255 - $C) ? 255 : 0\n\n    ", { $C });
      }
      function contrast$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        amount = parseParamNumber(amount);
        var $C = Math.max((128 + amount) / 128, 0);
        return pixel("\n        $r *= $C\n        $g *= $C\n        $b *= $C\n    ", { $C });
      }
      function gamma() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var $C = parseParamNumber(amount);
        return pixel("\n        $r = Math.pow($r / 255, $C) * 255\n        $g = Math.pow($g / 255, $C) * 255\n        $b = Math.pow($b / 255, $C) * 255\n    ", { $C });
      }
      function gradient$1() {
        var params = [].concat(Array.prototype.slice.call(arguments));
        if (params.length === 1 && typeof params[0] === "string") {
          params = Color$1.convertMatchesArray(params[0]);
        }
        params = params.map(function(arg) {
          var res = Color$1.matches(arg);
          if (!res.length) {
            return { type: "scale", value: arg };
          }
          return { type: "param", value: arg };
        });
        var $scale = params.filter(function(it3) {
          return it3.type == "scale";
        })[0];
        $scale = $scale ? +$scale.value : 256;
        params = params.filter(function(it3) {
          return it3.type == "param";
        }).map(function(it3) {
          return it3.value;
        }).join(",");
        var $colors = Color$1.gradient(params, $scale).map(function(c2) {
          var _Color$parse = Color$1.parse(c2), r = _Color$parse.r, g3 = _Color$parse.g, b2 = _Color$parse.b, a = _Color$parse.a;
          return { r, g: g3, b: b2, a };
        });
        return pixel("\n        const colorIndex = clamp(Math.ceil($r * 0.2126 + $g * 0.7152 + $b * 0.0722))\n        const newColorIndex = clamp(Math.floor(colorIndex * ($scale / 256)))\n        const color = $colors[newColorIndex]\n\n        $r = color.r \n        $g = color.g \n        $b = color.b \n        $a = clamp(Math.floor(color.a * 256))\n    ", {}, { $colors, $scale });
      }
      function grayscale(amount) {
        amount = parseParamNumber(amount);
        var C = amount / 100;
        if (C > 1) C = 1;
        var $matrix = [0.2126 + 0.7874 * (1 - C), 0.7152 - 0.7152 * (1 - C), 0.0722 - 0.0722 * (1 - C), 0, 0.2126 - 0.2126 * (1 - C), 0.7152 + 0.2848 * (1 - C), 0.0722 - 0.0722 * (1 - C), 0, 0.2126 - 0.2126 * (1 - C), 0.7152 - 0.7152 * (1 - C), 0.0722 + 0.9278 * (1 - C), 0, 0, 0, 0, 1];
        return pixel(
          /*javascript*/
          "\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a\n    ",
          {
            $matrix
          }
        );
      }
      function hue() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 360;
        var $C = parseParamNumber(amount);
        return pixel("\n        var hsv = Color.RGBtoHSV($r, $g, $b);\n\n        // 0 ~ 360 \n        var h = hsv.h;\n        h += Math.abs($C)\n        h = h % 360\n        hsv.h = h\n\n        var rgb = Color.HSVtoRGB(hsv);\n\n        $r = rgb.r\n        $g = rgb.g\n        $b = rgb.b\n    ", {
          $C
        });
      }
      function invert() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        var $C = amount / 100;
        return pixel("\n        $r = (255 - $r) * $C\n        $g = (255 - $g) * $C\n        $b = (255 - $b) * $C\n    ", {
          $C
        });
      }
      function kodachrome() {
        var $matrix = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 0, 0, 0, 1];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function matrix() {
        var $a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var $b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var $c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var $d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var $e3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var $f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
        var $g2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
        var $h = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 0;
        var $i = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0;
        var $j = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0;
        var $k = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0;
        var $l2 = arguments.length > 11 && arguments[11] !== void 0 ? arguments[11] : 0;
        var $m = arguments.length > 12 && arguments[12] !== void 0 ? arguments[12] : 0;
        var $n3 = arguments.length > 13 && arguments[13] !== void 0 ? arguments[13] : 0;
        var $o2 = arguments.length > 14 && arguments[14] !== void 0 ? arguments[14] : 0;
        var $p = arguments.length > 15 && arguments[15] !== void 0 ? arguments[15] : 0;
        var $matrix = [$a2, $b2, $c, $d, $e3, $f, $g2, $h, $i, $j, $k, $l2, $m, $n3, $o2, $p];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function noise() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var $C = parseParamNumber(amount);
        return pixel("\n        const C = Math.abs($C) * 5\n        const min = -C\n        const max = C \n        const noiseValue = Math.round(min + (Math.random() * (max - min)))\n\n        $r += noiseValue\n        $g += noiseValue\n        $b += noiseValue\n    ", {
          $C
        });
      }
      function opacity() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        var $C = amount / 100;
        return pixel("\n        $a *= $C \n    ", { $C });
      }
      function polaroid() {
        var $matrix = [1.438, -0.062, -0.062, 0, -0.122, 1.378, -0.122, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 1];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function saturation() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        var C = amount / 100;
        var L3 = 1 - Math.abs(C);
        var $matrix = [L3, 0, 0, 0, 0, L3, 0, 0, 0, 0, L3, 0, 0, 0, 0, L3];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function sepia() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = parseParamNumber(amount);
        if (C > 1) C = 1;
        var $matrix = [0.393 + 0.607 * (1 - C), 0.769 - 0.769 * (1 - C), 0.189 - 0.189 * (1 - C), 0, 0.349 - 0.349 * (1 - C), 0.686 + 0.314 * (1 - C), 0.168 - 0.168 * (1 - C), 0, 0.272 - 0.272 * (1 - C), 0.534 - 0.534 * (1 - C), 0.131 + 0.869 * (1 - C), 0, 0, 0, 0, 1];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function shade() {
        var redValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var greenValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var blueValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var $redValue = parseParamNumber(redValue);
        var $greenValue = parseParamNumber(greenValue);
        var $blueValue = parseParamNumber(blueValue);
        return pixel("\n        $r *= $redValue\n        $g *= $greenValue\n        $b *= $blueValue\n    ", {
          $redValue,
          $greenValue,
          $blueValue
        });
      }
      function shift() {
        var $matrix = [1.438, -0.062, -0.062, 0, -0.122, 1.378, -0.122, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 1];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function solarize(redValue, greenValue, blueValue) {
        var $redValue = parseParamNumber(redValue);
        var $greenValue = parseParamNumber(greenValue);
        var $blueValue = parseParamNumber(blueValue);
        return pixel("\n        $r = ($r < $redValue) ? 255 - $r: $r\n        $g = ($g < $greenValue) ? 255 - $g: $g\n        $b = ($b < $blueValue) ? 255 - $b: $b\n    ", {
          $redValue,
          $greenValue,
          $blueValue
        });
      }
      function technicolor() {
        var $matrix = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 0, 0, 0, 1];
        return pixel("\n        $r = $matrix[0] * $r + $matrix[1] * $g + $matrix[2] * $b + $matrix[3] * $a\n        $g = $matrix[4] * $r + $matrix[5] * $g + $matrix[6] * $b + $matrix[7] * $a\n        $b = $matrix[8] * $r + $matrix[9] * $g + $matrix[10] * $b + $matrix[11] * $a\n        $a = $matrix[12] * $r + $matrix[13] * $g + $matrix[14] * $b + $matrix[15] * $a        \n    ", {
          $matrix
        });
      }
      function thresholdColor() {
        var scale2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 200;
        var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
        var hasColor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        var $scale = parseParamNumber(scale2);
        amount = parseParamNumber(amount);
        var $C = amount / 100;
        var $hasColor = hasColor;
        return pixel("\n        // refer to Color.brightness \n        const v = ($C * Math.ceil($r * 0.2126 + $g * 0.7152 + $b * 0.0722) ) >= $scale ? 255 : 0;\n\n        if ($hasColor) {\n\n            if (v == 0) {\n                $r = 0 \n                $g = 0 \n                $b = 0\n            }\n            \n        } else {\n            const value = Math.round(v)\n            $r = value \n            $g = value \n            $b = value \n        }\n        \n    ", {
          $C,
          $scale,
          $hasColor
        });
      }
      function threshold() {
        var scale2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 200;
        var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
        return thresholdColor(scale2, amount, false);
      }
      function tint() {
        var redTint = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var greenTint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var blueTint = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var $redTint = parseParamNumber(redTint);
        var $greenTint = parseParamNumber(greenTint);
        var $blueTint = parseParamNumber(blueTint);
        return pixel("\n\n        $r += (255 - $r) * $redTint\n        $g += (255 - $g) * $greenTint\n        $b += (255 - $b) * $blueTint\n\n    ", {
          $redTint,
          $greenTint,
          $blueTint
        });
      }
      var pixel$1 = {
        bitonal,
        brightness: brightness$1,
        brownie,
        clip,
        contrast: contrast$1,
        gamma,
        gradient: gradient$1,
        grayscale,
        hue,
        invert,
        kodachrome,
        matrix,
        noise,
        opacity,
        polaroid,
        saturation,
        sepia,
        shade,
        shift,
        solarize,
        technicolor,
        threshold,
        "threshold-color": thresholdColor,
        tint
      };
      function blur() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
        amount = parseParamNumber(amount);
        return convolution(createBlurMatrix(amount));
      }
      function emboss() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 4;
        amount = parseParamNumber(amount);
        return convolution([amount * -2, -amount, 0, -amount, 1, amount, 0, amount, amount * 2]);
      }
      function gaussianBlur() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        var C = amount / 100;
        return convolution(weight([1, 2, 1, 2, 4, 2, 1, 2, 1], 1 / 16 * C));
      }
      function gaussianBlur5x() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        var C = amount / 100;
        return convolution(weight([1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1], 1 / 256 * C));
      }
      function grayscale2() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        return convolution(weight([0.3, 0.3, 0.3, 0, 0, 0.59, 0.59, 0.59, 0, 0, 0.11, 0.11, 0.11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], amount / 100));
      }
      function identity() {
        return convolution([0, 0, 0, 0, 1, 0, 0, 0, 0]);
      }
      function kirschHorizontal() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        count = parseParamNumber(count);
        return convolution([5, 5, 5, -3, 0, -3, -3, -3, -3]);
      }
      function kirschVertical() {
        var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        count = parseParamNumber(count);
        return convolution([5, -3, -3, 5, 0, -3, 5, -3, -3]);
      }
      function laplacian() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        return convolution(weight([-1, -1, -1, -1, 8, -1, -1, -1, -1], amount / 100));
      }
      function laplacian5x() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        return convolution(weight([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], amount / 100));
      }
      function motionBlur() {
        return convolution(weight([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], 1 / 9));
      }
      function motionBlur2() {
        return convolution(weight([1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], 1 / 9));
      }
      function motionBlur3() {
        return convolution(weight([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], 1 / 9));
      }
      function negative() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        return convolution(weight([-1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], amount / 100));
      }
      function sepia2() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        return convolution(weight([0.393, 0.349, 0.272, 0, 0, 0.769, 0.686, 0.534, 0, 0, 0.189, 0.168, 0.131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], amount / 100));
      }
      function sharpen() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        return convolution(weight([0, -1, 0, -1, 5, -1, 0, -1, 0], amount / 100));
      }
      function sobelHorizontal() {
        return convolution([-1, -2, -1, 0, 0, 0, 1, 2, 1]);
      }
      function sobelVertical() {
        return convolution([-1, 0, 1, -2, 0, 2, -1, 0, 1]);
      }
      var mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
      var shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
      function BlurStack() {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
      }
      function stackBlurImage(bitmap, radius, blurAlphaChannel) {
        if (blurAlphaChannel) return stackBlurCanvasRGBA(bitmap, 0, 0, radius);
        else return stackBlurCanvasRGB(bitmap, 0, 0, radius);
      }
      function stackBlurCanvasRGBA(bitmap, top_x, top_y, radius) {
        if (isNaN(radius) || radius < 1) return bitmap;
        radius |= 0;
        var pixels = bitmap.pixels, width = bitmap.width, height = bitmap.height;
        var x, y2, i, p, yp, yi2, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr2, pg, pb, pa, rbs;
        var div = radius + radius + 1;
        var widthMinus1 = width - 1;
        var heightMinus1 = height - 1;
        var radiusPlus1 = radius + 1;
        var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
        var stackStart = new BlurStack();
        var stack = stackStart;
        for (i = 1; i < div; i++) {
          stack = stack.next = new BlurStack();
          if (i == radiusPlus1) var stackEnd = stack;
        }
        stack.next = stackStart;
        var stackIn = null;
        var stackOut = null;
        yw = yi2 = 0;
        var mul_sum = mul_table[radius];
        var shg_sum = shg_table[radius];
        for (y2 = 0; y2 < height; y2++) {
          r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
          r_out_sum = radiusPlus1 * (pr2 = pixels[yi2]);
          g_out_sum = radiusPlus1 * (pg = pixels[yi2 + 1]);
          b_out_sum = radiusPlus1 * (pb = pixels[yi2 + 2]);
          a_out_sum = radiusPlus1 * (pa = pixels[yi2 + 3]);
          r_sum += sumFactor * pr2;
          g_sum += sumFactor * pg;
          b_sum += sumFactor * pb;
          a_sum += sumFactor * pa;
          stack = stackStart;
          for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr2;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
          }
          for (i = 1; i < radiusPlus1; i++) {
            p = yi2 + ((widthMinus1 < i ? widthMinus1 : i) << 2);
            r_sum += (stack.r = pr2 = pixels[p]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
            r_in_sum += pr2;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next;
          }
          stackIn = stackStart;
          stackOut = stackEnd;
          for (x = 0; x < width; x++) {
            pixels[yi2 + 3] = pa = a_sum * mul_sum >> shg_sum;
            if (pa != 0) {
              pa = 255 / pa;
              pixels[yi2] = (r_sum * mul_sum >> shg_sum) * pa;
              pixels[yi2 + 1] = (g_sum * mul_sum >> shg_sum) * pa;
              pixels[yi2 + 2] = (b_sum * mul_sum >> shg_sum) * pa;
            } else {
              pixels[yi2] = pixels[yi2 + 1] = pixels[yi2 + 2] = 0;
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
            r_in_sum += stackIn.r = pixels[p];
            g_in_sum += stackIn.g = pixels[p + 1];
            b_in_sum += stackIn.b = pixels[p + 2];
            a_in_sum += stackIn.a = pixels[p + 3];
            r_sum += r_in_sum;
            g_sum += g_in_sum;
            b_sum += b_in_sum;
            a_sum += a_in_sum;
            stackIn = stackIn.next;
            r_out_sum += pr2 = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr2;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi2 += 4;
          }
          yw += width;
        }
        for (x = 0; x < width; x++) {
          g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
          yi2 = x << 2;
          r_out_sum = radiusPlus1 * (pr2 = pixels[yi2]);
          g_out_sum = radiusPlus1 * (pg = pixels[yi2 + 1]);
          b_out_sum = radiusPlus1 * (pb = pixels[yi2 + 2]);
          a_out_sum = radiusPlus1 * (pa = pixels[yi2 + 3]);
          r_sum += sumFactor * pr2;
          g_sum += sumFactor * pg;
          b_sum += sumFactor * pb;
          a_sum += sumFactor * pa;
          stack = stackStart;
          for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr2;
            stack.g = pg;
            stack.b = pb;
            stack.a = pa;
            stack = stack.next;
          }
          yp = width;
          for (i = 1; i <= radius; i++) {
            yi2 = yp + x << 2;
            r_sum += (stack.r = pr2 = pixels[yi2]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[yi2 + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[yi2 + 2]) * rbs;
            a_sum += (stack.a = pa = pixels[yi2 + 3]) * rbs;
            r_in_sum += pr2;
            g_in_sum += pg;
            b_in_sum += pb;
            a_in_sum += pa;
            stack = stack.next;
            if (i < heightMinus1) {
              yp += width;
            }
          }
          yi2 = x;
          stackIn = stackStart;
          stackOut = stackEnd;
          for (y2 = 0; y2 < height; y2++) {
            p = yi2 << 2;
            pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
            if (pa > 0) {
              pa = 255 / pa;
              pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
              pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
              pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
            } else {
              pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
            }
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            a_sum -= a_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            a_out_sum -= stackIn.a;
            p = x + ((p = y2 + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
            r_sum += r_in_sum += stackIn.r = pixels[p];
            g_sum += g_in_sum += stackIn.g = pixels[p + 1];
            b_sum += b_in_sum += stackIn.b = pixels[p + 2];
            a_sum += a_in_sum += stackIn.a = pixels[p + 3];
            stackIn = stackIn.next;
            r_out_sum += pr2 = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            a_out_sum += pa = stackOut.a;
            r_in_sum -= pr2;
            g_in_sum -= pg;
            b_in_sum -= pb;
            a_in_sum -= pa;
            stackOut = stackOut.next;
            yi2 += width;
          }
        }
        return bitmap;
      }
      function stackBlurCanvasRGBA(bitmap, top_x, top_y, radius) {
        if (isNaN(radius) || radius < 1) return bitmap;
        radius |= 0;
        var pixels = bitmap.pixels, width = bitmap.width, height = bitmap.height;
        var x, y2, i, p, yp, yi2, yw, r_sum, g_sum, b_sum, r_out_sum, g_out_sum, b_out_sum, r_in_sum, g_in_sum, b_in_sum, pr2, pg, pb, rbs;
        var div = radius + radius + 1;
        var widthMinus1 = width - 1;
        var heightMinus1 = height - 1;
        var radiusPlus1 = radius + 1;
        var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
        var stackStart = new BlurStack();
        var stack = stackStart;
        for (i = 1; i < div; i++) {
          stack = stack.next = new BlurStack();
          if (i == radiusPlus1) var stackEnd = stack;
        }
        stack.next = stackStart;
        var stackIn = null;
        var stackOut = null;
        yw = yi2 = 0;
        var mul_sum = mul_table[radius];
        var shg_sum = shg_table[radius];
        for (y2 = 0; y2 < height; y2++) {
          r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
          r_out_sum = radiusPlus1 * (pr2 = pixels[yi2]);
          g_out_sum = radiusPlus1 * (pg = pixels[yi2 + 1]);
          b_out_sum = radiusPlus1 * (pb = pixels[yi2 + 2]);
          r_sum += sumFactor * pr2;
          g_sum += sumFactor * pg;
          b_sum += sumFactor * pb;
          stack = stackStart;
          for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr2;
            stack.g = pg;
            stack.b = pb;
            stack = stack.next;
          }
          for (i = 1; i < radiusPlus1; i++) {
            p = yi2 + ((widthMinus1 < i ? widthMinus1 : i) << 2);
            r_sum += (stack.r = pr2 = pixels[p]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
            r_in_sum += pr2;
            g_in_sum += pg;
            b_in_sum += pb;
            stack = stack.next;
          }
          stackIn = stackStart;
          stackOut = stackEnd;
          for (x = 0; x < width; x++) {
            pixels[yi2] = r_sum * mul_sum >> shg_sum;
            pixels[yi2 + 1] = g_sum * mul_sum >> shg_sum;
            pixels[yi2 + 2] = b_sum * mul_sum >> shg_sum;
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
            r_in_sum += stackIn.r = pixels[p];
            g_in_sum += stackIn.g = pixels[p + 1];
            b_in_sum += stackIn.b = pixels[p + 2];
            r_sum += r_in_sum;
            g_sum += g_in_sum;
            b_sum += b_in_sum;
            stackIn = stackIn.next;
            r_out_sum += pr2 = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            r_in_sum -= pr2;
            g_in_sum -= pg;
            b_in_sum -= pb;
            stackOut = stackOut.next;
            yi2 += 4;
          }
          yw += width;
        }
        for (x = 0; x < width; x++) {
          g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
          yi2 = x << 2;
          r_out_sum = radiusPlus1 * (pr2 = pixels[yi2]);
          g_out_sum = radiusPlus1 * (pg = pixels[yi2 + 1]);
          b_out_sum = radiusPlus1 * (pb = pixels[yi2 + 2]);
          r_sum += sumFactor * pr2;
          g_sum += sumFactor * pg;
          b_sum += sumFactor * pb;
          stack = stackStart;
          for (i = 0; i < radiusPlus1; i++) {
            stack.r = pr2;
            stack.g = pg;
            stack.b = pb;
            stack = stack.next;
          }
          yp = width;
          for (i = 1; i <= radius; i++) {
            yi2 = yp + x << 2;
            r_sum += (stack.r = pr2 = pixels[yi2]) * (rbs = radiusPlus1 - i);
            g_sum += (stack.g = pg = pixels[yi2 + 1]) * rbs;
            b_sum += (stack.b = pb = pixels[yi2 + 2]) * rbs;
            r_in_sum += pr2;
            g_in_sum += pg;
            b_in_sum += pb;
            stack = stack.next;
            if (i < heightMinus1) {
              yp += width;
            }
          }
          yi2 = x;
          stackIn = stackStart;
          stackOut = stackEnd;
          for (y2 = 0; y2 < height; y2++) {
            p = yi2 << 2;
            pixels[p] = r_sum * mul_sum >> shg_sum;
            pixels[p + 1] = g_sum * mul_sum >> shg_sum;
            pixels[p + 2] = b_sum * mul_sum >> shg_sum;
            r_sum -= r_out_sum;
            g_sum -= g_out_sum;
            b_sum -= b_out_sum;
            r_out_sum -= stackIn.r;
            g_out_sum -= stackIn.g;
            b_out_sum -= stackIn.b;
            p = x + ((p = y2 + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
            r_sum += r_in_sum += stackIn.r = pixels[p];
            g_sum += g_in_sum += stackIn.g = pixels[p + 1];
            b_sum += b_in_sum += stackIn.b = pixels[p + 2];
            stackIn = stackIn.next;
            r_out_sum += pr2 = stackOut.r;
            g_out_sum += pg = stackOut.g;
            b_out_sum += pb = stackOut.b;
            r_in_sum -= pr2;
            g_in_sum -= pg;
            b_in_sum -= pb;
            stackOut = stackOut.next;
            yi2 += width;
          }
        }
        return bitmap;
      }
      function stackBlur() {
        var radius = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
        var hasAlphaChannel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        radius = parseParamNumber(radius);
        return function(bitmap, done) {
          var newBitmap = stackBlurImage(bitmap, radius, hasAlphaChannel);
          done(newBitmap);
        };
      }
      function transparency() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
        amount = parseParamNumber(amount);
        return convolution(weight([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.3, 0, 0, 0, 0, 0, 1], amount / 100));
      }
      function unsharpMasking() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 256;
        amount = parseParamNumber(amount);
        return convolution(weight([1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, -476, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1], -1 / amount));
      }
      var matrix$1 = {
        blur,
        emboss,
        gaussianBlur,
        "gaussian-blur": gaussianBlur,
        gaussianBlur5x,
        "gaussian-blur-5x": gaussianBlur5x,
        grayscale2,
        normal: identity,
        kirschHorizontal,
        "kirsch-horizontal": kirschHorizontal,
        kirschVertical,
        "kirsch-vertical": kirschVertical,
        laplacian,
        laplacian5x,
        "laplacian-5x": laplacian5x,
        motionBlur,
        "motion-blur": motionBlur,
        motionBlur2,
        "motion-blur-2": motionBlur2,
        motionBlur3,
        "motion-blur-3": motionBlur3,
        negative,
        sepia2,
        sharpen,
        sobelHorizontal,
        "sobel-horizontal": sobelHorizontal,
        sobelVertical,
        "sobel-vertical": sobelVertical,
        stackBlur,
        "stack-blur": stackBlur,
        transparency,
        unsharpMasking,
        "unsharp-masking": unsharpMasking
      };
      function kirsch() {
        return filter$1("kirsch-horizontal kirsch-vertical");
      }
      function sobel() {
        return filter$1("sobel-horizontal sobel-vertical");
      }
      function vintage() {
        return filter$1("brightness(15) saturation(-20) gamma(1.8)");
      }
      var multi$2 = {
        kirsch,
        sobel,
        vintage
      };
      var FilterList = _extends({}, image$1, pixel$1, matrix$1, multi$2);
      var _functions;
      var makeId = 0;
      var functions$1 = (_functions = {
        partial,
        multi: multi$1,
        merge: merge$1,
        weight,
        repeat,
        colorMatrix,
        each: each$1,
        eachXY,
        createRandomCount,
        createRandRange,
        createBitmap,
        createBlurMatrix,
        pack: pack$1,
        packXY,
        pixel,
        getBitmap,
        putBitmap,
        radian,
        convolution,
        parseParamNumber,
        filter: filter$1,
        clamp: clamp$1,
        fillColor,
        fillPixelColor
      }, defineProperty(_functions, "multi", multi$1), defineProperty(_functions, "merge", merge$1), defineProperty(_functions, "matches", matches$1), defineProperty(_functions, "parseFilter", parseFilter), defineProperty(_functions, "partial", partial), _functions);
      var LocalFilter = functions$1;
      function weight(arr) {
        var num = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return arr.map(function(i) {
          return i * num;
        });
      }
      function repeat(value, num) {
        var arr = new Array(num);
        for (var i = 0; i < num; i++) {
          arr[i] = value;
        }
        return arr;
      }
      function colorMatrix(pixels, i, matrix2) {
        var r = pixels[i], g3 = pixels[i + 1], b2 = pixels[i + 2], a = pixels[i + 3];
        fillColor(pixels, i, matrix2[0] * r + matrix2[1] * g3 + matrix2[2] * b2 + matrix2[3] * a, matrix2[4] * r + matrix2[5] * g3 + matrix2[6] * b2 + matrix2[7] * a, matrix2[8] * r + matrix2[9] * g3 + matrix2[10] * b2 + matrix2[11] * a, matrix2[12] * r + matrix2[13] * g3 + matrix2[14] * b2 + matrix2[15] * a);
      }
      function makeFilter$1(filter2) {
        if (typeof filter2 == "function") {
          return filter2;
        }
        if (typeof filter2 == "string") {
          filter2 = [filter2];
        }
        filter2 = filter2.slice(0);
        var filterName = filter2.shift();
        if (typeof filterName == "function") {
          return filterName;
        }
        var params = filter2;
        var filterFunction = FilterList[filterName] || LocalFilter[filterName];
        if (!filterFunction) {
          throw new Error(filterName + " is not filter. please check filter name.");
        }
        return filterFunction.apply(filterFunction, params);
      }
      function forLoop(max2) {
        var index2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var step = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var callback = arguments[3];
        var done = arguments[4];
        var functionDumpCount = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1e4;
        var frameTimer = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "full";
        var loopCount = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 50;
        var runIndex = index2;
        var timer = function timer2(callback2) {
          setTimeout(callback2, 0);
        };
        if (frameTimer == "requestAnimationFrame") {
          timer = requestAnimationFrame;
          functionDumpCount = 1e3;
        }
        if (frameTimer == "full") {
          timer = null;
          functionDumpCount = max2;
        }
        function makeFunction() {
          var count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 50;
          var arr = [].concat(toConsumableArray(Array(count)));
          var functionStrings = arr.map(function(countIndex) {
            return "cri = ri + i * s; if (cri >= mx) return {currentRunIndex: cri, i: null}; c(cri); i++;";
          }).join("\n");
          var smallLoopFunction = new Function("ri", "i", "s", "mx", "c", "\n            let cri = ri;\n            \n            " + functionStrings + "\n            \n            return {currentRunIndex: cri, i: i} \n        ");
          return smallLoopFunction;
        }
        function runCallback() {
          var smallLoopFunction = makeFunction(loopCount);
          var currentRunIndex = runIndex;
          var ret = {};
          var i = 0;
          while (i < functionDumpCount) {
            ret = smallLoopFunction(runIndex, i, step, max2, callback);
            if (ret.i == null) {
              currentRunIndex = ret.currentRunIndex;
              break;
            }
            i = ret.i;
            currentRunIndex = ret.currentRunIndex;
          }
          nextCallback(currentRunIndex);
        }
        function nextCallback(currentRunIndex) {
          if (currentRunIndex) {
            runIndex = currentRunIndex;
          } else {
            runIndex += step;
          }
          if (runIndex >= max2) {
            done();
            return;
          }
          if (timer) timer(runCallback);
          else runCallback();
        }
        runCallback();
      }
      function each$1(len, callback, done) {
        var opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        forLoop(len, 0, 4, function(i) {
          callback(
            i,
            i >> 2
            /* xyIndex */
          );
        }, function() {
          done();
        }, opt.functionDumpCount, opt.frameTimer, opt.loopCount);
      }
      function eachXY(len, width, callback, done) {
        var opt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
        forLoop(len, 0, 4, function(i) {
          var xyIndex = i >> 2;
          callback(i, xyIndex % width, Math.floor(xyIndex / width));
        }, function() {
          done();
        }, opt.functionDumpCount, opt.frameTimer, opt.loopCount);
      }
      function createRandRange(min2, max2, count) {
        var result = [];
        for (var i = 1; i <= count; i++) {
          var num = Math.random() * (max2 - min2) + min2;
          var sign = Math.floor(Math.random() * 10) % 2 == 0 ? -1 : 1;
          result.push(sign * num);
        }
        result.sort();
        var centerIndex = Math.floor(count >> 1);
        var a = result[centerIndex];
        result[centerIndex] = result[0];
        result[0] = a;
        return result;
      }
      function createRandomCount() {
        return [3 * 3, 4 * 4, 5 * 5, 6 * 6, 7 * 7, 8 * 8, 9 * 9, 10 * 10].sort(function(a, b2) {
          return 0.5 - Math.random();
        })[0];
      }
      function createBitmap(length, width, height) {
        return { pixels: new Uint8ClampedArray(length), width, height };
      }
      function putPixel(dstBitmap, srcBitmap, startX, startY) {
        var len = srcBitmap.pixels.length / 4;
        var dstX = 0, dstY = 0, x = 0, y2 = 0, srcIndex = 0, dstIndex = 0;
        for (var i = 0; i < len; i++) {
          x = i % srcBitmap.width, y2 = Math.floor(i / srcBitmap.width);
          dstX = startX + x;
          dstY = startY + y2;
          if (dstX > dstBitmap.width) continue;
          if (dstY > dstBitmap.height) continue;
          srcIndex = y2 * srcBitmap.width + x << 2;
          dstIndex = dstY * dstBitmap.width + dstX << 2;
          dstBitmap.pixels[dstIndex] = srcBitmap.pixels[srcIndex];
          dstBitmap.pixels[dstIndex + 1] = srcBitmap.pixels[srcIndex + 1];
          dstBitmap.pixels[dstIndex + 2] = srcBitmap.pixels[srcIndex + 2];
          dstBitmap.pixels[dstIndex + 3] = srcBitmap.pixels[srcIndex + 3];
        }
      }
      function getPixel(srcBitmap, dstBitmap, startX, startY) {
        var len = dstBitmap.pixels.length >> 2;
        var srcX = 0, srcY = 0, x = 0, y2 = 0, srcIndex = 0, dstIndex = 0;
        for (var i = 0; i < len; i++) {
          var x = i % dstBitmap.width, y2 = Math.floor(i / dstBitmap.width);
          srcX = startX + x;
          srcY = startY + y2;
          if (srcX > srcBitmap.width) continue;
          if (srcY > srcBitmap.height) continue;
          srcIndex = srcY * srcBitmap.width + srcX << 2;
          dstIndex = y2 * dstBitmap.width + x << 2;
          dstBitmap.pixels[dstIndex] = srcBitmap.pixels[srcIndex];
          dstBitmap.pixels[dstIndex + 1] = srcBitmap.pixels[srcIndex + 1];
          dstBitmap.pixels[dstIndex + 2] = srcBitmap.pixels[srcIndex + 2];
          dstBitmap.pixels[dstIndex + 3] = srcBitmap.pixels[srcIndex + 3];
        }
      }
      function cloneBitmap(bitmap) {
        var padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var width = bitmap.width + padding;
        var height = bitmap.height + padding;
        var newBitmap = { pixels: new Uint8ClampedArray(width * height * 4), width, height };
        return newBitmap;
      }
      function getBitmap(bitmap, area) {
        return Canvas.getBitmap(bitmap, area);
      }
      function putBitmap(bitmap, subBitmap, area) {
        return Canvas.putBitmap(bitmap, subBitmap, area);
      }
      function parseParamNumber(param) {
        if (typeof param === "string") {
          param = param.replace(/deg/, "");
          param = param.replace(/px/, "");
        }
        return +param;
      }
      var filter_regexp = /(([\w_\-]+)(\(([^\)]*)\))?)+/gi;
      function pack$1(callback) {
        return function(bitmap, done) {
          each$1(bitmap.pixels.length, function(i, xyIndex) {
            callback(bitmap.pixels, i, xyIndex, bitmap.pixels[i], bitmap.pixels[i + 1], bitmap.pixels[i + 2], bitmap.pixels[i + 3]);
          }, function() {
            done(bitmap);
          });
        };
      }
      function makePrebuildUserFilterList(arr) {
        var codeString = arr.map(function(it3) {
          return " \n            " + it3.userFunction.$preContext + "\n\n            " + it3.userFunction.$preCallbackString + "\n\n            $r = clamp($r); $g = clamp($g); $b = clamp($b); $a = clamp($a);\n        ";
        }).join("\n\n");
        var rootContextObject = { clamp: clamp$1, Color: Color$1 };
        arr.forEach(function(it3) {
          Object.assign(rootContextObject, it3.userFunction.rootContextObject);
        });
        var rootContextDefine = "const " + Object.keys(rootContextObject).map(function(key) {
          return " " + key + " = $rc." + key + " ";
        }).join(",");
        var FunctionCode = " \n    let $r = $p[$pi], $g = $p[$pi+1], $b = $p[$pi+2], $a = $p[$pi+3];\n    \n    " + rootContextDefine + "\n\n    " + codeString + "\n    \n    $p[$pi] = $r; $p[$pi+1] = $g; $p[$pi+2] = $b; $p[$pi+3] = $a;\n    ";
        var userFunction = new Function("$p", "$pi", "$rc", FunctionCode);
        return function($pixels, $pixelIndex) {
          userFunction($pixels, $pixelIndex, rootContextObject);
        };
      }
      function makeUserFilterFunctionList(arr) {
        var rootContextObject = {};
        var list = arr.map(function(it3) {
          var newKeys = [];
          Object.keys(it3.context).forEach(function(key, i) {
            newKeys[key] = "n$" + makeId++ + key + "$";
          });
          Object.keys(it3.rootContext).forEach(function(key, i) {
            newKeys[key] = "r$" + makeId++ + key + "$";
            rootContextObject[newKeys[key]] = it3.rootContext[key];
          });
          var preContext2 = Object.keys(it3.context).filter(function(key) {
            if (typeof it3.context[key] === "number" || typeof it3.context[key] === "string") {
              return false;
            } else if (Array.isArray(it3.context[key])) {
              if (typeof it3.context[key][0] == "number" || typeof it3.context[key][0] == "string") {
                return false;
              }
            }
            return true;
          }).map(function(key, i) {
            return [newKeys[key], JSON.stringify(it3.context[key])].join(" = ");
          });
          var preCallbackString2 = it3.callback;
          if (typeof it3.callback === "function") {
            preCallbackString2 = it3.callback.toString().split("{");
            preCallbackString2.shift();
            preCallbackString2 = preCallbackString2.join("{");
            preCallbackString2 = preCallbackString2.split("}");
            preCallbackString2.pop();
            preCallbackString2 = preCallbackString2.join("}");
          }
          Object.keys(newKeys).forEach(function(key) {
            var newKey = newKeys[key];
            if (typeof it3.context[key] === "number" || typeof it3.context[key] === "string") {
              preCallbackString2 = preCallbackString2.replace(new RegExp("\\" + key, "g"), it3.context[key]);
            } else if (Array.isArray(it3.context[key])) {
              if (typeof it3.context[key][0] == "number" || typeof it3.context[key][0] == "string") {
                it3.context[key].forEach(function(item, index2) {
                  preCallbackString2 = preCallbackString2.replace(new RegExp("\\" + key + "\\[" + index2 + "\\]", "g"), item);
                });
              } else {
                preCallbackString2 = preCallbackString2.replace(new RegExp("\\" + key, "g"), newKey);
              }
            } else {
              preCallbackString2 = preCallbackString2.replace(new RegExp("\\" + key, "g"), newKey);
            }
          });
          return { preCallbackString: preCallbackString2, preContext: preContext2 };
        });
        var preContext = list.map(function(it3, i) {
          return it3.preContext.length ? "const " + it3.preContext + ";" : "";
        }).join("\n\n");
        var preCallbackString = list.map(function(it3) {
          return it3.preCallbackString;
        }).join("\n\n");
        var FunctionCode = " \n    let $r = $pixels[$pixelIndex], $g = $pixels[$pixelIndex+1], $b = $pixels[$pixelIndex+2], $a = $pixels[$pixelIndex+3];\n\n    " + preContext + "\n\n    " + preCallbackString + "\n    \n    $pixels[$pixelIndex] = $r\n    $pixels[$pixelIndex+1] = $g \n    $pixels[$pixelIndex+2] = $b   \n    $pixels[$pixelIndex+3] = $a   \n    ";
        var userFunction = new Function("$pixels", "$pixelIndex", "$clamp", "$Color", FunctionCode);
        userFunction.$preCallbackString = preCallbackString;
        userFunction.$preContext = preContext;
        userFunction.rootContextObject = rootContextObject;
        return userFunction;
      }
      function makeUserFilterFunction(callback) {
        var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var rootContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return makeUserFilterFunctionList([{ callback, context, rootContext }]);
      }
      function pixel(callback) {
        var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var rootContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var userFunction = makeUserFilterFunction(callback, context, rootContext);
        var returnCallback = function returnCallback2(bitmap, done) {
        };
        returnCallback.userFunction = userFunction;
        return returnCallback;
      }
      var ColorListIndex = [0, 1, 2, 3];
      function swapColor(pixels, startIndex, endIndex) {
        ColorListIndex.forEach(function(i) {
          var temp = pixels[startIndex + i];
          pixels[startIndex + i] = pixels[endIndex + i];
          pixels[endIndex + i] = temp;
        });
      }
      function packXY(callback) {
        return function(bitmap, done) {
          var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          eachXY(bitmap.pixels.length, bitmap.width, function(i, x, y2) {
            callback(bitmap.pixels, i, x, y2);
          }, function() {
            done(bitmap);
          }, opt);
        };
      }
      function radian(degree) {
        return Matrix.CONSTANT.radian(degree);
      }
      function createBlurMatrix() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
        var count = Math.pow(amount, 2);
        var value = 1 / count;
        return repeat(value, count);
      }
      function fillColor(pixels, i, r, g3, b2, a) {
        if (arguments.length == 3) {
          var _arguments$ = arguments[2], r = _arguments$.r, g3 = _arguments$.g, b2 = _arguments$.b, a = _arguments$.a;
        }
        if (typeof r == "number") {
          pixels[i] = r;
        }
        if (typeof g3 == "number") {
          pixels[i + 1] = g3;
        }
        if (typeof b2 == "number") {
          pixels[i + 2] = b2;
        }
        if (typeof a == "number") {
          pixels[i + 3] = a;
        }
      }
      function fillPixelColor(targetPixels, targetIndex, sourcePixels, sourceIndex) {
        fillColor(targetPixels, targetIndex, sourcePixels[sourceIndex], sourcePixels[sourceIndex + 1], sourcePixels[sourceIndex + 2], sourcePixels[sourceIndex + 3]);
      }
      function createWeightTable(weights) {
        var min2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 255;
        var weightTable = [];
        weightTable = weights.map(function(w2, i) {
          return [];
        });
        weights.forEach(function(w2, i) {
          if (w2 != 0) {
            var data = weightTable[i];
            for (var i = min2; i <= max2; i++) {
              data[i] = w2 * i;
            }
          }
        });
        return weightTable;
      }
      function createSubPixelWeightFunction(weights, weightTable, width, height, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);
        var alphaFac = opaque ? 1 : 0;
        var FunctionCode = "let r = 0, g = 0, b = 0, a = 0, scy = 0, scx =0, si = 0; ";
        var R2 = [];
        var G3 = [];
        var B2 = [];
        var A2 = [];
        weights.forEach(function(wt2, index2) {
          var cy = Math.floor(index2 / side);
          var cx = index2 % side;
          var distY = cy - halfSide;
          var distX = cx - halfSide;
          if (wt2 == 0) {
            return;
          }
          R2.push("$t[" + index2 + "][$sp[(($sy + (" + distY + ")) * " + width + " + ($sx + (" + distX + "))) * 4]]");
          G3.push("$t[" + index2 + "][$sp[(($sy + (" + distY + ")) * " + width + " + ($sx + (" + distX + "))) * 4 + 1]]");
          B2.push("$t[" + index2 + "][$sp[(($sy + (" + distY + ")) * " + width + " + ($sx + (" + distX + "))) * 4 + 2]]");
          A2.push("$t[" + index2 + "][$sp[(($sy + (" + distY + ")) * " + width + " + ($sx + (" + distX + "))) * 4 + 3]]");
        });
        FunctionCode += "r = " + R2.join(" + ") + "; g = " + G3.join(" + ") + "; b = " + B2.join(" + ") + "; a = " + A2.join(" + ") + ";";
        FunctionCode += "$dp[$di] = r; $dp[$di+1] = g;$dp[$di+2] = b;$dp[$di+3] = a + (" + alphaFac + ")*(255-a); ";
        var subPixelFunction = new Function("$dp", "$sp", "$di", "$sx", "$sy", "$t", FunctionCode);
        return function($dp, $sp, $di, $sx, $sy) {
          subPixelFunction($dp, $sp, $di, $sx, $sy, weightTable);
        };
      }
      function convolution(weights) {
        var opaque = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        var weightTable = createWeightTable(weights);
        return function(bitmap, done) {
          var side = Math.round(Math.sqrt(weights.length));
          var padding = side * 2;
          var sourceBitmap = cloneBitmap(bitmap, padding);
          putPixel(sourceBitmap, bitmap, side, side);
          var newBitmap = createBitmap(sourceBitmap.pixels.length, sourceBitmap.width, sourceBitmap.height);
          var returnBitmap = createBitmap(bitmap.pixels.length, bitmap.width, bitmap.height);
          var subPixelWeightFunction = createSubPixelWeightFunction(weights, weightTable, sourceBitmap.width, sourceBitmap.height, opaque);
          var len = bitmap.pixels.length / 4;
          for (var i = 0; i < len; i++) {
            var xyIndex = i, x = xyIndex % bitmap.width + side, y2 = Math.floor(xyIndex / bitmap.width) + side;
            subPixelWeightFunction(newBitmap.pixels, sourceBitmap.pixels, (y2 * sourceBitmap.width + x) * 4, x, y2);
          }
          getPixel(newBitmap, returnBitmap, side, side);
          done(returnBitmap);
        };
      }
      function matches$1(str) {
        var ret = Color$1.convertMatches(str);
        var matches2 = ret.str.match(filter_regexp);
        var result = [];
        if (!matches2) {
          return result;
        }
        result = matches2.map(function(it3) {
          return { filter: it3, origin: Color$1.reverseMatches(it3, ret.matches) };
        });
        var pos = { next: 0 };
        result = result.map(function(item) {
          var startIndex = str.indexOf(item.origin, pos.next);
          item.startIndex = startIndex;
          item.endIndex = startIndex + item.origin.length;
          item.arr = parseFilter(item.origin);
          pos.next = item.endIndex;
          return item;
        }).filter(function(it3) {
          if (!it3.arr.length) return false;
          return true;
        });
        return result;
      }
      function parseFilter(filterString) {
        var ret = Color$1.convertMatches(filterString);
        var matches2 = ret.str.match(filter_regexp);
        if (!matches2[0]) {
          return [];
        }
        var arr = matches2[0].split("(");
        var filterName = arr.shift();
        var filterParams = [];
        if (arr.length) {
          filterParams = arr.shift().split(")")[0].split(",").map(function(f) {
            return Color$1.reverseMatches(f, ret.matches);
          });
        }
        var result = [filterName].concat(toConsumableArray(filterParams)).map(Color$1.trim);
        return result;
      }
      function clamp$1(num) {
        return Math.min(255, num);
      }
      function filter$1(str) {
        return merge$1(matches$1(str).map(function(it3) {
          return it3.arr;
        }));
      }
      function makeGroupedFilter$1() {
        var filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var groupedFilter = [];
        var group = [];
        for (var i = 0, len = filters.length; i < len; i++) {
          var f = filters[i];
          if (f.userFunction) {
            group.push(f);
          } else {
            if (group.length) {
              groupedFilter.push([].concat(toConsumableArray(group)));
            }
            groupedFilter.push(f);
            group = [];
          }
        }
        if (group.length) {
          groupedFilter.push([].concat(toConsumableArray(group)));
        }
        groupedFilter.forEach(function(filter2, index2) {
          if (Array.isArray(filter2)) {
            groupedFilter[index2] = function() {
              var userFunction = makePrebuildUserFilterList(filter2);
              return function(bitmap, done) {
                for (var i2 = 0, len2 = bitmap.pixels.length; i2 < len2; i2 += 4) {
                  userFunction(bitmap.pixels, i2);
                }
                done(bitmap);
              };
            }();
          }
        });
        return groupedFilter;
      }
      function multi$1() {
        for (var _len = arguments.length, filters = Array(_len), _key = 0; _key < _len; _key++) {
          filters[_key] = arguments[_key];
        }
        filters = filters.map(function(filter2) {
          return makeFilter$1(filter2);
        }).filter(function(f) {
          return f;
        });
        filters = makeGroupedFilter$1(filters);
        var max2 = filters.length;
        return function(bitmap, done) {
          var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var currentBitmap = bitmap;
          var index2 = 0;
          function runFilter() {
            filters[index2].call(null, currentBitmap, function(nextBitmap) {
              currentBitmap = nextBitmap;
              nextFilter();
            }, opt);
          }
          function nextFilter() {
            index2++;
            if (index2 >= max2) {
              done(currentBitmap);
              return;
            }
            runFilter();
          }
          runFilter();
        };
      }
      function merge$1(filters) {
        return multi$1.apply(void 0, toConsumableArray(filters));
      }
      function partial(area) {
        var allFilter = null;
        for (var _len2 = arguments.length, filters = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          filters[_key2 - 1] = arguments[_key2];
        }
        if (filters.length == 1 && typeof filters[0] === "string") {
          allFilter = filter$1(filters[0]);
        } else {
          allFilter = merge$1(filters);
        }
        return function(bitmap, done) {
          var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          allFilter(getBitmap(bitmap, area), function(newBitmap) {
            done(putBitmap(bitmap, newBitmap, area));
          }, opt);
        };
      }
      function parseParamNumber$1(param) {
        if (typeof param === "string") {
          param = param.replace(/deg/, "");
          param = param.replace(/px/, "");
        }
        return +param;
      }
      function weight$1(arr) {
        var num = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return arr.map(function(i) {
          return i * num;
        });
      }
      var SHADER_INDEX = 0;
      function convolutionString(count) {
        var width = Math.sqrt(count);
        var half = Math.floor(width / 2);
        return [].concat(toConsumableArray(Array(count))).map(function(it3, index2) {
          var y2 = Math.floor(index2 / width) - half;
          var x = index2 % width - half;
          return "texture(u_image, v_texCoord + onePixel * vec2(" + x + ", " + y2 + ")) * u_kernel" + count + "[" + index2 + "]";
        }).join(" + \n");
      }
      function multi$3(str) {
        return [].concat(Array.prototype.slice.call(arguments));
      }
      function convolution$1(arr) {
        return {
          type: "convolution",
          length: arr.length,
          content: arr
        };
      }
      function makeShader(str, index2) {
        return "\n        if (u_filterIndex == " + index2 + ".0) {\n            " + str + "\n        }\n    ";
      }
      function shader(str, options) {
        return {
          type: "shader",
          index: SHADER_INDEX,
          options,
          content: makeShader(str, SHADER_INDEX++)
        };
      }
      function makeVertexShaderSource() {
        return "#version 300 es \n\n        in vec2 a_position;\n        in vec2 a_texCoord; \n\n        uniform vec2 u_resolution;\n        uniform float u_flipY;\n\n        out vec2 v_texCoord; \n\n        void main() {\n            vec2 zeroToOne = a_position / u_resolution;\n\n            vec2 zeroToTwo = zeroToOne * 2.0;\n\n            vec2 clipSpace = zeroToTwo - 1.0;\n\n            gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);\n\n            v_texCoord = a_texCoord;\n\n        }\n    ";
      }
      function makeConvolution(count) {
        return "\n    \n    if (u_kernelSelect == " + count + ".0) {\n        vec4 colorSum = " + convolutionString(count) + "; \n\n        outColor = vec4((colorSum / u_kernel" + count + "Weight).rgb, 1);\n        \n    }\n    ";
      }
      function makeFragmentShaderSource(filterShaderList) {
        var filterContent = filterShaderList.filter(function(f) {
          return f.type == "shader";
        }).map(function(f) {
          return f.content;
        }).join("\n\n");
        var weightTable = { "9": true };
        filterShaderList.filter(function(f) {
          return f.type == "convolution";
        }).forEach(function(f) {
          weightTable[f.length] = true;
        });
        var convolutionString2 = Object.keys(weightTable).map(function(len) {
          return makeConvolution(+len);
        }).join("\n");
        return "#version 300 es\n\n    precision highp int;\n    precision mediump float;\n    \n    uniform sampler2D u_image;\n\n    // 3 is 3x3 matrix kernel \n    uniform float u_kernelSelect;\n    uniform float u_filterIndex;\n\n    uniform float u_kernel9[9];\n    uniform float u_kernel9Weight;\n    uniform float u_kernel25[25];\n    uniform float u_kernel25Weight;\n    uniform float u_kernel49[49];\n    uniform float u_kernel49Weight;\n    uniform float u_kernel81[81];\n    uniform float u_kernel81Weight;    \n\n    in vec2 v_texCoord;\n    \n    out vec4 outColor;\n\n    float random (vec2 st) {\n        return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n    } \n\n    // \n    vec3 rgb2hsv(vec3 c)\n    {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n        vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n\n    vec3 hsv2rgb(vec3 c)\n    {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n    \n    void main() {\n        vec4 pixelColor = texture(u_image, v_texCoord);\n        vec2 onePixel = vec2(1) / vec2(textureSize(u_image, 0));                \n\n        " + filterContent + "\n\n        " + convolutionString2 + "\n\n    }";
      }
      function colorToVec4(color2) {
        color2 = [color2.r / 255, color2.g / 255, color2.b / 255, color2.a || 0].map(toFloatString);
        return "vec4(" + color2 + ")";
      }
      function toFloatString(number) {
        if (number == Math.floor(number)) {
          return number + ".0";
        }
        return number;
      }
      function blur$1() {
        return convolution$1([1, 1, 1, 1, 1, 1, 1, 1, 1]);
      }
      function normal() {
        return convolution$1([0, 0, 0, 0, 1, 0, 0, 0, 0]);
      }
      function emboss$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 4;
        amount = parseParamNumber$1(amount);
        return convolution$1([amount * -2, -amount, 0, -amount, 1, amount, 0, amount, amount * 2]);
      }
      function gaussianBlur$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = parseParamNumber$1(amount) * (1 / 16);
        return convolution$1(weight$1([1, 2, 1, 2, 4, 2, 1, 2, 1], C));
      }
      function gaussianBlur5x$1() {
        return convolution$1([1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, 36, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1]);
      }
      function grayscale2$1() {
        return convolution$1([0.3, 0.3, 0.3, 0, 0, 0.59, 0.59, 0.59, 0, 0, 0.11, 0.11, 0.11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      }
      function kirschHorizontal$1() {
        return convolution$1([5, 5, 5, -3, 0, -3, -3, -3, -3]);
      }
      function kirschVertical$1() {
        return convolution$1([5, -3, -3, 5, 0, -3, 5, -3, -3]);
      }
      function laplacian$1() {
        return convolution$1([-1, -1, -1, -1, 8, -1, -1, -1, -1]);
      }
      function laplacian5x$1() {
        return convolution$1([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);
      }
      function motionBlur$1() {
        return convolution$1([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]);
      }
      function motionBlur2$1() {
        return convolution$1([1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1]);
      }
      function motionBlur3$1() {
        return convolution$1([1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]);
      }
      function negative$1() {
        return convolution$1([-1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1]);
      }
      function sepia2$1() {
        return convolution$1([0.393, 0.349, 0.272, 0, 0, 0.769, 0.686, 0.534, 0, 0, 0.189, 0.168, 0.131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      }
      function sharpen$1() {
        return convolution$1([0, -1, 0, -1, 5, -1, 0, -1, 0]);
      }
      function sobelHorizontal$1() {
        return convolution$1([-1, -2, -1, 0, 0, 0, 1, 2, 1]);
      }
      function sobelVertical$1() {
        return convolution$1([-1, 0, 1, -2, 0, 2, -1, 0, 1]);
      }
      function transparency$1() {
        return convolution$1([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.3, 0, 0, 0, 0, 0, 1]);
      }
      function unsharpMasking$1() {
        return convolution$1(weight$1([1, 4, 6, 4, 1, 4, 16, 24, 16, 4, 6, 24, -476, 24, 6, 4, 16, 24, 16, 4, 1, 4, 6, 4, 1], -1 / 256));
      }
      var matrix$2 = {
        blur: blur$1,
        normal,
        emboss: emboss$1,
        gaussianBlur: gaussianBlur$1,
        "gaussian-blur": gaussianBlur$1,
        gaussianBlur5x: gaussianBlur5x$1,
        "gaussian-blur-5x": gaussianBlur5x$1,
        grayscale2: grayscale2$1,
        kirschHorizontal: kirschHorizontal$1,
        "kirsch-horizontal": kirschHorizontal$1,
        kirschVertical: kirschVertical$1,
        "kirsch-vertical": kirschVertical$1,
        laplacian: laplacian$1,
        laplacian5x: laplacian5x$1,
        "laplacian-5x": laplacian5x$1,
        motionBlur: motionBlur$1,
        "motion-blur": motionBlur$1,
        motionBlur2: motionBlur2$1,
        "motion-blur-2": motionBlur2$1,
        motionBlur3: motionBlur3$1,
        "motion-blur-3": motionBlur3$1,
        negative: negative$1,
        sepia2: sepia2$1,
        sharpen: sharpen$1,
        sobelHorizontal: sobelHorizontal$1,
        "sobel-horizontal": sobelHorizontal$1,
        sobelVertical: sobelVertical$1,
        "sobel-vertical": sobelVertical$1,
        transparency: transparency$1,
        unsharpMasking: unsharpMasking$1,
        "unsharp-masking": unsharpMasking$1
      };
      function bitonal$1(darkColor, lightColor) {
        var threshold2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.5;
        var checkVlue = toFloatString(threshold2);
        var darkColorString = colorToVec4(Color$1.parse(darkColor));
        var lightColorString = colorToVec4(Color$1.parse(lightColor));
        return shader("\n        if ((pixelColor.r + pixelColor.g + pixelColor.b) > " + checkVlue + ") {\n            outColor = vec4(" + lightColorString + ".rgb, pixelColor.a);\n        } else {\n            outColor = vec4(" + darkColorString + ".rgb, pixelColor.a);\n        }\n    ");
      }
      function brightness$2() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        outColor = pixelColor + (" + C + ");\n    ");
      }
      function matrix$3() {
        var $a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var $b2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var $c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var $d = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var $e3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var $f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
        var $g2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
        var $h = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 0;
        var $i = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0;
        var $j = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0;
        var $k = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0;
        var $l2 = arguments.length > 11 && arguments[11] !== void 0 ? arguments[11] : 0;
        var $m = arguments.length > 12 && arguments[12] !== void 0 ? arguments[12] : 0;
        var $n3 = arguments.length > 13 && arguments[13] !== void 0 ? arguments[13] : 0;
        var $o2 = arguments.length > 14 && arguments[14] !== void 0 ? arguments[14] : 0;
        var $p = arguments.length > 15 && arguments[15] !== void 0 ? arguments[15] : 0;
        var matrix2 = [$a2, $b2, $c, $d, $e3, $f, $g2, $h, $i, $j, $k, $l2, $m, $n3, $o2, $p].map(toFloatString);
        return shader("\n\n        outColor = vec4(\n            " + matrix2[0] + " * pixelColor.r + " + matrix2[1] + " * pixelColor.g + " + matrix2[2] + " * pixelColor.b + " + matrix2[3] + " * pixelColor.a,\n            " + matrix2[4] + " * pixelColor.r + " + matrix2[5] + " * pixelColor.g + " + matrix2[6] + " * pixelColor.b + " + matrix2[7] + " * pixelColor.a,\n            " + matrix2[8] + " * pixelColor.r + " + matrix2[9] + " * pixelColor.g + " + matrix2[10] + " * pixelColor.b + " + matrix2[11] + " * pixelColor.a,\n            " + matrix2[12] + " * pixelColor.r + " + matrix2[13] + " * pixelColor.g + " + matrix2[14] + " * pixelColor.b + " + matrix2[15] + " * pixelColor.a\n        ); \n    ");
      }
      function brownie$1() {
        return matrix$3(0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, 0, 0, 0, 1);
      }
      function clip$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        outColor = vec4(\n            (pixelColor.r > 1.0 - " + C + ") ? 1.0 : 0.0,\n            (pixelColor.g > 1.0 - " + C + ") ? 1.0 : 0.0,\n            (pixelColor.b > 1.0 - " + C + ") ? 1.0 : 0.0,\n            pixelColor.a \n        );\n    ");
      }
      function chaos() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        vec2 st = pixelColor.st;\n        st *= " + C + ";\n        \n        vec2 ipos = floor(st);  // get the integer coords\n\n        vec3 color = vec3(random( ipos ));\n\n        outColor = vec4(color, pixelColor.a);\n    ");
      }
      function contrast$2() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        outColor = pixelColor * " + C + ";\n    ");
      }
      function gamma$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        outColor = vec4(pow(pixelColor.r, " + C + "), pow(pixelColor.g, " + C + "), pow(pixelColor.b, " + C + "), pixelColor.a );\n    ");
      }
      function gradient$2() {
        var params = [].concat(Array.prototype.slice.call(arguments));
        if (params.length === 1 && typeof params[0] === "string") {
          params = Color$1.convertMatchesArray(params[0]);
        }
        params = params.map(function(arg) {
          return arg;
        }).join(", ");
        var colors = Color$1.parseGradient(params);
        colors[0][1] = 0;
        colors[colors.length - 1][1] = 1;
        colors = colors.map(function(c2) {
          var _Color$parse = Color$1.parse(c2[0]), r = _Color$parse.r, g3 = _Color$parse.g, b2 = _Color$parse.b, a = _Color$parse.a;
          return [{ r, g: g3, b: b2, a }, c2[1]];
        });
        var temp = [];
        for (var i = 0, len = colors.length; i < len - 1; i++) {
          var start = colors[i];
          var end = colors[i + 1];
          var startColor = colorToVec4(start[0]);
          var endColor = colorToVec4(end[0]);
          var startRate = toFloatString(start[1]);
          var endRate = toFloatString(end[1]);
          temp.push("\n            if (" + startRate + " <= rate && rate < " + endRate + ") {\n                outColor = mix(" + startColor + ", " + endColor + ", (rate - " + startRate + ")/(" + endRate + " - " + startRate + "));\n            }\n        ");
        }
        return shader("\n        float rate = (pixelColor.r * 0.2126 + pixelColor.g * 0.7152 + pixelColor.b * 0.0722); \n\n        " + temp.join("\n") + "        \n    ");
      }
      function grayscale$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = parseParamNumber$1(amount);
        if (C > 1) C = 1;
        return matrix$3(0.2126 + 0.7874 * (1 - C), 0.7152 - 0.7152 * (1 - C), 0.0722 - 0.0722 * (1 - C), 0, 0.2126 - 0.2126 * (1 - C), 0.7152 + 0.2848 * (1 - C), 0.0722 - 0.0722 * (1 - C), 0, 0.2126 - 0.2126 * (1 - C), 0.7152 - 0.7152 * (1 - C), 0.0722 + 0.9278 * (1 - C), 0, 0, 0, 0, 1);
      }
      function hue$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        vec3 hsv = rgb2hsv(pixelColor.rgb);\n        hsv.x += " + C + ";\n        outColor = vec4(hsv2rgb(hsv).rgb, pixelColor.a);\n    ");
      }
      function invert$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        outColor = vec4(\n            (1.0 - pixelColor.r) * " + C + ",\n            (1.0 - pixelColor.g) * " + C + ",\n            (1.0 - pixelColor.b) * " + C + ",\n            pixelColor.a\n        );\n    ");
      }
      function kodachrome$1() {
        return matrix$3(1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 0, 0, 0, 1);
      }
      function noise$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = Math.abs(parseParamNumber$1(amount));
        var min2 = toFloatString(-C);
        var max2 = toFloatString(C);
        return shader("\n        float rnd = " + min2 + " + random( pixelColor.st ) * (" + max2 + " - " + min2 + ");\n\n        outColor = vec4(pixelColor.rgb + rnd, 1.0);\n    ");
      }
      function opacity$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = toFloatString(parseParamNumber$1(amount));
        return shader("\n        outColor = vec4(pixelColor.rgb, pixelColor.a * " + C + ");\n    ");
      }
      function polaroid$1() {
        return matrix$3(1.438, -0.062, -0.062, 0, -0.122, 1.378, -0.122, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 1);
      }
      function saturation$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var L3 = 1 - Math.abs(parseParamNumber$1(amount));
        return matrix$3(L3, 0, 0, 0, 0, L3, 0, 0, 0, 0, L3, 0, 0, 0, 0, L3);
      }
      function sepia$1() {
        var amount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var C = parseParamNumber$1(amount);
        if (C > 1) C = 1;
        return matrix$3(0.393 + 0.607 * (1 - C), 0.769 - 0.769 * (1 - C), 0.189 - 0.189 * (1 - C), 0, 0.349 - 0.349 * (1 - C), 0.686 + 0.314 * (1 - C), 0.168 - 0.168 * (1 - C), 0, 0.272 - 0.272 * (1 - C), 0.534 - 0.534 * (1 - C), 0.131 + 0.869 * (1 - C), 0, 0, 0, 0, 1);
      }
      function shade$1() {
        var redValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var greenValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var blueValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var r = toFloatString(parseParamNumber$1(redValue) / 255);
        var g3 = toFloatString(parseParamNumber$1(greenValue) / 255);
        var b2 = toFloatString(parseParamNumber$1(blueValue) / 255);
        return shader("\n        outColor = vec4(\n            pixelColor.r * " + r + ",\n            pixelColor.g * " + g3 + ",\n            pixelColor.b * " + b2 + ",\n            pixelColor.a\n        );\n    ");
      }
      function shift$1() {
        return matrix$3(1.438, -0.062, -0.062, 0, -0.122, 1.378, -0.122, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 1);
      }
      function solarize$1(redValue, greenValue, blueValue) {
        var r = toFloatString(parseParamNumber$1(redValue));
        var g3 = toFloatString(parseParamNumber$1(greenValue));
        var b2 = toFloatString(parseParamNumber$1(blueValue));
        return shader("\n        outColor = vec4(\n            (pixelColor.r < " + r + ") ? 1.0 - pixelColor.r: pixelColor.r,\n            (pixelColor.g < " + g3 + ") ? 1.0 - pixelColor.g: pixelColor.g,\n            (pixelColor.b < " + b2 + ") ? 1.0 - pixelColor.b: pixelColor.b,\n            pixelColor.a\n        );\n    ");
      }
      function technicolor$1() {
        return matrix$3(1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 0, 0, 0, 1);
      }
      function thresholdColor$1() {
        var scale2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        scale2 = toFloatString(parseParamNumber$1(scale2));
        return shader("\n        float c = ( (pixelColor.r * 0.2126 + pixelColor.g * 0.7152 + pixelColor.b * 0.0722) ) >= " + scale2 + " ? 1.0 : 0.0;\n\n        outColor = vec4(c, c, c, pixelColor.a);\n    ");
      }
      function threshold$1() {
        var scale2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 200;
        var amount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
        return thresholdColor$1(scale2, amount, false);
      }
      function tint$1() {
        var redTint = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        var greenTint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var blueTint = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var r = parseParamNumber$1(redTint);
        var g3 = parseParamNumber$1(greenTint);
        var b2 = parseParamNumber$1(blueTint);
        return shader("\n        outColor = vec4(\n            pixelColor.r += (1 - pixelColor.r) * " + r + ",\n            pixelColor.g += (1 - pixelColor.g) * " + g3 + ",\n            pixelColor.b += (1 - pixelColor.b) * " + b2 + ",\n            pixelColor.a\n        );\n    ");
      }
      var pixel$2 = {
        bitonal: bitonal$1,
        brightness: brightness$2,
        brownie: brownie$1,
        clip: clip$1,
        chaos,
        contrast: contrast$2,
        gamma: gamma$1,
        gradient: gradient$2,
        grayscale: grayscale$1,
        hue: hue$1,
        invert: invert$1,
        kodachrome: kodachrome$1,
        matrix: matrix$3,
        noise: noise$1,
        opacity: opacity$1,
        polaroid: polaroid$1,
        saturation: saturation$1,
        sepia: sepia$1,
        shade: shade$1,
        shift: shift$1,
        solarize: solarize$1,
        technicolor: technicolor$1,
        threshold: threshold$1,
        "threshold-color": thresholdColor$1,
        tint: tint$1
      };
      function kirsch$1() {
        return multi$3("kirsch-horizontal kirsch-vertical");
      }
      function sobel$1() {
        return multi$3("sobel-horizontal sobel-vertical");
      }
      function vintage$1() {
        return multi$3("brightness(0.15) saturation(-0.2) gamma(1.8)");
      }
      var multi$4 = {
        kirsch: kirsch$1,
        sobel: sobel$1,
        vintage: vintage$1
      };
      var GLFilter = _extends({}, matrix$2, pixel$2, multi$4);
      var TEXTURE_INDEX = 0;
      var GLCanvas = function() {
        function GLCanvas2() {
          var opt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            width: "400px",
            height: "300px"
          };
          classCallCheck(this, GLCanvas2);
          this.img = opt.img;
          this.width = parseFloat(this.img.width || opt.width || "400px");
          this.height = parseFloat(this.img.height || opt.height || "300px");
          this.init();
        }
        createClass(GLCanvas2, [{
          key: "resize",
          value: function resize2() {
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            this.canvas.style.width = this.width + "px";
            this.canvas.style.height = this.height + "px";
            this.viewport();
          }
          /* Canvas 비우기, 비울 때 색 지정하기  */
        }, {
          key: "clear",
          value: function clear() {
            var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var g3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var b2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            var gl2 = this.gl;
            gl2.clearColor(r, g3, b2, a);
            gl2.clear(gl2.COLOR_BUFFER_BIT | gl2.DEPTH_BUFFER_BIT);
          }
          /* viewport 설정, 기본적으로 canvas 의 크기로 고정  */
        }, {
          key: "viewport",
          value: function viewport(x, y2, width, height) {
            var gl2 = this.gl;
            gl2.viewport(x || 0, y2 || 0, width || gl2.canvas.width, height || gl2.canvas.height);
          }
          // canvas 초기화 
          // gl context 구하기 
        }, {
          key: "initCanvas",
          value: function initCanvas(vertexSource, fragmentSource) {
            this.canvas = document.createElement("canvas");
            this.gl = this.canvas.getContext("webgl2");
            if (!this.gl) {
              throw new Error("you need webgl2 support");
            }
            this.program = this.createProgram(vertexSource, fragmentSource);
            this.resize();
            this.initBuffer();
          }
        }, {
          key: "draw",
          value: function draw() {
            var primitiveType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "TRIANGLES";
            var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var count = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 6;
            var gl2 = this.gl;
            gl2.drawArrays(gl2[primitiveType], offset, count);
          }
        }, {
          key: "triangles",
          value: function triangles() {
            var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
            this.draw("TRIANGLES", offset, count);
          }
        }, {
          key: "uniform2f",
          value: function uniform2f() {
            var _gl;
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var key = args.shift();
            (_gl = this.gl).uniform2f.apply(_gl, [this.locations[key]].concat(args));
          }
        }, {
          key: "uniform1f",
          value: function uniform1f() {
            var _gl2;
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            var key = args.shift();
            (_gl2 = this.gl).uniform1f.apply(_gl2, [this.locations[key]].concat(args));
          }
        }, {
          key: "uniform1fv",
          value: function uniform1fv() {
            var _gl3;
            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            var key = args.shift();
            (_gl3 = this.gl).uniform1fv.apply(_gl3, [this.locations[key]].concat(args));
          }
        }, {
          key: "uniform1i",
          value: function uniform1i() {
            var _gl4;
            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            var key = args.shift();
            (_gl4 = this.gl).uniform1i.apply(_gl4, [this.locations[key]].concat(args));
          }
        }, {
          key: "useProgram",
          value: function useProgram() {
            var gl2 = this.gl;
            gl2.useProgram(this.program);
          }
        }, {
          key: "bindBuffer",
          value: function bindBuffer(key, data) {
            var drawType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "STATIC_DRAW";
            var gl2 = this.gl;
            if (!this.buffers[key]) {
              this.buffers[key] = gl2.createBuffer();
            }
            gl2.bindBuffer(gl2.ARRAY_BUFFER, this.buffers[key]);
            if (data) {
              gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array(data), gl2[drawType]);
            }
          }
        }, {
          key: "enable",
          value: function enable(key) {
            var gl2 = this.gl;
            gl2.enableVertexAttribArray(this.locations[key]);
          }
        }, {
          key: "location",
          value: function location2(key) {
            var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "attribute";
            if (type === "attribute") {
              this.locations[key] = this.gl.getAttribLocation(this.program, key);
            } else if (type === "uniform") {
              this.locations[key] = this.gl.getUniformLocation(this.program, key);
            }
          }
        }, {
          key: "a",
          value: function a(key) {
            return this.location(key);
          }
        }, {
          key: "u",
          value: function u(key) {
            return this.location(key, "uniform");
          }
        }, {
          key: "pointer",
          value: function pointer(key) {
            var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "FLOAT";
            var size = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;
            var normalize = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
            var stride = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
            var offset = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
            var gl2 = this.gl;
            gl2.vertexAttribPointer(this.locations[key], size, gl2[type], normalize, stride, offset);
          }
        }, {
          key: "bufferData",
          value: function bufferData() {
            var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var gl2 = this.gl;
            gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array(data), gl2.STATIC_DRAW);
          }
        }, {
          key: "isPowerOf2",
          value: function isPowerOf2(value) {
            return (value & value - 1) == 0;
          }
        }, {
          key: "bindTexture",
          value: function bindTexture(key) {
            var img = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
            var mipLevel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var internalFormat = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "RGBA";
            var srcFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "RGBA";
            var srcType = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "UNSIGNED_BYTE";
            var gl2 = this.gl;
            if (arguments.length == 1) {
              gl2.bindTexture(gl2.TEXTURE_2D, this.textures[key]);
              return;
            }
            if (!this.textures[key]) {
              this.textures[key] = gl2.createTexture();
            }
            this.textureIndex[key] = TEXTURE_INDEX++;
            gl2.bindTexture(gl2.TEXTURE_2D, this.textures[key]);
            this.setTextureParameter();
            gl2.texImage2D(gl2.TEXTURE_2D, mipLevel, gl2[internalFormat], gl2[srcFormat], gl2[srcType], img.newImage || img);
          }
        }, {
          key: "bindColorTexture",
          value: function bindColorTexture(key, data) {
            var width = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 256;
            var height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
            var mipLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
            var internalFormat = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "RGBA";
            var srcFormat = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "RGBA";
            var srcType = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "UNSIGNED_BYTE";
            var gl2 = this.gl;
            if (!this.textures[key]) {
              this.textures[key] = gl2.createTexture();
            }
            this.textureIndex[key] = TEXTURE_INDEX++;
            gl2.bindTexture(gl2.TEXTURE_2D, this.textures[key]);
            this.setTextureParameter();
            gl2.texImage2D(gl2.TEXTURE_2D, mipLevel, gl2[internalFormat], width, height, 0, gl2[srcFormat], gl2[srcType], new Uint8Array(data));
          }
        }, {
          key: "bindEmptyTexture",
          value: function bindEmptyTexture(key, width, height) {
            var mipLevel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            var internalFormat = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "RGBA";
            var srcFormat = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "RGBA";
            var srcType = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "UNSIGNED_BYTE";
            var gl2 = this.gl;
            if (!this.textures[key]) {
              this.textures[key] = gl2.createTexture();
            }
            this.textureIndex[key] = TEXTURE_INDEX++;
            gl2.bindTexture(gl2.TEXTURE_2D, this.textures[key]);
            this.setTextureParameter();
            var border = 0;
            var data = null;
            gl2.texImage2D(gl2.TEXTURE_2D, mipLevel, gl2[internalFormat], width, height, border, gl2[srcFormat], gl2[srcType], data);
          }
        }, {
          key: "setTextureParameter",
          value: function setTextureParameter() {
            var gl2 = this.gl;
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
            gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
          }
        }, {
          key: "bindFrameBufferWithTexture",
          value: function bindFrameBufferWithTexture(key, textureKey, width, height) {
            this.bindEmptyTexture(textureKey, width, height);
            this.bindFrameBuffer(key, textureKey);
          }
        }, {
          key: "enumToString",
          value: function enumToString(value) {
            var gl2 = this.gl;
            if (value === 0) {
              return "NONE";
            }
            for (var key in gl2) {
              if (gl2[key] === value) {
                return key;
              }
            }
            return "0x" + value.toString(16);
          }
        }, {
          key: "bindFrameBuffer",
          value: function bindFrameBuffer(key) {
            var textureKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            var gl2 = this.gl;
            if (arguments.length === 1) {
              gl2.bindFramebuffer(gl2.FRAMEBUFFER, key == null ? null : this.framebuffers[key]);
              return;
            }
            if (!this.framebuffers[key]) {
              this.framebuffers[key] = gl2.createFramebuffer();
            }
            gl2.bindFramebuffer(gl2.FRAMEBUFFER, this.framebuffers[key]);
            var mipLevel = 0;
            var attachmentPoint = gl2.COLOR_ATTACHMENT0;
            gl2.framebufferTexture2D(gl2.FRAMEBUFFER, attachmentPoint, gl2.TEXTURE_2D, this.textures[textureKey], mipLevel);
            var status = gl2.checkFramebufferStatus(gl2.FRAMEBUFFER);
            if (status !== gl2.FRAMEBUFFER_COMPLETE) {
              return;
            }
          }
        }, {
          key: "bindVA",
          value: function bindVA() {
            var gl2 = this.gl;
            if (!this.vao) {
              this.vao = gl2.createVertexArray();
            }
            gl2.bindVertexArray(this.vao);
          }
        }, {
          key: "bindAttr",
          value: function bindAttr(key, data) {
            var drawType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "STATIC_DRAW";
            var size = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 2;
            this.bindBuffer(key, data, drawType);
            this.enable(key);
            this.pointer(key, "FLOAT", size);
          }
          /* 
              shader 에서 사용하는 Attribute, Uniform 변수 설정 
              변수 설정을 간소화 할 필요도 있을 듯 하다. 
          */
        }, {
          key: "initBuffer",
          value: function initBuffer() {
            var _canvas = this.canvas, width = _canvas.width, height = _canvas.height;
            this.a("a_position");
            this.a("a_texCoord");
            this.u("u_resolution");
            this.u("u_image");
            this.u("u_flipY");
            this.u("u_kernelSelect");
            this.u("u_filterIndex");
            this.u("u_kernel9[0]");
            this.u("u_kernel9Weight");
            this.u("u_kernel25[0]");
            this.u("u_kernel25Weight");
            this.u("u_kernel49[0]");
            this.u("u_kernel49Weight");
            this.u("u_kernel81[0]");
            this.u("u_kernel81Weight");
            this.bindVA();
            this.bindAttr(
              "a_position",
              [0, 0, width, 0, 0, height, 0, height, width, 0, width, height],
              "STATIC_DRAW",
              2
              /* components for iteration */
            );
            this.bindAttr(
              "a_texCoord",
              [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1],
              "STATIC_DRAW",
              2
              /* components for iteration */
            );
            this.bindTexture("u_image", this.img);
            this.bindFrameBufferWithTexture("frame_buffer_0", "img_texture_0", width, height);
            this.bindFrameBufferWithTexture("frame_buffer_1", "img_texture_1", width, height);
          }
        }, {
          key: "activeTexture",
          value: function activeTexture() {
            var index2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            var gl2 = this.gl;
            gl2.activeTexture(gl2.TEXTURE0 + index2);
          }
        }, {
          key: "drawFilter",
          value: function drawFilter() {
            var _this = this;
            var gl2 = this.gl;
            this.resize();
            this.clear();
            this.useProgram();
            this.bindVA();
            this.activeTexture(0);
            this.bindTexture("u_image");
            this.uniform1i("u_image", 0);
            this.uniform1f("u_flipY", 1);
            var _gl$canvas = gl2.canvas, width = _gl$canvas.width, height = _gl$canvas.height;
            this.eachFilter(function(f, index2) {
              _this.bindFrameBuffer("frame_buffer_" + index2 % 2);
              _this.uniform2f("u_resolution", width, height);
              _this.viewport(0, 0, width, height);
              _this.effectFilter(f);
              _this.bindTexture("img_texture_" + index2 % 2);
            });
            this.uniform1f("u_flipY", -1);
            this.bindFrameBuffer(null);
            this.uniform2f("u_resolution", width, height);
            this.viewport(0, 0, width, height);
            this.clear();
            this.effectFilter("normal");
          }
        }, {
          key: "effectFilter",
          value: function effectFilter(filterFunction) {
            if (typeof filterFunction == "string") {
              filterFunction = (GLFilter[filterFunction] || GLFilter.normal).call(GLFilter);
            }
            if (filterFunction.type == "convolution") {
              this.uniform1f("u_kernelSelect", filterFunction.length);
              this.uniform1f("u_filterIndex", -1);
              this.uniform1fv("u_kernel" + filterFunction.length + "[0]", filterFunction.content);
              this.uniform1f("u_kernel" + filterFunction.length + "Weight", this.computeKernelWeight(filterFunction.content));
            } else {
              this.uniform1f("u_kernelSelect", -1);
              this.uniform1f("u_filterIndex", filterFunction.index);
            }
            this.triangles(
              0,
              6
              /* 좌표(vertex, 꼭지점) 개수 */
            );
          }
        }, {
          key: "computeKernelWeight",
          value: function computeKernelWeight(kernel) {
            var weight2 = kernel.reduce(function(prev, curr) {
              return prev + curr;
            });
            return weight2 <= 0 ? 1 : weight2;
          }
        }, {
          key: "createProgram",
          value: function createProgram(vertexSource, fragmentSource) {
            var gl2 = this.gl;
            var program = gl2.createProgram();
            this.vertexShader = this.createVertexShader(vertexSource);
            this.fragmentShader = this.createFragmentShader(fragmentSource);
            gl2.attachShader(program, this.vertexShader);
            gl2.attachShader(program, this.fragmentShader);
            gl2.linkProgram(program);
            var success = gl2.getProgramParameter(program, gl2.LINK_STATUS);
            if (success) {
              return program;
            }
            console.error(gl2.getProgramInfoLog(program));
            gl2.deleteProgram(program);
          }
        }, {
          key: "createShader",
          value: function createShader(type, source2) {
            var gl2 = this.gl;
            var shader$$1 = gl2.createShader(type);
            gl2.shaderSource(shader$$1, source2);
            gl2.compileShader(shader$$1);
            var success = gl2.getShaderParameter(shader$$1, gl2.COMPILE_STATUS);
            if (success) {
              return shader$$1;
            }
            console.error(gl2.getShaderInfoLog(shader$$1));
            gl2.deleteShader(shader$$1);
          }
        }, {
          key: "createVertexShader",
          value: function createVertexShader(vertexSource) {
            var gl2 = this.gl;
            return this.createShader(gl2.VERTEX_SHADER, vertexSource);
          }
        }, {
          key: "createFragmentShader",
          value: function createFragmentShader(fragmentSource) {
            var gl2 = this.gl;
            return this.createShader(gl2.FRAGMENT_SHADER, fragmentSource);
          }
        }, {
          key: "eachFilter",
          value: function eachFilter(callback) {
            this.filterList.forEach(callback);
          }
        }, {
          key: "init",
          value: function init() {
            this.locations = {};
            this.buffers = {};
            this.framebuffers = {};
            this.textures = {};
            this.textureIndex = {};
            this.hasTexParameter = {};
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var gl2 = this.gl;
            this.init();
            gl2.deleteProgram(this.program);
          }
        }, {
          key: "filter",
          value: function filter2(filterList, doneCallback) {
            this.filterList = filterList;
            this.initCanvas(makeVertexShaderSource(), makeFragmentShaderSource(this.filterList));
            this.drawFilter();
            if (typeof doneCallback == "function") {
              doneCallback(this);
            }
          }
        }]);
        return GLCanvas2;
      }();
      var GL$1 = {
        GLCanvas
      };
      var functions = {
        filter
      };
      function makeFilterFunction(filterObj) {
        var filterName = filterObj.arr[0];
        var f = GLFilter[filterName];
        var arr = filterObj.arr;
        arr.shift();
        var result = f.apply(this, arr);
        return result;
      }
      function flatFilter(filterString) {
        var filter_list = [];
        if (typeof filterString == "string") {
          filter_list = matches$1(filterString);
        } else if (Array.isArray(filterString)) {
          filter_list = filterString;
        }
        var allFilter = [];
        filter_list.forEach(function(filterObj) {
          var filterName = filterObj.arr[0];
          if (GLFilter[filterName]) {
            var f = makeFilterFunction(filterObj);
            if (f.type == "convolution" || f.type == "shader") {
              allFilter.push(f);
            } else {
              f.forEach(function(subFilter) {
                allFilter = allFilter.concat(flatFilter(subFilter));
              });
            }
          }
        });
        return allFilter;
      }
      function filter(img, filterString, callback, opt) {
        var canvas = new GL$1.GLCanvas({
          width: opt.width || img.width,
          height: opt.height || img.height,
          img
        });
        canvas.filter(flatFilter(filterString), function done() {
          if (typeof callback == "function") {
            callback(canvas);
          }
        });
      }
      var GL = _extends({}, GL$1, functions);
      function palette(colors) {
        var k2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
        var exportFormat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "hex";
        if (colors.length > k2) {
          colors = kmeans(colors, k2);
        }
        return colors.map(function(c2) {
          return format(c2, exportFormat);
        });
      }
      function ImageToRGB(url) {
        var callbackOrOption = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var callback = arguments[2];
        if (!callback) {
          var img = new ImageLoader(url);
          img.loadImage(function() {
            if (typeof callbackOrOption == "function") {
              callbackOrOption(img.toRGB());
            }
          });
        } else if (callback) {
          var img = new ImageLoader(url, callbackOrOption);
          img.loadImage(function() {
            if (typeof callback == "function") {
              callback(img.toRGB());
            }
          });
        }
      }
      function ImageToCanvas(url, filter2, callback) {
        var opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { frameTimer: "full" };
        ImageToURL(url, filter2, callback, Object.assign({
          returnTo: "canvas"
        }, opt));
      }
      function ImageToURL(url, filter2, callback) {
        var opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { frameTimer: "full" };
        var img = new ImageLoader(url);
        img.loadImage(function() {
          img.toArray(filter2, function(datauri) {
            if (typeof callback == "function") {
              callback(datauri);
            }
          }, opt);
        });
      }
      function GLToCanvas(url, filter2, callback) {
        var opt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        var img = new ImageLoader(url);
        img.load(function() {
          GL.filter(img.newImage, filter2, function done(datauri) {
            if (typeof callback == "function") {
              callback(datauri);
            }
          }, opt);
        });
      }
      function histogram(url, callback) {
        var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var img = new ImageLoader(url);
        img.loadImage(function() {
          if (typeof callback == "function") {
            callback(img.toHistogram(opt));
          }
        });
      }
      function histogramToPoints(points) {
        var tension = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.2;
        var controlPoints = [];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          if (i == 0) {
            controlPoints[i] = [];
            continue;
          }
          if (i == points.length - 1) {
            controlPoints[i] = [];
            continue;
          }
          var prevPoint = points[i - 1];
          var nextPoint = points[i + 1];
          var M3 = (nextPoint[1] - prevPoint[1]) / (nextPoint[0] - prevPoint[0]);
          var newControlPoint = [prevPoint[0] + (nextPoint[0] - prevPoint[0]) * tension, prevPoint[1] + (nextPoint[1] - prevPoint[1]) * tension];
          var controlPoint = [
            [].concat(toConsumableArray(prevPoint)),
            /* start */
            [].concat(newControlPoint)
            /* end */
          ];
          var P3 = Math.sqrt(Math.pow(p[0] - prevPoint[0], 2) + Math.pow(p[1] - prevPoint[1], 2));
          var N3 = Math.sqrt(Math.pow(nextPoint[0] - p[0], 2) + Math.pow(nextPoint[1] - p[1], 2));
          var rate = P3 / N3;
          var dx = controlPoint[0][0] + (controlPoint[1][0] - controlPoint[0][0]) * rate;
          var dy = controlPoint[0][1] + (controlPoint[1][1] - controlPoint[0][1]) * rate;
          controlPoint[0][0] += p[0] - dx;
          controlPoint[0][1] += p[1] - dy;
          controlPoint[1][0] += p[0] - dx;
          controlPoint[1][1] += p[1] - dy;
          controlPoints[i] = controlPoint;
        }
        return controlPoints;
      }
      function ImageToHistogram(url, callback) {
        var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { width: 200, height: 100 };
        var img = new ImageLoader(url);
        img.loadImage(function() {
          Canvas.createHistogram(opt.width || 200, opt.height || 100, img.toHistogram(opt), function(canvas) {
            if (typeof callback == "function") callback(canvas.toDataURL("image/png"));
          }, opt);
        });
      }
      var image = {
        palette,
        ImageToCanvas,
        ImageToHistogram,
        ImageToRGB,
        ImageToURL,
        GLToCanvas,
        histogram,
        histogramToPoints
      };
      var Color$1 = _extends({}, formatter, math, mixin, parser, fromYCrCb, fromRGB, fromCMYK, fromHSV, fromHSL, fromLAB, image);
      var hue_color = [{ rgb: "#ff0000", start: 0 }, { rgb: "#ffff00", start: 0.17 }, { rgb: "#00ff00", start: 0.33 }, { rgb: "#00ffff", start: 0.5 }, { rgb: "#0000ff", start: 0.67 }, { rgb: "#ff00ff", start: 0.83 }, { rgb: "#ff0000", start: 1 }];
      function checkHueColor(p) {
        var startColor, endColor;
        for (var i = 0; i < hue_color.length; i++) {
          if (hue_color[i].start >= p) {
            startColor = hue_color[i - 1];
            endColor = hue_color[i];
            break;
          }
        }
        if (startColor && endColor) {
          return Color$1.interpolateRGB(startColor, endColor, (p - startColor.start) / (endColor.start - startColor.start));
        }
        return hue_color[0].rgb;
      }
      function initHueColors() {
        for (var i = 0, len = hue_color.length; i < len; i++) {
          var hue2 = hue_color[i];
          var obj = Color$1.parse(hue2.rgb);
          hue2.r = obj.r;
          hue2.g = obj.g;
          hue2.b = obj.b;
        }
      }
      initHueColors();
      var HueColor = {
        colors: hue_color,
        checkHueColor
      };
      var ImageFilter = _extends({}, FilterList, functions$1);
      var Util = {
        Color: Color$1,
        HueColor,
        ColorNames,
        ImageFilter,
        GL,
        Canvas,
        ImageLoader
      };
      var color = Color$1.color;
      var counter = 0;
      var cached = [];
      var Dom = function() {
        function Dom2(tag, className, attr) {
          classCallCheck(this, Dom2);
          if (typeof tag != "string") {
            this.el = tag;
          } else {
            var el = document.createElement(tag);
            this.uniqId = counter++;
            if (className) {
              el.className = className;
            }
            attr = attr || {};
            for (var k2 in attr) {
              el.setAttribute(k2, attr[k2]);
            }
            this.el = el;
          }
        }
        createClass(Dom2, [{
          key: "attr",
          value: function attr(key, value) {
            if (arguments.length == 1) {
              return this.el.getAttribute(key);
            }
            this.el.setAttribute(key, value);
            return this;
          }
        }, {
          key: "closest",
          value: function closest(cls) {
            var temp = this;
            var checkCls = false;
            while (!(checkCls = temp.hasClass(cls))) {
              if (temp.el.parentNode) {
                temp = new Dom2(temp.el.parentNode);
              } else {
                return null;
              }
            }
            if (checkCls) {
              return temp;
            }
            return null;
          }
        }, {
          key: "checked",
          value: function checked() {
            return this.el.checked;
          }
        }, {
          key: "removeClass",
          value: function removeClass(cls) {
            this.el.className = (" " + this.el.className + " ").replace(" " + cls + " ", " ").trim();
            return this;
          }
        }, {
          key: "hasClass",
          value: function hasClass(cls) {
            if (!this.el.className) {
              return false;
            } else {
              var newClass = " " + this.el.className + " ";
              return newClass.indexOf(" " + cls + " ") > -1;
            }
          }
        }, {
          key: "addClass",
          value: function addClass(cls) {
            if (!this.hasClass(cls)) {
              this.el.className = this.el.className + " " + cls;
            }
            return this;
          }
        }, {
          key: "toggleClass",
          value: function toggleClass(cls) {
            if (this.hasClass(cls)) {
              this.removeClass(cls);
            } else {
              this.addClass(cls);
            }
          }
        }, {
          key: "html",
          value: function html(_html) {
            try {
              if (typeof _html == "string") {
                this.el.innerHTML = _html;
              } else {
                this.empty().append(_html);
              }
            } catch (e) {
              console.log(_html);
            }
            return this;
          }
        }, {
          key: "find",
          value: function find(selector) {
            return this.el.querySelector(selector);
          }
        }, {
          key: "$",
          value: function $2(selector) {
            return new Dom2(this.find(selector));
          }
        }, {
          key: "findAll",
          value: function findAll(selector) {
            return this.el.querySelectorAll(selector);
          }
        }, {
          key: "$$",
          value: function $$(selector) {
            return [].concat(toConsumableArray(this.findAll(selector))).map(function(el) {
              return new Dom2(el);
            });
          }
        }, {
          key: "empty",
          value: function empty() {
            return this.html("");
          }
        }, {
          key: "append",
          value: function append(el) {
            if (typeof el == "string") {
              this.el.appendChild(document.createTextNode(el));
            } else {
              this.el.appendChild(el.el || el);
            }
            return this;
          }
        }, {
          key: "appendTo",
          value: function appendTo(target) {
            var t = target.el ? target.el : target;
            t.appendChild(this.el);
            return this;
          }
        }, {
          key: "remove",
          value: function remove() {
            if (this.el.parentNode) {
              this.el.parentNode.removeChild(this.el);
            }
            return this;
          }
        }, {
          key: "text",
          value: function text() {
            return this.el.textContent;
          }
        }, {
          key: "css",
          value: function css(key, value) {
            var _this = this;
            if (arguments.length == 2) {
              this.el.style[key] = value;
            } else if (arguments.length == 1) {
              if (typeof key == "string") {
                return getComputedStyle(this.el)[key];
              } else {
                var keys = key || {};
                Object.keys(keys).forEach(function(k2) {
                  _this.el.style[k2] = keys[k2];
                });
              }
            }
            return this;
          }
        }, {
          key: "cssFloat",
          value: function cssFloat(key) {
            return parseFloat(this.css(key));
          }
        }, {
          key: "cssInt",
          value: function cssInt(key) {
            return parseInt(this.css(key));
          }
        }, {
          key: "offset",
          value: function offset() {
            var rect = this.el.getBoundingClientRect();
            return {
              top: rect.top + Dom2.getScrollTop(),
              left: rect.left + Dom2.getScrollLeft()
            };
          }
        }, {
          key: "rect",
          value: function rect() {
            return this.el.getBoundingClientRect();
          }
        }, {
          key: "position",
          value: function position() {
            if (this.el.style.top) {
              return {
                top: parseFloat(this.css("top")),
                left: parseFloat(this.css("left"))
              };
            } else {
              return this.el.getBoundingClientRect();
            }
          }
        }, {
          key: "size",
          value: function size() {
            return [this.width(), this.height()];
          }
        }, {
          key: "width",
          value: function width() {
            return this.el.offsetWidth || this.el.getBoundingClientRect().width;
          }
        }, {
          key: "contentWidth",
          value: function contentWidth() {
            return this.width() - this.cssFloat("padding-left") - this.cssFloat("padding-right");
          }
        }, {
          key: "height",
          value: function height() {
            return this.el.offsetHeight || this.el.getBoundingClientRect().height;
          }
        }, {
          key: "contentHeight",
          value: function contentHeight() {
            return this.height() - this.cssFloat("padding-top") - this.cssFloat("padding-bottom");
          }
        }, {
          key: "dataKey",
          value: function dataKey(key) {
            return this.uniqId + "." + key;
          }
        }, {
          key: "data",
          value: function data(key, value) {
            if (arguments.length == 2) {
              cached[this.dataKey(key)] = value;
            } else if (arguments.length == 1) {
              return cached[this.dataKey(key)];
            } else {
              var keys = Object.keys(cached);
              var uniqId = this.uniqId + ".";
              return keys.filter(function(key2) {
                if (key2.indexOf(uniqId) == 0) {
                  return true;
                }
                return false;
              }).map(function(value2) {
                return cached[value2];
              });
            }
            return this;
          }
        }, {
          key: "val",
          value: function val(value) {
            if (arguments.length == 0) {
              return this.el.value;
            } else if (arguments.length == 1) {
              this.el.value = value;
            }
            return this;
          }
        }, {
          key: "int",
          value: function int() {
            return parseInt(this.val(), 10);
          }
        }, {
          key: "float",
          value: function float() {
            return parseFloat(this.val());
          }
        }, {
          key: "show",
          value: function show() {
            return this.css("display", "block");
          }
        }, {
          key: "hide",
          value: function hide() {
            return this.css("display", "none");
          }
        }, {
          key: "toggle",
          value: function toggle() {
            if (this.css("display") == "none") {
              return this.show();
            } else {
              return this.hide();
            }
          }
        }, {
          key: "scrollTop",
          value: function scrollTop() {
            if (this.el === document.body) {
              return Dom2.getScrollTop();
            }
            return this.el.scrollTop;
          }
        }, {
          key: "scrollLeft",
          value: function scrollLeft() {
            if (this.el === document.body) {
              return Dom2.getScrollLeft();
            }
            return this.el.scrollLeft;
          }
        }, {
          key: "on",
          value: function on3(eventName, callback, opt1, opt2) {
            this.el.addEventListener(eventName, callback, opt1, opt2);
            return this;
          }
        }, {
          key: "off",
          value: function off(eventName, callback) {
            this.el.removeEventListener(eventName, callback);
            return this;
          }
        }, {
          key: "getElement",
          value: function getElement() {
            return this.el;
          }
        }, {
          key: "createChild",
          value: function createChild(tag) {
            var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var css = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            var $element = new Dom2(tag, className, attrs);
            $element.css(css);
            this.append($element);
            return $element;
          }
        }, {
          key: "firstChild",
          value: function firstChild() {
            return new Dom2(this.el.firstElementChild);
          }
        }, {
          key: "replace",
          value: function replace(oldElement, newElement) {
            this.el.replaceChild(newElement, oldElement);
            return this;
          }
        }], [{
          key: "getScrollTop",
          value: function getScrollTop() {
            return Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
          }
        }, {
          key: "getScrollLeft",
          value: function getScrollLeft() {
            return Math.max(window.pageXOffset, document.documentElement.scrollLeft, document.body.scrollLeft);
          }
        }]);
        return Dom2;
      }();
      var BaseModule = function() {
        function BaseModule2($store) {
          classCallCheck(this, BaseModule2);
          this.$store = $store;
          this.initialize();
        }
        createClass(BaseModule2, [{
          key: "initialize",
          value: function initialize() {
            var _this = this;
            this.filterProps().forEach(function(key) {
              _this.$store.action(key, _this);
            });
          }
        }, {
          key: "filterProps",
          value: function filterProps() {
            var pattern = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "/";
            return Object.getOwnPropertyNames(this.__proto__).filter(function(key) {
              return key.startsWith(pattern);
            });
          }
        }]);
        return BaseModule2;
      }();
      var ColorSetsList = function(_BaseModule) {
        inherits(ColorSetsList2, _BaseModule);
        function ColorSetsList2() {
          classCallCheck(this, ColorSetsList2);
          return possibleConstructorReturn(this, (ColorSetsList2.__proto__ || Object.getPrototypeOf(ColorSetsList2)).apply(this, arguments));
        }
        createClass(ColorSetsList2, [{
          key: "initialize",
          value: function initialize() {
            get(ColorSetsList2.prototype.__proto__ || Object.getPrototypeOf(ColorSetsList2.prototype), "initialize", this).call(this);
            this.$store.colorSetsList = [{
              name: "Material",
              colors: ["#F44336", "#E91E63", "#9C27B0", "#673AB7", "#3F51B5", "#2196F3", "#03A9F4", "#00BCD4", "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFEB3B", "#FFC107", "#FF9800", "#FF5722", "#795548", "#9E9E9E", "#607D8B"]
            }, { name: "Custom", "edit": true, "colors": [] }, { name: "Color Scale", "scale": ["red", "yellow", "black"], count: 5 }];
            this.$store.currentColorSets = {};
          }
        }, {
          key: "/list",
          value: function list($store) {
            return Array.isArray($store.userList) && $store.userList.length ? $store.userList : $store.colorSetsList;
          }
        }, {
          key: "/setUserPalette",
          value: function setUserPalette($store, list) {
            $store.userList = list;
            $store.dispatch("/resetUserPalette");
            $store.dispatch("/setCurrentColorSets");
          }
        }, {
          key: "/resetUserPalette",
          value: function resetUserPalette($store) {
            if ($store.userList && $store.userList.length) {
              $store.userList = $store.userList.map(function(element, index2) {
                if (typeof element.colors == "function") {
                  var makeCallback = element.colors;
                  element.colors = makeCallback($store);
                  element._colors = makeCallback;
                }
                return Object.assign({
                  name: "color-" + index2,
                  colors: []
                }, element);
              });
              $store.emit("changeUserList");
            }
          }
        }, {
          key: "/setCurrentColorSets",
          value: function setCurrentColorSets($store, nameOrIndex) {
            var _list = $store.dispatch("/list");
            if (typeof nameOrIndex == "undefined") {
              $store.currentColorSets = _list[0];
            } else if (typeof nameOrIndex == "number") {
              $store.currentColorSets = _list[nameOrIndex];
            } else {
              $store.currentColorSets = _list.filter(function(obj) {
                return obj.name == nameOrIndex;
              })[0];
            }
            $store.emit("changeCurrentColorSets");
          }
        }, {
          key: "/getCurrentColorSets",
          value: function getCurrentColorSets($store) {
            return $store.currentColorSets;
          }
        }, {
          key: "/addCurrentColor",
          value: function addCurrentColor($store, color2) {
            if (Array.isArray($store.currentColorSets.colors)) {
              $store.currentColorSets.colors.push(color2);
              $store.emit("changeCurrentColorSets");
            }
          }
        }, {
          key: "/setCurrentColorAll",
          value: function setCurrentColorAll($store) {
            var colors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            $store.currentColorSets.colors = colors;
            $store.emit("changeCurrentColorSets");
          }
        }, {
          key: "/removeCurrentColor",
          value: function removeCurrentColor($store, index2) {
            if ($store.currentColorSets.colors[index2]) {
              $store.currentColorSets.colors.splice(index2, 1);
              $store.emit("changeCurrentColorSets");
            }
          }
        }, {
          key: "/removeCurrentColorToTheRight",
          value: function removeCurrentColorToTheRight($store, index2) {
            if ($store.currentColorSets.colors[index2]) {
              $store.currentColorSets.colors.splice(index2, Number.MAX_VALUE);
              $store.emit("changeCurrentColorSets");
            }
          }
        }, {
          key: "/clearPalette",
          value: function clearPalette($store) {
            if ($store.currentColorSets.colors) {
              $store.currentColorSets.colors = [];
              $store.emit("changeCurrentColorSets");
            }
          }
        }, {
          key: "/getCurrentColors",
          value: function getCurrentColors($store) {
            return $store.dispatch("/getColors", $store.currentColorSets);
          }
        }, {
          key: "/getColors",
          value: function getColors($store, element) {
            if (element.scale) {
              return Color$1.scale(element.scale, element.count);
            }
            return element.colors || [];
          }
        }, {
          key: "/getColorSetsList",
          value: function getColorSetsList($store) {
            return $store.dispatch("/list").map(function(element) {
              return {
                name: element.name,
                edit: element.edit,
                colors: $store.dispatch("/getColors", element)
              };
            });
          }
        }]);
        return ColorSetsList2;
      }(BaseModule);
      var Event = {
        addEvent: function addEvent(dom, eventName, callback, options) {
          if (dom) {
            dom.addEventListener(eventName, callback, options);
          }
        },
        removeEvent: function removeEvent(dom, eventName, callback) {
          if (dom) {
            dom.removeEventListener(eventName, callback);
          }
        },
        pos: function pos(e) {
          if (e.touches && e.touches[0]) {
            return e.touches[0];
          }
          return e;
        },
        posXY: function posXY(e) {
          var pos = this.pos(e);
          return {
            x: pos.pageX,
            y: pos.pageY
          };
        }
      };
      var DELEGATE_SPLIT = ".";
      var State = function() {
        function State2(masterObj) {
          var settingObj = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          classCallCheck(this, State2);
          this.masterObj = masterObj;
          this.settingObj = settingObj;
        }
        createClass(State2, [{
          key: "set",
          value: function set$$1(key, value) {
            var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
            this.settingObj[key] = value || defaultValue;
          }
        }, {
          key: "init",
          value: function init(key) {
            if (!this.has(key)) {
              var arr = key.split(DELEGATE_SPLIT);
              var obj = this.masterObj.refs[arr[0]] || this.masterObj[arr[0]] || this.masterObj;
              var method = arr.pop();
              if (obj[method]) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                var value = obj[method].apply(obj, args);
                this.set(key, value);
              }
            }
          }
        }, {
          key: "get",
          value: function get$$1(key) {
            var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            this.init(key, defaultValue);
            return this.settingObj[key] || defaultValue;
          }
        }, {
          key: "has",
          value: function has(key) {
            return !!this.settingObj[key];
          }
        }]);
        return State2;
      }();
      var CHECK_EVENT_PATTERN = /^(click|mouse(down|up|move|enter|leave)|touch(start|move|end)|key(down|up|press)|contextmenu|change|input)/ig;
      var CHECK_LOAD_PATTERN = /^load (.*)/ig;
      var EVENT_SAPARATOR = " ";
      var META_KEYS = ["Control", "Shift", "Alt", "Meta"];
      var EventMachin = function() {
        function EventMachin2() {
          classCallCheck(this, EventMachin2);
          this.state = new State(this);
          this.refs = {};
          this.childComponents = this.components();
        }
        createClass(EventMachin2, [{
          key: "newChildComponents",
          value: function newChildComponents() {
            var _this = this;
            var childKeys = Object.keys(this.childComponents);
            childKeys.forEach(function(key) {
              var Component = _this.childComponents[key];
              _this[key] = new Component(_this);
            });
          }
          /**
           * 부모가 정의한 template 과  그 안에서 동작하는 자식 컴포넌트들을 다 합쳐서 
           * 최종 element 를 만들어준다. 
           * 
           * 그리고 자동으로 load 되어질게 있으면 로드 해준다. 
           */
        }, {
          key: "render",
          value: function render() {
            this.$el = this.parseTemplate(this.template());
            this.refs.$el = this.$el;
            this.parseTarget();
            this.load();
            this.afterRender();
          }
        }, {
          key: "afterRender",
          value: function afterRender() {
          }
          /**
           * 자식 컴포넌트로 사용될 객체 정의 
           */
        }, {
          key: "components",
          value: function components() {
            return {};
          }
          /**
           * Class 기반으로 $el 을 생성하기 위해서 
           * 선언형으로 html 템플릿을 정의한다. 
           * 
           * @param {*} html 
           */
        }, {
          key: "parseTemplate",
          value: function parseTemplate(html) {
            var _this2 = this;
            var $el = new Dom("div").html(html).firstChild();
            var refs = $el.findAll("[ref]");
            [].concat(toConsumableArray(refs)).forEach(function(node) {
              var name = node.getAttribute("ref");
              _this2.refs[name] = new Dom(node);
            });
            return $el;
          }
          /**
           * target 으로 지정된 자식 컴포넌트를 대체해준다.
           */
        }, {
          key: "parseTarget",
          value: function parseTarget() {
            var _this3 = this;
            var $el = this.$el;
            var targets = $el.findAll("[target]");
            [].concat(toConsumableArray(targets)).forEach(function(node) {
              var targetComponentName = node.getAttribute("target");
              var refName = node.getAttribute("ref") || targetComponentName;
              var Component = _this3.childComponents[targetComponentName];
              var instance = new Component(_this3);
              _this3[refName] = instance;
              _this3.refs[refName] = instance.$el;
              if (instance) {
                instance.render();
                var $parent = new Dom(node.parentNode);
                $parent.replace(node, instance.$el.el);
              }
            });
          }
          // load function이 정의된 객체는 load 를 실행해준다. 
        }, {
          key: "load",
          value: function load() {
            var _this4 = this;
            this.filterProps(CHECK_LOAD_PATTERN).forEach(function(callbackName) {
              var elName = callbackName.split("load ")[1];
              if (_this4.refs[elName]) {
                _this4.refs[elName].html(_this4.parseTemplate(_this4[callbackName].call(_this4)));
              }
            });
          }
          // 기본 템플릿 지정 
        }, {
          key: "template",
          value: function template() {
            return "<div></div>";
          }
        }, {
          key: "initialize",
          value: function initialize() {
          }
          /**
           * 이벤트를 초기화한다. 
           */
        }, {
          key: "initializeEvent",
          value: function initializeEvent() {
            var _this5 = this;
            this.initializeEventMachin();
            Object.keys(this.childComponents).forEach(function(key) {
              if (_this5[key]) _this5[key].initializeEvent();
            });
          }
          /**
           * 자원을 해제한다. 
           * 이것도 역시 자식 컴포넌트까지 제어하기 때문에 가장 최상위 부모에서 한번만 호출되도 된다. 
           */
        }, {
          key: "destroy",
          value: function destroy() {
            var _this6 = this;
            this.destroyEventMachin();
            Object.keys(this.childComponents).forEach(function(key) {
              if (_this6[key]) _this6[key].destroy();
            });
          }
        }, {
          key: "destroyEventMachin",
          value: function destroyEventMachin() {
            this.removeEventAll();
          }
        }, {
          key: "initializeEventMachin",
          value: function initializeEventMachin() {
            this.filterProps(CHECK_EVENT_PATTERN).forEach(this.parseEvent.bind(this));
          }
          /**
           * property 수집하기 
           * 상위 클래스의 모든 property 를 수집해서 리턴한다. 
           */
        }, {
          key: "collectProps",
          value: function collectProps() {
            if (!this.collapsedProps) {
              var p = this.__proto__;
              var results = [];
              do {
                results.push.apply(results, toConsumableArray(Object.getOwnPropertyNames(p)));
                p = p.__proto__;
              } while (p);
              this.collapsedProps = results;
            }
            return this.collapsedProps;
          }
        }, {
          key: "filterProps",
          value: function filterProps(pattern) {
            return this.collectProps().filter(function(key) {
              return key.match(pattern);
            });
          }
        }, {
          key: "parseEvent",
          value: function parseEvent(key) {
            var arr = key.split(EVENT_SAPARATOR);
            this.bindingEvent(arr, this[key].bind(this));
          }
        }, {
          key: "getDefaultDomElement",
          value: function getDefaultDomElement(dom) {
            var el = void 0;
            if (dom) {
              el = this.refs[dom] || this[dom] || window[dom];
            } else {
              el = this.el || this.$el || this.$root;
            }
            if (el instanceof Dom) {
              return el.getElement();
            }
            return el;
          }
        }, {
          key: "getDefaultEventObject",
          value: function getDefaultEventObject(eventName) {
            var _this7 = this;
            var arr = eventName.split(".");
            var realEventName = arr.shift();
            var isControl = arr.includes("Control");
            var isShift = arr.includes("Shift");
            var isAlt = arr.includes("Alt");
            var isMeta = arr.includes("Meta");
            arr = arr.filter(function(code) {
              return META_KEYS.includes(code) === false;
            });
            var checkMethodList = arr.filter(function(code) {
              return !!_this7[code];
            });
            arr = arr.filter(function(code) {
              return checkMethodList.includes(code) === false;
            }).map(function(code) {
              return code.toLowerCase();
            });
            return {
              eventName: realEventName,
              isControl,
              isShift,
              isAlt,
              isMeta,
              codes: arr,
              checkMethodList
            };
          }
        }, {
          key: "bindingEvent",
          value: function bindingEvent(_ref, callback) {
            var _ref2 = toArray(_ref), eventName = _ref2[0], dom = _ref2[1], delegate = _ref2.slice(2);
            dom = this.getDefaultDomElement(dom);
            var eventObject = this.getDefaultEventObject(eventName);
            eventObject.dom = dom;
            eventObject.delegate = delegate.join(EVENT_SAPARATOR);
            this.addEvent(eventObject, callback);
          }
        }, {
          key: "matchPath",
          value: function matchPath(el, selector) {
            if (el) {
              if (el.matches(selector)) {
                return el;
              }
              return this.matchPath(el.parentElement, selector);
            }
            return null;
          }
        }, {
          key: "getBindings",
          value: function getBindings() {
            if (!this._bindings) {
              this.initBindings();
            }
            return this._bindings;
          }
        }, {
          key: "addBinding",
          value: function addBinding(obj) {
            this.getBindings().push(obj);
          }
        }, {
          key: "initBindings",
          value: function initBindings() {
            this._bindings = [];
          }
        }, {
          key: "checkEventType",
          value: function checkEventType(e, eventObject) {
            var _this8 = this;
            var onlyControl = eventObject.isControl ? e.ctrlKey : true;
            var onlyShift = eventObject.isShift ? e.shiftKey : true;
            var onlyAlt = eventObject.isAlt ? e.altKey : true;
            var onlyMeta = eventObject.isMeta ? e.metaKey : true;
            var hasKeyCode = true;
            if (eventObject.codes.length) {
              hasKeyCode = eventObject.codes.includes(e.code.toLowerCase()) || eventObject.codes.includes(e.key.toLowerCase());
            }
            var isAllCheck = true;
            if (eventObject.checkMethodList.length) {
              isAllCheck = eventObject.checkMethodList.every(function(method) {
                return _this8[method].call(_this8, e);
              });
            }
            return onlyControl && onlyAlt && onlyShift && onlyMeta && hasKeyCode && isAllCheck;
          }
        }, {
          key: "makeCallback",
          value: function makeCallback(eventObject, callback) {
            var _this9 = this;
            if (eventObject.delegate) {
              return function(e) {
                e.xy = Event.posXY(e);
                if (_this9.checkEventType(e, eventObject)) {
                  var delegateTarget = _this9.matchPath(e.target || e.srcElement, eventObject.delegate);
                  if (delegateTarget) {
                    e.delegateTarget = delegateTarget;
                    e.$delegateTarget = new Dom(delegateTarget);
                    return callback(e);
                  }
                }
              };
            } else {
              return function(e) {
                e.xy = Event.posXY(e);
                if (_this9.checkEventType(e, eventObject)) {
                  return callback(e);
                }
              };
            }
          }
        }, {
          key: "addEvent",
          value: function addEvent(eventObject, callback) {
            eventObject.callback = this.makeCallback(eventObject, callback);
            this.addBinding(eventObject);
            var options = true;
            if (eventObject.eventName === "touchstart") {
              options = { passive: true };
            }
            Event.addEvent(eventObject.dom, eventObject.eventName, eventObject.callback, options);
          }
        }, {
          key: "removeEventAll",
          value: function removeEventAll() {
            var _this10 = this;
            this.getBindings().forEach(function(obj) {
              _this10.removeEvent(obj);
            });
            this.initBindings();
          }
        }, {
          key: "removeEvent",
          value: function removeEvent(_ref3) {
            var eventName = _ref3.eventName, dom = _ref3.dom, callback = _ref3.callback;
            Event.removeEvent(dom, eventName, callback);
          }
        }]);
        return EventMachin2;
      }();
      var CHECK_STORE_EVENT_PATTERN = /^@/;
      var UIElement = function(_EventMachin) {
        inherits(UIElement2, _EventMachin);
        function UIElement2(opt) {
          classCallCheck(this, UIElement2);
          var _this = possibleConstructorReturn(this, (UIElement2.__proto__ || Object.getPrototypeOf(UIElement2)).call(this, opt));
          _this.opt = opt || {};
          if (opt && opt.$store) {
            _this.$store = opt.$store;
          }
          _this.initialize();
          _this.initializeStoreEvent();
          return _this;
        }
        createClass(UIElement2, [{
          key: "initializeStoreEvent",
          value: function initializeStoreEvent() {
            var _this2 = this;
            this.storeEvents = {};
            this.filterProps(CHECK_STORE_EVENT_PATTERN).forEach(function(key) {
              var arr = key.split("@");
              arr.shift();
              var event = arr.join("@");
              _this2.storeEvents[event] = _this2[key].bind(_this2);
              _this2.$store.on(event, _this2.storeEvents[event]);
            });
          }
        }, {
          key: "destoryStoreEvent",
          value: function destoryStoreEvent() {
            var _this3 = this;
            Object.keys(this.storeEvents).forEach(function(event) {
              _this3.$store.off(event, _this3.storeEvents[event]);
            });
          }
        }]);
        return UIElement2;
      }(EventMachin);
      function isUndefined(v2) {
        return typeof v2 == "undefined" || v2 == null;
      }
      var ColorManager = function(_BaseModule) {
        inherits(ColorManager2, _BaseModule);
        function ColorManager2() {
          classCallCheck(this, ColorManager2);
          return possibleConstructorReturn(this, (ColorManager2.__proto__ || Object.getPrototypeOf(ColorManager2)).apply(this, arguments));
        }
        createClass(ColorManager2, [{
          key: "initialize",
          value: function initialize() {
            get(ColorManager2.prototype.__proto__ || Object.getPrototypeOf(ColorManager2.prototype), "initialize", this).call(this);
            this.$store.rgb = {};
            this.$store.hsl = {};
            this.$store.hsv = {};
            this.$store.alpha = 1;
            this.$store.format = "hex";
          }
        }, {
          key: "/changeFormat",
          value: function changeFormat($store, format2) {
            $store.format = format2;
            $store.emit("changeFormat");
          }
        }, {
          key: "/initColor",
          value: function initColor($store, colorObj, source2) {
            $store.dispatch("/changeColor", colorObj, source2, true);
            $store.emit("initColor");
          }
        }, {
          key: "/changeColor",
          value: function changeColor($store, colorObj, source2, isNotEmit) {
            colorObj = colorObj || "#FF0000";
            if (typeof colorObj == "string") {
              colorObj = Color$1.parse(colorObj);
            }
            colorObj.source = colorObj.source || source2;
            $store.alpha = isUndefined(colorObj.a) ? $store.alpha : colorObj.a;
            $store.format = colorObj.type != "hsv" ? colorObj.type || $store.format : $store.format;
            if (colorObj.type == "hsl") {
              $store.hsl = Object.assign($store.hsl, colorObj);
              $store.rgb = Color$1.HSLtoRGB($store.hsl);
              $store.hsv = Color$1.HSLtoHSV(colorObj);
            } else if (colorObj.type == "hex") {
              $store.rgb = Object.assign($store.rgb, colorObj);
              $store.hsl = Color$1.RGBtoHSL($store.rgb);
              $store.hsv = Color$1.RGBtoHSV(colorObj);
            } else if (colorObj.type == "rgb") {
              $store.rgb = Object.assign($store.rgb, colorObj);
              $store.hsl = Color$1.RGBtoHSL($store.rgb);
              $store.hsv = Color$1.RGBtoHSV(colorObj);
            } else if (colorObj.type == "hsv") {
              $store.hsv = Object.assign($store.hsv, colorObj);
              $store.rgb = Color$1.HSVtoRGB($store.hsv);
              $store.hsl = Color$1.HSVtoHSL($store.hsv);
            }
            if (!isNotEmit) {
              $store.emit("changeColor", colorObj.source);
            }
          }
        }, {
          key: "/getHueColor",
          value: function getHueColor($store) {
            return HueColor.checkHueColor($store.hsv.h / 360);
          }
        }, {
          key: "/toString",
          value: function toString($store, type) {
            type = type || $store.format;
            var colorObj = $store[type] || $store.rgb;
            return Color$1.format(_extends({}, colorObj, {
              a: $store.alpha
            }), type);
          }
        }, {
          key: "/toColor",
          value: function toColor($store, type) {
            type = type || $store.format;
            if (type == "rgb") {
              return $store.dispatch("/toRGB");
            } else if (type == "hsl") {
              return $store.dispatch("/toHSL");
            } else if (type == "hex") {
              return $store.dispatch("/toHEX");
            }
            return $store.dispatch("/toString", type);
          }
        }, {
          key: "/toRGB",
          value: function toRGB($store) {
            return $store.dispatch("/toString", "rgb");
          }
        }, {
          key: "/toHSL",
          value: function toHSL($store) {
            return $store.dispatch("/toString", "hsl");
          }
        }, {
          key: "/toHEX",
          value: function toHEX($store) {
            return $store.dispatch("/toString", "hex").toUpperCase();
          }
        }]);
        return ColorManager2;
      }(BaseModule);
      var BaseStore = function() {
        function BaseStore2(opt) {
          classCallCheck(this, BaseStore2);
          this.callbacks = [];
          this.actions = [];
          this.modules = opt.modules || [];
          this.initialize();
        }
        createClass(BaseStore2, [{
          key: "initialize",
          value: function initialize() {
            this.initializeModule();
          }
        }, {
          key: "initializeModule",
          value: function initializeModule() {
            var _this = this;
            this.modules.forEach(function(Module) {
              var instance = new Module(_this);
            });
          }
        }, {
          key: "action",
          value: function action(_action, context) {
            this.actions[_action] = { context, callback: context[_action] };
          }
        }, {
          key: "dispatch",
          value: function dispatch(action) {
            var args = [].concat(Array.prototype.slice.call(arguments));
            var action = args.shift();
            var m = this.actions[action];
            if (m) {
              return m.callback.apply(m.context, [this].concat(toConsumableArray(args)));
            }
          }
        }, {
          key: "module",
          value: function module3(ModuleObject) {
          }
        }, {
          key: "on",
          value: function on3(event, callback) {
            this.callbacks.push({ event, callback });
          }
        }, {
          key: "off",
          value: function off(event, callback) {
            if (arguments.length == 0) {
              this.callbacks = [];
            } else if (arguments.length == 1) {
              this.callbacks = this.callbacks.filter(function(f) {
                return f.event != event;
              });
            } else if (arguments.length == 2) {
              this.callbacks = this.callbacks.filter(function(f) {
                return f.event != event && f.callback != callback;
              });
            }
          }
        }, {
          key: "emit",
          value: function emit() {
            var args = [].concat(Array.prototype.slice.call(arguments));
            var event = args.shift();
            this.callbacks.filter(function(f) {
              return f.event == event;
            }).forEach(function(f) {
              if (f && typeof f.callback == "function") {
                f.callback.apply(f, toConsumableArray(args));
              }
            });
          }
        }]);
        return BaseStore2;
      }();
      var BaseColorPicker = function(_UIElement) {
        inherits(BaseColorPicker2, _UIElement);
        function BaseColorPicker2(opt) {
          classCallCheck(this, BaseColorPicker2);
          var _this = possibleConstructorReturn(this, (BaseColorPicker2.__proto__ || Object.getPrototypeOf(BaseColorPicker2)).call(this, opt));
          _this.isColorPickerShow = false;
          _this.isShortCut = false;
          _this.hideDelay = +(typeof _this.opt.hideDeplay == "undefined" ? 2e3 : _this.opt.hideDelay);
          _this.timerCloseColorPicker;
          _this.autoHide = _this.opt.autoHide || true;
          _this.outputFormat = _this.opt.outputFormat;
          _this.$checkColorPickerClass = _this.checkColorPickerClass.bind(_this);
          return _this;
        }
        createClass(BaseColorPicker2, [{
          key: "initialize",
          value: function initialize() {
            var _this2 = this;
            this.$body = null;
            this.$root = null;
            this.$store = new BaseStore({
              modules: [ColorManager, ColorSetsList]
            });
            this.callbackChange = function() {
              _this2.callbackColorValue();
            };
            this.callbackLastUpdate = function() {
              _this2.callbackLastUpdateColorValue();
            };
            this.colorpickerShowCallback = function() {
            };
            this.colorpickerHideCallback = function() {
            };
            this.colorpickerLastUpdateCallback = function() {
            };
            this.$body = new Dom(this.getContainer());
            this.$root = new Dom("div", "ace-colorpicker");
            if (this.opt.position == "inline") {
              this.$body.append(this.$root);
            }
            if (this.opt.type) {
              this.$root.addClass(this.opt.type);
            }
            if (this.opt.hideInformation) {
              this.$root.addClass("hide-information");
            }
            if (this.opt.hideColorsets) {
              this.$root.addClass("hide-colorsets");
            }
            this.$arrow = new Dom("div", "arrow");
            this.$root.append(this.$arrow);
            this.$store.dispatch("/setUserPalette", this.opt.colorSets);
            this.render();
            this.$root.append(this.$el);
            this.initColorWithoutChangeEvent(this.opt.color);
            this.initializeEvent();
          }
        }, {
          key: "initColorWithoutChangeEvent",
          value: function initColorWithoutChangeEvent(color2) {
            this.$store.dispatch("/initColor", color2);
          }
          /** 
           * public method 
           * 
           */
          /**
           * 
           * show colorpicker with position  
           * 
           * @param {{left, top, hideDelay, isShortCut}} opt 
           * @param {String|Object} color  
           * @param {Function} showCallback  it is called when colorpicker is shown
           * @param {Function} hideCallback  it is called once when colorpicker is hidden
           */
        }, {
          key: "show",
          value: function show(opt, color2, showCallback, hideCallback, lastUpdateCallback) {
            this.colorpickerShowCallback = showCallback;
            this.colorpickerHideCallback = hideCallback;
            this.colorpickerLastUpdateCallback = lastUpdateCallback;
            this.$root.css(this.getInitalizePosition()).show();
            this.isColorPickerShow = true;
            this.isShortCut = opt.isShortCut || false;
            this.outputFormat = opt.outputFormat;
            this.hideDelay = +(typeof opt.hideDelay == "undefined" ? 2e3 : opt.hideDelay);
            if (this.hideDelay > 0) {
              this.setHideDelay(this.hideDelay);
            }
            this.$root.appendTo(this.$body);
            this.definePosition(opt);
            this.initColorWithoutChangeEvent(color2);
          }
          /**
           * 
           * initialize color for colorpicker
           * 
           * @param {String|Object} newColor 
           * @param {String} format  hex, rgb, hsl
           */
        }, {
          key: "initColor",
          value: function initColor(newColor, format2) {
            this.$store.dispatch("/changeColor", newColor, format2);
          }
          /**
           * hide colorpicker 
           * 
           */
        }, {
          key: "hide",
          value: function hide() {
            if (this.isColorPickerShow) {
              this.$root.hide();
              this.$root.remove();
              this.isColorPickerShow = false;
              this.callbackHideColorValue();
            }
          }
          /**
           * set to colors in current sets that you see 
           * @param {Array} colors 
           */
        }, {
          key: "setColorsInPalette",
          value: function setColorsInPalette() {
            var colors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            this.$store.dispatch("/setCurrentColorAll", colors);
          }
          /**
           * refresh all color palette 
           * 
           * @param {*} list 
           */
        }, {
          key: "setUserPalette",
          value: function setUserPalette() {
            var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            this.$store.dispatch("/setUserPalette", list);
          }
          /**
           * private method 
           */
        }, {
          key: "getOption",
          value: function getOption(key) {
            return this.opt[key];
          }
        }, {
          key: "setOption",
          value: function setOption(key, value) {
            this.opt[key] = value;
          }
        }, {
          key: "isType",
          value: function isType(key) {
            return this.getOption("type") == key;
          }
        }, {
          key: "isPaletteType",
          value: function isPaletteType() {
            return this.isType("palette");
          }
        }, {
          key: "isSketchType",
          value: function isSketchType() {
            return this.isType("sketch");
          }
        }, {
          key: "getContainer",
          value: function getContainer() {
            return this.opt.container || document.body;
          }
        }, {
          key: "getColor",
          value: function getColor(type) {
            return this.$store.dispatch("/toColor", type);
          }
        }, {
          key: "definePositionForArrow",
          value: function definePositionForArrow(opt, elementScreenLeft, elementScreenTop) {
          }
        }, {
          key: "definePosition",
          value: function definePosition(opt) {
            var width = this.$root.width();
            var height = this.$root.height();
            var elementScreenLeft = opt.left - this.$body.scrollLeft();
            if (width + elementScreenLeft > window.innerWidth) {
              elementScreenLeft -= width + elementScreenLeft - window.innerWidth;
            }
            if (elementScreenLeft < 0) {
              elementScreenLeft = 0;
            }
            var elementScreenTop = opt.top - this.$body.scrollTop();
            var elementScreenBottom = opt.bottom - this.$body.scrollTop();
            if (height / 2 + elementScreenBottom > window.innerHeight) {
              elementScreenTop = elementScreenTop - height + this.$body.scrollTop();
            } else {
              elementScreenTop = elementScreenBottom + this.$body.scrollTop() + 1;
            }
            if (elementScreenTop < 0) {
              elementScreenTop = 0;
            }
            this.$root.css({
              left: elementScreenLeft + "px",
              top: elementScreenTop + "px"
            });
          }
        }, {
          key: "getInitalizePosition",
          value: function getInitalizePosition() {
            if (this.opt.position == "inline") {
              return {
                position: "relative",
                left: "auto",
                top: "auto",
                display: "inline-block"
              };
            } else {
              return {
                position: "absolute",
                // color picker has fixed position
                left: "-10000px",
                top: "-10000px"
              };
            }
          }
        }, {
          key: "isAbsolute",
          value: function isAbsolute() {
            return this.opt.position !== "inline";
          }
          // Event Bindings 
        }, {
          key: "mouseup.isAbsolute document",
          value: function mouseupIsAbsoluteDocument(e) {
            this.__isMouseDown = false;
            if (this.checkInHtml(e.target)) {
            } else if (this.checkColorPickerClass(e.target) == false) {
              this.hide();
            } else {
              if (!this.__isMouseIn) {
                clearTimeout(this.timerCloseColorPicker);
                this.timerCloseColorPicker = setTimeout(this.hide.bind(this), this.delayTime || this.hideDelay);
              }
            }
          }
        }, {
          key: "keyup.isAbsolute.escape $root",
          value: function keyupIsAbsoluteEscape$root(e) {
            this.hide();
          }
        }, {
          key: "mouseover.isAbsolute $root",
          value: function mouseoverIsAbsolute$root(e) {
            clearTimeout(this.timerCloseColorPicker);
          }
        }, {
          key: "mousemove.isAbsolute $root",
          value: function mousemoveIsAbsolute$root(e) {
            clearTimeout(this.timerCloseColorPicker);
          }
        }, {
          key: "mouseenter.isAbsolute $root",
          value: function mouseenterIsAbsolute$root(e) {
            clearTimeout(this.timerCloseColorPicker);
            this.__isMouseIn = true;
          }
        }, {
          key: "mouseleave.isAbsolute $root",
          value: function mouseleaveIsAbsolute$root(e) {
            this.__isMouseIn = false;
            if (!this.__isMouseDown) {
              clearTimeout(this.timerCloseColorPicker);
              this.timerCloseColorPicker = setTimeout(this.hide.bind(this), this.delayTime || this.hideDelay);
            }
          }
        }, {
          key: "mousedown.isAbsolute $root",
          value: function mousedownIsAbsolute$root(e) {
            this.__isMouseDown = true;
          }
        }, {
          key: "setHideDelay",
          value: function setHideDelay(delayTime) {
            this.delayTime = delayTime || 0;
          }
        }, {
          key: "runHideDelay",
          value: function runHideDelay() {
            if (this.isColorPickerShow) {
              this.setHideDelay();
            }
          }
        }, {
          key: "callbackColorValue",
          value: function callbackColorValue(color2) {
            color2 = color2 || this.getCurrentColor();
            if (typeof this.opt.onChange == "function") {
              this.opt.onChange.call(this, color2);
            }
            if (typeof this.colorpickerShowCallback == "function") {
              this.colorpickerShowCallback(color2);
            }
          }
        }, {
          key: "callbackLastUpdateColorValue",
          value: function callbackLastUpdateColorValue(color2) {
            color2 = color2 || this.getCurrentColor();
            if (typeof this.opt.onLastUpdate == "function") {
              this.opt.onLastUpdate.call(this, color2);
            }
            if (typeof this.colorpickerLastUpdateCallback == "function") {
              this.colorpickerLastUpdateCallback(color2);
            }
          }
        }, {
          key: "callbackHideColorValue",
          value: function callbackHideColorValue(color2) {
            color2 = color2 || this.getCurrentColor();
            if (typeof this.opt.onHide == "function") {
              this.opt.onHide.call(this, color2);
            }
            if (typeof this.colorpickerHideCallback == "function") {
              this.colorpickerHideCallback(color2);
            }
          }
        }, {
          key: "getCurrentColor",
          value: function getCurrentColor() {
            return this.$store.dispatch("/toColor", this.outputFormat);
          }
        }, {
          key: "checkColorPickerClass",
          value: function checkColorPickerClass(el) {
            var hasColorView = new Dom(el).closest("ace-colorview");
            var hasColorPicker = new Dom(el).closest("ace-colorpicker");
            return !!(hasColorPicker || hasColorView);
          }
        }, {
          key: "checkInHtml",
          value: function checkInHtml(el) {
            var IsInHtml = el.nodeName == "HTML";
            return IsInHtml;
          }
        }, {
          key: "initializeStoreEvent",
          value: function initializeStoreEvent() {
            get(BaseColorPicker2.prototype.__proto__ || Object.getPrototypeOf(BaseColorPicker2.prototype), "initializeStoreEvent", this).call(this);
            this.$store.on("changeColor", this.callbackChange);
            this.$store.on("lastUpdateColor", this.callbackLastUpdate);
            this.$store.on("changeFormat", this.callbackChange);
          }
        }, {
          key: "destroy",
          value: function destroy() {
            get(BaseColorPicker2.prototype.__proto__ || Object.getPrototypeOf(BaseColorPicker2.prototype), "destroy", this).call(this);
            this.$store.off("changeColor", this.callbackChange);
            this.$store.off("lastUpdateColor", this.callbackLastUpdate);
            this.$store.off("changeFormat", this.callbackChange);
            this.callbackChange = void 0;
            this.callbackLastUpdate = void 0;
            this.colorpickerShowCallback = void 0;
            this.colorpickerHideCallback = void 0;
          }
        }]);
        return BaseColorPicker2;
      }(UIElement);
      var BaseBox = function(_UIElement) {
        inherits(BaseBox2, _UIElement);
        function BaseBox2(opt) {
          classCallCheck(this, BaseBox2);
          var _this = possibleConstructorReturn(this, (BaseBox2.__proto__ || Object.getPrototypeOf(BaseBox2)).call(this, opt));
          _this.source = "base-box";
          return _this;
        }
        createClass(BaseBox2, [{
          key: "refresh",
          value: function refresh() {
          }
        }, {
          key: "refreshColorUI",
          value: function refreshColorUI(e) {
          }
          /** push change event  */
        }, {
          key: "changeColor",
          value: function changeColor(opt) {
            this.$store.dispatch("/changeColor", Object.assign({
              source: this.source
            }, opt || {}));
          }
          // Event Bindings 
        }, {
          key: "mouseup document",
          value: function mouseupDocument(e) {
            this.onDragEnd(e);
          }
        }, {
          key: "mousemove document",
          value: function mousemoveDocument(e) {
            this.onDragMove(e);
          }
        }, {
          key: "mousedown $bar",
          value: function mousedown$bar(e) {
            e.preventDefault();
            this.isDown = true;
          }
        }, {
          key: "mousedown $container",
          value: function mousedown$container(e) {
            this.isDown = true;
            this.onDragStart(e);
          }
        }, {
          key: "touchend document",
          value: function touchendDocument(e) {
            this.onDragEnd(e);
          }
        }, {
          key: "touchmove document",
          value: function touchmoveDocument(e) {
            this.onDragMove(e);
          }
        }, {
          key: "touchstart $bar",
          value: function touchstart$bar(e) {
            e.preventDefault();
            this.isDown = true;
          }
        }, {
          key: "touchstart $container",
          value: function touchstart$container(e) {
            this.onDragStart(e);
          }
        }, {
          key: "onDragStart",
          value: function onDragStart(e) {
            this.isDown = true;
            this.refreshColorUI(e);
          }
        }, {
          key: "onDragMove",
          value: function onDragMove(e) {
            if (this.isDown) {
              this.refreshColorUI(e);
            }
          }
          /* called when mouse is ended move  */
        }, {
          key: "onDragEnd",
          value: function onDragEnd(e) {
            if (this.isDown) {
              this.$store.emit("lastUpdateColor");
              this.isDown = false;
            }
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (this.source != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return BaseBox2;
      }(UIElement);
      var BaseSlider = function(_BaseBox) {
        inherits(BaseSlider2, _BaseBox);
        function BaseSlider2(opt) {
          classCallCheck(this, BaseSlider2);
          var _this = possibleConstructorReturn(this, (BaseSlider2.__proto__ || Object.getPrototypeOf(BaseSlider2)).call(this, opt));
          _this.minValue = 0;
          _this.maxValue = 1;
          _this.source = "base-slider";
          return _this;
        }
        createClass(BaseSlider2, [{
          key: "getMinMaxPosition",
          value: function getMinMaxPosition() {
            var min2 = this.getMinPosition();
            var width = this.getMaxDist();
            var max2 = min2 + width;
            return { min: min2, max: max2, width };
          }
          /** get current position on page  */
        }, {
          key: "getCurrent",
          value: function getCurrent(value) {
            return min + this.getMaxDist() * value;
          }
          /** get min position on slider container  */
        }, {
          key: "getMinPosition",
          value: function getMinPosition() {
            return this.refs.$container.offset().left;
          }
        }, {
          key: "getMaxDist",
          value: function getMaxDist() {
            return this.state.get("$container.width");
          }
          /** get dist for position value */
        }, {
          key: "getDist",
          value: function getDist(current) {
            var _getMinMaxPosition = this.getMinMaxPosition(), min2 = _getMinMaxPosition.min, max2 = _getMinMaxPosition.max;
            var dist;
            if (current < min2) {
              dist = 0;
            } else if (current > max2) {
              dist = 100;
            } else {
              dist = (current - min2) / (max2 - min2) * 100;
            }
            return dist;
          }
          /** get caculated dist for domain value   */
        }, {
          key: "getCaculatedDist",
          value: function getCaculatedDist(e) {
            var current = e ? this.getMousePosition(e) : this.getCurrent(this.getDefaultValue() / this.maxValue);
            var dist = this.getDist(current);
            return dist;
          }
          /** get default value used in slider container */
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return 0;
          }
          /** set mosue position */
        }, {
          key: "setMousePosition",
          value: function setMousePosition(x) {
            this.refs.$bar.css({ left: x + "px" });
          }
          /** set mouse position in page */
        }, {
          key: "getMousePosition",
          value: function getMousePosition(e) {
            return Event.pos(e).pageX;
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
          }
          /** set drag bar position  */
        }, {
          key: "setColorUI",
          value: function setColorUI(v2) {
            v2 = v2 || this.getDefaultValue();
            if (v2 <= this.minValue) {
              this.refs.$bar.addClass("first").removeClass("last");
            } else if (v2 >= this.maxValue) {
              this.refs.$bar.addClass("last").removeClass("first");
            } else {
              this.refs.$bar.removeClass("last").removeClass("first");
            }
            this.setMousePosition(this.getMaxDist() * ((v2 || 0) / this.maxValue));
          }
        }]);
        return BaseSlider2;
      }(BaseBox);
      var Value = function(_BaseSlider) {
        inherits(Value2, _BaseSlider);
        function Value2(opt) {
          classCallCheck(this, Value2);
          var _this = possibleConstructorReturn(this, (Value2.__proto__ || Object.getPrototypeOf(Value2)).call(this, opt));
          _this.minValue = 0;
          _this.maxValue = 1;
          _this.source = "value-control";
          return _this;
        }
        createClass(Value2, [{
          key: "template",
          value: function template() {
            return '\n            <div class="value">\n                <div ref="$container" class="value-container">\n                    <div ref="$bar" class="drag-bar"></div>\n                </div>\n            </div>\n        ';
          }
        }, {
          key: "setBackgroundColor",
          value: function setBackgroundColor() {
            this.refs.$container.css("background-color", this.$store.dispatch("/toRGB"));
          }
        }, {
          key: "refresh",
          value: function refresh() {
            get(Value2.prototype.__proto__ || Object.getPrototypeOf(Value2.prototype), "refresh", this).call(this);
            this.setBackgroundColor();
          }
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return this.$store.hsv.v;
          }
        }, {
          key: "refreshColorUI",
          value: function refreshColorUI(e) {
            var dist = this.getCaculatedDist(e);
            this.setColorUI(dist / 100 * this.maxValue);
            this.changeColor({
              type: "hsv",
              v: dist / 100 * this.maxValue
            });
          }
        }]);
        return Value2;
      }(BaseSlider);
      var Opacity = function(_BaseSlider) {
        inherits(Opacity2, _BaseSlider);
        function Opacity2(opt) {
          classCallCheck(this, Opacity2);
          var _this = possibleConstructorReturn(this, (Opacity2.__proto__ || Object.getPrototypeOf(Opacity2)).call(this, opt));
          _this.minValue = 0;
          _this.maxValue = 1;
          _this.source = "opacity-control";
          return _this;
        }
        createClass(Opacity2, [{
          key: "template",
          value: function template() {
            return '\n        <div class="opacity">\n            <div ref="$container" class="opacity-container">\n                <div ref="$colorbar" class="color-bar"></div>\n                <div ref="$bar" class="drag-bar"></div>\n            </div>\n        </div>\n        ';
          }
        }, {
          key: "refresh",
          value: function refresh() {
            get(Opacity2.prototype.__proto__ || Object.getPrototypeOf(Opacity2.prototype), "refresh", this).call(this);
            this.setOpacityColorBar();
          }
        }, {
          key: "setOpacityColorBar",
          value: function setOpacityColorBar() {
            var rgb2 = Object.assign({}, this.$store.rgb);
            rgb2.a = 0;
            var start = Color$1.format(rgb2, "rgb");
            rgb2.a = 1;
            var end = Color$1.format(rgb2, "rgb");
            this.setOpacityColorBarBackground(start, end);
          }
        }, {
          key: "setOpacityColorBarBackground",
          value: function setOpacityColorBarBackground(start, end) {
            this.refs.$colorbar.css("background", "linear-gradient(to right, " + start + ", " + end + ")");
          }
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return this.$store.alpha;
          }
        }, {
          key: "refreshColorUI",
          value: function refreshColorUI(e) {
            var dist = this.getCaculatedDist(e);
            this.setColorUI(dist / 100 * this.maxValue);
            this.changeColor({
              a: Math.floor(dist) / 100 * this.maxValue
            });
          }
        }]);
        return Opacity2;
      }(BaseSlider);
      var source = "macos-control";
      var ColorControl = function(_UIElement) {
        inherits(ColorControl2, _UIElement);
        function ColorControl2() {
          classCallCheck(this, ColorControl2);
          return possibleConstructorReturn(this, (ColorControl2.__proto__ || Object.getPrototypeOf(ColorControl2)).apply(this, arguments));
        }
        createClass(ColorControl2, [{
          key: "components",
          value: function components() {
            return { Value, Opacity };
          }
        }, {
          key: "template",
          value: function template() {
            return '\n        <div class="control">\n            <div target="Value" ></div>\n            <div target="Opacity" ></div>\n            <div ref="$controlPattern" class="empty"></div>\n            <div ref="$controlColor" class="color"></div>\n        </div>\n        ';
          }
        }, {
          key: "setBackgroundColor",
          value: function setBackgroundColor() {
            this.refs.$controlColor.css("background-color", this.$store.dispatch("/toRGB"));
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
            this.setBackgroundColor();
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            this.Value.setColorUI();
            this.Opacity.setColorUI();
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return ColorControl2;
      }(UIElement);
      var ColorWheel = function(_UIElement) {
        inherits(ColorWheel2, _UIElement);
        function ColorWheel2(opt) {
          classCallCheck(this, ColorWheel2);
          var _this = possibleConstructorReturn(this, (ColorWheel2.__proto__ || Object.getPrototypeOf(ColorWheel2)).call(this, opt));
          _this.width = 214;
          _this.height = 214;
          _this.thinkness = 0;
          _this.half_thinkness = 0;
          _this.source = "colorwheel";
          return _this;
        }
        createClass(ColorWheel2, [{
          key: "template",
          value: function template() {
            return '\n        <div class="wheel">\n            <canvas class="wheel-canvas" ref="$colorwheel" ></canvas>\n            <div class="wheel-canvas" ref="$valuewheel" ></div>\n            <div class="drag-pointer" ref="$drag_pointer"></div>\n        </div>\n        ';
          }
        }, {
          key: "refresh",
          value: function refresh(isEvent) {
            this.setColorUI(isEvent);
          }
        }, {
          key: "setColorUI",
          value: function setColorUI(isEvent) {
            this.renderCanvas();
            this.renderValue();
            this.setHueColor(null, isEvent);
          }
        }, {
          key: "renderValue",
          value: function renderValue() {
            var value = 1 - this.$store.hsv.v;
            this.refs.$valuewheel.css({
              "background-color": "rgba(0, 0, 0, " + value + ")"
            });
          }
        }, {
          key: "renderWheel",
          value: function renderWheel(width, height) {
            if (this.width && !width) width = this.width;
            if (this.height && !height) height = this.height;
            var $canvas = new Dom("canvas");
            var context = $canvas.el.getContext("2d");
            $canvas.el.width = width;
            $canvas.el.height = height;
            $canvas.css({ width: width + "px", height: height + "px" });
            var img = context.getImageData(0, 0, width, height);
            var pixels = img.data;
            var half_width = Math.floor(width / 2);
            var half_height = Math.floor(height / 2);
            var radius = width > height ? half_height : half_width;
            var cx = half_width;
            var cy = half_height;
            for (var y2 = 0; y2 < height; y2++) {
              for (var x = 0; x < width; x++) {
                var rx = x - cx + 1, ry = y2 - cy + 1, d = rx * rx + ry * ry, hue2 = caculateAngle(rx, ry);
                var rgb2 = Color$1.HSVtoRGB(
                  hue2,
                  // 0~360 hue 
                  Math.min(Math.sqrt(d) / radius, 1),
                  // 0..1 Saturation 
                  1
                  //  0..1 Value
                );
                var index2 = (y2 * width + x) * 4;
                pixels[index2] = rgb2.r;
                pixels[index2 + 1] = rgb2.g;
                pixels[index2 + 2] = rgb2.b;
                pixels[index2 + 3] = 255;
              }
            }
            context.putImageData(img, 0, 0);
            if (this.thinkness > 0) {
              context.globalCompositeOperation = "destination-out";
              context.fillStyle = "black";
              context.beginPath();
              context.arc(cx, cy, radius - this.thinkness, 0, Math.PI * 2);
              context.closePath();
              context.fill();
            }
            return $canvas;
          }
        }, {
          key: "renderCanvas",
          value: function renderCanvas() {
            if (this.$store.createdWheelCanvas) return;
            var $canvas = this.refs.$colorwheel;
            var context = $canvas.el.getContext("2d");
            var _$canvas$size = $canvas.size(), _$canvas$size2 = slicedToArray(_$canvas$size, 2), width = _$canvas$size2[0], height = _$canvas$size2[1];
            if (this.width && !width) width = this.width;
            if (this.height && !height) height = this.height;
            $canvas.el.width = width;
            $canvas.el.height = height;
            $canvas.css({ width: width + "px", height: height + "px" });
            var $wheelCanvas = this.renderWheel(width, height);
            context.drawImage($wheelCanvas.el, 0, 0);
            this.$store.createdWheelCanvas = true;
          }
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return this.$store.hsv.h;
          }
        }, {
          key: "getDefaultSaturation",
          value: function getDefaultSaturation() {
            return this.$store.hsv.s;
          }
        }, {
          key: "getCurrentXY",
          value: function getCurrentXY(e, angle, radius, centerX, centerY) {
            return e ? Event.posXY(e) : getXYInCircle(angle, radius, centerX, centerY);
          }
        }, {
          key: "getRectangle",
          value: function getRectangle() {
            var width = this.state.get("$el.width");
            var height = this.state.get("$el.height");
            var radius = this.state.get("$colorwheel.width") / 2;
            var minX = this.refs.$el.offset().left;
            var centerX = minX + width / 2;
            var minY = this.refs.$el.offset().top;
            var centerY = minY + height / 2;
            return { minX, minY, width, height, radius, centerX, centerY };
          }
        }, {
          key: "setHueColor",
          value: function setHueColor(e, isEvent) {
            if (!this.state.get("$el.width")) return;
            var _getRectangle = this.getRectangle(), minX = _getRectangle.minX, minY = _getRectangle.minY, radius = _getRectangle.radius, centerX = _getRectangle.centerX, centerY = _getRectangle.centerY;
            var _getCurrentXY = this.getCurrentXY(e, this.getDefaultValue(), this.getDefaultSaturation() * radius, centerX, centerY), x = _getCurrentXY.x, y2 = _getCurrentXY.y;
            var rx = x - centerX, ry = y2 - centerY, d = rx * rx + ry * ry, hue2 = caculateAngle(rx, ry);
            if (d > radius * radius) {
              var _getCurrentXY2 = this.getCurrentXY(null, hue2, radius, centerX, centerY), x = _getCurrentXY2.x, y2 = _getCurrentXY2.y;
            }
            var saturation2 = Math.min(Math.sqrt(d) / radius, 1);
            this.refs.$drag_pointer.css({
              left: x - minX + "px",
              top: y2 - minY + "px"
            });
            if (!isEvent) {
              this.changeColor({
                type: "hsv",
                h: hue2,
                s: saturation2
              });
            }
          }
        }, {
          key: "changeColor",
          value: function changeColor(opt) {
            this.$store.dispatch("/changeColor", Object.assign({
              source: this.source
            }, opt || {}));
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (this.source != sourceType) {
              this.refresh(true);
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh(true);
          }
          // Event Bindings 
        }, {
          key: "mouseup document",
          value: function mouseupDocument(e) {
            if (this.isDown) {
              this.isDown = false;
              this.$store.emit("lastUpdateColor");
            }
          }
        }, {
          key: "mousemove document",
          value: function mousemoveDocument(e) {
            if (this.isDown) {
              this.setHueColor(e);
            }
          }
        }, {
          key: "mousedown $drag_pointer",
          value: function mousedown$drag_pointer(e) {
            e.preventDefault();
            this.isDown = true;
          }
        }, {
          key: "mousedown $el",
          value: function mousedown$el(e) {
            this.isDown = true;
            this.setHueColor(e);
          }
        }, {
          key: "touchend document",
          value: function touchendDocument(e) {
            if (this.isDown) {
              this.isDown = false;
              this.$store.emit("lastUpdateColor");
            }
          }
        }, {
          key: "touchmove document",
          value: function touchmoveDocument(e) {
            if (this.isDown) {
              this.setHueColor(e);
            }
          }
        }, {
          key: "touchstart $drag_pointer",
          value: function touchstart$drag_pointer(e) {
            e.preventDefault();
            this.isDown = true;
          }
        }, {
          key: "touchstart $el",
          value: function touchstart$el(e) {
            e.preventDefault();
            this.isDown = true;
            this.setHueColor(e);
          }
        }]);
        return ColorWheel2;
      }(UIElement);
      var source$2 = "chromedevtool-information";
      var ColorInformation = function(_UIElement) {
        inherits(ColorInformation2, _UIElement);
        function ColorInformation2() {
          classCallCheck(this, ColorInformation2);
          return possibleConstructorReturn(this, (ColorInformation2.__proto__ || Object.getPrototypeOf(ColorInformation2)).apply(this, arguments));
        }
        createClass(ColorInformation2, [{
          key: "template",
          value: function template() {
            return (
              /*html*/
              '\n        <div class="information hex">\n            <div ref="$informationChange" class="information-change">\n                <button ref="$formatChangeButton" type="button" class="format-change-button arrow-button"></button>\n            </div>\n            <div class="information-item hex">\n                <div class="input-field hex">\n                    <input ref="$hexCode" class="input" type="text" />\n                    <div class="title">HEX</div>\n                </div>\n            </div>\n            <div class="information-item rgb">\n                <div class="input-field rgb-r">\n                    <input ref="$rgb_r" class="input" type="number" step="1" min="0" max="255" />\n                    <div class="title">R</div>\n                </div>\n                <div class="input-field rgb-g">\n                    <input ref="$rgb_g" class="input" type="number" step="1" min="0" max="255" />\n                    <div class="title">G</div>\n                </div>\n                <div class="input-field rgb-b">\n                    <input ref="$rgb_b" class="input" type="number" step="1" min="0" max="255" />\n                    <div class="title">B</div>\n                </div>          \n                <div class="input-field rgb-a">\n                    <input ref="$rgb_a" class="input" type="number" step="0.01" min="0" max="1" />\n                    <div class="title">A</div>\n                </div>                                                            \n            </div>\n            <div class="information-item hsl">\n                <div class="input-field hsl-h">\n                    <input ref="$hsl_h" class="input" type="number" step="1" min="0" max="360" />\n                    <div class="title">H</div>\n                </div>\n                <div class="input-field hsl-s">\n                    <input ref="$hsl_s" class="input" type="number" step="1" min="0" max="100" />\n                    <div class="postfix">%</div>\n                    <div class="title">S</div>\n                </div>\n                <div class="input-field hsl-l">\n                    <input ref="$hsl_l" class="input" type="number" step="1" min="0" max="100" />\n                    <div class="postfix">%</div>                        \n                    <div class="title">L</div>\n                </div>\n                <div class="input-field hsl-a">\n                    <input ref="$hsl_a" class="input" type="number" step="0.01" min="0" max="1" />\n                    <div class="title">A</div>\n                </div>\n            </div>\n        </div>\n        '
            );
          }
        }, {
          key: "setCurrentFormat",
          value: function setCurrentFormat(format2) {
            this.format = format2;
            this.initFormat();
          }
        }, {
          key: "initFormat",
          value: function initFormat() {
            var _this2 = this;
            var current_format = this.format || "hex";
            ["hex", "rgb", "hsl"].filter(function(it3) {
              return it3 !== current_format;
            }).forEach(function(formatString) {
              _this2.$el.removeClass(formatString);
            });
            this.$el.addClass(current_format);
          }
        }, {
          key: "nextFormat",
          value: function nextFormat() {
            var current_format = this.$store.format || "hex";
            var next_format = "hex";
            if (current_format == "hex") {
              next_format = "rgb";
            } else if (current_format == "rgb") {
              next_format = "hsl";
            } else if (current_format == "hsl") {
              next_format = "hex";
            }
            this.format = next_format;
            this.$store.dispatch("/changeFormat", next_format);
            this.$store.emit("lastUpdateColor");
            this.initFormat();
          }
        }, {
          key: "goToFormat",
          value: function goToFormat(to_format) {
            this.format = to_format;
            this.$store.dispatch("/changeFormat", this.format);
            this.$store.emit("lastUpdateColor");
            this.initFormat();
          }
        }, {
          key: "getFormat",
          value: function getFormat() {
            return this.format || "hex";
          }
        }, {
          key: "checkNumberKey",
          value: function checkNumberKey(e) {
            var code = e.which, isExcept = false;
            if (code == 37 || code == 39 || code == 8 || code == 46 || code == 9) isExcept = true;
            if (!isExcept && (code < 48 || code > 57)) return false;
            return true;
          }
        }, {
          key: "checkNotNumberKey",
          value: function checkNotNumberKey(e) {
            return !this.checkNumberKey(e);
          }
        }, {
          key: "changeRgbColor",
          value: function changeRgbColor() {
            this.$store.dispatch("/changeColor", {
              type: "rgb",
              r: this.refs.$rgb_r.int(),
              g: this.refs.$rgb_g.int(),
              b: this.refs.$rgb_b.int(),
              a: this.refs.$rgb_a.float(),
              source: source$2
            });
            this.$store.emit("lastUpdateColor");
          }
        }, {
          key: "changeHslColor",
          value: function changeHslColor() {
            this.$store.dispatch("/changeColor", {
              type: "hsl",
              h: this.refs.$hsl_h.int(),
              s: this.refs.$hsl_s.int(),
              l: this.refs.$hsl_l.int(),
              a: this.refs.$hsl_a.float(),
              source: source$2
            });
            this.$store.emit("lastUpdateColor");
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source$2 != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }, {
          key: "input $rgb_r",
          value: function input$rgb_r(e) {
            this.changeRgbColor();
          }
        }, {
          key: "input $rgb_g",
          value: function input$rgb_g(e) {
            this.changeRgbColor();
          }
        }, {
          key: "input $rgb_b",
          value: function input$rgb_b(e) {
            this.changeRgbColor();
          }
        }, {
          key: "input $rgb_a",
          value: function input$rgb_a(e) {
            this.changeRgbColor();
          }
        }, {
          key: "input $hsl_h",
          value: function input$hsl_h(e) {
            this.changeHslColor();
          }
        }, {
          key: "input $hsl_s",
          value: function input$hsl_s(e) {
            this.changeHslColor();
          }
        }, {
          key: "input $hsl_l",
          value: function input$hsl_l(e) {
            this.changeHslColor();
          }
        }, {
          key: "input $hsl_a",
          value: function input$hsl_a(e) {
            this.changeHslColor();
          }
        }, {
          key: "keyup $hexCode",
          value: function keyup$hexCode(e) {
            var code = this.refs.$hexCode.val();
            if (code.charAt(0) == "#" && (code.length == 7 || code.length === 9)) {
              this.$store.dispatch("/changeColor", code, source$2);
              this.$store.emit("lastUpdateColor");
            }
          }
        }, {
          key: "click $formatChangeButton",
          value: function click$formatChangeButton(e) {
            this.nextFormat();
          }
        }, {
          key: "click $el .information-item.hex .input-field .title",
          value: function click$elInformationItemHexInputFieldTitle(e) {
            this.goToFormat("rgb");
          }
        }, {
          key: "click $el .information-item.rgb .input-field .title",
          value: function click$elInformationItemRgbInputFieldTitle(e) {
            this.goToFormat("hsl");
          }
        }, {
          key: "click $el .information-item.hsl .input-field .title",
          value: function click$elInformationItemHslInputFieldTitle(e) {
            this.goToFormat("hex");
          }
        }, {
          key: "setRGBInput",
          value: function setRGBInput() {
            this.refs.$rgb_r.val(this.$store.rgb.r);
            this.refs.$rgb_g.val(this.$store.rgb.g);
            this.refs.$rgb_b.val(this.$store.rgb.b);
            this.refs.$rgb_a.val(this.$store.alpha);
          }
        }, {
          key: "setHSLInput",
          value: function setHSLInput() {
            this.refs.$hsl_h.val(this.$store.hsl.h);
            this.refs.$hsl_s.val(this.$store.hsl.s);
            this.refs.$hsl_l.val(this.$store.hsl.l);
            this.refs.$hsl_a.val(this.$store.alpha);
          }
        }, {
          key: "setHexInput",
          value: function setHexInput() {
            this.refs.$hexCode.val(this.$store.dispatch("/toHEX"));
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setCurrentFormat(this.$store.format);
            this.setRGBInput();
            this.setHSLInput();
            this.setHexInput();
          }
        }]);
        return ColorInformation2;
      }(UIElement);
      var DATA_COLORSETS_INDEX = "data-colorsets-index";
      var ColorSetsChooser = function(_UIElement) {
        inherits(ColorSetsChooser2, _UIElement);
        function ColorSetsChooser2() {
          classCallCheck(this, ColorSetsChooser2);
          return possibleConstructorReturn(this, (ColorSetsChooser2.__proto__ || Object.getPrototypeOf(ColorSetsChooser2)).apply(this, arguments));
        }
        createClass(ColorSetsChooser2, [{
          key: "template",
          value: function template() {
            return '\n            <div class="color-chooser">\n                <div class="color-chooser-container">\n                    <div class="colorsets-item colorsets-item-header">\n                        <h1 class="title">Color Palettes</h1>\n                        <span ref="$toggleButton" class="items">&times;</span>\n                    </div>\n                    <div ref="$colorsetsList" class="colorsets-list"></div>\n                </div>\n            </div>\n        ';
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.load();
          }
        }, {
          key: "@changeCurrentColorSets",
          value: function changeCurrentColorSets() {
            this.refresh();
          }
        }, {
          key: "@toggleColorChooser",
          value: function toggleColorChooser() {
            this.toggle();
          }
          // loadable 
        }, {
          key: "load $colorsetsList",
          value: function load$colorsetsList() {
            var colorSets = this.$store.dispatch("/getColorSetsList");
            return "\n            <div>\n                " + colorSets.map(function(element, index2) {
              return '\n                        <div class="colorsets-item" data-colorsets-index="' + index2 + '" >\n                            <h1 class="title">' + element.name + '</h1>\n                            <div class="items">\n                                <div>\n                                    ' + element.colors.filter(function(color2, i) {
                return i < 5;
              }).map(function(color2) {
                color2 = color2 || "rgba(255, 255, 255, 1)";
                return '<div class="color-item" title="' + color2 + '">\n                                                <div class="color-view" style="background-color: ' + color2 + '"></div>\n                                            </div>';
              }).join("") + "\n                                </div>\n                            </div>\n                        </div>";
            }).join("") + "\n            </div>\n        ";
          }
        }, {
          key: "show",
          value: function show() {
            this.$el.addClass("open");
          }
        }, {
          key: "hide",
          value: function hide() {
            this.$el.removeClass("open");
          }
        }, {
          key: "toggle",
          value: function toggle() {
            this.$el.toggleClass("open");
          }
        }, {
          key: "click $toggleButton",
          value: function click$toggleButton(e) {
            this.toggle();
          }
        }, {
          key: "click $colorsetsList .colorsets-item",
          value: function click$colorsetsListColorsetsItem(e) {
            var $item = e.$delegateTarget;
            if ($item) {
              var index2 = parseInt($item.attr(DATA_COLORSETS_INDEX));
              this.$store.dispatch("/setCurrentColorSets", index2);
              this.hide();
            }
          }
        }, {
          key: "destroy",
          value: function destroy() {
            get(ColorSetsChooser2.prototype.__proto__ || Object.getPrototypeOf(ColorSetsChooser2.prototype), "destroy", this).call(this);
            this.hide();
          }
        }]);
        return ColorSetsChooser2;
      }(UIElement);
      var CurrentColorSets = function(_UIElement) {
        inherits(CurrentColorSets2, _UIElement);
        function CurrentColorSets2() {
          classCallCheck(this, CurrentColorSets2);
          return possibleConstructorReturn(this, (CurrentColorSets2.__proto__ || Object.getPrototypeOf(CurrentColorSets2)).apply(this, arguments));
        }
        createClass(CurrentColorSets2, [{
          key: "template",
          value: function template() {
            return '\n            <div class="colorsets">\n                <div class="menu" title="Open Color Palettes">\n                    <button ref="$colorSetsChooseButton" type="button" class="color-sets-choose-btn arrow-button"></button>\n                </div>\n                <div ref="$colorSetsColorList" class="color-list"></div>\n            </div>\n        ';
          }
        }, {
          key: "load $colorSetsColorList",
          value: function load$colorSetsColorList() {
            var currentColorSets = this.$store.dispatch("/getCurrentColorSets");
            var colors = this.$store.dispatch("/getCurrentColors");
            return '\n            <div class="current-color-sets">\n            ' + colors.map(function(color2, i) {
              return '<div class="color-item" title="' + color2 + '" data-index="' + i + '" data-color="' + color2 + '">\n                    <div class="empty"></div>\n                    <div class="color-view" style="background-color: ' + color2 + '"></div>\n                </div>';
            }).join("") + "   \n            " + (currentColorSets.edit ? '<div class="add-color-item">+</div>' : "") + "         \n            </div>\n        ";
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.load();
          }
        }, {
          key: "addColor",
          value: function addColor(color2) {
            this.$store.dispatch("/addCurrentColor", color2);
          }
        }, {
          key: "@changeCurrentColorSets",
          value: function changeCurrentColorSets() {
            this.refresh();
          }
        }, {
          key: "click $colorSetsChooseButton",
          value: function click$colorSetsChooseButton(e) {
            this.$store.emit("toggleColorChooser");
          }
        }, {
          key: "contextmenu $colorSetsColorList",
          value: function contextmenu$colorSetsColorList(e) {
            e.preventDefault();
            var currentColorSets = this.$store.dispatch("/getCurrentColorSets");
            if (!currentColorSets.edit) {
              return;
            }
            var $target = new Dom(e.target);
            var $item = $target.closest("color-item");
            if ($item) {
              var index2 = parseInt($item.attr("data-index"));
              this.$store.emit("showContextMenu", e, index2);
            } else {
              this.$store.emit("showContextMenu", e);
            }
          }
        }, {
          key: "click $colorSetsColorList .add-color-item",
          value: function click$colorSetsColorListAddColorItem(e) {
            this.addColor(this.$store.dispatch("/toColor"));
          }
        }, {
          key: "click $colorSetsColorList .color-item",
          value: function click$colorSetsColorListColorItem(e) {
            this.$store.dispatch("/changeColor", e.$delegateTarget.attr("data-color"));
            this.$store.emit("lastUpdateColor");
          }
        }]);
        return CurrentColorSets2;
      }(UIElement);
      var CurrentColorSetsContextMenu = function(_UIElement) {
        inherits(CurrentColorSetsContextMenu2, _UIElement);
        function CurrentColorSetsContextMenu2() {
          classCallCheck(this, CurrentColorSetsContextMenu2);
          return possibleConstructorReturn(this, (CurrentColorSetsContextMenu2.__proto__ || Object.getPrototypeOf(CurrentColorSetsContextMenu2)).apply(this, arguments));
        }
        createClass(CurrentColorSetsContextMenu2, [{
          key: "template",
          value: function template() {
            return '\n            <ul class="colorsets-contextmenu">\n                <li class="menu-item small-hide" data-type="remove-color">Remove color</li>\n                <li class="menu-item small-hide" data-type="remove-all-to-the-right">Remove all to the right</li>\n                <li class="menu-item" data-type="clear-palette">Clear palette</li>\n            </ul>\n        ';
          }
        }, {
          key: "show",
          value: function show(e, index2) {
            var $event = Event.pos(e);
            this.$el.css({
              top: $event.clientY - 10 + "px",
              left: $event.clientX + "px"
            });
            this.$el.addClass("show");
            this.selectedColorIndex = index2;
            if (typeof this.selectedColorIndex == "undefined") {
              this.$el.addClass("small");
            } else {
              this.$el.removeClass("small");
            }
          }
        }, {
          key: "hide",
          value: function hide() {
            this.$el.removeClass("show");
          }
        }, {
          key: "runCommand",
          value: function runCommand(command) {
            switch (command) {
              case "remove-color":
                this.$store.dispatch("/removeCurrentColor", this.selectedColorIndex);
                break;
              case "remove-all-to-the-right":
                this.$store.dispatch("/removeCurrentColorToTheRight", this.selectedColorIndex);
                break;
              case "clear-palette":
                this.$store.dispatch("/clearPalette");
                break;
            }
          }
        }, {
          key: "@showContextMenu",
          value: function showContextMenu(e, index2) {
            this.show(e, index2);
          }
        }, {
          key: "click $el .menu-item",
          value: function click$elMenuItem(e) {
            e.preventDefault();
            this.runCommand(e.$delegateTarget.attr("data-type"));
            this.hide();
          }
        }]);
        return CurrentColorSetsContextMenu2;
      }(UIElement);
      var MacOSColorPicker = function(_BaseColorPicker) {
        inherits(MacOSColorPicker2, _BaseColorPicker);
        function MacOSColorPicker2() {
          classCallCheck(this, MacOSColorPicker2);
          return possibleConstructorReturn(this, (MacOSColorPicker2.__proto__ || Object.getPrototypeOf(MacOSColorPicker2)).apply(this, arguments));
        }
        createClass(MacOSColorPicker2, [{
          key: "template",
          value: function template() {
            return `
            <div class='colorpicker-body'>
                <div target="colorwheel"></div>
                <div target="control"></div>
                <div target="information"></div>
                <div target="currentColorSets"></div>
                <div target="colorSetsChooser"></div>
                <div target="contextMenu"></div>                
            </div>
        `;
          }
        }, {
          key: "components",
          value: function components() {
            return {
              colorwheel: ColorWheel,
              control: ColorControl,
              information: ColorInformation,
              currentColorSets: CurrentColorSets,
              colorSetsChooser: ColorSetsChooser,
              contextMenu: CurrentColorSetsContextMenu
            };
          }
        }]);
        return MacOSColorPicker2;
      }(BaseColorPicker);
      var Hue = function(_BaseSlider) {
        inherits(Hue2, _BaseSlider);
        function Hue2(opt) {
          classCallCheck(this, Hue2);
          var _this = possibleConstructorReturn(this, (Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call(this, opt));
          _this.minValue = 0;
          _this.maxValue = 360;
          _this.source = "hue-control";
          return _this;
        }
        createClass(Hue2, [{
          key: "template",
          value: function template() {
            return '\n            <div class="hue">\n                <div ref="$container" class="hue-container">\n                    <div ref="$bar" class="drag-bar"></div>\n                </div>\n            </div>\n        ';
          }
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return this.$store.hsv.h;
          }
        }, {
          key: "refreshColorUI",
          value: function refreshColorUI(e) {
            var dist = this.getCaculatedDist(e);
            this.setColorUI(dist / 100 * this.maxValue);
            this.changeColor({
              h: dist / 100 * this.maxValue,
              type: "hsv"
            });
          }
        }]);
        return Hue2;
      }(BaseSlider);
      var source$3 = "chromedevtool-control";
      var ColorControl$2 = function(_UIElement) {
        inherits(ColorControl2, _UIElement);
        function ColorControl2() {
          classCallCheck(this, ColorControl2);
          return possibleConstructorReturn(this, (ColorControl2.__proto__ || Object.getPrototypeOf(ColorControl2)).apply(this, arguments));
        }
        createClass(ColorControl2, [{
          key: "components",
          value: function components() {
            return { Hue, Opacity };
          }
        }, {
          key: "template",
          value: function template() {
            return '\n        <div class="control">\n            <div target="Hue" ></div>\n            <div target="Opacity" ></div>\n            <div ref="$controlPattern" class="empty"></div>\n            <div ref="$controlColor" class="color"></div>\n        </div>\n        ';
          }
        }, {
          key: "setBackgroundColor",
          value: function setBackgroundColor() {
            this.refs.$controlColor.css("background-color", this.$store.dispatch("/toRGB"));
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
            this.setBackgroundColor();
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            this.Hue.setColorUI();
            this.Opacity.setColorUI();
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source$3 != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return ColorControl2;
      }(UIElement);
      var source$4 = "chromedevtool-palette";
      var ColorPalette = function(_UIElement) {
        inherits(ColorPalette2, _UIElement);
        function ColorPalette2() {
          classCallCheck(this, ColorPalette2);
          return possibleConstructorReturn(this, (ColorPalette2.__proto__ || Object.getPrototypeOf(ColorPalette2)).apply(this, arguments));
        }
        createClass(ColorPalette2, [{
          key: "template",
          value: function template() {
            return '\n        <div class="color">\n            <div ref="$saturation" class="saturation">\n                <div ref="$value" class="value">\n                    <div ref="$drag_pointer" class="drag-pointer"></div>\n                </div>\n            </div>        \n        </div>        \n        ';
          }
        }, {
          key: "setBackgroundColor",
          value: function setBackgroundColor(color2) {
            this.$el.css("background-color", color2);
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
          }
        }, {
          key: "caculateSV",
          value: function caculateSV() {
            var pos = this.drag_pointer_pos || { x: 0, y: 0 };
            var width = this.state.get("$el.width");
            var height = this.state.get("$el.height");
            var s = pos.x / width;
            var v2 = (height - pos.y) / height;
            this.$store.dispatch("/changeColor", {
              type: "hsv",
              s,
              v: v2,
              source: source$4
            });
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            var x = this.state.get("$el.width") * this.$store.hsv.s, y2 = this.state.get("$el.height") * (1 - this.$store.hsv.v);
            this.refs.$drag_pointer.css({
              left: x + "px",
              top: y2 + "px"
            });
            this.drag_pointer_pos = { x, y: y2 };
            this.setBackgroundColor(this.$store.dispatch("/getHueColor"));
          }
        }, {
          key: "setMainColor",
          value: function setMainColor(e) {
            var pos = this.$el.offset();
            var w2 = this.state.get("$el.contentWidth");
            var h = this.state.get("$el.contentHeight");
            var x = Event.pos(e).pageX - pos.left;
            var y2 = Event.pos(e).pageY - pos.top;
            if (x < 0) x = 0;
            else if (x > w2) x = w2;
            if (y2 < 0) y2 = 0;
            else if (y2 > h) y2 = h;
            this.refs.$drag_pointer.css({
              left: x + "px",
              top: y2 + "px"
            });
            this.drag_pointer_pos = { x, y: y2 };
            this.caculateSV();
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source$4 != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }, {
          key: "mouseup document",
          value: function mouseupDocument(e) {
            if (this.isDown) {
              this.isDown = false;
              this.$store.emit("lastUpdateColor");
            }
          }
        }, {
          key: "mousemove document",
          value: function mousemoveDocument(e) {
            if (this.isDown) {
              this.setMainColor(e);
            }
          }
        }, {
          key: "mousedown",
          value: function mousedown(e) {
            this.isDown = true;
            this.setMainColor(e);
          }
        }, {
          key: "touchend document",
          value: function touchendDocument(e) {
            if (this.isDown) {
              this.isDown = false;
              this.$store.emit("lastUpdateColor");
            }
          }
        }, {
          key: "touchmove document",
          value: function touchmoveDocument(e) {
            if (this.isDown) {
              this.setMainColor(e);
            }
          }
        }, {
          key: "touchstart",
          value: function touchstart(e) {
            e.preventDefault();
            this.isDown = true;
            this.setMainColor(e);
          }
        }]);
        return ColorPalette2;
      }(UIElement);
      var ChromeDevToolColorPicker = function(_BaseColorPicker) {
        inherits(ChromeDevToolColorPicker2, _BaseColorPicker);
        function ChromeDevToolColorPicker2() {
          classCallCheck(this, ChromeDevToolColorPicker2);
          return possibleConstructorReturn(this, (ChromeDevToolColorPicker2.__proto__ || Object.getPrototypeOf(ChromeDevToolColorPicker2)).apply(this, arguments));
        }
        createClass(ChromeDevToolColorPicker2, [{
          key: "template",
          value: function template() {
            return `
            <div class='colorpicker-body'>
                <div target="palette"></div> 
                <div target="control"></div>
                <div target="information"></div>
                <div target="currentColorSets"></div>
                <div target="colorSetsChooser"></div>
                <div target="contextMenu"></div>
            </div>
        `;
          }
        }, {
          key: "components",
          value: function components() {
            return {
              palette: ColorPalette,
              control: ColorControl$2,
              information: ColorInformation,
              currentColorSets: CurrentColorSets,
              colorSetsChooser: ColorSetsChooser,
              contextMenu: CurrentColorSetsContextMenu
            };
          }
        }]);
        return ChromeDevToolColorPicker2;
      }(BaseColorPicker);
      var source$5 = "mini-control";
      var ColorControl$4 = function(_UIElement) {
        inherits(ColorControl2, _UIElement);
        function ColorControl2() {
          classCallCheck(this, ColorControl2);
          return possibleConstructorReturn(this, (ColorControl2.__proto__ || Object.getPrototypeOf(ColorControl2)).apply(this, arguments));
        }
        createClass(ColorControl2, [{
          key: "components",
          value: function components() {
            return { Hue, Opacity };
          }
        }, {
          key: "template",
          value: function template() {
            return '\n        <div class="control">\n            <div target="Hue" ></div>\n            <div target="Opacity" ></div>\n        </div>\n        ';
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            this.Hue.setColorUI();
            this.Opacity.setColorUI();
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source$5 != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return ColorControl2;
      }(UIElement);
      var MiniColorPicker = function(_BaseColorPicker) {
        inherits(MiniColorPicker2, _BaseColorPicker);
        function MiniColorPicker2() {
          classCallCheck(this, MiniColorPicker2);
          return possibleConstructorReturn(this, (MiniColorPicker2.__proto__ || Object.getPrototypeOf(MiniColorPicker2)).apply(this, arguments));
        }
        createClass(MiniColorPicker2, [{
          key: "template",
          value: function template() {
            return `
            <div class='colorpicker-body'>
                <div target="palette"></div>
                <div target="control"></div>
            </div>
        `;
          }
        }, {
          key: "components",
          value: function components() {
            return {
              palette: ColorPalette,
              control: ColorControl$4
            };
          }
        }]);
        return MiniColorPicker2;
      }(BaseColorPicker);
      var VerticalSlider = function(_BaseSlider) {
        inherits(VerticalSlider2, _BaseSlider);
        function VerticalSlider2(opt) {
          classCallCheck(this, VerticalSlider2);
          var _this = possibleConstructorReturn(this, (VerticalSlider2.__proto__ || Object.getPrototypeOf(VerticalSlider2)).call(this, opt));
          _this.source = "vertical-slider";
          return _this;
        }
        createClass(VerticalSlider2, [{
          key: "getMaxDist",
          value: function getMaxDist() {
            return this.state.get("$container.height");
          }
          /** set mouse pointer for vertical slider */
        }, {
          key: "setMousePosition",
          value: function setMousePosition(y2) {
            this.refs.$bar.css({ top: y2 + "px" });
          }
          /** get mouse position by pageY for vertical slider */
        }, {
          key: "getMousePosition",
          value: function getMousePosition(e) {
            return Event.pos(e).pageY;
          }
          /** get min position for vertial slider */
        }, {
          key: "getMinPosition",
          value: function getMinPosition() {
            return this.refs.$container.offset().top;
          }
          /** get caculated dist for domain value   */
        }, {
          key: "getCaculatedDist",
          value: function getCaculatedDist(e) {
            var current = e ? this.getMousePosition(e) : this.getCurrent(this.getDefaultValue() / this.maxValue);
            var dist = 100 - this.getDist(current);
            return dist;
          }
          /** set drag bar position  */
        }, {
          key: "setColorUI",
          value: function setColorUI(v2) {
            v2 = v2 || this.getDefaultValue();
            if (v2 <= this.minValue) {
              this.refs.$bar.addClass("first").removeClass("last");
            } else if (v2 >= this.maxValue) {
              this.refs.$bar.addClass("last").removeClass("first");
            } else {
              this.refs.$bar.removeClass("last").removeClass("first");
            }
            var per = 1 - (v2 || 0) / this.maxValue;
            this.setMousePosition(this.getMaxDist() * per);
          }
        }]);
        return VerticalSlider2;
      }(BaseSlider);
      var VerticalHue = function(_VerticalSlider) {
        inherits(VerticalHue2, _VerticalSlider);
        function VerticalHue2(opt) {
          classCallCheck(this, VerticalHue2);
          var _this = possibleConstructorReturn(this, (VerticalHue2.__proto__ || Object.getPrototypeOf(VerticalHue2)).call(this, opt));
          _this.minValue = 0;
          _this.maxValue = 360;
          _this.source = "vertical-hue-control";
          return _this;
        }
        createClass(VerticalHue2, [{
          key: "template",
          value: function template() {
            return '\n            <div class="hue">\n                <div ref="$container" class="hue-container">\n                    <div ref="$bar" class="drag-bar"></div>\n                </div>\n            </div>\n        ';
          }
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return this.$store.hsv.h;
          }
        }, {
          key: "refreshColorUI",
          value: function refreshColorUI(e) {
            var dist = this.getCaculatedDist(e);
            this.setColorUI(dist / 100 * this.maxValue);
            this.changeColor({
              h: dist / 100 * this.maxValue,
              type: "hsv"
            });
          }
        }]);
        return VerticalHue2;
      }(VerticalSlider);
      var Opacity$2 = function(_VerticalSlider) {
        inherits(Opacity2, _VerticalSlider);
        function Opacity2(opt) {
          classCallCheck(this, Opacity2);
          var _this = possibleConstructorReturn(this, (Opacity2.__proto__ || Object.getPrototypeOf(Opacity2)).call(this, opt));
          _this.source = "vertical-opacity-control";
          return _this;
        }
        createClass(Opacity2, [{
          key: "template",
          value: function template() {
            return '\n        <div class="opacity">\n            <div ref="$container" class="opacity-container">\n                <div ref="$colorbar" class="color-bar"></div>\n                <div ref="$bar" class="drag-bar2"></div>\n            </div>\n        </div>\n        ';
          }
        }, {
          key: "refresh",
          value: function refresh() {
            get(Opacity2.prototype.__proto__ || Object.getPrototypeOf(Opacity2.prototype), "refresh", this).call(this);
            this.setOpacityColorBar();
          }
        }, {
          key: "setOpacityColorBar",
          value: function setOpacityColorBar() {
            var rgb2 = Object.assign({}, this.$store.rgb);
            rgb2.a = 0;
            var start = Color$1.format(rgb2, "rgb");
            rgb2.a = 1;
            var end = Color$1.format(rgb2, "rgb");
            this.refs.$colorbar.css("background", "linear-gradient(to top, " + start + ", " + end + ")");
          }
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return this.$store.alpha;
          }
        }, {
          key: "refreshColorUI",
          value: function refreshColorUI(e) {
            var dist = this.getCaculatedDist(e);
            this.setColorUI(dist / 100 * this.maxValue);
            this.changeColor({
              a: Math.floor(dist) / 100 * this.maxValue
            });
          }
        }]);
        return Opacity2;
      }(VerticalSlider);
      var source$6 = "mini-control";
      var ColorControl$6 = function(_UIElement) {
        inherits(ColorControl2, _UIElement);
        function ColorControl2() {
          classCallCheck(this, ColorControl2);
          return possibleConstructorReturn(this, (ColorControl2.__proto__ || Object.getPrototypeOf(ColorControl2)).apply(this, arguments));
        }
        createClass(ColorControl2, [{
          key: "components",
          value: function components() {
            return { Hue: VerticalHue, Opacity: Opacity$2 };
          }
        }, {
          key: "template",
          value: function template() {
            return '<div class="control"><div target="Hue" ></div><div target="Opacity" ></div></div>';
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            this.Hue.setColorUI();
            this.Opacity.setColorUI();
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source$6 != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return ColorControl2;
      }(UIElement);
      var MiniColorPicker$2 = function(_BaseColorPicker) {
        inherits(MiniColorPicker2, _BaseColorPicker);
        function MiniColorPicker2() {
          classCallCheck(this, MiniColorPicker2);
          return possibleConstructorReturn(this, (MiniColorPicker2.__proto__ || Object.getPrototypeOf(MiniColorPicker2)).apply(this, arguments));
        }
        createClass(MiniColorPicker2, [{
          key: "template",
          value: function template() {
            return `
            <div class='colorpicker-body'>
                <div target="palette"></div><div target="control"></div>
            </div>
        `;
          }
        }, {
          key: "components",
          value: function components() {
            return {
              palette: ColorPalette,
              control: ColorControl$6
            };
          }
        }]);
        return MiniColorPicker2;
      }(BaseColorPicker);
      var source$7 = "macos-control";
      var ColorControl$8 = function(_UIElement) {
        inherits(ColorControl2, _UIElement);
        function ColorControl2() {
          classCallCheck(this, ColorControl2);
          return possibleConstructorReturn(this, (ColorControl2.__proto__ || Object.getPrototypeOf(ColorControl2)).apply(this, arguments));
        }
        createClass(ColorControl2, [{
          key: "components",
          value: function components() {
            return { Value, Opacity };
          }
        }, {
          key: "template",
          value: function template() {
            return '\n        <div class="control">\n            <div target="Value" ></div>\n            <div target="Opacity" ></div>\n            <div ref="$controlPattern" class="empty"></div>\n            <div ref="$controlColor" class="color"></div>\n        </div>\n        ';
          }
        }, {
          key: "setBackgroundColor",
          value: function setBackgroundColor() {
            this.refs.$controlColor.css("background-color", this.$store.dispatch("/toRGB"));
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
            this.setBackgroundColor();
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            this.Value.setColorUI();
            this.Opacity.setColorUI();
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source$7 != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return ColorControl2;
      }(UIElement);
      var ColorRing = function(_ColorWheel) {
        inherits(ColorRing2, _ColorWheel);
        function ColorRing2(opt) {
          classCallCheck(this, ColorRing2);
          var _this = possibleConstructorReturn(this, (ColorRing2.__proto__ || Object.getPrototypeOf(ColorRing2)).call(this, opt));
          _this.width = 214;
          _this.height = 214;
          _this.thinkness = 16;
          _this.half_thinkness = _this.thinkness / 2;
          _this.source = "colorring";
          return _this;
        }
        createClass(ColorRing2, [{
          key: "template",
          value: function template() {
            return '\n        <div class="wheel" data-type="ring">\n            <canvas class="wheel-canvas" ref="$colorwheel" ></canvas>\n            <div class="drag-pointer" ref="$drag_pointer"></div>\n        </div>\n        ';
          }
        }, {
          key: "setColorUI",
          value: function setColorUI(isEvent) {
            this.renderCanvas();
            this.setHueColor(null, isEvent);
          }
        }, {
          key: "getDefaultValue",
          value: function getDefaultValue() {
            return this.$store.hsv.h;
          }
        }, {
          key: "setHueColor",
          value: function setHueColor(e, isEvent) {
            if (!this.state.get("$el.width")) return;
            var _getRectangle = this.getRectangle(), minX = _getRectangle.minX, minY = _getRectangle.minY, radius = _getRectangle.radius, centerX = _getRectangle.centerX, centerY = _getRectangle.centerY;
            var _getCurrentXY = this.getCurrentXY(e, this.getDefaultValue(), radius, centerX, centerY), x = _getCurrentXY.x, y2 = _getCurrentXY.y;
            var rx = x - centerX, ry = y2 - centerY, hue2 = caculateAngle(rx, ry);
            {
              var _getCurrentXY2 = this.getCurrentXY(null, hue2, radius - this.half_thinkness, centerX, centerY), x = _getCurrentXY2.x, y2 = _getCurrentXY2.y;
            }
            this.refs.$drag_pointer.css({
              left: x - minX + "px",
              top: y2 - minY + "px"
            });
            if (!isEvent) {
              this.changeColor({
                type: "hsv",
                h: hue2
              });
            }
          }
        }]);
        return ColorRing2;
      }(ColorWheel);
      var RingColorPicker = function(_BaseColorPicker) {
        inherits(RingColorPicker2, _BaseColorPicker);
        function RingColorPicker2() {
          classCallCheck(this, RingColorPicker2);
          return possibleConstructorReturn(this, (RingColorPicker2.__proto__ || Object.getPrototypeOf(RingColorPicker2)).apply(this, arguments));
        }
        createClass(RingColorPicker2, [{
          key: "template",
          value: function template() {
            return `
            <div class='colorpicker-body'>
                <div target="colorring"></div>
                <div target="palette"></div> 
                <div target="control"></div>
                <div target="information"></div>
                <div target="currentColorSets"></div>
                <div target="colorSetsChooser"></div>
                <div target="contextMenu"></div>
            </div>
        `;
          }
        }, {
          key: "components",
          value: function components() {
            return {
              colorring: ColorRing,
              palette: ColorPalette,
              control: ColorControl$8,
              information: ColorInformation,
              currentColorSets: CurrentColorSets,
              colorSetsChooser: ColorSetsChooser,
              contextMenu: CurrentColorSetsContextMenu
            };
          }
        }]);
        return RingColorPicker2;
      }(BaseColorPicker);
      var ColorControl$10 = function(_UIElement) {
        inherits(ColorControl2, _UIElement);
        function ColorControl2() {
          classCallCheck(this, ColorControl2);
          return possibleConstructorReturn(this, (ColorControl2.__proto__ || Object.getPrototypeOf(ColorControl2)).apply(this, arguments));
        }
        createClass(ColorControl2, [{
          key: "components",
          value: function components() {
            return { Hue: VerticalHue, Opacity: Opacity$2 };
          }
        }, {
          key: "template",
          value: function template() {
            return '\n        <div class="control">\n            <div target="Hue" ></div>\n            <div target="Opacity" ></div>\n        </div>\n        ';
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            this.Hue.setColorUI();
            this.Opacity.setColorUI();
          }
        }, {
          key: "@changeColor",
          value: function changeColor() {
            this.refresh();
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return ColorControl2;
      }(UIElement);
      var XDColorPicker = function(_BaseColorPicker) {
        inherits(XDColorPicker2, _BaseColorPicker);
        function XDColorPicker2() {
          classCallCheck(this, XDColorPicker2);
          return possibleConstructorReturn(this, (XDColorPicker2.__proto__ || Object.getPrototypeOf(XDColorPicker2)).apply(this, arguments));
        }
        createClass(XDColorPicker2, [{
          key: "template",
          value: function template() {
            return `
            <div class='colorpicker-body'>
                <div target="palette"></div> 
                <div target="control"></div>
                <div target="information"></div>
                <div target="currentColorSets"></div>
                <div target="colorSetsChooser"></div>
                <div target="contextMenu"></div>
            </div>
        `;
          }
        }, {
          key: "components",
          value: function components() {
            return {
              palette: ColorPalette,
              control: ColorControl$10,
              information: ColorInformation,
              currentColorSets: CurrentColorSets,
              colorSetsChooser: ColorSetsChooser,
              contextMenu: CurrentColorSetsContextMenu
            };
          }
        }]);
        return XDColorPicker2;
      }(BaseColorPicker);
      var source$8 = "mini-control";
      var ColorControl$12 = function(_UIElement) {
        inherits(ColorControl2, _UIElement);
        function ColorControl2() {
          classCallCheck(this, ColorControl2);
          return possibleConstructorReturn(this, (ColorControl2.__proto__ || Object.getPrototypeOf(ColorControl2)).apply(this, arguments));
        }
        createClass(ColorControl2, [{
          key: "components",
          value: function components() {
            return { Hue: VerticalHue, Opacity: Opacity$2 };
          }
        }, {
          key: "template",
          value: function template() {
            return (
              /*html*/
              '\n            <div class="control">\n                <div target="Opacity" ></div>            \n                <div target="Hue" ></div>\n            </div>\n        '
            );
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setColorUI();
          }
        }, {
          key: "setColorUI",
          value: function setColorUI() {
            this.Hue.setColorUI();
            this.Opacity.setColorUI();
          }
        }, {
          key: "@changeColor",
          value: function changeColor(sourceType) {
            if (source$8 != sourceType) {
              this.refresh();
            }
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return ColorControl2;
      }(UIElement);
      var VSCodePicker = function(_BaseColorPicker) {
        inherits(VSCodePicker2, _BaseColorPicker);
        function VSCodePicker2() {
          classCallCheck(this, VSCodePicker2);
          return possibleConstructorReturn(this, (VSCodePicker2.__proto__ || Object.getPrototypeOf(VSCodePicker2)).apply(this, arguments));
        }
        createClass(VSCodePicker2, [{
          key: "template",
          value: function template() {
            return (
              /*html*/
              `
            <div class='colorpicker-body'>
                <div class='color-view'>
                    <div class='color-view-container'  ref="$colorview"></div>
                </div>
                <div class='color-tool'>
                    <div target="palette"></div>
                    <div target="control"></div>
                </div>
            </div>
        `
            );
          }
        }, {
          key: "components",
          value: function components() {
            return {
              palette: ColorPalette,
              control: ColorControl$12
            };
          }
        }, {
          key: "initColorWithoutChangeEvent",
          value: function initColorWithoutChangeEvent(color2) {
            this.$store.dispatch("/initColor", color2);
            this.refresh();
          }
        }, {
          key: "setBackgroundColor",
          value: function setBackgroundColor() {
            var color2 = this.$store.dispatch("/toColor");
            var rgb2 = this.$store.rgb;
            var bValue = Color$1.brightness(rgb2.r, rgb2.g, rgb2.b);
            this.refs.$colorview.css({
              "background-color": color2,
              "color": bValue > 127 ? "black" : "white"
            });
            this.refs.$colorview.html(color2);
          }
        }, {
          key: "click $colorview",
          value: function click$colorview(e) {
            this.nextFormat();
          }
        }, {
          key: "nextFormat",
          value: function nextFormat() {
            var current_format = this.$store.format || "hex";
            var next_format = "hex";
            if (current_format == "hex") {
              next_format = "rgb";
            } else if (current_format == "rgb") {
              next_format = "hsl";
            } else if (current_format == "hsl") {
              next_format = "hex";
            }
            this.$store.dispatch("/changeFormat", next_format);
            this.$store.emit("lastUpdateColor");
            this.refresh();
          }
        }, {
          key: "refresh",
          value: function refresh() {
            this.setBackgroundColor();
          }
        }, {
          key: "@changeColor",
          value: function changeColor() {
            this.refresh();
          }
        }, {
          key: "@initColor",
          value: function initColor() {
            this.refresh();
          }
        }]);
        return VSCodePicker2;
      }(BaseColorPicker);
      var ColorPicker = {
        create: function create(opts) {
          switch (opts.type) {
            case "macos":
              return new MacOSColorPicker(opts);
            case "xd":
              return new XDColorPicker(opts);
            case "ring":
              return new RingColorPicker(opts);
            case "mini":
              return new MiniColorPicker(opts);
            case "vscode":
              return new VSCodePicker(opts);
            case "mini-vertical":
              return new MiniColorPicker$2(opts);
            case "sketch":
            case "palette":
            default:
              return new ChromeDevToolColorPicker(opts);
          }
        },
        ColorPicker: ChromeDevToolColorPicker,
        ChromeDevToolColorPicker,
        MacOSColorPicker,
        RingColorPicker,
        MiniColorPicker,
        VSCodePicker,
        MiniVerticalColorPicker: MiniColorPicker$2
      };
      function debounce8(callback, delay) {
        var t = void 0;
        return function($1, $2, $3, $4, $5) {
          if (t) {
            clearTimeout(t);
          }
          t = setTimeout(function() {
            callback($1, $2, $3, $4, $5);
          }, delay || 300);
        };
      }
      var colorpicker_token_class = "ace_color";
      var colorpicker_container_class = "ace-colorpicker";
      var ColorView = function() {
        function ColorView2(ace4, editor) {
          var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            type: "vscode",
            showDelay: 300,
            containerClass: colorpicker_container_class
          };
          classCallCheck(this, ColorView2);
          this.opt = opt;
          this.ace = ace4;
          this.editor = editor;
          this.colorpicker = ColorPicker.create(this.opt);
          this.init_event();
        }
        createClass(ColorView2, [{
          key: "get_brightness",
          value: function get_brightness(colorString) {
            var colorObj = Color$1.parse(colorString);
            var fontColorString = brightness(colorObj.r, colorObj.g, colorObj.b) > 127 ? "#000" : "#fff";
            return fontColorString;
          }
        }, {
          key: "mouse_over",
          value: function mouse_over(evt) {
            var $colorElement = new Dom(evt.target);
            this.__colorview_check_target = evt.target;
            if ($colorElement.hasClass(colorpicker_token_class)) {
              this.openDebouncedColorPicker(evt);
            }
          }
        }, {
          key: "init_mouse_event",
          value: function init_mouse_event() {
            var renderer = this.editor.renderer;
            var content = renderer.content;
            this.openDebouncedColorPicker = debounce8(this.open_color_picker.bind(this), this.opt.showDelay);
            this.onMouseOver = this.mouse_over.bind(this);
            content.addEventListener("mousemove", this.onMouseOver);
          }
        }, {
          key: "init_event",
          value: function init_event() {
            var _this = this;
            var _editor = this.editor, renderer = _editor.renderer, session = _editor.session;
            var content = renderer.content;
            this.init_mouse_event();
            var rules = session.$mode.$highlightRules.getRules();
            for (var stateName in rules) {
              if (Object.prototype.hasOwnProperty.call(rules, stateName)) {
                rules[stateName].unshift({
                  token: "color",
                  regex: "#(?:[\\da-f]{8})|#(?:[\\da-f]{3}){1,2}|rgb\\((?:\\s*\\d{1,3},\\s*){2}\\d{1,3}\\s*\\)|rgba\\((?:\\s*\\d{1,3},\\s*){3}\\d*\\.?\\d+\\s*\\)|hsl\\(\\s*\\d{1,3}(?:,\\s*\\d{1,3}%){2}\\s*\\)|hsla\\(\\s*\\d{1,3}(?:,\\s*\\d{1,3}%){2},\\s*\\d*\\.?\\d+\\s*\\)"
                });
                rules[stateName].unshift({
                  token: "color",
                  regex: "blue|green|red"
                });
              }
            }
            session.$mode.$tokenizer = null;
            session.bgTokenizer.setTokenizer(session.$mode.getTokenizer());
            session.bgTokenizer.start(0);
            renderer.on("afterRender", function() {
              var colors = content.getElementsByClassName(colorpicker_token_class);
              for (var i = 0, len = colors.length; i < len; i++) {
                var colorString = colors[i].textContent;
                if (colors[i].getAttribute("data-color") === colorString) {
                  continue;
                }
                var fontColorString = _this.get_brightness(colorString);
                colors[i].setAttribute("data-color", colorString);
                colors[i].style.cssText = "\n                    background-color: " + colorString + ";\n                    color: " + fontColorString + ";\n                    pointer-events: all;\n                ";
              }
            });
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var renderer = this.editor.renderer;
            var content = renderer.content;
            content.removeEventListener("mousemove", this.onMouseOver);
          }
        }, {
          key: "open_color_picker",
          value: function open_color_picker(evt) {
            var _this2 = this;
            if (evt.target !== this.__colorview_check_target) {
              this.close_color_picker();
              return;
            }
            var Range = this.ace.Range;
            var _editor2 = this.editor, renderer = _editor2.renderer, session = _editor2.session;
            var layerConfig = renderer.layerConfig;
            var screenPosition = renderer.screenToTextCoordinates(evt.clientX - layerConfig.padding, evt.clientY);
            var token = session.getTokenAt(screenPosition.row, screenPosition.column);
            if (!token || token.type.includes("color") === false) {
              return;
            }
            var row = screenPosition.row;
            var startColumn = token.start;
            var colorString = token.value;
            var prevColor = colorString;
            var pos = renderer.textToScreenCoordinates(row, startColumn);
            var scrollTop = Dom.getScrollTop();
            this.colorpicker.show({
              left: pos.pageX,
              top: pos.pageY + scrollTop,
              bottom: pos.pageY + scrollTop + layerConfig.lineHeight,
              hideDelay: this.opt.hideDelay || 10
            }, colorString, function(newColor) {
              _this2.editor.session.replace(new Range(row, startColumn, row, startColumn + prevColor.length), newColor);
              prevColor = newColor;
            });
          }
        }, {
          key: "close_color_picker",
          value: function close_color_picker() {
            if (this.colorpicker) {
              this.colorpicker.hide();
            }
          }
        }, {
          key: "hide_delay_color_picker",
          value: function hide_delay_color_picker() {
            if (this.colorpicker) {
              this.colorpicker.runHideDelay();
            }
          }
        }, {
          key: "key",
          value: function key(lineNo, ch) {
            return [lineNo, ch].join(":");
          }
        }, {
          key: "keyup",
          value: function keyup(evt) {
            if (this.colorpicker) {
              if (evt.key == "Escape") {
                this.colorpicker.hide();
              } else if (this.colorpicker.isShortCut == false) {
                this.colorpicker.hide();
              }
            }
          }
        }]);
        return ColorView2;
      }();
      function LOAD_ACE_COLORPICKER(ace4, editor, opt) {
        return new ColorView(ace4, editor, opt);
      }
      var AceExtension = {
        load: LOAD_ACE_COLORPICKER
      };
      var index = _extends({}, Util, ColorPicker, AceExtension);
      return index;
    });
  }
});

// src/modals/confirmModal.ts
var confirmModal_exports = {};
__export(confirmModal_exports, {
  confirm: () => confirm
});
var import_obsidian4, ConfirmModal, confirm;
var init_confirmModal = __esm({
  "src/modals/confirmModal.ts"() {
    import_obsidian4 = require("obsidian");
    ConfirmModal = class extends import_obsidian4.Modal {
      constructor(app) {
        super(app);
        this.buttonContainerEl = this.modalEl.createDiv("modal-button-container");
        this.resolve = null;
        this.containerEl.addClass("mod-confirmation");
        this.containerEl.addClass("snippet-import-confirmation");
        this.addCancelButton();
        this.addButton("", "OK", () => this.resolve && this.resolve(true));
      }
      open() {
        super.open();
        return new Promise((resolve) => this.resolve = resolve);
      }
      addButton(cls, text, callback) {
        this.buttonContainerEl.createEl(
          "button",
          {
            cls,
            text,
            attr: {
              "tabindex": 0
            }
          }
        ).addEventListener("click", async (evt) => {
          callback && await callback(evt);
          this.close();
        });
        return this;
      }
      onClose() {
        this.resolve && this.resolve(false);
      }
      addCancelButton() {
        this.addButton("confirm-modal-cancel-button", "Cancel", this.close.bind(this));
      }
    };
    confirm = (message, app) => {
      const modal = new ConfirmModal(app);
      modal.contentEl.setText(message);
      return modal.open();
    };
  }
});

// node_modules/ace-builds/src-noconflict/theme-chrome.js
var require_theme_chrome = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-chrome.js"(exports, module2) {
    ace.define("ace/theme/chrome-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-chrome .ace_gutter {\n  background: #ebebeb;\n  color: #333;\n  overflow : hidden;\n}\n\n.ace-chrome .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-chrome {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-chrome .ace_cursor {\n  color: black;\n}\n\n.ace-chrome .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-chrome .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-chrome .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-chrome .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-chrome .ace_invalid {\n  background-color: rgb(153, 0, 0);\n  color: white;\n}\n\n.ace-chrome .ace_fold {\n}\n\n.ace-chrome .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-chrome .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-chrome .ace_support.ace_type,\n.ace-chrome .ace_support.ace_class\n.ace-chrome .ace_support.ace_other {\n  color: rgb(109, 121, 222);\n}\n\n.ace-chrome .ace_variable.ace_parameter {\n  font-style:italic;\n  color:#FD971F;\n}\n.ace-chrome .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-chrome .ace_comment {\n  color: #236e24;\n}\n\n.ace-chrome .ace_comment.ace_doc {\n  color: #236e24;\n}\n\n.ace-chrome .ace_comment.ace_doc.ace_tag {\n  color: #236e24;\n}\n\n.ace-chrome .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-chrome .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-chrome .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-chrome .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-chrome .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-chrome .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-chrome .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n\n.ace-chrome .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-chrome .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-chrome .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-chrome .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-chrome .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-chrome .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-chrome .ace_storage,\n.ace-chrome .ace_keyword,\n.ace-chrome .ace_meta.ace_tag {\n  color: rgb(147, 15, 128);\n}\n\n.ace-chrome .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-chrome .ace_string {\n  color: #1A1AA6;\n}\n\n.ace-chrome .ace_entity.ace_other.ace_attribute-name {\n  color: #994409;\n}\n\n.ace-chrome .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n  \n.ace-chrome .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/chrome", ["require", "exports", "module", "ace/theme/chrome-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-chrome";
      exports2.cssText = require3("./chrome-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/chrome"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-cloud_editor.js
var require_theme_cloud_editor = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-cloud_editor.js"(exports, module2) {
    ace.define("ace/theme/cloud_editor-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '\n.ace-cloud_editor .ace_gutter {\n    background: #ffffff;\n    color: #3a3a42;\n}\n\n.ace-cloud_editor .ace_tooltip-marker-error.ace_tooltip-marker {\n    background-color: #d13212;\n}\n.ace-cloud_editor .ace_tooltip-marker-security.ace_tooltip-marker {\n    background-color: #d13212;\n}\n.ace-cloud_editor .ace_tooltip-marker-warning.ace_tooltip-marker {\n    background-color: #906806;\n}\n\n.ace-cloud_editor .ace_print-margin {\n    width: 1px;\n    background: #697077;\n}\n\n.ace-cloud_editor {\n    background-color: #ffffff;\n    color: #3a3a42;\n}\n\n.ace-cloud_editor .ace_cursor {\n    color: #3a3a42;\n}\n\n.ace-cloud_editor .ace_marker-layer .ace_selection {\n    background: #bfceff;\n}\n\n.ace-cloud_editor.ace_multiselect .ace_selection.ace_start {\n    box-shadow: 0 0 3px 0px #ffffff;\n    border-radius: 2px;\n}\n\n.ace-cloud_editor .ace_marker-layer .ace_step {\n    background: #697077;\n}\n\n.ace-cloud_editor .ace_marker-layer .ace_bracket {\n    margin: 0 0 0 -1px;\n    border: 1px solid #697077;\n}\n\n.ace-cloud_editor .ace_gutter-active-line::before,\n.ace-cloud_editor .ace_marker-layer .ace_active-line {\n    box-sizing: border-box;\n    border-top: 1px solid #9191ac;\n    border-bottom: 1px solid #9191ac;\n}\n\n.ace-cloud_editor .ace_gutter-active-line::before {\n    content: "";\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    left: 0;\n    z-index: 1;\n    pointer-events: none;\n}\n\n.ace-cloud_editor .ace_marker-layer .ace_selected-word {\n    border: 1px solid #bfceff;\n}\n\n.ace-cloud_editor .ace_fold {\n    background-color: #0E45B4;\n    border-color: #3a3a42;\n}\n\n.ace-cloud_editor .ace_keyword {\n    color: #9749d1;\n}\n\n.ace-cloud_editor .ace_meta.ace_tag {\n    color: #0E45B4;\n}\n\n.ace-cloud_editor .ace_constant {\n    color: #A16101;\n}\n\n.ace-cloud_editor .ace_constant.ace_numeric {\n    color: #A16101;\n}\n\n.ace-cloud_editor .ace_constant.ace_character.ace_escape {\n    color: #BD1880;\n}\n\n.ace-cloud_editor .ace_support.ace_function {\n    color: #A81700;\n}\n\n.ace-cloud_editor .ace_support.ace_class {\n    color: #A16101;\n}\n\n.ace-cloud_editor .ace_storage {\n    color: #9749d1;\n}\n\n.ace-cloud_editor .ace_invalid.ace_illegal {\n    color: #ffffff;\n    background-color: #0E45B4;\n}\n\n.ace-cloud_editor .ace_invalid.ace_deprecated {\n    color: #ffffff;\n    background-color: #A16101;\n}\n\n.ace-cloud_editor .ace_string {\n    color: #207A7F;\n}\n\n.ace-cloud_editor .ace_string.ace_regexp {\n    color: #207A7F;\n}\n\n.ace-cloud_editor .ace_comment,\n.ace-cloud_editor .ace_ghost_text {\n    color: #697077;\n    opacity: 1;\n}\n\n.ace-cloud_editor .ace_variable {\n    color: #0E45B4;\n}\n\n.ace-cloud_editor .ace_meta.ace_selector {\n    color: #9749d1;\n}\n\n.ace-cloud_editor .ace_entity.ace_other.ace_attribute-name {\n    color: #A16101;\n}\n\n.ace-cloud_editor .ace_entity.ace_name.ace_function {\n    color: #A81700;\n}\n\n.ace-cloud_editor .ace_entity.ace_name.ace_tag {\n    color: #0E45B4;\n}\n\n.ace-cloud_editor .ace_heading {\n    color: #A81700;\n}\n\n.ace-cloud_editor .ace_xml-pe {\n    color: #A16101;\n}\n.ace-cloud_editor .ace_doctype {\n    color: #0E45B4;\n}\n\n.ace-cloud_editor .ace_tooltip {\n    background-color: #ffffff;\n    color: #3a3a42;\n}\n\n.ace-cloud_editor .ace_icon_svg.ace_error,\n.ace-cloud_editor .ace_icon_svg.ace_error_fold {\n    background-color: #d13212;\n}\n.ace-cloud_editor .ace_icon_svg.ace_security,\n.ace-cloud_editor .ace_icon_svg.ace_security_fold {\n    background-color: #d13212;\n}\n.ace-cloud_editor .ace_icon_svg.ace_warning,\n.ace-cloud_editor .ace_icon_svg.ace_warning_fold {\n    background-color: #906806;\n}\n.ace-cloud_editor .ace_icon_svg.ace_info {\n    background-color: #0073bb;\n}\n.ace-cloud_editor .ace_icon_svg.ace_hint {\n    background-color: #0073bb;\n}\n.ace-cloud_editor .ace_highlight-marker {\n    background: none;\n    border: #0E45B4 1px solid;\n}\n.ace-cloud_editor .ace_tooltip.ace_hover-tooltip:focus > div {\n    outline: 1px solid #0073bb;\n}\n.ace-cloud_editor .ace_snippet-marker {\n    background-color: #CED6E0;\n    border: 0;\n}\n\n.ace-cloud_editor.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #f2f3f3;\n    border: #0F68AE 1.5px solid;\n}\n.ace-cloud_editor.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #16191f;\n    background: #f2f3f3;\n}\n.ace-cloud_editor.ace_editor.ace_autocomplete .ace_completion-meta {\n    color: #545b64;\n    opacity: 1;\n}\n.ace-cloud_editor.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #0F68AE;\n}\n.ace-cloud_editor.ace_editor.ace_autocomplete {\n    box-shadow: 0 1px 1px 0 #001c244d, 1px 1px 1px 0 #001c2426, -1px 1px 1px 0 #001c2426;\n    line-height: 1.5;\n    border: 1px solid #eaeded;\n    background: #ffffff;\n    color: #16191f;\n}\n\n';
    });
    ace.define("ace/theme/cloud_editor", ["require", "exports", "module", "ace/theme/cloud_editor-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-cloud_editor";
      exports2.cssText = require3("./cloud_editor-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/cloud_editor"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-cloud9_day.js
var require_theme_cloud9_day = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-cloud9_day.js"(exports, module2) {
    ace.define("ace/theme/cloud9_day-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-cloud9-day .ace_gutter {\n    background: #ECECEC;\n    color: #333;\n}\n\n.ace-cloud9-day .ace_print-margin {\n    width: 1px;\n    background: #e8e8e8;\n}\n\n.ace-cloud9-day .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-cloud9-day {\n    background-color: #FBFBFB;\n    color: black;\n}\n\n.ace-cloud9-day .ace_cursor {\n    color: black;\n}\n\n.ace-cloud9-day .ace_invisible {\n    color: rgb(191, 191, 191);\n}\n\n.ace-cloud9-day .ace_storage,\n.ace-cloud9-day .ace_keyword {\n    color: rgb(24, 122, 234);\n}\n\n.ace-cloud9-day .ace_constant {\n    color: rgb(197, 6, 11);\n}\n\n.ace-cloud9-day .ace_constant.ace_buildin {\n    color: rgb(88, 72, 246);\n}\n\n.ace-cloud9-day .ace_constant.ace_language {\n    color: rgb(88, 92, 246);\n}\n\n.ace-cloud9-day .ace_constant.ace_library {\n    color: rgb(6, 150, 14);\n}\n\n.ace-cloud9-day .ace_invalid {\n    background-color: rgba(255, 0, 0, 0.1);\n    color: red;\n}\n\n.ace-cloud9-day .ace_support.ace_function {\n    color: rgb(60, 76, 114);\n}\n\n.ace-cloud9-day .ace_support.ace_constant {\n    color: rgb(6, 150, 14);\n}\n\n.ace-cloud9-day .ace_support.ace_type,\n.ace-cloud9-day .ace_support.ace_class {\n    color: rgb(109, 121, 222);\n}\n\n.ace-cloud9-day .ace_keyword.ace_operator {\n    color: rgb(104, 118, 135);\n}\n\n.ace-cloud9-day .ace_string {\n    color: rgb(3, 106, 7);\n}\n\n.ace-cloud9-day .ace_comment {\n    color: rgb(76, 136, 107);\n}\n\n.ace-cloud9-day .ace_comment.ace_doc {\n    color: rgb(0, 102, 255);\n}\n\n.ace-cloud9-day .ace_comment.ace_doc.ace_tag {\n    color: rgb(128, 159, 191);\n}\n\n.ace-cloud9-day .ace_constant.ace_numeric {\n    color: rgb(0, 0, 205);\n}\n\n.ace-cloud9-day .ace_variable {\n    color: rgb(49, 132, 149);\n}\n\n.ace-cloud9-day .ace_xml-pe {\n    color: rgb(104, 104, 91);\n}\n\n.ace-cloud9-day .ace_entity.ace_name.ace_function {\n    color: #0000A2;\n}\n\n\n.ace-cloud9-day .ace_heading {\n    color: rgb(12, 7, 255);\n}\n\n.ace-cloud9-day .ace_list {\n    color: rgb(185, 6, 144);\n}\n\n.ace-cloud9-day .ace_meta.ace_tag {\n    color: rgb(0, 22, 142);\n}\n\n.ace-cloud9-day .ace_string.ace_regex {\n    color: rgb(255, 0, 0)\n}\n\n.ace-cloud9-day .ace_marker-layer .ace_selection {\n    background: rgb(181, 213, 255);\n}\n\n.ace-cloud9-day.ace_multiselect .ace_selection.ace_start {\n    box-shadow: 0 0 3px 0px white;\n}\n\n.ace-cloud9-day .ace_marker-layer .ace_step {\n    background: rgb(247, 237, 137);\n}\n\n.ace-cloud9-day .ace_marker-layer .ace_stack {\n    background: #BAE0A0;\n}\n\n.ace-cloud9-day .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-cloud9-day .ace_marker-layer .ace_active-line {\n    background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-cloud9-day .ace_gutter-active-line {\n    background-color: #E5E5E5;\n}\n\n.ace-cloud9-day .ace_marker-layer .ace_selected-word {\n    background: rgb(250, 250, 255);\n    border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-cloud9-day .ace_indent-guide {\n    background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-cloud9-day .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/cloud9_day", ["require", "exports", "module", "ace/theme/cloud9_day-css", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      exports2.isDark = false;
      exports2.cssClass = "ace-cloud9-day";
      exports2.cssText = require3("./cloud9_day-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass);
    });
    (function() {
      ace.require(["ace/theme/cloud9_day"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-clouds.js
var require_theme_clouds = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-clouds.js"(exports, module2) {
    ace.define("ace/theme/clouds-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-clouds .ace_gutter {\n  background: #ebebeb;\n  color: #333\n}\n\n.ace-clouds .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8\n}\n\n.ace-clouds {\n  background-color: #FFFFFF;\n  color: #000000\n}\n\n.ace-clouds .ace_cursor {\n  color: #000000\n}\n\n.ace-clouds .ace_marker-layer .ace_selection {\n  background: #BDD5FC\n}\n\n.ace-clouds.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #FFFFFF;\n}\n\n.ace-clouds .ace_marker-layer .ace_step {\n  background: rgb(255, 255, 0)\n}\n\n.ace-clouds .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #BFBFBF\n}\n\n.ace-clouds .ace_marker-layer .ace_active-line {\n  background: #FFFBD1\n}\n\n.ace-clouds .ace_gutter-active-line {\n  background-color : #dcdcdc\n}\n\n.ace-clouds .ace_marker-layer .ace_selected-word {\n  border: 1px solid #BDD5FC\n}\n\n.ace-clouds .ace_invisible {\n  color: #BFBFBF\n}\n\n.ace-clouds .ace_keyword,\n.ace-clouds .ace_meta,\n.ace-clouds .ace_support.ace_constant.ace_property-value {\n  color: #AF956F\n}\n\n.ace-clouds .ace_keyword.ace_operator {\n  color: #484848\n}\n\n.ace-clouds .ace_keyword.ace_other.ace_unit {\n  color: #96DC5F\n}\n\n.ace-clouds .ace_constant.ace_language {\n  color: #39946A\n}\n\n.ace-clouds .ace_constant.ace_numeric {\n  color: #46A609\n}\n\n.ace-clouds .ace_constant.ace_character.ace_entity {\n  color: #BF78CC\n}\n\n.ace-clouds .ace_invalid {\n  background-color: #FF002A\n}\n\n.ace-clouds .ace_fold {\n  background-color: #AF956F;\n  border-color: #000000\n}\n\n.ace-clouds .ace_storage,\n.ace-clouds .ace_support.ace_class,\n.ace-clouds .ace_support.ace_function,\n.ace-clouds .ace_support.ace_other,\n.ace-clouds .ace_support.ace_type {\n  color: #C52727\n}\n\n.ace-clouds .ace_string {\n  color: #5D90CD\n}\n\n.ace-clouds .ace_comment {\n  color: #BCC8BA\n}\n\n.ace-clouds .ace_entity.ace_name.ace_tag,\n.ace-clouds .ace_entity.ace_other.ace_attribute-name {\n  color: #606060\n}\n\n.ace-clouds .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y\n}\n\n.ace-clouds .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/clouds", ["require", "exports", "module", "ace/theme/clouds-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-clouds";
      exports2.cssText = require3("./clouds-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/clouds"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-crimson_editor.js
var require_theme_crimson_editor = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-crimson_editor.js"(exports, module2) {
    ace.define("ace/theme/crimson_editor-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-crimson-editor .ace_gutter {\n  background: #ebebeb;\n  color: #333;\n  overflow : hidden;\n}\n\n.ace-crimson-editor .ace_gutter-layer {\n  width: 100%;\n  text-align: right;\n}\n\n.ace-crimson-editor .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-crimson-editor {\n  background-color: #FFFFFF;\n  color: rgb(64, 64, 64);\n}\n\n.ace-crimson-editor .ace_cursor {\n  color: black;\n}\n\n.ace-crimson-editor .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-crimson-editor .ace_identifier {\n  color: black;\n}\n\n.ace-crimson-editor .ace_keyword {\n  color: blue;\n}\n\n.ace-crimson-editor .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-crimson-editor .ace_constant.ace_language {\n  color: rgb(255, 156, 0);\n}\n\n.ace-crimson-editor .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-crimson-editor .ace_invalid {\n  text-decoration: line-through;\n  color: rgb(224, 0, 0);\n}\n\n.ace-crimson-editor .ace_fold {\n}\n\n.ace-crimson-editor .ace_support.ace_function {\n  color: rgb(192, 0, 0);\n}\n\n.ace-crimson-editor .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-crimson-editor .ace_support.ace_type,\n.ace-crimson-editor .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-crimson-editor .ace_keyword.ace_operator {\n  color: rgb(49, 132, 149);\n}\n\n.ace-crimson-editor .ace_string {\n  color: rgb(128, 0, 128);\n}\n\n.ace-crimson-editor .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-crimson-editor .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-crimson-editor .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-crimson-editor .ace_constant.ace_numeric {\n  color: rgb(0, 0, 64);\n}\n\n.ace-crimson-editor .ace_variable {\n  color: rgb(0, 64, 128);\n}\n\n.ace-crimson-editor .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-crimson-editor .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n\n.ace-crimson-editor .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-crimson-editor .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-crimson-editor .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-crimson-editor .ace_marker-layer .ace_active-line {\n  background: rgb(232, 242, 254);\n}\n\n.ace-crimson-editor .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-crimson-editor .ace_meta.ace_tag {\n  color:rgb(28, 2, 255);\n}\n\n.ace-crimson-editor .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-crimson-editor .ace_string.ace_regex {\n  color: rgb(192, 0, 192);\n}\n\n.ace-crimson-editor .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-crimson-editor .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/crimson_editor", ["require", "exports", "module", "ace/theme/crimson_editor-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssText = require3("./crimson_editor-css");
      exports2.cssClass = "ace-crimson-editor";
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/crimson_editor"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-dawn.js
var require_theme_dawn = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-dawn.js"(exports, module2) {
    ace.define("ace/theme/dawn-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-dawn .ace_gutter {\n  background: #ebebeb;\n  color: #333\n}\n\n.ace-dawn .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8\n}\n\n.ace-dawn {\n  background-color: #F9F9F9;\n  color: #080808\n}\n\n.ace-dawn .ace_cursor {\n  color: #000000\n}\n\n.ace-dawn .ace_marker-layer .ace_selection {\n  background: rgba(39, 95, 255, 0.30)\n}\n\n.ace-dawn.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #F9F9F9;\n}\n\n.ace-dawn .ace_marker-layer .ace_step {\n  background: rgb(255, 255, 0)\n}\n\n.ace-dawn .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(75, 75, 126, 0.50)\n}\n\n.ace-dawn .ace_marker-layer .ace_active-line {\n  background: rgba(36, 99, 180, 0.12)\n}\n\n.ace-dawn .ace_gutter-active-line {\n  background-color : #dcdcdc\n}\n\n.ace-dawn .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(39, 95, 255, 0.30)\n}\n\n.ace-dawn .ace_invisible {\n  color: rgba(75, 75, 126, 0.50)\n}\n\n.ace-dawn .ace_keyword,\n.ace-dawn .ace_meta {\n  color: #794938\n}\n\n.ace-dawn .ace_constant,\n.ace-dawn .ace_constant.ace_character,\n.ace-dawn .ace_constant.ace_character.ace_escape,\n.ace-dawn .ace_constant.ace_other {\n  color: #811F24\n}\n\n.ace-dawn .ace_invalid.ace_illegal {\n  text-decoration: underline;\n  font-style: italic;\n  color: #F8F8F8;\n  background-color: #B52A1D\n}\n\n.ace-dawn .ace_invalid.ace_deprecated {\n  text-decoration: underline;\n  font-style: italic;\n  color: #B52A1D\n}\n\n.ace-dawn .ace_support {\n  color: #691C97\n}\n\n.ace-dawn .ace_support.ace_constant {\n  color: #B4371F\n}\n\n.ace-dawn .ace_fold {\n  background-color: #794938;\n  border-color: #080808\n}\n\n.ace-dawn .ace_list,\n.ace-dawn .ace_markup.ace_list,\n.ace-dawn .ace_support.ace_function {\n  color: #693A17\n}\n\n.ace-dawn .ace_storage {\n  font-style: italic;\n  color: #A71D5D\n}\n\n.ace-dawn .ace_string {\n  color: #0B6125\n}\n\n.ace-dawn .ace_string.ace_regexp {\n  color: #CF5628\n}\n\n.ace-dawn .ace_comment {\n  font-style: italic;\n  color: #5A525F\n}\n\n.ace-dawn .ace_heading,\n.ace-dawn .ace_markup.ace_heading {\n  color: #19356D\n}\n\n.ace-dawn .ace_variable {\n  color: #234A97\n}\n\n.ace-dawn .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYLh/5+x/AAizA4hxNNsZAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-dawn .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/dawn", ["require", "exports", "module", "ace/theme/dawn-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-dawn";
      exports2.cssText = require3("./dawn-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/dawn"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-dreamweaver.js
var require_theme_dreamweaver = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-dreamweaver.js"(exports, module2) {
    ace.define("ace/theme/dreamweaver-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-dreamweaver .ace_gutter {\n  background: #e8e8e8;\n  color: #333;\n}\n\n.ace-dreamweaver .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-dreamweaver {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-dreamweaver .ace_fold {\n    background-color: #757AD8;\n}\n\n.ace-dreamweaver .ace_cursor {\n  color: black;\n}\n        \n.ace-dreamweaver .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-dreamweaver .ace_storage,\n.ace-dreamweaver .ace_keyword {\n  color: blue;\n}\n\n.ace-dreamweaver .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-dreamweaver .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-dreamweaver .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-dreamweaver .ace_invalid {\n  background-color: rgb(153, 0, 0);\n  color: white;\n}\n\n.ace-dreamweaver .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-dreamweaver .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-dreamweaver .ace_support.ace_type,\n.ace-dreamweaver .ace_support.ace_class {\n  color: #009;\n}\n\n.ace-dreamweaver .ace_support.ace_php_tag {\n  color: #f00;\n}\n\n.ace-dreamweaver .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-dreamweaver .ace_string {\n  color: #00F;\n}\n\n.ace-dreamweaver .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-dreamweaver .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-dreamweaver .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-dreamweaver .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-dreamweaver .ace_variable {\n  color: #06F\n}\n\n.ace-dreamweaver .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-dreamweaver .ace_entity.ace_name.ace_function {\n  color: #00F;\n}\n\n\n.ace-dreamweaver .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-dreamweaver .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-dreamweaver .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n\n.ace-dreamweaver .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-dreamweaver .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-dreamweaver .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-dreamweaver .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-dreamweaver .ace_gutter-active-line {\n  background-color : #DCDCDC;\n}\n\n.ace-dreamweaver .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-dreamweaver .ace_meta.ace_tag {\n  color:#009;\n}\n\n.ace-dreamweaver .ace_meta.ace_tag.ace_anchor {\n  color:#060;\n}\n\n.ace-dreamweaver .ace_meta.ace_tag.ace_form {\n  color:#F90;\n}\n\n.ace-dreamweaver .ace_meta.ace_tag.ace_image {\n  color:#909;\n}\n\n.ace-dreamweaver .ace_meta.ace_tag.ace_script {\n  color:#900;\n}\n\n.ace-dreamweaver .ace_meta.ace_tag.ace_style {\n  color:#909;\n}\n\n.ace-dreamweaver .ace_meta.ace_tag.ace_table {\n  color:#099;\n}\n\n.ace-dreamweaver .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-dreamweaver .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-dreamweaver .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/dreamweaver", ["require", "exports", "module", "ace/theme/dreamweaver-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-dreamweaver";
      exports2.cssText = require3("./dreamweaver-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/dreamweaver"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-eclipse.js
var require_theme_eclipse = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-eclipse.js"(exports, module2) {
    ace.define("ace/theme/eclipse-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-eclipse .ace_gutter {\n  background: #ebebeb;\n  border-right: 1px solid rgb(159, 159, 159);\n  color: rgb(136, 136, 136);\n}\n\n.ace-eclipse .ace_print-margin {\n  width: 1px;\n  background: #ebebeb;\n}\n\n.ace-eclipse {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-eclipse .ace_fold {\n    background-color: rgb(60, 76, 114);\n}\n\n.ace-eclipse .ace_cursor {\n  color: black;\n}\n\n.ace-eclipse .ace_storage,\n.ace-eclipse .ace_keyword,\n.ace-eclipse .ace_variable {\n  color: rgb(127, 0, 85);\n}\n\n.ace-eclipse .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-eclipse .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-eclipse .ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-eclipse .ace_string {\n  color: rgb(42, 0, 255);\n}\n\n.ace-eclipse .ace_comment {\n  color: rgb(113, 150, 130);\n}\n\n.ace-eclipse .ace_comment.ace_doc {\n  color: rgb(63, 95, 191);\n}\n\n.ace-eclipse .ace_comment.ace_doc.ace_tag {\n  color: rgb(127, 159, 191);\n}\n\n.ace-eclipse .ace_constant.ace_numeric {\n  color: darkblue;\n}\n\n.ace-eclipse .ace_tag {\n  color: rgb(25, 118, 116);\n}\n\n.ace-eclipse .ace_type {\n  color: rgb(127, 0, 127);\n}\n\n.ace-eclipse .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-eclipse .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n\n.ace-eclipse .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-eclipse .ace_meta.ace_tag {\n  color:rgb(25, 118, 116);\n}\n\n.ace-eclipse .ace_invisible {\n  color: #ddd;\n}\n\n.ace-eclipse .ace_entity.ace_other.ace_attribute-name {\n  color:rgb(127, 0, 127);\n}\n.ace-eclipse .ace_marker-layer .ace_step {\n  background: rgb(255, 255, 0);\n}\n\n.ace-eclipse .ace_active-line {\n  background: rgb(232, 242, 254);\n}\n\n.ace-eclipse .ace_gutter-active-line {\n  background-color : #DADADA;\n}\n\n.ace-eclipse .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgb(181, 213, 255);\n}\n\n.ace-eclipse .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-eclipse .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/eclipse", ["require", "exports", "module", "ace/theme/eclipse-css", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      exports2.isDark = false;
      exports2.cssText = require3("./eclipse-css");
      exports2.cssClass = "ace-eclipse";
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/eclipse"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-github.js
var require_theme_github = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-github.js"(exports, module2) {
    ace.define("ace/theme/github-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = `/* CSS style content from github's default pygments highlighter template.
   Cursor and selection styles from textmate.css. */
.ace-github .ace_gutter {
  background: #e8e8e8;
  color: #AAA;
}

.ace-github  {
  background: #fff;
  color: #000;
}

.ace-github .ace_keyword {
  font-weight: bold;
}

.ace-github .ace_string {
  color: #D14;
}

.ace-github .ace_variable.ace_class {
  color: teal;
}

.ace-github .ace_constant.ace_numeric {
  color: #099;
}

.ace-github .ace_constant.ace_buildin {
  color: #0086B3;
}

.ace-github .ace_support.ace_function {
  color: #0086B3;
}

.ace-github .ace_comment {
  color: #998;
  font-style: italic;
}

.ace-github .ace_variable.ace_language  {
  color: #0086B3;
}

.ace-github .ace_paren {
  font-weight: bold;
}

.ace-github .ace_boolean {
  font-weight: bold;
}

.ace-github .ace_string.ace_regexp {
  color: #009926;
  font-weight: normal;
}

.ace-github .ace_variable.ace_instance {
  color: teal;
}

.ace-github .ace_constant.ace_language {
  font-weight: bold;
}

.ace-github .ace_cursor {
  color: black;
}

.ace-github.ace_focus .ace_marker-layer .ace_active-line {
  background: rgb(255, 255, 204);
}
.ace-github .ace_marker-layer .ace_active-line {
  background: rgb(245, 245, 245);
}

.ace-github .ace_marker-layer .ace_selection {
  background: rgb(181, 213, 255);
}

.ace-github.ace_multiselect .ace_selection.ace_start {
  box-shadow: 0 0 3px 0px white;
}
/* bold keywords cause cursor issues for some fonts */
/* this disables bold style for editor and keeps for static highlighter */
.ace-github.ace_nobold .ace_line > span {
    font-weight: normal !important;
}

.ace-github .ace_marker-layer .ace_step {
  background: rgb(252, 255, 0);
}

.ace-github .ace_marker-layer .ace_stack {
  background: rgb(164, 229, 101);
}

.ace-github .ace_marker-layer .ace_bracket {
  margin: -1px 0 0 -1px;
  border: 1px solid rgb(192, 192, 192);
}

.ace-github .ace_gutter-active-line {
    background-color : rgba(0, 0, 0, 0.07);
}

.ace-github .ace_marker-layer .ace_selected-word {
  background: rgb(250, 250, 255);
  border: 1px solid rgb(200, 200, 250);
}

.ace-github .ace_invisible {
  color: #BFBFBF
}

.ace-github .ace_print-margin {
  width: 1px;
  background: #e8e8e8;
}

.ace-github .ace_indent-guide {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;
}

.ace-github .ace_indent-guide-active {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;
}
`;
    });
    ace.define("ace/theme/github", ["require", "exports", "module", "ace/theme/github-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-github";
      exports2.cssText = require3("./github-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/github"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-github_light_default.js
var require_theme_github_light_default = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-github_light_default.js"(exports, module2) {
    ace.define("ace/theme/github_light_default-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-github-light-default .ace_gutter {\n    background: #ffffff;\n    color: rgba(27, 31, 35, 0.3);\n}\n\n.ace-github-light-default .ace_print-margin {\n    width: 1px;\n    background: #e8e8e8;\n}\n\n.ace-github-light-default {\n    background-color: #FFFFFF;\n    color: #24292E;\n}\n\n.ace-github-light-default .ace_cursor {\n    color: #044289;\n    background: none;\n}\n\n.ace-github-light-default .ace_marker-layer .ace_selection {\n    background: rgba(3, 102, 214, 0.14);\n}\n\n.ace-github-light-default.ace_multiselect .ace_selection.ace_start {\n    box-shadow: 0 0 3px 0px #FFFFFF;\n    border-radius: 2px;\n}\n\n.ace-github-light-default .ace_marker-layer .ace_step {\n    background: rgb(198, 219, 174);\n}\n\n.ace-github-light-default .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid rgba(52, 208, 88, 0);\n    background: rgba(52, 208, 88, 0.25);\n}\n\n.ace-github-light-default .ace_marker-layer .ace_active-line {\n    background: #f6f8fa;\n    border: 2px solid #eeeeee;\n}\n\n.ace-github-light-default .ace_gutter-active-line {\n    background-color: #f6f8fa;\n    color: #24292e\n}\n\n.ace-github-light-default .ace_marker-layer .ace_selected-word {\n    border: 1px solid rgba(3, 102, 214, 0.14);\n}\n\n.ace-github-light-default .ace_fold {\n    background-color: #D73A49;\n    border-color: #24292E;\n}\n\n.ace_tooltip.ace-github-light-default {\n    background-color: #f6f8fa !important;\n    color: #444d56 !important;\n    border: 1px solid #444d56\n}\n\n.ace-github-light-default .language_highlight_error {\n    border-bottom: dotted 1px #cb2431;\n    background: none;\n}\n\n.ace-github-light-default .language_highlight_warning {\n    border-bottom: solid 1px #f9c513;\n    background: none;\n}\n\n.ace-github-light-default .language_highlight_info {\n    border-bottom: dotted 1px #1a85ff;\n    background: none;\n}\n\n.ace-github-light-default .ace_keyword {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_constant {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_support {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_support.ace_constant {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_support.ace_type {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_storage {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_storage.ace_type {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_invalid.ace_illegal {\n    font-style: italic;\n    color: #B31D28;\n}\n\n.ace-github-light-default .ace_invalid.ace_deprecated {\n    font-style: italic;\n    color: #B31D28;\n}\n\n.ace-github-light-default .ace_string {\n    color: #032F62;\n}\n\n.ace-github-light-default .ace_string.ace_regexp {\n    color: #032F62;\n}\n\n.ace-github-light-default .ace_comment {\n    color: #6A737D;\n}\n\n.ace-github-light-default .ace_variable {\n    color: #E36209;\n}\n\n.ace-github-light-default .ace_variable.ace_language {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_entity.ace_name {\n    color: #6F42C1;\n}\n\n.ace-github-light-default .ace_entity {\n    color: #6F42C1;\n}\n\n.ace-github-light-default .ace_entity.ace_name.ace_tag {\n    color: #22863A;\n}\n\n.ace-github-light-default .ace_meta.ace_tag {\n    color: #22863A;\n}\n\n.ace-github-light-default .ace_markup.ace_heading {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-github-light-default .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/github_light_default", ["require", "exports", "module", "ace/theme/github_light_default-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-github-light-default";
      exports2.cssText = require3("./github_light_default-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/github_light_default"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-gruvbox_light_hard.js
var require_theme_gruvbox_light_hard = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-gruvbox_light_hard.js"(exports, module2) {
    ace.define("ace/theme/gruvbox_light_hard-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-gruvbox-light-hard .ace_gutter {\n  background: #f9f5d7;\n  color: rgb(155,151,135)\n}\n\n.ace-gruvbox-light-hard .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8\n}\n\n.ace-gruvbox-light-hard {\n  background-color: #f9f5d7;\n  color: rgba(60, 56, 54, 0.50)\n}\n\n.ace-gruvbox-light-hard .ace_cursor {\n  color: #7c6f64\n}\n\n.ace-gruvbox-light-hard .ace_marker-layer .ace_selection {\n  background: #ebdbb2\n}\n\n.ace-gruvbox-light-hard.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #f9f5d7;\n  border-radius: 2px\n}\n\n.ace-gruvbox-light-hard .ace_marker-layer .ace_step {\n  background: rgb(198, 219, 174)\n}\n\n.ace-gruvbox-light-hard .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(60, 56, 54, 0.15)\n}\n\n.ace-gruvbox-light-hard .ace_marker-layer .ace_active-line {\n  background: #ebdbb2\n}\n\n.ace-gruvbox-light-hard .ace_gutter-active-line {\n  background-color: #ebdbb2\n}\n\n.ace-gruvbox-light-hard .ace_marker-layer .ace_selected-word {\n  border: 1px solid #ebdbb2\n}\n\n.ace-gruvbox-light-hard .ace_fold {\n  background-color: #79740e;\n  border-color: rgba(60, 56, 54, 0.50)\n}\n\n.ace-gruvbox-light-hard .ace_keyword {\n  color: #9d0006\n}\n\n.ace-gruvbox-light-hard .ace_keyword.ace_operator {\n  color: #427b58\n}\n\n.ace-gruvbox-light-hard .ace_keyword.ace_other.ace_unit {\n  color: #b16286\n}\n\n.ace-gruvbox-light-hard .ace_constant {\n  color: #8f3f71\n}\n\n.ace-gruvbox-light-hard .ace_constant.ace_numeric {\n  color: #8f3f71\n}\n\n.ace-gruvbox-light-hard .ace_constant.ace_character.ace_escape {\n  color: #9d0006\n}\n\n.ace-gruvbox-light-hard .ace_constant.ace_other {\n  color: #8f3f71\n}\n\n.ace-gruvbox-light-hard .ace_support.ace_function {\n  color: #427b58\n}\n\n.ace-gruvbox-light-hard .ace_support.ace_constant {\n  color: #8f3f71\n}\n\n.ace-gruvbox-light-hard .ace_support.ace_constant.ace_property-value {\n  color: #1d2021\n}\n\n.ace-gruvbox-light-hard .ace_support.ace_class {\n  color: #b57614\n}\n\n.ace-gruvbox-light-hard .ace_support.ace_type {\n  color: #b57614\n}\n\n.ace-gruvbox-light-hard .ace_storage {\n  color: #9d0006\n}\n\n.ace-gruvbox-light-hard .ace_invalid {\n  color: #1d2021;\n  background-color: #9d0006\n}\n\n.ace-gruvbox-light-hard .ace_string {\n  color: #79740e\n}\n\n.ace-gruvbox-light-hard .ace_string.ace_regexp {\n  color: #79740e\n}\n\n.ace-gruvbox-light-hard .ace_comment {\n  font-style: italic;\n  color: #928374\n}\n\n.ace-gruvbox-light-hard .ace_variable {\n  color: #076678\n}\n\n.ace-gruvbox-light-hard .ace_variable.ace_language {\n  color: #8f3f71\n}\n\n.ace-gruvbox-light-hard .ace_variable.ace_parameter {\n  color: #1d2021\n}\n\n.ace-gruvbox-light-hard .ace_meta.ace_tag {\n  color: #1d2021\n}\n\n.ace-gruvbox-light-hard .ace_entity.ace_other.ace_attribute-name {\n  color: #b57614\n}\n\n.ace-gruvbox-light-hard .ace_entity.ace_name.ace_function {\n  color: #79740e\n}\n\n.ace-gruvbox-light-hard .ace_entity.ace_name.ace_tag {\n  color: #076678\n}\n\n.ace-gruvbox-light-hard .ace_markup.ace_heading {\n  color: #79740e\n}\n\n.ace-gruvbox-light-hard .ace_markup.ace_list {\n  color: #076678\n}\n\n.ace-gruvbox-light-hard .ace_indent-guide {\n    background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-gruvbox-light-hard .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/gruvbox_light_hard", ["require", "exports", "module", "ace/theme/gruvbox_light_hard-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-gruvbox-light-hard";
      exports2.cssText = require3("./gruvbox_light_hard-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass);
    });
    (function() {
      ace.require(["ace/theme/gruvbox_light_hard"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-iplastic.js
var require_theme_iplastic = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-iplastic.js"(exports, module2) {
    ace.define("ace/theme/iplastic-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-iplastic .ace_gutter {\n  background: #dddddd;\n  color: #666666\n}\n\n.ace-iplastic .ace_print-margin {\n  width: 1px;\n  background: #bbbbbb\n}\n\n.ace-iplastic {\n  background-color: #eeeeee;\n  color: #333333\n}\n\n.ace-iplastic .ace_cursor {\n  color: #333\n}\n\n.ace-iplastic .ace_marker-layer .ace_selection {\n  background: #BAD6FD;\n}\n\n.ace-iplastic.ace_multiselect .ace_selection.ace_start {\n  border-radius: 4px\n}\n\n.ace-iplastic .ace_marker-layer .ace_step {\n  background: #444444\n}\n\n.ace-iplastic .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #49483E;\n  background: #FFF799\n}\n\n.ace-iplastic .ace_marker-layer .ace_active-line {\n  background: #e5e5e5\n}\n\n.ace-iplastic .ace_gutter-active-line {\n  background-color: #eeeeee\n}\n\n.ace-iplastic .ace_marker-layer .ace_selected-word {\n  border: 1px solid #555555;\n  border-radius:4px\n}\n\n.ace-iplastic .ace_invisible {\n  color: #999999\n}\n\n.ace-iplastic .ace_entity.ace_name.ace_tag,\n.ace-iplastic .ace_keyword,\n.ace-iplastic .ace_meta.ace_tag,\n.ace-iplastic .ace_storage {\n  color: #0000FF\n}\n\n.ace-iplastic .ace_punctuation,\n.ace-iplastic .ace_punctuation.ace_tag {\n  color: #000\n}\n\n.ace-iplastic .ace_constant {\n  color: #333333;\n  font-weight: 700\n}\n\n.ace-iplastic .ace_constant.ace_character,\n.ace-iplastic .ace_constant.ace_language,\n.ace-iplastic .ace_constant.ace_numeric,\n.ace-iplastic .ace_constant.ace_other {\n  color: #0066FF;\n  font-weight: 700\n}\n\n.ace-iplastic .ace_constant.ace_numeric{\n  font-weight: 100\n}\n\n.ace-iplastic .ace_invalid {\n  color: #F8F8F0;\n  background-color: #F92672\n}\n\n.ace-iplastic .ace_invalid.ace_deprecated {\n  color: #F8F8F0;\n  background-color: #AE81FF\n}\n\n.ace-iplastic .ace_support.ace_constant,\n.ace-iplastic .ace_support.ace_function {\n  color: #333333;\n  font-weight: 700\n}\n\n.ace-iplastic .ace_fold {\n  background-color: #464646;\n  border-color: #F8F8F2\n}\n\n.ace-iplastic .ace_storage.ace_type,\n.ace-iplastic .ace_support.ace_class,\n.ace-iplastic .ace_support.ace_type {\n  color: #3333fc;\n  font-weight: 700\n}\n\n.ace-iplastic .ace_entity.ace_name.ace_function,\n.ace-iplastic .ace_entity.ace_other,\n.ace-iplastic .ace_entity.ace_other.ace_attribute-name,\n.ace-iplastic .ace_variable {\n  color: #3366cc;\n  font-style: italic\n}\n\n.ace-iplastic .ace_variable.ace_parameter {\n  font-style: italic;\n  color: #2469E0\n}\n\n.ace-iplastic .ace_string {\n  color: #a55f03\n}\n\n.ace-iplastic .ace_comment {\n  color: #777777;\n  font-style: italic\n}\n\n.ace-iplastic .ace_fold-widget {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==);\n}\n\n.ace-iplastic .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAABlJREFUeNpi+P//PwMzMzPzfwAAAAD//wMAGRsECSML/RIAAAAASUVORK5CYII=) right repeat-y\n}\n\n.ace-iplastic .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/iplastic", ["require", "exports", "module", "ace/theme/iplastic-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-iplastic";
      exports2.cssText = require3("./iplastic-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/iplastic"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-katzenmilch.js
var require_theme_katzenmilch = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-katzenmilch.js"(exports, module2) {
    ace.define("ace/theme/katzenmilch-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-katzenmilch .ace_gutter,\n/* THIS THEME WAS AUTOGENERATED BY Theme.tmpl.css (UUID: ) */\n\n.ace-katzenmilch .ace_gutter {\n  background: #e8e8e8;\n  color: #333\n}\n\n.ace-katzenmilch .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8\n}\n\n.ace-katzenmilch {\n  background-color: #f3f2f3;\n  color: rgba(15, 0, 9, 1.0)\n}\n\n.ace-katzenmilch .ace_cursor {\n  border-left: 2px solid #100011\n}\n\n.ace-katzenmilch .ace_overwrite-cursors .ace_cursor {\n  border-left: 0px;\n  border-bottom: 1px solid #100011\n}\n\n.ace-katzenmilch .ace_marker-layer .ace_selection {\n  background: rgba(100, 5, 208, 0.27)\n}\n\n.ace-katzenmilch.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #f3f2f3;\n}\n\n.ace-katzenmilch .ace_marker-layer .ace_step {\n  background: rgb(198, 219, 174)\n}\n\n.ace-katzenmilch .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(0, 0, 0, 0.33);\n}\n\n.ace-katzenmilch .ace_marker-layer .ace_active-line {\n  background: rgb(232, 242, 254)\n}\n\n.ace-katzenmilch .ace_gutter-active-line {\n  background-color: rgb(232, 242, 254)\n}\n\n.ace-katzenmilch .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(100, 5, 208, 0.27)\n}\n\n.ace-katzenmilch .ace_invisible {\n  color: #BFBFBF\n}\n\n.ace-katzenmilch .ace_fold {\n  background-color: rgba(2, 95, 73, 0.97);\n  border-color: rgba(15, 0, 9, 1.0)\n}\n\n.ace-katzenmilch .ace_keyword {\n  color: #674Aa8;\n  rbackground-color: rgba(163, 170, 216, 0.055)\n}\n\n.ace-katzenmilch .ace_constant.ace_language {\n  color: #7D7e52;\n  rbackground-color: rgba(189, 190, 130, 0.059)\n}\n\n.ace-katzenmilch .ace_constant.ace_numeric {\n  color: rgba(79, 130, 123, 0.93);\n  rbackground-color: rgba(119, 194, 187, 0.059)\n}\n\n.ace-katzenmilch .ace_constant.ace_character,\n.ace-katzenmilch .ace_constant.ace_other {\n  color: rgba(2, 95, 105, 1.0);\n  rbackground-color: rgba(127, 34, 153, 0.063)\n}\n\n.ace-katzenmilch .ace_support.ace_function {\n  color: #9D7e62;\n  rbackground-color: rgba(189, 190, 130, 0.039)\n}\n\n.ace-katzenmilch .ace_support.ace_class {\n  color: rgba(239, 106, 167, 1.0);\n  rbackground-color: rgba(239, 106, 167, 0.063)\n}\n\n.ace-katzenmilch .ace_storage {\n  color: rgba(123, 92, 191, 1.0);\n  rbackground-color: rgba(139, 93, 223, 0.051)\n}\n\n.ace-katzenmilch .ace_invalid {\n  color: #DFDFD5;\n  rbackground-color: #CC1B27\n}\n\n.ace-katzenmilch .ace_string {\n  color: #5a5f9b;\n  rbackground-color: rgba(170, 175, 219, 0.035)\n}\n\n.ace-katzenmilch .ace_comment {\n  font-style: italic;\n  color: rgba(64, 79, 80, 0.67);\n  rbackground-color: rgba(95, 15, 255, 0.0078)\n}\n\n.ace-katzenmilch .ace_entity.ace_name.ace_function,\n.ace-katzenmilch .ace_variable {\n  color: rgba(2, 95, 73, 0.97);\n  rbackground-color: rgba(34, 255, 73, 0.12)\n}\n\n.ace-katzenmilch .ace_variable.ace_language {\n  color: #316fcf;\n  rbackground-color: rgba(58, 175, 255, 0.039)\n}\n\n.ace-katzenmilch .ace_variable.ace_parameter {\n  font-style: italic;\n  color: rgba(51, 150, 159, 0.87);\n  rbackground-color: rgba(5, 214, 249, 0.043)\n}\n\n.ace-katzenmilch .ace_entity.ace_other.ace_attribute-name {\n  color: rgba(73, 70, 194, 0.93);\n  rbackground-color: rgba(73, 134, 194, 0.035)\n}\n\n.ace-katzenmilch .ace_entity.ace_name.ace_tag {\n  color: #3976a2;\n  rbackground-color: rgba(73, 166, 210, 0.039)\n}\n\n.ace-katzenmilch .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-katzenmilch .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/katzenmilch", ["require", "exports", "module", "ace/theme/katzenmilch-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-katzenmilch";
      exports2.cssText = require3("./katzenmilch-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/katzenmilch"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-kuroir.js
var require_theme_kuroir = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-kuroir.js"(exports, module2) {
    ace.define("ace/theme/kuroir-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '/* THIS THEME WAS AUTOGENERATED BY Theme.tmpl.css (UUID: 467560D0-6ACE-4409-82FD-4791420837AC) */\n\n.ace-kuroir .ace_gutter {\n  background: #e8e8e8;\n  color: #333;\n}\n\n.ace-kuroir .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-kuroir {\n  background-color: #E8E9E8;\n  color: #363636;\n}\n\n.ace-kuroir .ace_cursor {\n  color: #202020;\n}\n\n.ace-kuroir .ace_marker-layer .ace_selection {\n  background: rgba(245, 170, 0, 0.57);\n}\n\n.ace-kuroir.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #E8E9E8;\n}\n\n.ace-kuroir .ace_marker-layer .ace_step {\n  background: rgb(198, 219, 174);\n}\n\n.ace-kuroir .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(0, 0, 0, 0.29);\n}\n\n.ace-kuroir .ace_marker-layer .ace_active-line {\n  background: rgba(203, 220, 47, 0.22);\n}\n\n.ace-kuroir .ace_gutter-active-line {\n  background-color: rgba(203, 220, 47, 0.22);\n}\n\n.ace-kuroir .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(245, 170, 0, 0.57);\n}\n\n.ace-kuroir .ace_invisible {\n  color: #BFBFBF\n}\n\n.ace-kuroir .ace_fold {\n  border-color: #363636;\n}\n\n\n\n\n\n.ace-kuroir .ace_constant{color:#CD6839;}.ace-kuroir .ace_constant.ace_numeric{color:#9A5925;}.ace-kuroir .ace_support{color:#104E8B;}.ace-kuroir .ace_support.ace_function{color:#005273;}.ace-kuroir .ace_support.ace_constant{color:#CF6A4C;}.ace-kuroir .ace_storage{color:#A52A2A;}.ace-kuroir .ace_invalid.ace_illegal{color:#FD1224;\nbackground-color:rgba(255, 6, 0, 0.15);}.ace-kuroir .ace_invalid.ace_deprecated{text-decoration:underline;\nfont-style:italic;\ncolor:#FD1732;\nbackground-color:#E8E9E8;}.ace-kuroir .ace_string{color:#639300;}.ace-kuroir .ace_string.ace_regexp{color:#417E00;\nbackground-color:#C9D4BE;}.ace-kuroir .ace_comment{color:rgba(148, 148, 148, 0.91);\nbackground-color:rgba(220, 220, 220, 0.56);}.ace-kuroir .ace_variable{color:#009ACD;}.ace-kuroir .ace_meta.ace_tag{color:#005273;}.ace-kuroir .ace_markup.ace_heading{color:#B8012D;\nbackground-color:rgba(191, 97, 51, 0.051);}.ace-kuroir .ace_markup.ace_list{color:#8F5B26;}\n\n.ace-kuroir .ace_indent-guide {\n    background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-kuroir .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/kuroir", ["require", "exports", "module", "ace/theme/kuroir-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-kuroir";
      exports2.cssText = require3("./kuroir-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/kuroir"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-solarized_light.js
var require_theme_solarized_light = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-solarized_light.js"(exports, module2) {
    ace.define("ace/theme/solarized_light-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-solarized-light .ace_gutter {\n  background: #fbf1d3;\n  color: #333\n}\n\n.ace-solarized-light .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8\n}\n\n.ace-solarized-light {\n  background-color: #FDF6E3;\n  color: #586E75\n}\n\n.ace-solarized-light .ace_cursor {\n  color: #000000\n}\n\n.ace-solarized-light .ace_marker-layer .ace_selection {\n  background: rgba(7, 54, 67, 0.09)\n}\n\n.ace-solarized-light.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #FDF6E3;\n}\n\n.ace-solarized-light .ace_marker-layer .ace_step {\n  background: rgb(255, 255, 0)\n}\n\n.ace-solarized-light .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(147, 161, 161, 0.50)\n}\n\n.ace-solarized-light .ace_marker-layer .ace_active-line {\n  background: #EEE8D5\n}\n\n.ace-solarized-light .ace_gutter-active-line {\n  background-color : #EDE5C1\n}\n\n.ace-solarized-light .ace_marker-layer .ace_selected-word {\n  border: 1px solid #7f9390\n}\n\n.ace-solarized-light .ace_invisible {\n  color: rgba(147, 161, 161, 0.50)\n}\n\n.ace-solarized-light .ace_keyword,\n.ace-solarized-light .ace_meta,\n.ace-solarized-light .ace_support.ace_class,\n.ace-solarized-light .ace_support.ace_type {\n  color: #859900\n}\n\n.ace-solarized-light .ace_constant.ace_character,\n.ace-solarized-light .ace_constant.ace_other {\n  color: #CB4B16\n}\n\n.ace-solarized-light .ace_constant.ace_language {\n  color: #B58900\n}\n\n.ace-solarized-light .ace_constant.ace_numeric {\n  color: #D33682\n}\n\n.ace-solarized-light .ace_fold {\n  background-color: #268BD2;\n  border-color: #586E75\n}\n\n.ace-solarized-light .ace_entity.ace_name.ace_function,\n.ace-solarized-light .ace_entity.ace_name.ace_tag,\n.ace-solarized-light .ace_support.ace_function,\n.ace-solarized-light .ace_variable,\n.ace-solarized-light .ace_variable.ace_language {\n  color: #268BD2\n}\n\n.ace-solarized-light .ace_storage {\n  color: #073642\n}\n\n.ace-solarized-light .ace_string {\n  color: #2AA198\n}\n\n.ace-solarized-light .ace_string.ace_regexp {\n  color: #D30102\n}\n\n.ace-solarized-light .ace_comment,\n.ace-solarized-light .ace_entity.ace_other.ace_attribute-name {\n  color: #93A1A1\n}\n\n.ace-solarized-light .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHjy8NJ/AAjgA5fzQUmBAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-solarized-light .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/solarized_light", ["require", "exports", "module", "ace/theme/solarized_light-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-solarized-light";
      exports2.cssText = require3("./solarized_light-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/solarized_light"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-sqlserver.js
var require_theme_sqlserver = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-sqlserver.js"(exports, module2) {
    ace.define("ace/theme/sqlserver-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-sqlserver .ace_gutter {\n    background: #ebebeb;\n    color: #333;\n    overflow: hidden;\n}\n\n.ace-sqlserver .ace_print-margin {\n    width: 1px;\n    background: #e8e8e8;\n}\n\n.ace-sqlserver {\n    background-color: #FFFFFF;\n    color: black;\n}\n\n.ace-sqlserver .ace_identifier {\n    color: black;\n}\n\n.ace-sqlserver .ace_keyword {\n    color: #0000FF;\n}\n\n.ace-sqlserver .ace_numeric {\n    color: black;\n}\n\n.ace-sqlserver .ace_storage {\n    color: #11B7BE;\n}\n\n.ace-sqlserver .ace_keyword.ace_operator,\n.ace-sqlserver .ace_lparen,\n.ace-sqlserver .ace_rparen,\n.ace-sqlserver .ace_punctuation {\n    color: #808080;\n}\n\n.ace-sqlserver .ace_set.ace_statement {\n    color: #0000FF;\n    text-decoration: underline;\n}\n\n.ace-sqlserver .ace_cursor {\n    color: black;\n}\n\n.ace-sqlserver .ace_invisible {\n    color: rgb(191, 191, 191);\n}\n\n.ace-sqlserver .ace_constant.ace_buildin {\n    color: rgb(88, 72, 246);\n}\n\n.ace-sqlserver .ace_constant.ace_language {\n    color: #979797;\n}\n\n.ace-sqlserver .ace_constant.ace_library {\n    color: rgb(6, 150, 14);\n}\n\n.ace-sqlserver .ace_invalid {\n    background-color: rgb(153, 0, 0);\n    color: white;\n}\n\n.ace-sqlserver .ace_support.ace_function {\n    color: #FF00FF;\n}\n\n.ace-sqlserver .ace_support.ace_constant {\n    color: rgb(6, 150, 14);\n}\n\n.ace-sqlserver .ace_class {\n    color: #008080;\n}\n\n.ace-sqlserver .ace_support.ace_other {\n    color: #6D79DE;\n}\n\n.ace-sqlserver .ace_variable.ace_parameter {\n    font-style: italic;\n    color: #FD971F;\n}\n\n.ace-sqlserver .ace_comment {\n    color: #008000;\n}\n\n.ace-sqlserver .ace_constant.ace_numeric {\n    color: black;\n}\n\n.ace-sqlserver .ace_variable {\n    color: rgb(49, 132, 149);\n}\n\n.ace-sqlserver .ace_xml-pe {\n    color: rgb(104, 104, 91);\n}\n\n.ace-sqlserver .ace_support.ace_storedprocedure {\n    color: #800000;\n}\n\n.ace-sqlserver .ace_heading {\n    color: rgb(12, 7, 255);\n}\n\n.ace-sqlserver .ace_list {\n    color: rgb(185, 6, 144);\n}\n\n.ace-sqlserver .ace_marker-layer .ace_selection {\n    background: rgb(181, 213, 255);\n}\n\n.ace-sqlserver .ace_marker-layer .ace_step {\n    background: rgb(252, 255, 0);\n}\n\n.ace-sqlserver .ace_marker-layer .ace_stack {\n    background: rgb(164, 229, 101);\n}\n\n.ace-sqlserver .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-sqlserver .ace_marker-layer .ace_active-line {\n    background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-sqlserver .ace_gutter-active-line {\n    background-color: #dcdcdc;\n}\n\n.ace-sqlserver .ace_marker-layer .ace_selected-word {\n    background: rgb(250, 250, 255);\n    border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-sqlserver .ace_meta.ace_tag {\n    color: #0000FF;\n}\n\n.ace-sqlserver .ace_string.ace_regex {\n    color: #FF0000;\n}\n\n.ace-sqlserver .ace_string {\n    color: #FF0000;\n}\n\n.ace-sqlserver .ace_entity.ace_other.ace_attribute-name {\n    color: #994409;\n}\n\n.ace-sqlserver .ace_indent-guide {\n    background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-sqlserver .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/sqlserver", ["require", "exports", "module", "ace/theme/sqlserver-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-sqlserver";
      exports2.cssText = require3("./sqlserver-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/sqlserver"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-textmate.js
var require_theme_textmate = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-textmate.js"(exports, module2) {
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate-css", "ace/lib/dom"], function(require3, exports2, module3) {
      "use strict";
      exports2.isDark = false;
      exports2.cssClass = "ace-tm";
      exports2.cssText = require3("./textmate-css");
      exports2.$id = "ace/theme/textmate";
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/textmate"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-tomorrow.js
var require_theme_tomorrow = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-tomorrow.js"(exports, module2) {
    ace.define("ace/theme/tomorrow-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-tomorrow .ace_gutter {\n  background: #f6f6f6;\n  color: #4D4D4C\n}\n\n.ace-tomorrow .ace_print-margin {\n  width: 1px;\n  background: #f6f6f6\n}\n\n.ace-tomorrow {\n  background-color: #FFFFFF;\n  color: #4D4D4C\n}\n\n.ace-tomorrow .ace_cursor {\n  color: #AEAFAD\n}\n\n.ace-tomorrow .ace_marker-layer .ace_selection {\n  background: #D6D6D6\n}\n\n.ace-tomorrow.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #FFFFFF;\n}\n\n.ace-tomorrow .ace_marker-layer .ace_step {\n  background: rgb(255, 255, 0)\n}\n\n.ace-tomorrow .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #D1D1D1\n}\n\n.ace-tomorrow .ace_marker-layer .ace_active-line {\n  background: #EFEFEF\n}\n\n.ace-tomorrow .ace_gutter-active-line {\n  background-color : #dcdcdc\n}\n\n.ace-tomorrow .ace_marker-layer .ace_selected-word {\n  border: 1px solid #D6D6D6\n}\n\n.ace-tomorrow .ace_invisible {\n  color: #D1D1D1\n}\n\n.ace-tomorrow .ace_keyword,\n.ace-tomorrow .ace_meta,\n.ace-tomorrow .ace_storage,\n.ace-tomorrow .ace_storage.ace_type,\n.ace-tomorrow .ace_support.ace_type {\n  color: #8959A8\n}\n\n.ace-tomorrow .ace_keyword.ace_operator {\n  color: #3E999F\n}\n\n.ace-tomorrow .ace_constant.ace_character,\n.ace-tomorrow .ace_constant.ace_language,\n.ace-tomorrow .ace_constant.ace_numeric,\n.ace-tomorrow .ace_keyword.ace_other.ace_unit,\n.ace-tomorrow .ace_support.ace_constant,\n.ace-tomorrow .ace_variable.ace_parameter {\n  color: #F5871F\n}\n\n.ace-tomorrow .ace_constant.ace_other {\n  color: #666969\n}\n\n.ace-tomorrow .ace_invalid {\n  color: #FFFFFF;\n  background-color: #C82829\n}\n\n.ace-tomorrow .ace_invalid.ace_deprecated {\n  color: #FFFFFF;\n  background-color: #8959A8\n}\n\n.ace-tomorrow .ace_fold {\n  background-color: #4271AE;\n  border-color: #4D4D4C\n}\n\n.ace-tomorrow .ace_entity.ace_name.ace_function,\n.ace-tomorrow .ace_support.ace_function,\n.ace-tomorrow .ace_variable {\n  color: #4271AE\n}\n\n.ace-tomorrow .ace_support.ace_class,\n.ace-tomorrow .ace_support.ace_type {\n  color: #C99E00\n}\n\n.ace-tomorrow .ace_heading,\n.ace-tomorrow .ace_markup.ace_heading,\n.ace-tomorrow .ace_string {\n  color: #718C00\n}\n\n.ace-tomorrow .ace_entity.ace_name.ace_tag,\n.ace-tomorrow .ace_entity.ace_other.ace_attribute-name,\n.ace-tomorrow .ace_meta.ace_tag,\n.ace-tomorrow .ace_string.ace_regexp,\n.ace-tomorrow .ace_variable {\n  color: #C82829\n}\n\n.ace-tomorrow .ace_comment {\n  color: #8E908C\n}\n\n.ace-tomorrow .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bdu3f/BwAlfgctduB85QAAAABJRU5ErkJggg==) right repeat-y\n}\n\n.ace-tomorrow .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/tomorrow", ["require", "exports", "module", "ace/theme/tomorrow-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-tomorrow";
      exports2.cssText = require3("./tomorrow-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/tomorrow"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-xcode.js
var require_theme_xcode = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-xcode.js"(exports, module2) {
    ace.define("ace/theme/xcode-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '/* THIS THEME WAS AUTOGENERATED BY Theme.tmpl.css (UUID: EE3AD170-2B7F-4DE1-B724-C75F13FE0085) */\n\n.ace-xcode .ace_gutter {\n  background: #e8e8e8;\n  color: #333\n}\n\n.ace-xcode .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8\n}\n\n.ace-xcode {\n  background-color: #FFFFFF;\n  color: #000000\n}\n\n.ace-xcode .ace_cursor {\n  color: #000000\n}\n\n.ace-xcode .ace_marker-layer .ace_selection {\n  background: #B5D5FF\n}\n\n.ace-xcode.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #FFFFFF;\n}\n\n.ace-xcode .ace_marker-layer .ace_step {\n  background: rgb(198, 219, 174)\n}\n\n.ace-xcode .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #BFBFBF\n}\n\n.ace-xcode .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.071)\n}\n\n.ace-xcode .ace_gutter-active-line {\n  background-color: rgba(0, 0, 0, 0.071)\n}\n\n.ace-xcode .ace_marker-layer .ace_selected-word {\n  border: 1px solid #B5D5FF\n}\n\n.ace-xcode .ace_constant.ace_language,\n.ace-xcode .ace_keyword,\n.ace-xcode .ace_meta,\n.ace-xcode .ace_variable.ace_language {\n  color: #C800A4\n}\n\n.ace-xcode .ace_invisible {\n  color: #BFBFBF\n}\n\n.ace-xcode .ace_constant.ace_character,\n.ace-xcode .ace_constant.ace_other {\n  color: #275A5E\n}\n\n.ace-xcode .ace_constant.ace_numeric {\n  color: #3A00DC\n}\n\n.ace-xcode .ace_entity.ace_other.ace_attribute-name,\n.ace-xcode .ace_support.ace_constant,\n.ace-xcode .ace_support.ace_function {\n  color: #450084\n}\n\n.ace-xcode .ace_fold {\n  background-color: #C800A4;\n  border-color: #000000\n}\n\n.ace-xcode .ace_entity.ace_name.ace_tag,\n.ace-xcode .ace_support.ace_class,\n.ace-xcode .ace_support.ace_type {\n  color: #790EAD\n}\n\n.ace-xcode .ace_storage {\n  color: #C900A4\n}\n\n.ace-xcode .ace_string {\n  color: #DF0002\n}\n\n.ace-xcode .ace_comment {\n  color: #008E00\n}\n\n.ace-xcode .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==) right repeat-y\n}\n\n.ace-xcode .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n} \n';
    });
    ace.define("ace/theme/xcode", ["require", "exports", "module", "ace/theme/xcode-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = false;
      exports2.cssClass = "ace-xcode";
      exports2.cssText = require3("./xcode-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/xcode"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-ambiance.js
var require_theme_ambiance = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-ambiance.js"(exports, module2) {
    ace.define("ace/theme/ambiance-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = `.ace-ambiance .ace_gutter {
  background-color: #3d3d3d;
  background-image: linear-gradient(left, #3D3D3D, #333);
  background-repeat: repeat-x;
  border-right: 1px solid #4d4d4d;
  text-shadow: 0px 1px 1px #4d4d4d;
  color: #222;
}

.ace-ambiance .ace_gutter-layer {
  background: repeat left top;
}

.ace-ambiance .ace_gutter-active-line {
  background-color: #3F3F3F;
}

.ace-ambiance .ace_fold-widget {
  text-align: center;
}

.ace-ambiance .ace_fold-widget:hover {
  color: #777;
}

.ace-ambiance .ace_fold-widget.ace_start,
.ace-ambiance .ace_fold-widget.ace_end,
.ace-ambiance .ace_fold-widget.ace_closed{
  background: none !important;
  border: none;
  box-shadow: none;
}

.ace-ambiance .ace_fold-widget.ace_start:after {
  content: '\u25BE'
}

.ace-ambiance .ace_fold-widget.ace_end:after {
  content: '\u25B4'
}

.ace-ambiance .ace_fold-widget.ace_closed:after {
  content: '\u2023'
}

.ace-ambiance .ace_print-margin {
  border-left: 1px dotted #2D2D2D;
  right: 0;
  background: #262626;
}

.ace-ambiance .ace_scroller {
  -webkit-box-shadow: inset 0 0 10px black;
  -moz-box-shadow: inset 0 0 10px black;
  -o-box-shadow: inset 0 0 10px black;
  box-shadow: inset 0 0 10px black;
}

.ace-ambiance {
  color: #E6E1DC;
  background-color: #202020;
}

.ace-ambiance .ace_cursor {
  border-left: 1px solid #7991E8;
}

.ace-ambiance .ace_overwrite-cursors .ace_cursor {
  border: 1px solid #FFE300;
  background: #766B13;
}

.ace-ambiance.normal-mode .ace_cursor-layer {
  z-index: 0;
}
 
.ace-ambiance .ace_marker-layer .ace_selection {
  background: rgba(221, 240, 255, 0.20);
}

.ace-ambiance .ace_marker-layer .ace_selected-word {
  border-radius: 4px;
  border: 8px solid #3f475d;
  box-shadow: 0 0 4px black;
}

.ace-ambiance .ace_marker-layer .ace_step {
  background: rgb(198, 219, 174);
}

.ace-ambiance .ace_marker-layer .ace_bracket {
  margin: -1px 0 0 -1px;
  border: 1px solid rgba(255, 255, 255, 0.25);
}

.ace-ambiance .ace_marker-layer .ace_active-line {
  background: rgba(255, 255, 255, 0.031);
}

.ace-ambiance .ace_invisible {
  color: #333;
}

.ace-ambiance .ace_paren {
  color: #24C2C7;
}

.ace-ambiance .ace_keyword {
  color: #cda869;
}

.ace-ambiance .ace_keyword.ace_operator {
  color: #fa8d6a;
}

.ace-ambiance .ace_punctuation.ace_operator {
  color: #fa8d6a;
}

.ace-ambiance .ace_identifier {
}

.ace-ambiance .ace-statement {
  color: #cda869;
}

.ace-ambiance .ace_constant {
  color: #CF7EA9;
}

.ace-ambiance .ace_constant.ace_language {
  color: #CF7EA9;
}

.ace-ambiance .ace_constant.ace_library {
  
}

.ace-ambiance .ace_constant.ace_numeric {
  color: #78CF8A;
}

.ace-ambiance .ace_invalid {
  text-decoration: underline;
}

.ace-ambiance .ace_invalid.ace_illegal {
  color:#F8F8F8;
  background-color: rgba(86, 45, 86, 0.75);
}

.ace-ambiance .ace_invalid,
.ace-ambiance .ace_deprecated {
  text-decoration: underline;
  font-style: italic;
  color: #D2A8A1;
}

.ace-ambiance .ace_support {
  color: #9B859D;
}

.ace-ambiance .ace_support.ace_function {
  color: #DAD085;
}

.ace-ambiance .ace_function.ace_buildin {
  color: #9b859d;
}

.ace-ambiance .ace_string {
  color: #8f9d6a;
}

.ace-ambiance .ace_string.ace_regexp {
  color: #DAD085;
}

.ace-ambiance .ace_comment {
  font-style: italic;
  color: #555;
}

.ace-ambiance .ace_comment.ace_doc {
}

.ace-ambiance .ace_comment.ace_doc.ace_tag {
  color: #666;
  font-style: normal;
}

.ace-ambiance .ace_definition,
.ace-ambiance .ace_type {
  color: #aac6e3;
}

.ace-ambiance .ace_variable {
  color: #9999cc;
}

.ace-ambiance .ace_variable.ace_language {
  color: #9b859d;
}

.ace-ambiance .ace_xml-pe {
  color: #494949;
}

.ace-ambiance .ace_gutter-layer,
.ace-ambiance .ace_text-layer {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAQAAAAHUWYVAABFFUlEQVQYGbzBCeDVU/74/6fj9HIcx/FRHx9JCFmzMyGRURhLZIkUsoeRfUjS2FNDtr6WkMhO9sm+S8maJfu+Jcsg+/o/c+Z4z/t97/vezy3z+z8ekGlnYICG/o7gdk+wmSHZ1z4pJItqapjoKXWahm8NmV6eOTbWUOp6/6a/XIg6GQqmenJ2lDHyvCFZ2cBDbmtHA043VFhHwXxClWmeYAdLhV00Bd85go8VmaFCkbVkzlQENzfBDZ5gtN7HwF0KDrTwJ0dypSOzpaKCMwQHKTIreYIxlmhXTzTWkVm+LTynZhiSBT3RZQ7aGfjGEd3qyXQ1FDymqbKxpspERQN2MiRjNZlFFQXfCNFm9nM1zpAsoYjmtRTc5ajwuaXc5xrWskT97RaKzAGe5ARHhVUsDbjKklziiX5WROcJwSNCNI+9w1Jwv4Zb2r7lCMZ4oq5C0EdTx+2GzNuKpJ+iFf38JEWkHJn9DNF7mmBDITrWEg0VWL3pHU20tSZnuqWu+R3BtYa8XxV1HO7GyD32UkOpL/yDloINFTmvtId+nmAjxRw40VMwVKiwrKLE4bK5UOVntYwhOcSSXKrJHKPJedocpGjVz/ZMIbnYUPB10/eKCrs5apqpgVmWzBYWpmtKHecJPjaUuEgRDDaU0oZghCJ6zNMQ5ZhDYx05r5v2muQdM0EILtXUsaKiQX9WMEUotagQzFbUNN6NUPC2nm5pxEWGCjMc3GdJHjSU2kORLK/JGSrkfGEIjncU/CYUnOipoYemwj8tST9NsJmB7TUVXtbUtXATJVZXBMvYeTXJfobgJUPmGMP/yFaWonaa6BcFO3nqcIqCozSZoZoSr1g4zJOzuyGnxTEX3lUEJ7WcZgme8ddaWvWJo2AJR9DZU3CUIbhCSG6ybSwN6qtJVnCU2svDTP2ZInOw2cBTrqtQahtNZn9NcJ4l2NaSmSkkP1noZWnVwkLmdUPOwLZEwy2Z3S3R+4rIG9hcbpPXHFVWcQdZkn2FOta3cKWQnNRC5g1LsJah4GCzSVsKnCOY5OAFRTBekyyryeyilhFKva75r4Mc0aWanGEaThcy31s439KKxTzJYY5WTHPU1FtIHjQU3Oip4xlNzj/lBw23dYZVliQa7WAXf4shetcQfatI+jWRDBPmyNeW6A1P5kdDgyYJlba0BIM8BZu1JfrFwItyjcAMR3K0BWOIrtMEXyhyrlVEx3ui5dUBjmB/Q3CXW85R4mBD0s7B+4q5tKUjOlb9qqmhi5AZ6GFIC5HXtOobdYGlVdMVbNJ8toNTFcHxnoL+muBagcctjWnbNMuR00uI7nQESwg5q2qqrKWIfrNUmeQocY6HuyxJV02wj36w00yhpmUFenv4p6fUkZYqLyuinx2RGOjhCXYyJF84oiU00YMOOhhquNdfbOB7gU88pY4xJO8LVdp6/q2voeB4R04vIdhSE40xZObx1HGGJ/ja0LBthFInKaLPPFzuCaYaoj8JjPME8yoyxo6zlBqkiUZYgq00OYMswbWO5NGmq+xhipxHLRW29ARjNKXO0wRnear8XSg4XFPLKEPUS1GqvyLwiuBUoa7zpZ0l5xxFwWmWZC1H5h5FwU8eQ7K+g8UcVY6TMQreVQT/8uQ8Z+ALIXnSEa2pYZQneE9RZbSBNYXfWYJzW/h/4j4Dp1tYVcFIC5019Vyi4ThPqSFCzjGWaHQTBU8q6vrVwgxP9Lkm840imWKpcLCjYTtrKuwvsKSnrvHCXGkSMk9p6lhckfRpIeis+N2PiszT+mFLspyGleUhDwcLrZqmyeylxwjBcKHEapqkmyangyLZRVOijwOtCY5SsG5zL0OwlCJ4y5KznF3EUNDDrinwiyLZRzOXtlBbK5ITHFGLp8Q0R6ab6mS7enI2cFrxOyHvOCFaT1HThS1krjCwqWeurCkk+willhCC+RSZnRXBiZaC5RXRIZYKp2lyfrHwiKPKR0JDzrdU2EFgpidawlFDR6FgXUMNa+g1FY3bUQh2cLCwosRdnuQTS/S+JVrGLeWIvtQUvONJxlqSQYYKpwoN2kaocLjdVsis4Mk80ESF2YpSkzwldjHkjFCUutI/r+EHDU8oCs6yzL3PhWiEooZdFMkymlas4AcI3KmoMMNSQ3tHzjGWCrcJJdYyZC7QFGwjRL9p+MrRkAGWzIaWCn9W0F3TsK01c2ZvQw0byvxuQU0r1lM0qJO7wW0kRIMdDTtXEdzi4VIh+EoIHm0mWtAtpCixlabgn83fKTI7anJe9ST7WIK1DMGpQmYeA58ImV6ezOGOzK2Kgq01pd60cKWiUi9Lievb/0vIDPHQ05Kzt4ddPckQBQtoaurjyHnek/nKzpQLrVgKPjIkh2v4uyezpv+Xoo7fPFXaGFp1vaLKxQ4uUpQQS5VuQs7BCq4xRJv7fwpVvvFEB3j+620haOuocqMhWd6TTPAEx+mdFNGHdranFe95WrWmIvlY4F1Dle2ECgc6cto7SryuqGGGha0tFQ5V53migUKmg6XKAo4qS3mik+0OZpAhOLeZKicacgaYcyx5hypYQE02ZA4xi/pNhOQxR4klNKyqacj+mpxnLTnnGSo85++3ZCZq6lrZkXlGEX3o+C9FieccJbZWVFjC0Yo1FZnJhoYMFoI1hEZ9r6hwg75HwzBNhbZCdJEfJwTPGzJvaKImw1yYX1HDAmpXR+ZJQ/SmgqMNVQb5vgamGwLtt7VwvP7Qk1xpiM5x5Cyv93E06MZmgs0Nya2azIKOYKCGBQQW97RmhKNKF02JZqHEJ4o58qp7X5EcZmc56trXEqzjCBZ1MFGR87Ql2tSTs6CGxS05PTzRQorkbw7aKoKXFDXsYW42VJih/q+FP2BdTzDTwVqOYB13liM50vG7wy28qagyuIXMeQI/Oqq8bcn5wJI50xH00CRntyfpL1T4hydYpoXgNiFzoIUTDZnLNRzh4TBHwbYGDvZkxmlyJloyr6tRihpeUG94GnKtIznREF0tzJG/OOr73JBcrSh1k6WuTprgLU+mnSGnv6Zge0NNz+kTDdH8nuAuTdJDCNb21LCiIuqlYbqGzT3RAoZofQfjFazkqeNWdYaGvYTM001EW2oKPvVk1ldUGSgUtHFwjKM1h9jnFcmy5lChoLNaQMGGDsYbKixlaMBmmsx1QjCfflwTfO/gckW0ruZ3jugKR3R5W9hGUWqCgxuFgsuaCHorotGKzGaeZB9DMsaTnKCpMtwTvOzhYk0rdrArKCqcaWmVk1+F372ur1YkKxgatI8Qfe1gIX9wE9FgS8ESmuABIXnRUbCapcKe+nO7slClSZFzpV/LkLncEb1qiO42fS3R855Su2mCLh62t1SYZZYVmKwIHjREF2uihTzB20JOkz7dkxzYQnK0UOU494wh+VWRc6Un2kpTaVgLDFEkJ/uhzRcI0YKGgpGWOlocBU/a4fKoJ/pEaNV6jip3+Es9VXY078rGnmAdf7t9ylPXS34RBSuYPs1UecZTU78WanhBCHpZ5sAoTz0LGZKjPf9TRypqWEiTvOFglL1fCEY3wY/++rbk7C8bWebA6p6om6PgOL2kp44TFJlVNBXae2rqqdZztOJpT87GQsE9jqCPIe9VReZuQ/CIgacsyZdCpIScSYqcZk8r+nsyCzhyfhOqHGOIvrLknC8wTpFcaYiGC/RU1NRbUeUpocQOnkRpGOrIOcNRx+1uA0UrzhSSt+VyS3SJpnFWkzNDqOFGIWcfR86DnmARTQ1HKIL33ExPiemeOhYSSjzlSUZZuE4TveoJLnBUOFof6KiysCbnAEcZgcUNTDOwkqWu3RWtmGpZwlHhJENdZ3miGz0lJlsKnjbwqSHQjpxnFDlTLLwqJPMZMjd7KrzkSG7VsxXBZE+F8YZkb01Oe00yyRK9psh5SYh29ySPKBo2ylNht7ZkZnsKenjKNJu9PNEyZpaCHv4Kt6RQsLvAVp7M9kIimmCUwGeWqLMmGuIotYMmWNpSahkhZw9FqZsVnKJhsjAHvtHMsTM9fCI06Dx/u3vfUXCqfsKRc4oFY2jMsoo/7DJDwZ1CsIKnJu+J9ldkpmiCxQx1rWjI+T9FwcWWzOuaYH0Hj7klNRVWEQpmaqosakiGNTFHdjS/qnUdmf0NJW5xsL0HhimCCZZSRzmSPTXJQ4aaztAwtZnoabebJ+htCaZ7Cm535ByoqXKbX1WRc4Eh2MkRXWzImVc96Cj4VdOKVxR84VdQsIUM8Psoou2byVHyZFuq7O8otbSQ2UAoeEWTudATLGSpZzVLlXVkPU2Jc+27lsw2jmg5T5VhbeE3BT083K9WsTTkFU/Osi0rC5lRlpwRHUiesNS0sOvmqGML1aRbPAxTJD9ZKtxuob+hhl8cwYGWpJ8nub7t5p6coYbMovZ1BTdaKn1jYD6h4GFDNFyT/Kqe1XCXphXHOKLZmuRSRdBPEfVUXQzJm5YGPGGJdvAEr7hHNdGZnuBvrpciGmopOLf5N0uVMy0FfYToJk90uUCbJupaVpO53UJXR2bVpoU00V2KOo4zMFrBd0Jtz2pa0clT5Q5L8IpQ177mWQejPMEJhuQjS10ref6HHjdEhy1P1EYR7GtO0uSsKJQYLiTnG1rVScj5lyazpqWGl5uBbRWl7m6ixGOOnEsMJR7z8J0n6KMnCdxhiNYQCoZ6CmYLnO8omC3MkW3bktlPmEt/VQQHejL3+dOE5FlPdK/Mq8hZxxJtLyRrepLThYKbLZxkSb5W52vYxNOaOxUF0yxMUPwBTYqCzy01XayYK0sJyWBLqX0MwU5CzoymRzV0EjjeUeLgDpTo6ij42ZAzvD01dHUUTPLU96MdLbBME8nFBn7zJCMtJcZokn8YoqU0FS5WFKyniHobguMcmW8N0XkWZjkyN3hqOMtS08r+/xTBwpZSZ3qiVRX8SzMHHjfUNFjgHEPmY9PL3ykEzxkSre/1ZD6z/NuznuB0RcE1TWTm9zRgfUWVJiG6yrzgmWPXC8EAR4Wxhlad0ZbgQyEz3pG5RVEwwDJH2mgKpjcTiCOzn1lfUWANFbZ2BA8balnEweJC9J0iuaeZoI+ippFCztEKVvckR2iice1JvhVytrQwUAZpgsubCPaU7xUe9vWnaOpaSBEspalykhC9bUlOMpT42ZHca6hyrqKmw/wMR8H5ZmdFoBVJb03O4UL0tSNnvIeRmkrLWqrs78gcrEn2tpcboh0UPOW3UUR9PMk4T4nnNKWmCjlrefhCwxRNztfmIQVdDElvS4m1/WuOujoZCs5XVOjtKPGokJzsYCtFYoWonSPT21DheU/wWhM19FcElwqNGOsp9Q8N/cwXaiND1MmeL1Q5XROtYYgGeFq1aTMsoMmcrKjQrOFQTQ1fmBYhmW6o8Jkjc7iDJRTBIo5kgJD5yMEYA3srCg7VFKwiVJkmRCc5ohGOKhsYMn/XBLdo5taZjlb9YAlGWRimqbCsoY7HFAXLa5I1HPRxMMsQDHFkWtRNniqT9UEeNjcE7RUlrCJ4R2CSJuqlKHWvJXjAUNcITYkenuBRB84TbeepcqTj3zZyFJzgYQdHnqfgI0ddUwS6GqWpsKWhjq9cV0vBAEMN2znq+EBfIWT+pClYw5xsTlJU6GeIBsjGmmANTzJZiIYpgrM0Oa8ZMjd7NP87jxhqGOhJlnQtjuQpB+8aEE00wZFznSJPyHxgH3HkPOsJFvYk8zqCHzTs1BYOa4J3PFU+UVRZxlHDM4YavlNUuMoRveiZA2d7grMNc2g+RbSCEKzmgYsUmWmazFJyoiOZ4KnyhKOGRzWJa0+moyV4TVHDzn51Awtqaphfk/lRQ08FX1iiqxTB/kLwd0VynKfEvI6cd4XMV5bMhZ7gZUWVzYQ6Nm2BYzxJbw3bGthEUUMfgbGeorae6DxHtJoZ6alhZ0+ytiVoK1R4z5PTrOECT/SugseEOlb1MMNR4VRNcJy+V1Hg9ONClSZFZjdHlc6W6FBLdJja2MC5hhpu0DBYEY1TFGwiFAxRRCsYkiM9JRb0JNMVkW6CZYT/2EiTGWmo8k+h4FhDNE7BvppoTSFnmCV5xZKzvcCdDo7VVPnIU+I+Rc68juApC90MwcFCsJ5hDqxgScYKreruyQwTqrzoqDCmhWi4IbhB0Yrt3RGa6GfDv52rKXWhh28dyZaWUvcZeMTBaZoSGyiCtRU5J8iviioHaErs7Jkj61syVzTTgOcUOQ8buFBTYWdL5g3T4qlpe0+wvD63heAXRfCCIed9RbCsp2CiI7raUOYOTU13N8PNHvpaGvayo4a3LLT1lDrVEPT2zLUlheB1R+ZTRfKWJ+dcocLJfi11vyJ51lLqJ0WD7tRwryezjiV5W28uJO9qykzX8JDe2lHl/9oyBwa2UMfOngpXCixvKdXTk3wrsKmiVYdZIqsoWEERjbcUNDuiaQomGoIbFdEHmsyWnuR+IeriKDVLnlawlyNHKwKlSU631PKep8J4Q+ayjkSLKYLhalNHlYvttb6fHm0p6OApsZ4l2VfdqZkjuysy6ysKLlckf1KUutCTs39bmCgEyyoasIWlVaMF7mgmWtBT8Kol5xpH9IGllo8cJdopcvZ2sImlDmMIbtDk3KIpeNiS08lQw11NFPTwVFlPP6pJ2gvRfI7gQUfmNAtf6Gs0wQxDsKGlVBdF8rCa3jzdwMaGHOsItrZk7hAyOzpK9VS06j5F49b0VNGOOfKs3lDToMsMBe9ZWtHFEgxTJLs7qrygKZjUnmCYoeAqeU6jqWuLJup4WghOdvCYJnrSkSzoyRkm5M2StQwVltPkfCAk58tET/CSg+8MUecmotMEnhBKfWBIZsg2ihruMJQaoIm+tkTLKEqspMh00w95gvFCQRtDwTT1gVDDSEVdlwqZfxoQRbK0g+tbiBZxzKlpnpypejdDwTaeOvorMk/IJE10h9CqRe28hhLbe0pMsdSwv4ZbhKivo2BjDWfL8UKJgeavwlwb5KlwhyE4u4XkGE2ytZCznKLCDZZq42VzT8HLCrpruFbIfOIINmh/qCdZ1ZBc65kLHR1Bkyf5zn6pN3SvGKIlFNGplhrO9QSXanLOMQTLCa0YJCRrCZm/CZmrLTm7WzCK4GJDiWUdFeYx1LCFg3NMd0XmCuF3Y5rITLDUsYS9zoHVzwnJoYpSTQoObyEzr4cFBNqYTopoaU/wkyLZ2lPhX/5Y95ulxGTV7KjhWrOZgl8MyUUafjYraNjNU1N3IWcjT5WzWqjwtoarHSUObGYO3GCJZpsBlnJGPd6ZYLyl1GdCA2625IwwJDP8GUKymbzuyPlZlvTUsaUh5zFDhRWFzPKKZLAlWdcQbObgF9tOqOsmB1dqcqYJmWstFbZRRI9poolmqiLnU0POvxScpah2iSL5UJNzgScY5+AuIbpO0YD3NCW+dLMszFSdFCWGqG6eVq2uYVNDdICGD6W7EPRWZEY5gpsE9rUkS3mijzzJnm6UpUFXG1hCUeVoS5WfNcFpblELL2qqrCvMvRfd45oalvKU2tiQ6ePJOVMRXase9iTtLJztPxJKLWpo2CRDcJwn2sWSLKIO1WQWNTCvpVUvOZhgSC40JD0dOctaSqzkCRbXsKlb11Oip6PCJ0IwSJM31j3akRxlP7Rwn6aGaUL0qiLnJkvB3xWZ2+Q1TfCwpQH3G0o92UzmX4o/oJNQMMSQc547wVHhdk+VCw01DFYEnTxzZKAm74QmeNNR1w6WzEhNK15VJzuCdxQ53dRUDws5KvwgBMOEgpcVNe0hZI6RXT1Jd0cyj5nsaEAHgVmGaJIlWdsc5Ui2ElrRR6jrRAttNMEAIWrTDFubkZaok7/AkzfIwfuWVq0jHzuCK4QabtLUMVPB3kJ0oyHTSVFlqMALilJf2Rf8k5aaHtMfayocLBS8L89oKoxpJvnAkDPa0qp5DAUTHKWmCcnthlou8iCKaFFLHWcINd1nyIwXqrSxMNmSs6KmoL2QrKuWtlQ5V0120xQ5vRyZS1rgFkWwhiOwiuQbR0OOVhQM9iS3tiXp4RawRPMp5tDletOOBL95MpM01dZTBM9pkn5qF010rIeHFcFZhmSGpYpTsI6nwhqe5C9ynhlpp5ophuRb6WcJFldkVnVEwwxVfrVkvnWUuNLCg5bgboFHPDlDPDmnK7hUrWiIbjadDclujlZcaokOFup4Ri1kacV6jmrrK1hN9bGwpKEBQ4Q6DvIUXOmo6U5LqQM6EPyiKNjVkPnJkDPNEaxhiFay5ExW1NXVUGqcpYYdPcGiCq7z/TSlbhL4pplWXKd7NZO5QQFrefhRQW/NHOsqcIglc4UhWklR8K0QzbAw08CBDnpbgqXdeD/QUsM4RZXDFBW6WJKe/mFPdH0LtBgiq57wFLzlyQzz82qYx5D5WJP5yVJDW01BfyHnS6HKO/reZqId1WGa4Hkh2kWodJ8i6KoIPlAj2hPt76CzXsVR6koPRzWTfKqIentatYpQw2me4AA3y1Kind3SwoOKZDcFXTwl9tWU6mfgRk9d71sKtlNwrjnYw5tC5n5LdKiGry3JKNlHEd3oaMCFHrazBPMp/uNJ+V7IudcSbeOIdjUEdwl0VHCOZo5t6YluEuaC9mQeMgSfOyKnYGFHcIeQ84yQWbuJYJpZw5CzglDH7gKnWqqM9ZTaXcN0TeYhR84eQtJT76JJ1lREe7WnnvsMmRc9FQ7SBBM9mV3lCUdmHk/S2RAMt0QjFNFqQpWjDPQ01DXWUdDBkXziKPjGEP3VP+zIWU2t7im41FOloyWzn/L6dkUy3VLDaZ6appgDLHPjJEsyvJngWEPUyVBiAaHCTEXwrLvSEbV1e1gKJniicWorC1MUrVjB3uDhJE/wgSOzk1DXpk0k73qCM8xw2UvD5kJmDUfOomqMpWCkJRlvKXGmoeBm18USjVIk04SClxTB6YrgLAPLWYK9HLUt5cmc0vYES8GnTeRc6skZbQkWdxRsIcyBRzx1DbTk9FbU0caTPOgJHhJKnOGIVhQqvKmo0llRw9sabrZkDtdg3PqaKi9oatjY8B+G371paMg6+mZFNNtQ04mWBq3rYLOmtWWQp8KJnpy9DdFensyjdqZ+yY40VJlH8wcdLzC8PZnvHMFUTZUrDTkLyQaGus5X5LzpYAf3i+e/ZlhqGqWhh6Ou6xTR9Z6oi5AZZtp7Mj2EEm8oSpxiYZCHU/1fbGdNNNRRoZMhmilEb2gqHOEJDtXkHK/JnG6IrvbPCwV3NhONVdS1thBMs1T4QOBcTWa2IzhMk2nW5Kyn9tXUtpv9RsG2msxk+ZsQzRQacJncpgke0+T8y5Fzj8BiGo7XlJjaTIlpQs7KFjpqGnKuoyEPeIKnFMkZHvopgh81ySxNFWvJWcKRs70j2FOT012IllEEO1n4pD1513Yg2ssQPOThOkvyrqHUdEXOSEsihmBbTbKX1kLBPWqWkLOqJbjB3GBIZmoa8qWl4CG/iZ7oiA72ZL7TJNeZUY7kFQftDcHHluBzRbCegzMtrRjVQpX2lgoPKKLJAkcbMl01XK2p7yhL8pCBbQ3BN2avJgKvttcrWDK3CiUOVxQ8ZP+pqXKyIxnmBymCg5vJjNfkPK4+c8cIfK8ocVt7kmfd/I5SR1hKvCzUtb+lhgc00ZaO6CyhIQP1Uv4yIZjload72PXX0OIJvnFU+0Zf6MhsJwTfW0r0UwQfW4LNLZl5HK261JCZ4qnBaAreVAS3WrjV0LBnNDUNNDToCEeFfwgcb4gOEqLRhirWkexrCEYKVV711DLYEE1XBEsp5tpTGjorkomKYF9FDXv7fR3BGwbettSxnyL53MBPjsxDZjMh+VUW9NRxq1DhVk+FSxQcaGjV9Pawv6eGByw5qzoy7xk4RsOShqjJwWKe/1pEEfzkobeD/dQJmpqedcyBTy2sr4nGNRH0c0SPWTLrqAc0OQcb/gemKgqucQT7ySWKCn2EUotoCvpZct7RO2sy/QW0IWcXd7pQRQyZVwT2USRO87uhjioTLKV2brpMUcMQRbKH/N2T+UlTpaMls6cmc6CCNy3JdYYSUzzJQ4oSD3oKLncULOiJvjBEC2oqnCJkJluCYy2ZQ5so9YYlZ1VLlQU1mXEW1jZERwj/MUSRc24TdexlqLKfQBtDTScJUV8FszXBEY5ktpD5Ur9hYB4Nb1iikw3JoYpkKX+RodRKFt53MMuRnKSpY31PwYaGaILh3wxJGz9TkTPEETxoCWZrgvOlmyMzxFEwVJE5xZKzvyJ4WxEc16Gd4Xe3Weq4XH2jKRikqOkGQ87hQnC7wBmGYLAnesX3M+S87eFATauuN+Qcrh7xIxXJbUIdMw3JGE3ylCWzrieaqCn4zhGM19TQ3z1oH1AX+pWEqIc7wNGAkULBo/ZxRaV9NNyh4Br3rCHZzbzmSfawBL0dNRwpW1kK9mxPXR9povcdrGSZK9c2k0xwFGzjuniCtRSZCZ6ccZ7gaktmgAOtKbG/JnOkJrjcQTdFMsxRQ2cLY3WTIrlCw1eWKn8R6pvt4GFDso3QoL4a3nLk3G6JrtME3dSenpx7PNFTmga0EaJTLQ061sEeQoWXhSo9LTXsaSjoJQRXeZLtDclbCrYzfzHHeaKjHCVOUkQHO3JeEepr56mhiyaYYKjjNU+Fed1wS5VlhWSqI/hYUdDOkaxiKehoyOnrCV5yBHtbWFqTHCCwtpDcYolesVR5yUzTZBb3RNMd0d6WP+SvhuBmRcGxnuQzT95IC285cr41cLGQ6aJJhmi4TMGempxeimBRQw1tFKV+8jd6KuzoSTqqDxzRtpZkurvKEHxlqXKRIjjfUNNXQsNOsRScoWFLT+YeRZVD3GRN0MdQcKqQjHDMrdGGVu3iYJpQx3WGUvfbmxwFfR20WBq0oYY7LMFhhgYtr8jpaEnaOzjawWWaTP8mMr0t/EPDPoqcnxTBI5o58L7uoWnMrpoqPwgVrlAUWE+V+TQl9rawoyP6QGAlQw2TPRX+YSkxyBC8Z6jhHkXBgQL7WII3DVFnRfCrBfxewv9D6xsyjys4VkhWb9pUU627JllV0YDNHMku/ldNMMXDEo4aFnAkk4U6frNEU4XgZUPmEKHUl44KrzmYamjAbh0JFvGnaTLPu1s9jPCwjFpYiN7z1DTOk/nc07CfDFzmCf7i+bfNHXhDtLeBXzTBT5rkMvWOIxpl4EMh2LGJBu2syDnAEx2naEhHDWMMzPZEhygyS1mS5RTJr5ZkoKbEUoYqr2kqdDUE8ztK7OaIntJkFrIECwv8LJTaVx5XJE86go8dFeZ3FN3rjabCAYpoYEeC9zzJVULBbmZhDyd7ko09ydpNZ3nm2Kee4FPPXHnYEF1nqOFEC08LUVcDvYXkJHW8gTaKCk9YGOeIJhqiE4ToPEepdp7IWFjdwnWaufGMwJJCMtUTTBBK9BGCOy2tGGrJTHIwyEOzp6aPzNMOtlZkDvcEWpP5SVNhfkvDxhmSazTJXYrM9U1E0xwFVwqZQwzJxw6+kGGGUj2FglGGmnb1/G51udRSMNlTw6GGnCcUwVcOpmsqTHa06o72sw1RL02p9z0VbnMLOaIX3QKaYKSCFQzBKEUNHTSc48k53RH9wxGMtpQa5KjjW0W0n6XCCCG4yxNNdhQ4R4l1Ff+2sSd6UFHiIEOyqqFgT01mEUMD+joy75jPhOA+oVVLm309FR4yVOlp4RhLiScNmSmaYF5Pw0STrOIoWMSR2UkRXOMp+M4SHW8o8Zoi6OZgjKOaFar8zZDzkWzvKOjkKBjmCXby8JahhjXULY4KlzgKLvAwxVGhvyd4zxB1d9T0piazmKLCVZY5sKiD0y2ZSYrkUEPUbIk+dlQ4SJHTR50k1DPaUWIdTZW9NJwnJMOECgd7ou/MnppMJ02O1VT4Wsh85MnZzcFTngpXGKo84qmwgKbCL/orR/SzJ2crA+t6Mp94KvxJUeIbT3CQu1uIdlQEOzlKfS3UMcrTiFmOuroocrZrT2AcmamOKg8YomeEKm/rlT2sociMaybaUlFhuqHCM2qIJ+rg4EcDFymiDSxzaHdPcpE62pD5kyM5SBMoA1PaUtfIthS85ig1VPiPPYXgYEMNk4Qq7TXBgo7oT57gPUdwgCHzhIVFPFU6OYJzHAX9m5oNrVjeE61miDrqQ4VSa1oiURTsKHC0IfjNwU2WzK6eqK8jWln4g15TVBnqmDteCJ501PGAocJhhqjZdtBEB6lnhLreFJKxmlKbeGrqLiSThVIbCdGzloasa6lpMQXHCME2boLpJgT7yWaemu6wBONbqGNVRS0PKIL7LckbjmQtR7K8I5qtqel+T/ChJTNIKLjdUMNIRyvOEko9YYl2cwQveBikCNawJKcLBbc7+JM92mysNvd/Fqp8a0k6CNEe7cnZrxlW0wQXaXjaktnRwNOGZKYiONwS7a1JVheq3WgJHlQUGKHKmp4KAxXR/ULURcNgoa4zhKSLpZR3kxRRb0NmD0OFn+UCS7CzI1nbP6+o4x47QZE5xRCt3ZagnYcvmpYQktXdk5YKXTzBC57kKEe0VVuiSYqapssMS3C9p2CKkHOg8B8Pa8p5atrIw3qezIWanMGa5HRDNF6RM9wcacl0N+Q8Z8hsIkSnaIIdHRUOEebAPy1zbCkhM062FCJtif7PU+UtoVXzWKqM1PxXO8cfdruhFQ/a6x3JKYagvVDhQEtNiyiiSQ7OsuRsZUku0CRNDs4Sog6KKjsZgk2bYJqijgsEenoKeniinRXBn/U3lgpPdyDZynQx8IiioMnCep5Ky8mjGs6Wty0l1hUQTcNWswS3WRp2kCNZwJG8omG8JphPUaFbC8lEfabwP7VtM9yoaNCAjpR41VNhrD9LkbN722v0CoZMByFzhaW+MyzRYEWFDQwN2M4/JiT76PuljT3VU/A36eaIThb+R9oZGOAJ9tewkgGvqOMNRWYjT/Cwu99Q8LqDE4TgbLWxJ1jaDDAERsFOFrobgjUsBScaguXU8kKm2RL19tRypSHnHNlHiIZqgufs4opgQdVdwxBNNFBR6kVFqb8ogimOzB6a6HTzrlDHEpYaxjiiA4TMQobkDg2vejjfwJGWmnbVFAw3H3hq2NyQfG7hz4aC+w3BbwbesG0swYayvpAs6++Ri1Vfzx93mFChvyN5xVHTS+0p9aqCAxyZ6ZacZyw5+7uuQkFPR9DDk9NOiE7X1PCYJVjVUqq7JlrHwWALF5nfHNGjApdpqgzx5OwilDhCiDYTgnc9waGW4BdLNNUQvOtpzDOWHDH8D7TR/A/85KljEQu3NREc4Pl/6B1Hhc8Umb5CsKMmGC9EPcxoT2amwHNCmeOEnOPbklnMkbOgIvO5UMOpQrS9UGVdt6iH/fURjhI/WOpaW9OKLYRod6HCUEdOX000wpDZQ6hwg6LgZfOqo1RfT/CrJzjekXOGhpc1VW71ZLbXyyp+93ILbC1kPtIEYx0FIx1VDrLoVzXRKRYWk809yYlC9ImcrinxtabKnzRJk3lAU1OLEN1j2zrYzr2myHRXJFf4h4QKT1qSTzTB5+ZNTzTRkAxX8FcLV2uS8eoQQ2aAkFzvCM72sJIcJET3WPjRk5wi32uSS9rfZajpWEvj9hW42F4o5NytSXYy8IKHay10VYdrcl4SkqscrXpMwyGOgtkajheSxdQqmpxP1L3t4R5PqasFnrQEjytq6qgp9Y09Qx9o4S1FzhUCn1kyHSzBWLemoSGvOqLNhZyBjmCaAUYpMgt4Ck7wBBMMwWKWgjsUwTaGVsxWC1mYoKiyqqeGKYqonSIRQ3KIkHO0pmAxTdBHkbOvfllfr+AA+7gnc50huVKYK393FOyg7rbPO/izI7hE4CnHHHnJ0ogNPRUGeUpsrZZTBJcrovUcJe51BPsr6GkJdhCCsZ6aTtMEb2pqWkqeVtDXE/QVggsU/Nl86d9RMF3DxvZTA58agu810RWawCiSzzXBeU3MMW9oyJUedvNEvQyNu1f10BSMddR1vaLCYpYa/mGocLSiYDcLbQz8aMn5iyF4xBNMs1P0QEOV7o5gaWGuzSeLue4tt3ro7y4Tgm4G/mopdZgl6q0o6KzJWE3mMksNr3r+a6CbT8g5wZNzT9O7fi/zpaOmnz3BRoqos+tv9zMbdpxsqDBOEewtJLt7cg5wtKKbvldpSzRRCD43VFheCI7yZLppggMVBS/KMAdHODJvOwq2NQSbKKKPLdFWQs7Fqo+mpl01JXYRgq8dnGLhTiFzqmWsUMdpllZdbKlyvSdYxhI9YghOtxR8LgSLWHK62mGGVoxzBE8LNWzqH9CUesQzFy5RQzTc56mhi6fgXEWwpKfE5Z7M05ZgZUPmo6auiv8YKzDYwWBLMErIbKHJvOwIrvEdhOBcQ9JdU1NHQ7CXn2XIDFBKU2WAgcX9UAUzDXWd5alwuyJ41Z9rjKLCL4aCp4WarhPm2rH+SaHUYE001JDZ2ZAzXPjdMpZWvC9wmqIB2lLhQ01D5jO06hghWMndbM7yRJMsoCj1vYbnFQVrW9jak3OlEJ3s/96+p33dEPRV5GxiqaGjIthUU6FFEZyqCa5qJrpBdzSw95IUnOPIrCUUjRZQFrbw5PR0R1qiYx3cb6nrWUMrBmmiBQxVHtTew5ICP/ip6g4hed/Akob/32wvBHsIOX83cI8hGeNeNPCIkPmXe8fPKx84OMSRM1MTdXSwjCZ4S30jVGhvqTRak/OVhgGazHuOCud5onEO1lJr6ecVyaOK6H7zqlBlIaHE0oroCgfvGJIdPcmfLNGLjpz7hZwZQpUbFME0A1cIJa7VNORkgfsMBatbKgwwJM9bSvQXeNOvbIjelg6WWvo5kvbKaJJNHexkKNHL9xRyFlH8Ti2riB5wVPhUk7nGkJnoCe428LR/wRGdYIlmWebCyxou1rCk4g/ShugBDX0V0ZQWkh0dOVsagkM0yV6OoLd5ye+pRlsCr0n+KiQrGuq5yJDzrTAXHtLUMduTDBVKrSm3eHL+6ijxhFDX9Z5gVU/wliHYTMiMFpKLNMEywu80wd3meoFmt6VbRMPenhrOc6DVe4pgXU8DnnHakLOIIrlF4FZPIw6R+zxBP0dyq6OOZ4Q5sLKCcz084ok+VsMMyQhNZmmBgX5xIXOEJTmi7VsGTvMTNdHHhpzdbE8Du2oKxgvBqQKdDDnTFOylCFaxR1syz2iqrOI/FEpNc3C6f11/7+ASS6l2inq2ciTrCCzgyemrCL5SVPjQkdPZUmGy2c9Sw9FtR1sS30RmsKPCS4rkIC/2U0MduwucYolGaPjKEyhzmiPYXagyWbYz8LWBDdzRimAXzxx4z8K9hpzlhLq+NiQ97HuKorMUfK/OVvC2JfiHUPCQI/q7J2gjK+tTDNxkCc4TMssqCs4TGtLVwQihyoAWgj9bosU80XGW6Ac9TJGziaUh5+hnFcHOnlaM1iRn29NaqGENTTTSUHCH2tWTeV0osUhH6psuVLjRUmGWhm6OZEshGeNowABHcJ2Bpy2ZszRcKkRXd2QuKVEeXnbfaEq825FguqfgfE2whlChSRMdron+LATTPQ2Z369t4B9C5gs/ylzv+CMmepIDPclFQl13W0rspPd1JOcbghGOEutqCv5qacURQl3dDKyvyJlqKXGPgcM9FfawJAMVmdcspcYKOZc4GjDYkFlK05olNMHyHn4zFNykyOxt99RkHlfwmiHo60l2EKI+mhreEKp080Tbug08BVPcgoqC5zWt+NLDTZ7oNSF51N1qie7Va3uCCwyZbkINf/NED6jzOsBdZjFN8oqG3wxVunqCSYYKf3EdhJyf9YWGf7tRU2oH3VHgPr1fe5J9hOgHd7xQ0y7qBwXr23aGErP0cm64JVjZwsOGqL+mhNgZmhJLW2oY4UhedsyBgzrCKrq7BmcpNVhR6jBPq64Vgi+kn6XE68pp8J5/+0wRHGOpsKenQn9DZntPzjRLZpDAdD2fnSgkG9tmIXnUwQ6WVighs7Yi2MxQ0N3CqYaCXkJ0oyOztMDJjmSSpcpvlrk0RMMOjmArQ04PRV1DO1FwhCVaUVPpKUM03JK5SxPsIWRu8/CGHi8UHChiqGFDTbSRJWeYUDDcH6vJWUxR4k1FXbMUwV6e4AJFXS8oMqsZKqzvYQ9DDQdZckY4aGsIhtlubbd2r3j4QBMoTamdPZk7O/Bf62lacZwneNjQoGcdVU7zJOd7ghsUHOkosagic6cnWc8+4gg285R6zZP5s1/LUbCKIznTwK36PkdwlOrl4U1LwfdCCa+IrvFkmgw1PCAUXKWo0sURXWcI2muKJlgyFzhynCY4RBOsqCjoI1R5zREco0n2Vt09BQtYSizgKNHfUmUrQ5UOCh51BFcLmY7umhYqXKQomOop8bUnWNNQcIiBcYaC6xzMNOS8JQQfeqKBmmglB+97ok/lfk3ygaHSyZaCRTzRxQo6GzLfa2jWBPepw+UmT7SQEJyiyRkhBLMVOfcoMjcK0eZChfUNzFAUzCsEN5vP/X1uP/n/aoMX+K+nw/Hjr/9xOo7j7Pju61tLcgvJpTWXNbfN5jLpi6VfCOviTktKlFusQixdEKWmEBUKNaIpjZRSSOXSgzaaKLdabrm1/9nZ+/f+vd/vz/v9+Xy+zZ7PRorYoZqyLrCwQdEAixxVOEXNNnjX2nUSRlkqGmWowk8lxR50JPy9Bo6qJXaXwNvREBvnThPEPrewryLhcAnj5WE15Fqi8W7R1sAuEu86S4ENikItFN4xkv9Af4nXSnUVcLiA9xzesFpivRRVeFKtsMRaKBhuSbjOELnAUtlSQUpXgdfB4Z1oSbnFEetbQ0IrAe+Y+pqnDcEJFj6S8LDZzZHwY4e3XONNlARraomNEt2bkvGsosA3ioyHm+6jCMbI59wqt4eeara28IzEmyPgoRaUOEDhTVdEJhmCoTWfC0p8aNkCp0oYqih2iqGi4yXeMkOsn4LdLLnmKfh/YogjNsPebeFGR4m9BJHLzB61XQ3BtpISfS2FugsK9FAtLWX1dCRcrCnUp44CNzuCowUZmxSRgYaE6Za0W2u/E7CVXCiI/UOR8aAm1+OSyE3mOUcwyc1zBBeoX1kiKy0Zfxck1Gsyulti11i83QTBF5Kg3pDQThFMVHiPSlK+0cSedng/VaS8bOZbtsBcTcZAR8JP5KeqQ1OYKAi20njdNNRpgnsU//K+JnaXJaGTomr7aYIphoRn9aeShJWKEq9LcozSF7QleEfDI5LYm5bgVkFkRwVDBCVu0DDIkGupo8TZBq+/pMQURYErJQmPKGKjNDkWOLx7Jd5QizdUweIaKrlP7SwJDhZvONjLkOsBBX9UpGxnydhXkfBLQ8IxgojQbLFnJf81JytSljclYYyEFyx0kVBvKWOFJmONpshGAcsduQY5giVNCV51eOdJYo/pLhbvM0uDHSevNKRcrKZIqnCtJeEsO95RoqcgGK4ocZcho1tTYtcZvH41pNQ7vA0WrhIfOSraIIntIAi+NXWCErdbkvrWwjRLrt0NKUdL6KSOscTOdMSOUtBHwL6OLA0vNSdynaWQEnCpIvKaIrJJEbvHkmuNhn6OjM8VkSGSqn1uYJCGHnq9I3aLhNME3t6GjIkO7xrNFumpyTNX/NrwX7CrIRiqqWijI9JO4d1iieykyfiposQIQ8YjjsjlBh6oHWbwRjgYJQn2NgSnNycmJAk3NiXhx44Sxykihxm8ybUwT1OVKySc7vi3OXVkdBJ4AyXBeksDXG0IhgtYY0lY5ahCD0ehborIk5aUWRJviMA7Xt5kyRjonrXENkm8yYqgs8VzgrJmClK20uMM3jRJ0FiQICQF9hdETlLQWRIb5ki6WDfWRPobvO6a4GP5mcOrNzDFELtTkONLh9dXE8xypEg7z8A9jkhrQ6Fhjlg/QVktJXxt4WXzT/03Q8IaQWSqIuEvloQ2mqC9Jfi7wRul4RX3pSPlzpoVlmCtI2jvKHCFhjcM3sN6lqF6HxnKelLjXWbwrpR4xzuCrTUZx2qq9oAh8p6ixCUGr78g8oyjRAtB5CZFwi80VerVpI0h+IeBxa6Zg6kWvpDHaioYYuEsRbDC3eOmC2JvGYLeioxGknL2UATNJN6hmtj1DlpLvDVmocYbrGCVJKOrg4X6DgddLA203BKMFngdJJFtFd7vJLm6KEpc5yjQrkk7M80SGe34X24nSex1Ra5Omgb71JKyg8SrU3i/kARKwWpH0kOGhKkObyfd0ZGjvyXlAkVZ4xRbYJ2irFMkFY1SwyWxr2oo4zlNiV+7zmaweFpT4kR3kaDAFW6xpSqzJay05FtYR4HmZhc9UxKbbfF2V8RG1MBmSaE+kmC6JnaRXK9gsiXhJHl/U0qM0WTcbyhwkYIvFGwjSbjfwhiJt8ZSQU+Bd5+marPMOkVkD0muxYLIfEuhh60x/J92itguihJSEMySVPQnTewnEm+620rTQEMsOfo4/kP/0ARvWjitlpSX7GxBgcMEsd3EEeYWvdytd+Saawi6aCIj1CkGb6Aj9rwhx16Cf3vAwFy5pyLhVonXzy51FDpdEblbkdJbUcEPDEFzQ8qNmhzzLTmmKWKbFCXeEuRabp6rxbvAtLF442QjQ+wEA9eL1xSR7Q0JXzlSHjJ4exq89yR0laScJ/FW6z4a73pFMEfDiRZvuvijIt86RaSFOl01riV2mD1UEvxGk/Geg5aWwGki1zgKPG9J2U8PEg8qYvMsZeytiTRXBMslCU8JSlxi8EabjwUldlDNLfzTUmCgxWsjqWCOHavYAqsknKFIO0yQ61VL5AVFxk6WhEaCAkdJgt9aSkzXlKNX2jEa79waYuc7gq0N3GDJGCBhoiTXUEPsdknCUE1CK0fwsiaylSF2uiDyO4XX3pFhNd7R4itFGc0k/ElBZwWvq+GC6szVeEoS/MZ+qylwpKNKv9Z469UOjqCjwlusicyTxG6VpNxcQ8IncoR4RhLbR+NdpGGmJWOcIzJGUuKPGpQg8rrG21dOMqQssJQ4RxH5jaUqnZuQ0F4Q+cjxLwPtpZbIAk3QTJHQWBE5S1BokoVtDd6lhqr9UpHSUxMcIYl9pojsb8h4SBOsMQcqvOWC2E8EVehqiJ1hrrAEbQxeK0NGZ0Gkq+guSRgniM23bIHVkqwx4hiHd7smaOyglyIyQuM978j4VS08J/A2G1KeMBRo4fBaSNhKUEZfQewVQ/C1I+MgfbEleEzCUw7mKXI0M3hd1EESVji8x5uQ41nxs1q4RMJCCXs7Iq9acpxn22oSDnQ/sJTxsCbHIYZiLyhY05TY0ZLIOQrGaSJDDN4t8pVaIrsqqFdEegtizc1iTew5Q4ayBDMUsQMkXocaYkc0hZua412siZ1rSXlR460zRJ5SlHGe5j801RLMlJTxtaOM3Q1pvxJ45zUlWFD7rsAbpfEm1JHxG0eh8w2R7QQVzBUw28FhFp5QZzq8t2rx2joqulYTWSuJdTYfWwqMFMcovFmSyJPNyLhE4E10pHzYjOC3huArRa571ZsGajQpQx38SBP5pyZB6lMU3khDnp0MBV51BE9o2E+TY5Ml2E8S7C0o6w1xvCZjf0HkVEHCzFoyNmqC+9wdcqN+Tp7jSDheE9ws8Y5V0NJCn2bk2tqSY4okdrEhx1iDN8cSudwepWmAGXKcJXK65H9to8jYQRH7SBF01ESUJdd0TayVInaWhLkOjlXE5irKGOnI6GSWGCJa482zBI9rCr0jyTVcEuzriC1vcr6mwFGSiqy5zMwxBH/TJHwjSPhL8+01kaaSUuMFKTcLEvaUePcrSmwn8DZrgikWb7CGPxkSjhQwrRk57tctmxLsb9sZvL9LSlyuSLlWkqOjwduo8b6Uv1DkmudIeFF2dHCgxVtk8dpIvHpBxhEOdhKk7OLIUSdJ+cSRY57B+0DgGUUlNfpthTfGkauzxrvTsUUaCVhlKeteTXCoJDCa2NOKhOmC4G1H8JBd4OBZReSRGkqcb/CO1PyLJTLB4j1q8JYaIutEjSLX8YKM+a6phdMsdLFUoV5RTm9JSkuDN8WcIon0NZMNZWh1q8C7SJEwV5HxrmnnTrf3KoJBlmCYI2ilSLlfEvlE4011NNgjgthzEua0oKK7JLE7HZHlEl60BLMVFewg4EWNt0ThrVNEVkkiTwpKXSWJzdRENgvKGq4IhjsiezgSFtsfCUq8qki5S1LRQeYQQ4nemmCkImWMw3tFUoUBZk4NOeZYEp4XRKTGa6wJjrWNHBVJR4m3FCnbuD6aak2WsMTh3SZImGCIPKNgsDpVwnsa70K31lCFJZYcwwSMFcQulGTsZuEaSdBXkPGZhu0FsdUO73RHjq8MPGGIfaGIbVTk6iuI3GFgucHrIQkmWSJdBd7BBu+uOryWAhY7+Lki9rK5wtEQzWwvtbqGhIMFwWRJsElsY4m9IIg9L6lCX0VklaPAYkfkZEGDnOWowlBJjtMUkcGK4Lg6EtoZInMUBVYLgn0UsdmCyCz7gIGHFfk+k1QwTh5We7A9x+IdJ6CvIkEagms0hR50eH9UnTQJ+2oiKyVlLFUE+8gBGu8MQ3CppUHesnjTHN4QB/UGPhCTHLFPHMFrCqa73gqObUJGa03wgbhHkrCfpEpzNLE7JDS25FMKhlhKKWKfCgqstLCPu1zBXy0J2ztwjtixBu8UTRn9LVtkmCN2iyFhtME70JHRQ1KVZXqKI/KNIKYMCYs1GUMEKbM1bKOI9LDXC7zbHS+bt+1MTWS9odA9DtrYtpbImQJ2VHh/lisEwaHqUk1kjKTAKknkBEXkbkdMGwq0dnhzLJF3NJH3JVwrqOB4Sca2hti75nmJN0WzxS6UxDYoEpxpa4htVlRjkYE7DZGzJVU72uC9IyhQL4i8YfGWSYLLNcHXloyz7QhNifmKSE9JgfGmuyLhc403Xm9vqcp6gXe3xuuv8F6VJNxkyTHEkHG2g0aKXL0MsXc1bGfgas2//dCONXiNLCX+5mB7eZIl1kHh7ajwpikyzlUUWOVOsjSQlsS+M0R+pPje/dzBXRZGO0rMtgQrLLG9VSu9n6CMXS3BhwYmSoIBhsjNBmZbgusE9BCPCP5triU4VhNbJfE+swSP27aayE8tuTpYYjtrYjMVGZdp2NpS1s6aBnKSHDsbKuplKbHM4a0wMFd/5/DmGyKrJSUaW4IBrqUhx0vyfzTBBLPIUcnZdrAkNsKR0sWRspumSns6Ch0v/qqIbBYUWKvPU/CFoyrDJGwSNFhbA/MlzKqjrO80hRbpKx0Jewsi/STftwGSlKc1JZyAzx05dhLEdnfQvhZOqiHWWEAHC7+30FuRcZUgaO5gpaIK+xsiHRUsqaPElTV40xQZQ107Q9BZE1nryDVGU9ZSQ47bmhBpLcYpUt7S+xuK/FiT8qKjwXYw5ypS2iuCv7q1gtgjhuBuB8LCFY5cUuCNtsQOFcT+4Ih9JX+k8Ea6v0iCIRZOtCT0Et00JW5UeC85Cg0ScK0k411HcG1zKtre3SeITBRk7WfwDhEvaYLTHP9le0m8By0JDwn4TlLW/aJOvGHxdjYUes+ScZigCkYQdNdEOhkiezgShqkx8ueKjI8lDfK2oNiOFvrZH1hS+tk7NV7nOmLHicGWEgubkXKdwdtZknCLJXaCpkrjZBtLZFsDP9CdxWsSr05Sxl6CMmoFbCOgryX40uDtamB7SVmXW4Ihlgpmq+00tBKUUa83WbjLUNkzDmY7cow1JDygyPGlhgGKYKz4vcV7QBNbJIgM11TUqZaMdwTeSguH6rOaw1JRKzaaGyxVm2EJ/uCIrVWUcZUkcp2grMsEjK+DMwS59jQk3Kd6SEq1d0S6uVmO4Bc1lDXTUcHjluCXEq+1OlBDj1pi9zgiXxnKuE0SqTXwhqbETW6RggMEnGl/q49UT2iCzgJvRwVXS2K/d6+ZkyUl7jawSVLit46EwxVljDZwoSQ20sDBihztHfk2yA8NVZghiXwrYHQdfKAOtzsayjhY9bY0yE2CWEeJ9xfzO423xhL5syS2TFJofO2pboHob0nY4GiAgRrvGQEDa/FWSsoaaYl0syRsEt3kWoH3B01shCXhTUWe9w3Bt44SC9QCh3eShQctwbaK2ApLroGCMlZrYqvlY3qYhM0aXpFkPOuoqJ3Dm6fxXrGwVF9gCWZagjPqznfkuMKQ8DPTQRO8ZqG1hPGKEm9IgpGW4DZDgTNriTxvFiq+Lz+0cKfp4wj6OCK9JSnzNSn9LFU7UhKZZMnYwcJ8s8yRsECScK4j5UOB95HFO0CzhY4xJxuCix0lDlEUeMdS6EZBkTsUkZ4K74dugyTXS7aNgL8aqjDfkCE0ZbwkCXpaWCKhl8P7VD5jxykivSyxyZrYERbe168LYu9ZYh86IkscgVLE7tWPKmJv11CgoyJltMEbrohtVAQfO4ImltiHEroYEs7RxAarVpY8AwXMcMReFOTYWe5iiLRQxJ5Q8DtJ8LQhWOhIeFESPGsILhbNDRljNbHzNRlTFbk2S3L0NOS6V1KFJYKUbSTcIIhM0wQ/s2TM0SRMNcQmSap3jCH4yhJZKSkwyRHpYYgsFeQ4U7xoCB7VVOExhXepo9ABBsYbvGWKXPME3lyH95YioZ0gssQRWWbI+FaSMkXijZXwgiTlYdPdkNLaETxlyDVIwqeaEus0aTcYcg0RVOkpR3CSJqIddK+90JCxzsDVloyrFd5ZAr4TBKfaWa6boEA7C7s6EpYaeFPjveooY72mjIccLHJ9HUwVlDhKkmutJDJBwnp1rvulJZggKDRfbXAkvC/4l3ozQOG9a8lxjx0i7nV4jSXc7vhe3OwIxjgSHjdEhhsif9YkPGlus3iLFDnWOFhtCZbJg0UbQcIaR67JjthoCyMEZRwhiXWyxO5QxI6w5NhT4U1WsJvDO60J34fW9hwzwlKij6ZAW9ne4L0s8C6XeBMEkd/LQy1VucBRot6QMlbivaBhoBgjqGiCJNhsqVp/S2SsG6DIONCR0dXhvWbJ+MRRZJkkuEjgDXJjFQW6SSL7GXK8Z2CZg7cVsbWGoKmEpzQ5elpiy8Ryg7dMkLLUEauzeO86CuwlSOlgYLojZWeJ9xM3S1PWfEfKl5ISLQ0MEKR8YOB2QfCxJBjrKPCN4f9MkaSsqoVXJBmP7EpFZ9UQfOoOFwSzBN4MQ8LsGrymlipcJQhmy0GaQjPqCHaXRwuCZwRbqK2Fg9wlClZqYicrIgMdZfxTQ0c7TBIbrChxmuzoKG8XRaSrIhhiyNFJkrC7oIAWMEOQa5aBekPCRknCo4IKPrYkvCDI8aYmY7WFtprgekcJZ3oLIqssCSMtFbQTJKwXYy3BY5oCh2iKPCpJOE+zRdpYgi6O2KmOAgvVCYaU4ySRek1sgyFhJ403QFHiVEmJHwtybO1gs8Hr5+BETQX3War0qZngYGgtVZtoqd6vFSk/UwdZElYqyjrF4HXUeFspIi9IGKf4j92pKGAdCYMVsbcV3kRF0N+R8LUd5PCsIGWoxDtBkCI0nKofdJQxT+LtZflvuc8Q3CjwWkq8KwUpHzkK/NmSsclCL0nseQdj5FRH5CNHSgtLiW80Of5HU9Hhlsga9bnBq3fEVltKfO5IaSTmGjjc4J0otcP7QsJUSQM8pEj5/wCuUuC2DWz8AAAAAElFTkSuQmCC");
}

.ace-ambiance .ace_indent-guide {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNQUFD4z6Crq/sfAAuYAuYl+7lfAAAAAElFTkSuQmCC") right repeat-y;
}

.ace-ambiance .ace_indent-guide-active {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;
}
`;
    });
    ace.define("ace/theme/ambiance", ["require", "exports", "module", "ace/theme/ambiance-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-ambiance";
      exports2.cssText = require3("./ambiance-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/ambiance"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-chaos.js
var require_theme_chaos = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-chaos.js"(exports, module2) {
    ace.define("ace/theme/chaos-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-chaos .ace_gutter {\n  background: #141414;\n  color: #595959;\n  border-right: 1px solid #282828;\n}\n.ace-chaos .ace_gutter-cell.ace_warning {\n  background-image: none;\n  background: #FC0;\n  border-left: none;\n  padding-left: 0;\n  color: #000;\n}\n.ace-chaos .ace_gutter-cell.ace_error {\n  background-position: -6px center;\n  background-image: none;\n  background: #F10;\n  border-left: none;\n  padding-left: 0;\n  color: #000;\n}\n.ace-chaos .ace_print-margin {\n  border-left: 1px solid #555;\n  right: 0;\n  background: #1D1D1D;\n}\n.ace-chaos {\n  background-color: #161616;\n  color: #E6E1DC;\n}\n\n.ace-chaos .ace_cursor {\n  border-left: 2px solid #FFFFFF;\n}\n.ace-chaos .ace_cursor.ace_overwrite {\n  border-left: 0px;\n  border-bottom: 1px solid #FFFFFF;\n}\n.ace-chaos .ace_marker-layer .ace_selection {\n  background: #494836;\n}\n.ace-chaos .ace_marker-layer .ace_step {\n  background: rgb(198, 219, 174);\n}\n.ace-chaos .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #FCE94F;\n}\n.ace-chaos .ace_marker-layer .ace_active-line {\n  background: #333;\n}\n.ace-chaos .ace_gutter-active-line {\n  background-color: #222;\n}\n.ace-chaos .ace_invisible {\n  color: #404040;\n}\n.ace-chaos .ace_keyword {\n  color:#00698F;\n}\n.ace-chaos .ace_keyword.ace_operator {\n  color:#FF308F;\n}\n.ace-chaos .ace_constant {\n  color:#1EDAFB;\n}\n.ace-chaos .ace_constant.ace_language {\n  color:#FDC251;\n}\n.ace-chaos .ace_constant.ace_library {\n  color:#8DFF0A;\n}\n.ace-chaos .ace_constant.ace_numeric {\n  color:#58C554;\n}\n.ace-chaos .ace_invalid {\n  color:#FFFFFF;\n  background-color:#990000;\n}\n.ace-chaos .ace_invalid.ace_deprecated {\n  color:#FFFFFF;\n  background-color:#990000;\n}\n.ace-chaos .ace_support {\n  color: #999;\n}\n.ace-chaos .ace_support.ace_function {\n  color:#00AEEF;\n}\n.ace-chaos .ace_function {\n  color:#00AEEF;\n}\n.ace-chaos .ace_string {\n  color:#58C554;\n}\n.ace-chaos .ace_comment {\n  color:#555;\n  font-style:italic;\n  padding-bottom: 0px;\n}\n.ace-chaos .ace_variable {\n  color:#997744;\n}\n.ace-chaos .ace_meta.ace_tag {\n  color:#BE53E6;\n}\n.ace-chaos .ace_entity.ace_other.ace_attribute-name {\n  color:#FFFF89;\n}\n.ace-chaos .ace_markup.ace_underline {\n  text-decoration: underline;\n}\n.ace-chaos .ace_fold-widget {\n  text-align: center;\n}\n\n.ace-chaos .ace_fold-widget:hover {\n  color: #777;\n}\n\n.ace-chaos .ace_fold-widget.ace_start,\n.ace-chaos .ace_fold-widget.ace_end,\n.ace-chaos .ace_fold-widget.ace_closed{\n  background: none !important;\n  border: none;\n  box-shadow: none;\n}\n\n.ace-chaos .ace_fold-widget.ace_start:after {\n  content: '\u25BE'\n}\n\n.ace-chaos .ace_fold-widget.ace_end:after {\n  content: '\u25B4'\n}\n\n.ace-chaos .ace_fold-widget.ace_closed:after {\n  content: '\u2023'\n}\n\n.ace-chaos .ace_indent-guide {\n  border-right:1px dotted #333333;\n  margin-right:-1px;\n}\n\n.ace-chaos .ace_indent-guide-active {\n  border-right:1px dotted #afafaf;\n  margin-right:-1px;\n}\n\n.ace-chaos .ace_fold { \n  background: #222; \n  border-radius: 3px; \n  color: #7AF; \n  border: none; \n}\n.ace-chaos .ace_fold:hover {\n  background: #CCC; \n  color: #000;\n}\n";
    });
    ace.define("ace/theme/chaos", ["require", "exports", "module", "ace/theme/chaos-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-chaos";
      exports2.cssText = require3("./chaos-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/chaos"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-cloud9_night.js
var require_theme_cloud9_night = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-cloud9_night.js"(exports, module2) {
    ace.define("ace/theme/cloud9_night-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-cloud9-night .ace_gutter {\n    background: #303130;\n    color: #eee\n}\n\n.ace-cloud9-night .ace_print-margin {\n    width: 1px;\n    background: #222\n}\n\n.ace-cloud9-night {\n    background-color: #181818;\n    color: #EBEBEB\n}\n\n.ace-cloud9-night .ace_cursor {\n    color: #9F9F9F\n}\n\n.ace-cloud9-night .ace_marker-layer .ace_selection {\n    background: #424242\n}\n\n.ace-cloud9-night.ace_multiselect .ace_selection.ace_start {\n    box-shadow: 0 0 3px 0px #000000;\n    border-radius: 2px\n}\n\n.ace-cloud9-night .ace_marker-layer .ace_step {\n    background: rgb(102, 82, 0)\n}\n\n.ace-cloud9-night .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid #888888\n}\n\n.ace-cloud9-night .ace_marker-layer .ace_highlight {\n    border: 1px solid rgb(110, 119, 0);\n    border-bottom: 0;\n    box-shadow: inset 0 -1px rgb(110, 119, 0);\n    margin: -1px 0 0 -1px;\n    background: rgba(255, 235, 0, 0.1);\n}\n\n.ace-cloud9-night .ace_marker-layer .ace_active-line {\n    background: #292929\n}\n\n.ace-cloud9-night .ace_gutter-active-line {\n    background-color: #3D3D3D\n}\n\n.ace-cloud9-night .ace_stack {\n    background-color: rgb(66, 90, 44)\n}\n\n.ace-cloud9-night .ace_marker-layer .ace_selected-word {\n    border: 1px solid #888888\n}\n\n.ace-cloud9-night .ace_invisible {\n    color: #343434\n}\n\n.ace-cloud9-night .ace_keyword,\n.ace-cloud9-night .ace_meta,\n.ace-cloud9-night .ace_storage,\n.ace-cloud9-night .ace_storage.ace_type,\n.ace-cloud9-night .ace_support.ace_type {\n    color: #C397D8\n}\n\n.ace-cloud9-night .ace_keyword.ace_operator {\n    color: #70C0B1\n}\n\n.ace-cloud9-night .ace_constant.ace_character,\n.ace-cloud9-night .ace_constant.ace_language,\n.ace-cloud9-night .ace_constant.ace_numeric,\n.ace-cloud9-night .ace_keyword.ace_other.ace_unit,\n.ace-cloud9-night .ace_support.ace_constant,\n.ace-cloud9-night .ace_variable.ace_parameter {\n    color: #E78C45\n}\n\n.ace-cloud9-night .ace_constant.ace_other {\n    color: #EEEEEE\n}\n\n.ace-cloud9-night .ace_invalid {\n    color: #CED2CF;\n    background-color: #DF5F5F\n}\n\n.ace-cloud9-night .ace_invalid.ace_deprecated {\n    color: #CED2CF;\n    background-color: #B798BF\n}\n\n.ace-cloud9-night .ace_fold {\n    background-color: #7AA6DA;\n    border-color: #DEDEDE\n}\n\n.ace-cloud9-night .ace_entity.ace_name.ace_function,\n.ace-cloud9-night .ace_support.ace_function,\n.ace-cloud9-night .ace_variable:not(.ace_parameter),\n.ace-cloud9-night .ace_constant:not(.ace_numeric) {\n    color: #7AA6DA\n}\n\n.ace-cloud9-night .ace_support.ace_class,\n.ace-cloud9-night .ace_support.ace_type {\n    color: #E7C547\n}\n\n.ace-cloud9-night .ace_heading,\n.ace-cloud9-night .ace_markup.ace_heading,\n.ace-cloud9-night .ace_string {\n    color: #B9CA4A\n}\n\n.ace-cloud9-night .ace_entity.ace_name.ace_tag,\n.ace-cloud9-night .ace_entity.ace_other.ace_attribute-name,\n.ace-cloud9-night .ace_meta.ace_tag,\n.ace-cloud9-night .ace_string.ace_regexp,\n.ace-cloud9-night .ace_variable {\n    color: #D54E53\n}\n\n.ace-cloud9-night .ace_comment {\n    color: #969896\n}\n\n.ace-cloud9-night .ace_c9searchresults.ace_keyword {\n    color: #C2C280;\n}\n\n.ace-cloud9-night .ace_indent-guide {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYFBXV/8PAAJoAXX4kT2EAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-cloud9-night .ace_indent-guide-active {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/cloud9_night", ["require", "exports", "module", "ace/theme/cloud9_night-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-cloud9-night";
      exports2.cssText = require3("./cloud9_night-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass);
    });
    (function() {
      ace.require(["ace/theme/cloud9_night"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-cloud9_night_low_color.js
var require_theme_cloud9_night_low_color = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-cloud9_night_low_color.js"(exports, module2) {
    ace.define("ace/theme/cloud9_night_low_color-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-cloud9-night-low-color .ace_gutter {\n    background: #303130;\n    color: #eee\n}\n\n.ace-cloud9-night-low-color .ace_print-margin {\n    width: 1px;\n    background: #222\n}\n\n.ace-cloud9-night-low-color {\n    background-color: #181818;\n    color: #EBEBEB\n}\n\n.ace-cloud9-night-low-color .ace_cursor {\n    color: #9F9F9F\n}\n\n.ace-cloud9-night-low-color .ace_marker-layer .ace_selection {\n    background: #424242\n}\n\n.ace-cloud9-night-low-color.ace_multiselect .ace_selection.ace_start {\n    box-shadow: 0 0 3px 0px #000000;\n    border-radius: 2px\n}\n\n.ace-cloud9-night-low-color .ace_marker-layer .ace_step {\n    background: rgb(102, 82, 0)\n}\n\n.ace-cloud9-night-low-color .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid #888888\n}\n\n.ace-cloud9-night-low-color .ace_marker-layer .ace_highlight {\n    border: 1px solid rgb(110, 119, 0);\n    border-bottom: 0;\n    box-shadow: inset 0 -1px rgb(110, 119, 0);\n    margin: -1px 0 0 -1px;\n    background: rgba(255, 235, 0, 0.1);\n}\n\n.ace-cloud9-night-low-color .ace_marker-layer .ace_active-line {\n    background: #292929\n}\n\n.ace-cloud9-night-low-color .ace_gutter-active-line {\n    background-color: #3D3D3D\n}\n\n.ace-cloud9-night-low-color .ace_stack {\n    background-color: rgb(66, 90, 44)\n}\n\n.ace-cloud9-night-low-color .ace_marker-layer .ace_selected-word {\n    border: 1px solid #888888\n}\n\n.ace-cloud9-night-low-color .ace_invisible {\n    color: #343434\n}\n\n.ace-cloud9-night-low-color .ace_keyword,\n.ace-cloud9-night-low-color .ace_meta,\n.ace-cloud9-night-low-color .ace_storage {\n    color: #C397D8\n}\n\n.ace-cloud9-night-low-color .ace_keyword.ace_operator {\n    color: #70C0B1\n}\n\n.ace-cloud9-night-low-color .ace_constant.ace_character,\n.ace-cloud9-night-low-color .ace_constant.ace_language,\n.ace-cloud9-night-low-color .ace_constant.ace_numeric,\n.ace-cloud9-night-low-color .ace_keyword.ace_other.ace_unit {\n    color: #DAA637\n}\n\n.ace-cloud9-night-low-color .ace_constant.ace_other {\n    color: #EEEEEE\n}\n\n.ace-cloud9-night-low-color .ace_invalid {\n    color: #CED2CF;\n    background-color: #DF5F5F\n}\n\n.ace-cloud9-night-low-color .ace_invalid.ace_deprecated {\n    color: #CED2CF;\n    background-color: #B798BF\n}\n\n.ace-cloud9-night-low-color .ace_fold {\n    background-color: #7AA6DA;\n    border-color: #DEDEDE\n}\n\n.ace-cloud9-night-low-color .ace_entity.ace_name.ace_function,\n.ace-cloud9-night-low-color .ace_support.ace_function,\n.ace-cloud9-night-low-color .ace_variable:not(.ace_parameter),\n.ace-cloud9-night-low-color .ace_constant:not(.ace_numeric) {\n    color: #7AA6DA\n}\n\n.ace-cloud9-night-low-color .ace_support.ace_class,\n.ace-cloud9-night-low-color .ace_support.ace_type {\n    color: #E7C547\n}\n\n.ace-cloud9-night-low-color .ace_heading,\n.ace-cloud9-night-low-color .ace_markup.ace_heading,\n.ace-cloud9-night-low-color .ace_string {\n    color: #B9CA4A\n}\n\n.ace-cloud9-night-low-color .ace_comment {\n    color: #969896\n}\n\n.ace-cloud9-night-low-color .ace_c9searchresults.ace_keyword {\n    color: #C2C280;\n}\n\n.ace-cloud9-night-low-color .ace_indent-guide {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYFBXV/8PAAJoAXX4kT2EAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-cloud9-night-low-color .ace_indent-guide-active {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/cloud9_night_low_color", ["require", "exports", "module", "ace/theme/cloud9_night_low_color-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-cloud9-night-low-color";
      exports2.cssText = require3("./cloud9_night_low_color-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass);
    });
    (function() {
      ace.require(["ace/theme/cloud9_night_low_color"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-clouds_midnight.js
var require_theme_clouds_midnight = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-clouds_midnight.js"(exports, module2) {
    ace.define("ace/theme/clouds_midnight-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-clouds-midnight .ace_gutter {\n  background: #232323;\n  color: #929292\n}\n\n.ace-clouds-midnight .ace_print-margin {\n  width: 1px;\n  background: #232323\n}\n\n.ace-clouds-midnight {\n  background-color: #191919;\n  color: #929292\n}\n\n.ace-clouds-midnight .ace_cursor {\n  color: #7DA5DC\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_selection {\n  background: #000000\n}\n\n.ace-clouds-midnight.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #191919;\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #BFBFBF\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_active-line {\n  background: rgba(215, 215, 215, 0.031)\n}\n\n.ace-clouds-midnight .ace_gutter-active-line {\n  background-color: rgba(215, 215, 215, 0.031)\n}\n\n.ace-clouds-midnight .ace_marker-layer .ace_selected-word {\n  border: 1px solid #000000\n}\n\n.ace-clouds-midnight .ace_invisible {\n  color: #666\n}\n\n.ace-clouds-midnight .ace_keyword,\n.ace-clouds-midnight .ace_meta,\n.ace-clouds-midnight .ace_support.ace_constant.ace_property-value {\n  color: #927C5D\n}\n\n.ace-clouds-midnight .ace_keyword.ace_operator {\n  color: #4B4B4B\n}\n\n.ace-clouds-midnight .ace_keyword.ace_other.ace_unit {\n  color: #366F1A\n}\n\n.ace-clouds-midnight .ace_constant.ace_language {\n  color: #39946A\n}\n\n.ace-clouds-midnight .ace_constant.ace_numeric {\n  color: #46A609\n}\n\n.ace-clouds-midnight .ace_constant.ace_character.ace_entity {\n  color: #A165AC\n}\n\n.ace-clouds-midnight .ace_invalid {\n  color: #FFFFFF;\n  background-color: #E92E2E\n}\n\n.ace-clouds-midnight .ace_fold {\n  background-color: #927C5D;\n  border-color: #929292\n}\n\n.ace-clouds-midnight .ace_storage,\n.ace-clouds-midnight .ace_support.ace_class,\n.ace-clouds-midnight .ace_support.ace_function,\n.ace-clouds-midnight .ace_support.ace_other,\n.ace-clouds-midnight .ace_support.ace_type {\n  color: #E92E2E\n}\n\n.ace-clouds-midnight .ace_string {\n  color: #5D90CD\n}\n\n.ace-clouds-midnight .ace_comment {\n  color: #3C403B\n}\n\n.ace-clouds-midnight .ace_entity.ace_name.ace_tag,\n.ace-clouds-midnight .ace_entity.ace_other.ace_attribute-name {\n  color: #606060\n}\n\n.ace-clouds-midnight .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHB3d/8PAAOIAdULw8qMAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-clouds-midnight .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/clouds_midnight", ["require", "exports", "module", "ace/theme/clouds_midnight-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-clouds-midnight";
      exports2.cssText = require3("./clouds_midnight-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/clouds_midnight"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-cobalt.js
var require_theme_cobalt = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-cobalt.js"(exports, module2) {
    ace.define("ace/theme/cobalt-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-cobalt .ace_gutter {\n  background: #011e3a;\n  color: rgb(128,145,160)\n}\n\n.ace-cobalt .ace_print-margin {\n  width: 1px;\n  background: #555555\n}\n\n.ace-cobalt {\n  background-color: #002240;\n  color: #FFFFFF\n}\n\n.ace-cobalt .ace_cursor {\n  color: #FFFFFF\n}\n\n.ace-cobalt .ace_marker-layer .ace_selection {\n  background: rgba(179, 101, 57, 0.75)\n}\n\n.ace-cobalt.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #002240;\n}\n\n.ace-cobalt .ace_marker-layer .ace_step {\n  background: rgb(127, 111, 19)\n}\n\n.ace-cobalt .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(255, 255, 255, 0.15)\n}\n\n.ace-cobalt .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.35)\n}\n\n.ace-cobalt .ace_gutter-active-line {\n  background-color: rgba(0, 0, 0, 0.35)\n}\n\n.ace-cobalt .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(179, 101, 57, 0.75)\n}\n\n.ace-cobalt .ace_invisible {\n  color: rgba(255, 255, 255, 0.15)\n}\n\n.ace-cobalt .ace_keyword,\n.ace-cobalt .ace_meta {\n  color: #FF9D00\n}\n\n.ace-cobalt .ace_constant,\n.ace-cobalt .ace_constant.ace_character,\n.ace-cobalt .ace_constant.ace_character.ace_escape,\n.ace-cobalt .ace_constant.ace_other {\n  color: #FF628C\n}\n\n.ace-cobalt .ace_invalid {\n  color: #F8F8F8;\n  background-color: #800F00\n}\n\n.ace-cobalt .ace_support {\n  color: #80FFBB\n}\n\n.ace-cobalt .ace_support.ace_constant {\n  color: #EB939A\n}\n\n.ace-cobalt .ace_fold {\n  background-color: #FF9D00;\n  border-color: #FFFFFF\n}\n\n.ace-cobalt .ace_support.ace_function {\n  color: #FFB054\n}\n\n.ace-cobalt .ace_storage {\n  color: #FFEE80\n}\n\n.ace-cobalt .ace_entity {\n  color: #FFDD00\n}\n\n.ace-cobalt .ace_string {\n  color: #3AD900\n}\n\n.ace-cobalt .ace_string.ace_regexp {\n  color: #80FFC2\n}\n\n.ace-cobalt .ace_comment {\n  font-style: italic;\n  color: #0088FF\n}\n\n.ace-cobalt .ace_heading,\n.ace-cobalt .ace_markup.ace_heading {\n  color: #C8E4FD;\n  background-color: #001221\n}\n\n.ace-cobalt .ace_list,\n.ace-cobalt .ace_markup.ace_list {\n  background-color: #130D26\n}\n\n.ace-cobalt .ace_variable {\n  color: #CCCCCC\n}\n\n.ace-cobalt .ace_variable.ace_language {\n  color: #FF80E1\n}\n\n.ace-cobalt .ace_meta.ace_tag {\n  color: #9EFFFF\n}\n\n.ace-cobalt .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHCLSvkPAAP3AgSDTRd4AAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-cobalt .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/cobalt", ["require", "exports", "module", "ace/theme/cobalt-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-cobalt";
      exports2.cssText = require3("./cobalt-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/cobalt"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-dracula.js
var require_theme_dracula = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-dracula.js"(exports, module2) {
    ace.define("ace/theme/dracula-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '/*\n * Copyright \xA9 2017 Zeno Rocha <hi@zenorocha.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201CSoftware\u201D), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n.ace-dracula .ace_gutter {\n  background: #282a36;\n  color: rgb(144,145,148)\n}\n\n.ace-dracula .ace_print-margin {\n  width: 1px;\n  background: #44475a\n}\n\n.ace-dracula {\n  background-color: #282a36;\n  color: #f8f8f2\n}\n\n.ace-dracula .ace_cursor {\n  color: #f8f8f0\n}\n\n.ace-dracula .ace_marker-layer .ace_selection {\n  background: #44475a\n}\n\n.ace-dracula.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #282a36;\n  border-radius: 2px\n}\n\n.ace-dracula .ace_marker-layer .ace_step {\n  background: rgb(198, 219, 174)\n}\n\n.ace-dracula .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #a29709\n}\n\n.ace-dracula .ace_marker-layer .ace_active-line {\n  background: #44475a\n}\n\n.ace-dracula .ace_gutter-active-line {\n  background-color: #44475a\n}\n\n.ace-dracula .ace_marker-layer .ace_selected-word {\n  box-shadow: 0px 0px 0px 1px #a29709;\n  border-radius: 3px;\n}\n\n.ace-dracula .ace_fold {\n  background-color: #50fa7b;\n  border-color: #f8f8f2\n}\n\n.ace-dracula .ace_keyword {\n  color: #ff79c6\n}\n\n.ace-dracula .ace_constant.ace_language {\n  color: #bd93f9\n}\n\n.ace-dracula .ace_constant.ace_numeric {\n  color: #bd93f9\n}\n\n.ace-dracula .ace_constant.ace_character {\n  color: #bd93f9\n}\n\n.ace-dracula .ace_constant.ace_character.ace_escape {\n  color: #ff79c6\n}\n\n.ace-dracula .ace_constant.ace_other {\n  color: #bd93f9\n}\n\n.ace-dracula .ace_support.ace_function {\n  color: #8be9fd\n}\n\n.ace-dracula .ace_support.ace_constant {\n  color: #6be5fd\n}\n\n.ace-dracula .ace_support.ace_class {\n  font-style: italic;\n  color: #66d9ef\n}\n\n.ace-dracula .ace_support.ace_type {\n  font-style: italic;\n  color: #66d9ef\n}\n\n.ace-dracula .ace_storage {\n  color: #ff79c6\n}\n\n.ace-dracula .ace_storage.ace_type {\n  font-style: italic;\n  color: #8be9fd\n}\n\n.ace-dracula .ace_invalid {\n  color: #F8F8F0;\n  background-color: #ff79c6\n}\n\n.ace-dracula .ace_invalid.ace_deprecated {\n  color: #F8F8F0;\n  background-color: #bd93f9\n}\n\n.ace-dracula .ace_string {\n  color: #f1fa8c\n}\n\n.ace-dracula .ace_comment {\n  color: #6272a4\n}\n\n.ace-dracula .ace_variable {\n  color: #50fa7b\n}\n\n.ace-dracula .ace_variable.ace_parameter {\n  font-style: italic;\n  color: #ffb86c\n}\n\n.ace-dracula .ace_entity.ace_other.ace_attribute-name {\n  color: #50fa7b\n}\n\n.ace-dracula .ace_entity.ace_name.ace_function {\n  color: #50fa7b\n}\n\n.ace-dracula .ace_entity.ace_name.ace_tag {\n  color: #ff79c6\n}\n.ace-dracula .ace_invisible {\n  color: #626680;\n}\n\n.ace-dracula .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHB3d/8PAAOIAdULw8qMAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-dracula .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACAQMAAACjTyRkAAAABlBMVEUAAADCwsK76u2xAAAAAXRSTlMAQObYZgAAAAxJREFUCNdjYGBoAAAAhACBGFbxzQAAAABJRU5ErkJggg==") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/dracula", ["require", "exports", "module", "ace/theme/dracula-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-dracula";
      exports2.cssText = require3("./dracula-css");
      exports2.$selectionColorConflict = true;
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/dracula"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-github_dark.js
var require_theme_github_dark = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-github_dark.js"(exports, module2) {
    ace.define("ace/theme/github_dark-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-github-dark .ace_gutter {\n  background: #24292e;\n  color: #7388b5\n}\n\n.ace-github-dark .ace_print-margin {\n  width: 1px;\n  background: #00204b\n}\n\n.ace-github-dark {\n  background-color: #24292e;\n  color: #FFFFFF\n}\n\n.ace-github-dark .ace_constant.ace_other,\n.ace-github-dark .ace_cursor {\n  color: #FFFFFF\n}\n\n.ace-github-dark .ace_marker-layer .ace_selection {\n  background: #003F8E\n}\n\n.ace-github-dark.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #24292e;\n}\n\n.ace-github-dark .ace_marker-layer .ace_step {\n  background: rgb(127, 111, 19)\n}\n\n.ace-github-dark .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #404F7D\n}\n\n.ace-github-dark .ace_marker-layer .ace_active-line {\n  background: #00346E\n}\n\n.ace-github-dark .ace_gutter-active-line {\n  background-color: #24292e\n}\n\n.ace-github-dark .ace_marker-layer .ace_selected-word {\n  border: 1px solid #003F8E\n}\n\n.ace-github-dark .ace_invisible {\n  color: #404F7D\n}\n\n.ace-github-dark .ace_keyword,\n.ace-github-dark .ace_meta,\n.ace-github-dark .ace_storage,\n.ace-github-dark .ace_storage.ace_type,\n.ace-github-dark .ace_support.ace_type {\n  color: #ff7b72\n}\n\n.ace-github-dark .ace_keyword.ace_operator {\n  color: #79c0ff\n}\n\n.ace-github-dark .ace_constant.ace_character,\n.ace-github-dark .ace_constant.ace_language,\n.ace-github-dark .ace_constant.ace_numeric,\n.ace-github-dark .ace_keyword.ace_other.ace_unit,\n.ace-github-dark .ace_support.ace_constant,\n.ace-github-dark .ace_variable.ace_parameter {\n  color: #FFC58F\n}\n\n.ace-github-dark .ace_invalid {\n  color: #FFFFFF;\n  background-color: #F99DA5\n}\n\n.ace-github-dark .ace_invalid.ace_deprecated {\n  color: #FFFFFF;\n  background-color: #ff7b72\n}\n\n.ace-github-dark .ace_fold {\n  background-color: #BBDAFF;\n  border-color: #FFFFFF\n}\n\n.ace-github-dark .ace_entity.ace_name.ace_function,\n.ace-github-dark .ace_support.ace_function,\n.ace-github-dark .ace_variable {\n  color: #BBDAFF\n}\n\n.ace-github-dark .ace_support.ace_class,\n.ace-github-dark .ace_support.ace_type {\n  color: #FFEEAD\n}\n\n.ace-github-dark .ace_heading,\n.ace-github-dark .ace_markup.ace_heading,\n.ace-github-dark .ace_string {\n  color: #9fcef6\n}\n\n.ace-github-dark .ace_entity.ace_name.ace_tag,\n.ace-github-dark .ace_entity.ace_other.ace_attribute-name,\n.ace-github-dark .ace_meta.ace_tag,\n.ace-github-dark .ace_string.ace_regexp,\n.ace-github-dark .ace_variable {\n  color: #FF9DA4\n}\n\n.ace-github-dark .ace_comment {\n  color: #7285B7\n}\n\n.ace-github-dark .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYJDzqfwPAANXAeNsiA+ZAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-github-dark .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n\n.ace-github-dark .ace_constant.ace_buildin {\n  color: #0086B3;\n}\n\n.ace-github-dark .ace_variable.ace_language {\n  color: #ffffff;\n}\n  ";
    });
    ace.define("ace/theme/github_dark", ["require", "exports", "module", "ace/theme/github_dark-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-github-dark";
      exports2.cssText = require3("./github_dark-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/github_dark"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-gob.js
var require_theme_gob = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-gob.js"(exports, module2) {
    ace.define("ace/theme/gob-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-gob .ace_gutter {\n  background: #0B1818;\n  color: #03EE03\n}\n\n.ace-gob .ace_print-margin {\n  width: 1px;\n  background: #131313\n}\n\n.ace-gob {\n  background-color: #0B0B0B;\n  color: #00FF00\n}\n\n.ace-gob .ace_cursor {\n  border-color: rgba(16, 248, 255, 0.90);\n  background-color: rgba(16, 240, 248, 0.70);\n  opacity: 0.4;\n}\n\n.ace-gob .ace_marker-layer .ace_selection {\n  background: rgba(221, 240, 255, 0.20)\n}\n\n.ace-gob.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #141414;\n}\n\n.ace-gob .ace_marker-layer .ace_step {\n  background: rgb(16, 128, 0)\n}\n\n.ace-gob .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(64, 255, 255, 0.25)\n}\n\n.ace-gob .ace_marker-layer .ace_active-line {\n  background: rgba(255, 255, 255, 0.04)\n}\n\n.ace-gob .ace_gutter-active-line {\n  background-color: rgba(255, 255, 255, 0.04)\n}\n\n.ace-gob .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(192, 240, 255, 0.20)\n}\n\n.ace-gob .ace_invisible {\n  color: rgba(255, 255, 255, 0.25)\n}\n\n.ace-gob .ace_keyword,\n.ace-gob .ace_meta {\n  color: #10D8E8\n}\n\n.ace-gob .ace_constant,\n.ace-gob .ace_constant.ace_character,\n.ace-gob .ace_constant.ace_character.ace_escape,\n.ace-gob .ace_constant.ace_other,\n.ace-gob .ace_heading,\n.ace-gob .ace_markup.ace_heading,\n.ace-gob .ace_support.ace_constant {\n  color: #10F0A0\n}\n\n.ace-gob .ace_invalid.ace_illegal {\n  color: #F8F8F8;\n  background-color: rgba(86, 45, 86, 0.75)\n}\n\n.ace-gob .ace_invalid.ace_deprecated {\n  text-decoration: underline;\n  font-style: italic;\n  color: #20F8C0\n}\n\n.ace-gob .ace_support {\n  color: #20E8B0\n}\n\n.ace-gob .ace_fold {\n  background-color: #50B8B8;\n  border-color: #70F8F8\n}\n\n.ace-gob .ace_support.ace_function {\n  color: #00F800\n}\n\n.ace-gob .ace_list,\n.ace-gob .ace_markup.ace_list,\n.ace-gob .ace_storage {\n  color: #10FF98\n}\n\n.ace-gob .ace_entity.ace_name.ace_function,\n.ace-gob .ace_meta.ace_tag,\n.ace-gob .ace_variable {\n  color: #00F868\n}\n\n.ace-gob .ace_string {\n  color: #10F060\n}\n\n.ace-gob .ace_string.ace_regexp {\n  color: #20F090;\n}\n\n.ace-gob .ace_comment {\n  font-style: italic;\n  color: #00E060;\n}\n\n.ace-gob .ace_variable {\n  color: #00F888;\n}\n\n.ace-gob .ace_xml-pe {\n  color: #488858;\n}\n\n.ace-gob .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMQERFpYLC1tf0PAAgOAnPnhxyiAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-gob .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/gob", ["require", "exports", "module", "ace/theme/gob-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-gob";
      exports2.cssText = require3("./gob-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/gob"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-gruvbox.js
var require_theme_gruvbox = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-gruvbox.js"(exports, module2) {
    ace.define("ace/theme/gruvbox-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = '.ace-gruvbox .ace_gutter-active-line {\n  background-color: #3C3836;\n}\n\n.ace-gruvbox {\n  color: #EBDAB4;\n  background-color: #1D2021;\n}\n\n.ace-gruvbox .ace_invisible {\n  color: #504945;\n}\n\n.ace-gruvbox .ace_marker-layer .ace_selection {\n  background: rgba(179, 101, 57, 0.75)\n}\n\n.ace-gruvbox.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #002240;\n}\n\n.ace-gruvbox .ace_keyword {\n  color: #8ec07c;\n}\n\n.ace-gruvbox .ace_comment {\n  font-style: italic;\n  color: #928375;\n}\n\n.ace-gruvbox .ace-statement {\n  color: red;\n}\n\n.ace-gruvbox .ace_variable {\n  color: #84A598;\n}\n\n.ace-gruvbox .ace_variable.ace_language {\n  color: #D2879B;\n}\n\n.ace-gruvbox .ace_constant {\n  color: #C2859A;\n}\n\n.ace-gruvbox .ace_constant.ace_language {\n  color: #C2859A;\n}\n\n.ace-gruvbox .ace_constant.ace_numeric {\n  color: #C2859A;\n}\n\n.ace-gruvbox .ace_string {\n  color: #B8BA37;\n}\n\n.ace-gruvbox .ace_support {\n  color: #F9BC41;\n}\n\n.ace-gruvbox .ace_support.ace_function {\n  color: #F84B3C;\n}\n\n.ace-gruvbox .ace_storage {\n  color: #8FBF7F;\n}\n\n.ace-gruvbox .ace_keyword.ace_operator {\n  color: #EBDAB4;\n}\n\n.ace-gruvbox .ace_punctuation.ace_operator {\n  color: yellow;\n}\n\n.ace-gruvbox .ace_marker-layer .ace_active-line {\n  background: #3C3836;\n}\n\n.ace-gruvbox .ace_marker-layer .ace_selected-word {\n  border-radius: 4px;\n  border: 8px solid #3f475d;\n}\n\n.ace-gruvbox .ace_print-margin {\n  width: 5px;\n  background: #3C3836;\n}\n\n.ace-gruvbox .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNQUFD4z6Crq/sfAAuYAuYl+7lfAAAAAElFTkSuQmCC") right repeat-y;\n}\n\n.ace-gruvbox .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n';
    });
    ace.define("ace/theme/gruvbox", ["require", "exports", "module", "ace/theme/gruvbox-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-gruvbox";
      exports2.cssText = require3("./gruvbox-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/gruvbox"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-gruvbox_dark_hard.js
var require_theme_gruvbox_dark_hard = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-gruvbox_dark_hard.js"(exports, module2) {
    ace.define("ace/theme/gruvbox_dark_hard-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-gruvbox-dark-hard .ace_gutter {\n  background: #1d2021;\n  color: rgb(132,126,106)\n}\n\n.ace-gruvbox-dark-hard .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8\n}\n\n.ace-gruvbox-dark-hard {\n  background-color: #1d2021;\n  color: rgba(235, 219, 178, 0.50)\n}\n\n.ace-gruvbox-dark-hard .ace_cursor {\n  color: #a89984\n}\n\n.ace-gruvbox-dark-hard .ace_marker-layer .ace_selection {\n  background: #3c3836\n}\n\n.ace-gruvbox-dark-hard.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #1d2021;\n  border-radius: 2px\n}\n\n.ace-gruvbox-dark-hard .ace_marker-layer .ace_step {\n  background: rgb(198, 219, 174)\n}\n\n.ace-gruvbox-dark-hard .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(235, 219, 178, 0.15)\n}\n\n.ace-gruvbox-dark-hard .ace_marker-layer .ace_active-line {\n  background: #3c3836\n}\n\n.ace-gruvbox-dark-hard .ace_gutter-active-line {\n  background-color: #3c3836\n}\n\n.ace-gruvbox-dark-hard .ace_marker-layer .ace_selected-word {\n  border: 1px solid #3c3836\n}\n\n.ace-gruvbox-dark-hard .ace_fold {\n  background-color: #b8bb26;\n  border-color: rgba(235, 219, 178, 0.50)\n}\n\n.ace-gruvbox-dark-hard .ace_keyword {\n  color: #fb4934\n}\n\n.ace-gruvbox-dark-hard .ace_keyword.ace_operator {\n  color: #8ec07c\n}\n\n.ace-gruvbox-dark-hard .ace_keyword.ace_other.ace_unit {\n  color: #b16286\n}\n\n.ace-gruvbox-dark-hard .ace_constant {\n  color: #d3869b\n}\n\n.ace-gruvbox-dark-hard .ace_constant.ace_numeric {\n  color: #d3869b\n}\n\n.ace-gruvbox-dark-hard .ace_constant.ace_character.ace_escape {\n  color: #fb4934\n}\n\n.ace-gruvbox-dark-hard .ace_constant.ace_other {\n  color: #d3869b\n}\n\n.ace-gruvbox-dark-hard .ace_support.ace_function {\n  color: #8ec07c\n}\n\n.ace-gruvbox-dark-hard .ace_support.ace_constant {\n  color: #d3869b\n}\n\n.ace-gruvbox-dark-hard .ace_support.ace_constant.ace_property-value {\n  color: #f9f5d7\n}\n\n.ace-gruvbox-dark-hard .ace_support.ace_class {\n  color: #fabd2f\n}\n\n.ace-gruvbox-dark-hard .ace_support.ace_type {\n  color: #fabd2f\n}\n\n.ace-gruvbox-dark-hard .ace_storage {\n  color: #fb4934\n}\n\n.ace-gruvbox-dark-hard .ace_invalid {\n  color: #f9f5d7;\n  background-color: #fb4934\n}\n\n.ace-gruvbox-dark-hard .ace_string {\n  color: #b8bb26\n}\n\n.ace-gruvbox-dark-hard .ace_string.ace_regexp {\n  color: #b8bb26\n}\n\n.ace-gruvbox-dark-hard .ace_comment {\n  font-style: italic;\n  color: #928374\n}\n\n.ace-gruvbox-dark-hard .ace_variable {\n  color: #83a598\n}\n\n.ace-gruvbox-dark-hard .ace_variable.ace_language {\n  color: #d3869b\n}\n\n.ace-gruvbox-dark-hard .ace_variable.ace_parameter {\n  color: #f9f5d7\n}\n\n.ace-gruvbox-dark-hard .ace_meta.ace_tag {\n  color: #f9f5d7\n}\n\n.ace-gruvbox-dark-hard .ace_entity.ace_other.ace_attribute-name {\n  color: #fabd2f\n}\n\n.ace-gruvbox-dark-hard .ace_entity.ace_name.ace_function {\n  color: #b8bb26\n}\n\n.ace-gruvbox-dark-hard .ace_entity.ace_name.ace_tag {\n  color: #83a598\n}\n\n.ace-gruvbox-dark-hard .ace_markup.ace_heading {\n  color: #b8bb26\n}\n\n.ace-gruvbox-dark-hard .ace_markup.ace_list {\n  color: #83a598\n}\n\n.ace-gruvbox-dark-hard .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/gruvbox_dark_hard", ["require", "exports", "module", "ace/theme/gruvbox_dark_hard-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-gruvbox-dark-hard";
      exports2.cssText = require3("./gruvbox_dark_hard-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass);
    });
    (function() {
      ace.require(["ace/theme/gruvbox_dark_hard"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-idle_fingers.js
var require_theme_idle_fingers = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-idle_fingers.js"(exports, module2) {
    ace.define("ace/theme/idle_fingers-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-idle-fingers .ace_gutter {\n  background: #3b3b3b;\n  color: rgb(153,153,153)\n}\n\n.ace-idle-fingers .ace_print-margin {\n  width: 1px;\n  background: #3b3b3b\n}\n\n.ace-idle-fingers {\n  background-color: #323232;\n  color: #FFFFFF\n}\n\n.ace-idle-fingers .ace_cursor {\n  color: #91FF00\n}\n\n.ace-idle-fingers .ace_marker-layer .ace_selection {\n  background: rgba(90, 100, 126, 0.88)\n}\n\n.ace-idle-fingers.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #323232;\n}\n\n.ace-idle-fingers .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-idle-fingers .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #404040\n}\n\n.ace-idle-fingers .ace_marker-layer .ace_active-line {\n  background: #353637\n}\n\n.ace-idle-fingers .ace_gutter-active-line {\n  background-color: #353637\n}\n\n.ace-idle-fingers .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(90, 100, 126, 0.88)\n}\n\n.ace-idle-fingers .ace_invisible {\n  color: #404040\n}\n\n.ace-idle-fingers .ace_keyword,\n.ace-idle-fingers .ace_meta {\n  color: #CC7833\n}\n\n.ace-idle-fingers .ace_constant,\n.ace-idle-fingers .ace_constant.ace_character,\n.ace-idle-fingers .ace_constant.ace_character.ace_escape,\n.ace-idle-fingers .ace_constant.ace_other,\n.ace-idle-fingers .ace_support.ace_constant {\n  color: #6C99BB\n}\n\n.ace-idle-fingers .ace_invalid {\n  color: #FFFFFF;\n  background-color: #FF0000\n}\n\n.ace-idle-fingers .ace_fold {\n  background-color: #CC7833;\n  border-color: #FFFFFF\n}\n\n.ace-idle-fingers .ace_support.ace_function {\n  color: #B83426\n}\n\n.ace-idle-fingers .ace_variable.ace_parameter {\n  font-style: italic\n}\n\n.ace-idle-fingers .ace_string {\n  color: #A5C261\n}\n\n.ace-idle-fingers .ace_string.ace_regexp {\n  color: #CCCC33\n}\n\n.ace-idle-fingers .ace_comment {\n  font-style: italic;\n  color: #BC9458\n}\n\n.ace-idle-fingers .ace_meta.ace_tag {\n  color: #FFE5BB\n}\n\n.ace-idle-fingers .ace_entity.ace_name {\n  color: #FFC66D\n}\n\n.ace-idle-fingers .ace_collab.ace_user1 {\n  color: #323232;\n  background-color: #FFF980\n}\n\n.ace-idle-fingers .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMwMjLyZYiPj/8PAAreAwAI1+g0AAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-idle-fingers .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/idle_fingers", ["require", "exports", "module", "ace/theme/idle_fingers-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-idle-fingers";
      exports2.cssText = require3("./idle_fingers-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/idle_fingers"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-kr_theme.js
var require_theme_kr_theme = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-kr_theme.js"(exports, module2) {
    ace.define("ace/theme/kr_theme-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-kr-theme .ace_gutter {\n  background: #1c1917;\n  color: #FCFFE0\n}\n\n.ace-kr-theme .ace_print-margin {\n  width: 1px;\n  background: #1c1917\n}\n\n.ace-kr-theme {\n  background-color: #0B0A09;\n  color: #FCFFE0\n}\n\n.ace-kr-theme .ace_cursor {\n  color: #FF9900\n}\n\n.ace-kr-theme .ace_marker-layer .ace_selection {\n  background: rgba(170, 0, 255, 0.45)\n}\n\n.ace-kr-theme.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #0B0A09;\n}\n\n.ace-kr-theme .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-kr-theme .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(255, 177, 111, 0.32)\n}\n\n.ace-kr-theme .ace_marker-layer .ace_active-line {\n  background: #38403D\n}\n\n.ace-kr-theme .ace_gutter-active-line {\n  background-color : #38403D\n}\n\n.ace-kr-theme .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(170, 0, 255, 0.45)\n}\n\n.ace-kr-theme .ace_invisible {\n  color: rgba(255, 177, 111, 0.32)\n}\n\n.ace-kr-theme .ace_keyword,\n.ace-kr-theme .ace_meta {\n  color: #949C8B\n}\n\n.ace-kr-theme .ace_constant,\n.ace-kr-theme .ace_constant.ace_character,\n.ace-kr-theme .ace_constant.ace_character.ace_escape,\n.ace-kr-theme .ace_constant.ace_other {\n  color: rgba(210, 117, 24, 0.76)\n}\n\n.ace-kr-theme .ace_invalid {\n  color: #F8F8F8;\n  background-color: #A41300\n}\n\n.ace-kr-theme .ace_support {\n  color: #9FC28A\n}\n\n.ace-kr-theme .ace_support.ace_constant {\n  color: #C27E66\n}\n\n.ace-kr-theme .ace_fold {\n  background-color: #949C8B;\n  border-color: #FCFFE0\n}\n\n.ace-kr-theme .ace_support.ace_function {\n  color: #85873A\n}\n\n.ace-kr-theme .ace_storage {\n  color: #FFEE80\n}\n\n.ace-kr-theme .ace_string {\n  color: rgba(164, 161, 181, 0.8)\n}\n\n.ace-kr-theme .ace_string.ace_regexp {\n  color: rgba(125, 255, 192, 0.65)\n}\n\n.ace-kr-theme .ace_comment {\n  font-style: italic;\n  color: #706D5B\n}\n\n.ace-kr-theme .ace_variable {\n  color: #D1A796\n}\n\n.ace-kr-theme .ace_list,\n.ace-kr-theme .ace_markup.ace_list {\n  background-color: #0F0040\n}\n\n.ace-kr-theme .ace_variable.ace_language {\n  color: #FF80E1\n}\n\n.ace-kr-theme .ace_meta.ace_tag {\n  color: #BABD9C\n}\n\n.ace-kr-theme .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYFBXV/8PAAJoAXX4kT2EAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-kr-theme .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/kr_theme", ["require", "exports", "module", "ace/theme/kr_theme-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-kr-theme";
      exports2.cssText = require3("./kr_theme-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/kr_theme"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-merbivore.js
var require_theme_merbivore = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-merbivore.js"(exports, module2) {
    ace.define("ace/theme/merbivore-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-merbivore .ace_gutter {\n  background: #202020;\n  color: #E6E1DC\n}\n\n.ace-merbivore .ace_print-margin {\n  width: 1px;\n  background: #555651\n}\n\n.ace-merbivore {\n  background-color: #161616;\n  color: #E6E1DC\n}\n\n.ace-merbivore .ace_cursor {\n  color: #FFFFFF\n}\n\n.ace-merbivore .ace_marker-layer .ace_selection {\n  background: #454545\n}\n\n.ace-merbivore.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #161616;\n}\n\n.ace-merbivore .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-merbivore .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #404040\n}\n\n.ace-merbivore .ace_marker-layer .ace_active-line {\n  background: #333435\n}\n\n.ace-merbivore .ace_gutter-active-line {\n  background-color: #333435\n}\n\n.ace-merbivore .ace_marker-layer .ace_selected-word {\n  border: 1px solid #454545\n}\n\n.ace-merbivore .ace_invisible {\n  color: #404040\n}\n\n.ace-merbivore .ace_entity.ace_name.ace_tag,\n.ace-merbivore .ace_keyword,\n.ace-merbivore .ace_meta,\n.ace-merbivore .ace_meta.ace_tag,\n.ace-merbivore .ace_storage,\n.ace-merbivore .ace_support.ace_function {\n  color: #FC6F09\n}\n\n.ace-merbivore .ace_constant,\n.ace-merbivore .ace_constant.ace_character,\n.ace-merbivore .ace_constant.ace_character.ace_escape,\n.ace-merbivore .ace_constant.ace_other,\n.ace-merbivore .ace_support.ace_type {\n  color: #1EDAFB\n}\n\n.ace-merbivore .ace_constant.ace_character.ace_escape {\n  color: #519F50\n}\n\n.ace-merbivore .ace_constant.ace_language {\n  color: #FDC251\n}\n\n.ace-merbivore .ace_constant.ace_library,\n.ace-merbivore .ace_string,\n.ace-merbivore .ace_support.ace_constant {\n  color: #8DFF0A\n}\n\n.ace-merbivore .ace_constant.ace_numeric {\n  color: #58C554\n}\n\n.ace-merbivore .ace_invalid {\n  color: #FFFFFF;\n  background-color: #990000\n}\n\n.ace-merbivore .ace_fold {\n  background-color: #FC6F09;\n  border-color: #E6E1DC\n}\n\n.ace-merbivore .ace_comment {\n  font-style: italic;\n  color: #AD2EA4\n}\n\n.ace-merbivore .ace_entity.ace_other.ace_attribute-name {\n  color: #FFFF89\n}\n\n.ace-merbivore .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMQFxf3ZXB1df0PAAdsAmERTkEHAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-merbivore .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/merbivore", ["require", "exports", "module", "ace/theme/merbivore-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-merbivore";
      exports2.cssText = require3("./merbivore-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/merbivore"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-merbivore_soft.js
var require_theme_merbivore_soft = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-merbivore_soft.js"(exports, module2) {
    ace.define("ace/theme/merbivore_soft-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-merbivore-soft .ace_gutter {\n  background: #262424;\n  color: #E6E1DC\n}\n\n.ace-merbivore-soft .ace_print-margin {\n  width: 1px;\n  background: #262424\n}\n\n.ace-merbivore-soft {\n  background-color: #1C1C1C;\n  color: #E6E1DC\n}\n\n.ace-merbivore-soft .ace_cursor {\n  color: #FFFFFF\n}\n\n.ace-merbivore-soft .ace_marker-layer .ace_selection {\n  background: #494949\n}\n\n.ace-merbivore-soft.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #1C1C1C;\n}\n\n.ace-merbivore-soft .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-merbivore-soft .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #404040\n}\n\n.ace-merbivore-soft .ace_marker-layer .ace_active-line {\n  background: #333435\n}\n\n.ace-merbivore-soft .ace_gutter-active-line {\n  background-color: #333435\n}\n\n.ace-merbivore-soft .ace_marker-layer .ace_selected-word {\n  border: 1px solid #494949\n}\n\n.ace-merbivore-soft .ace_invisible {\n  color: #404040\n}\n\n.ace-merbivore-soft .ace_entity.ace_name.ace_tag,\n.ace-merbivore-soft .ace_keyword,\n.ace-merbivore-soft .ace_meta,\n.ace-merbivore-soft .ace_meta.ace_tag,\n.ace-merbivore-soft .ace_storage {\n  color: #FC803A\n}\n\n.ace-merbivore-soft .ace_constant,\n.ace-merbivore-soft .ace_constant.ace_character,\n.ace-merbivore-soft .ace_constant.ace_character.ace_escape,\n.ace-merbivore-soft .ace_constant.ace_other,\n.ace-merbivore-soft .ace_support.ace_type {\n  color: #68C1D8\n}\n\n.ace-merbivore-soft .ace_constant.ace_character.ace_escape {\n  color: #B3E5B4\n}\n\n.ace-merbivore-soft .ace_constant.ace_language {\n  color: #E1C582\n}\n\n.ace-merbivore-soft .ace_constant.ace_library,\n.ace-merbivore-soft .ace_string,\n.ace-merbivore-soft .ace_support.ace_constant {\n  color: #8EC65F\n}\n\n.ace-merbivore-soft .ace_constant.ace_numeric {\n  color: #7FC578\n}\n\n.ace-merbivore-soft .ace_invalid,\n.ace-merbivore-soft .ace_invalid.ace_deprecated {\n  color: #FFFFFF;\n  background-color: #FE3838\n}\n\n.ace-merbivore-soft .ace_fold {\n  background-color: #FC803A;\n  border-color: #E6E1DC\n}\n\n.ace-merbivore-soft .ace_comment,\n.ace-merbivore-soft .ace_meta {\n  font-style: italic;\n  color: #AC4BB8\n}\n\n.ace-merbivore-soft .ace_entity.ace_other.ace_attribute-name {\n  color: #EAF1A3\n}\n\n.ace-merbivore-soft .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWOQkpLyZfD09PwPAAfYAnaStpHRAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-merbivore-soft .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/merbivore_soft", ["require", "exports", "module", "ace/theme/merbivore_soft-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-merbivore-soft";
      exports2.cssText = require3("./merbivore_soft-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/merbivore_soft"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-mono_industrial.js
var require_theme_mono_industrial = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-mono_industrial.js"(exports, module2) {
    ace.define("ace/theme/mono_industrial-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-mono-industrial .ace_gutter {\n  background: #1d2521;\n  color: #C5C9C9\n}\n\n.ace-mono-industrial .ace_print-margin {\n  width: 1px;\n  background: #555651\n}\n\n.ace-mono-industrial {\n  background-color: #222C28;\n  color: #FFFFFF\n}\n\n.ace-mono-industrial .ace_cursor {\n  color: #FFFFFF\n}\n\n.ace-mono-industrial .ace_marker-layer .ace_selection {\n  background: rgba(145, 153, 148, 0.40)\n}\n\n.ace-mono-industrial.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #222C28;\n}\n\n.ace-mono-industrial .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-mono-industrial .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(102, 108, 104, 0.50)\n}\n\n.ace-mono-industrial .ace_marker-layer .ace_active-line {\n  background: rgba(12, 13, 12, 0.25)\n}\n\n.ace-mono-industrial .ace_gutter-active-line {\n  background-color: rgba(12, 13, 12, 0.25)\n}\n\n.ace-mono-industrial .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(145, 153, 148, 0.40)\n}\n\n.ace-mono-industrial .ace_invisible {\n  color: rgba(102, 108, 104, 0.50)\n}\n\n.ace-mono-industrial .ace_string {\n  background-color: #151C19;\n  color: #FFFFFF\n}\n\n.ace-mono-industrial .ace_keyword,\n.ace-mono-industrial .ace_meta {\n  color: #A39E64\n}\n\n.ace-mono-industrial .ace_constant,\n.ace-mono-industrial .ace_constant.ace_character,\n.ace-mono-industrial .ace_constant.ace_character.ace_escape,\n.ace-mono-industrial .ace_constant.ace_numeric,\n.ace-mono-industrial .ace_constant.ace_other {\n  color: #E98800\n}\n\n.ace-mono-industrial .ace_entity.ace_name.ace_function,\n.ace-mono-industrial .ace_keyword.ace_operator,\n.ace-mono-industrial .ace_variable {\n  color: #A8B3AB\n}\n\n.ace-mono-industrial .ace_invalid {\n  color: #FFFFFF;\n  background-color: rgba(153, 0, 0, 0.68)\n}\n\n.ace-mono-industrial .ace_support.ace_constant {\n  color: #C87500\n}\n\n.ace-mono-industrial .ace_fold {\n  background-color: #A8B3AB;\n  border-color: #FFFFFF\n}\n\n.ace-mono-industrial .ace_support.ace_function {\n  color: #588E60\n}\n\n.ace-mono-industrial .ace_entity.ace_name,\n.ace-mono-industrial .ace_support.ace_class,\n.ace-mono-industrial .ace_support.ace_type {\n  color: #5778B6\n}\n\n.ace-mono-industrial .ace_storage {\n  color: #C23B00\n}\n\n.ace-mono-industrial .ace_variable.ace_language,\n.ace-mono-industrial .ace_variable.ace_parameter {\n  color: #648BD2\n}\n\n.ace-mono-industrial .ace_comment {\n  color: #666C68;\n  background-color: #151C19\n}\n\n.ace-mono-industrial .ace_entity.ace_other.ace_attribute-name {\n  color: #909993\n}\n\n.ace-mono-industrial .ace_entity.ace_name.ace_tag {\n  color: #A65EFF\n}\n\n.ace-mono-industrial .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNQ1NbwZfALD/4PAAlTArlEC4r/AAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-mono-industrial .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/mono_industrial", ["require", "exports", "module", "ace/theme/mono_industrial-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-mono-industrial";
      exports2.cssText = require3("./mono_industrial-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/mono_industrial"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-monokai.js
var require_theme_monokai = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-monokai.js"(exports, module2) {
    ace.define("ace/theme/monokai-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-monokai .ace_gutter {\n  background: #2F3129;\n  color: #8F908A\n}\n\n.ace-monokai .ace_print-margin {\n  width: 1px;\n  background: #555651\n}\n\n.ace-monokai {\n  background-color: #272822;\n  color: #F8F8F2\n}\n\n.ace-monokai .ace_cursor {\n  color: #F8F8F0\n}\n\n.ace-monokai .ace_marker-layer .ace_selection {\n  background: #49483E\n}\n\n.ace-monokai.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #272822;\n}\n\n.ace-monokai .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-monokai .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #49483E\n}\n\n.ace-monokai .ace_marker-layer .ace_active-line {\n  background: #202020\n}\n\n.ace-monokai .ace_gutter-active-line {\n  background-color: #272727\n}\n\n.ace-monokai .ace_marker-layer .ace_selected-word {\n  border: 1px solid #49483E\n}\n\n.ace-monokai .ace_invisible {\n  color: #52524d\n}\n\n.ace-monokai .ace_entity.ace_name.ace_tag,\n.ace-monokai .ace_keyword,\n.ace-monokai .ace_meta.ace_tag,\n.ace-monokai .ace_storage {\n  color: #F92672\n}\n\n.ace-monokai .ace_punctuation,\n.ace-monokai .ace_punctuation.ace_tag {\n  color: #fff\n}\n\n.ace-monokai .ace_constant.ace_character,\n.ace-monokai .ace_constant.ace_language,\n.ace-monokai .ace_constant.ace_numeric,\n.ace-monokai .ace_constant.ace_other {\n  color: #AE81FF\n}\n\n.ace-monokai .ace_invalid {\n  color: #F8F8F0;\n  background-color: #F92672\n}\n\n.ace-monokai .ace_invalid.ace_deprecated {\n  color: #F8F8F0;\n  background-color: #AE81FF\n}\n\n.ace-monokai .ace_support.ace_constant,\n.ace-monokai .ace_support.ace_function {\n  color: #66D9EF\n}\n\n.ace-monokai .ace_fold {\n  background-color: #A6E22E;\n  border-color: #F8F8F2\n}\n\n.ace-monokai .ace_storage.ace_type,\n.ace-monokai .ace_support.ace_class,\n.ace-monokai .ace_support.ace_type {\n  font-style: italic;\n  color: #66D9EF\n}\n\n.ace-monokai .ace_entity.ace_name.ace_function,\n.ace-monokai .ace_entity.ace_other,\n.ace-monokai .ace_entity.ace_other.ace_attribute-name,\n.ace-monokai .ace_variable {\n  color: #A6E22E\n}\n\n.ace-monokai .ace_variable.ace_parameter {\n  font-style: italic;\n  color: #FD971F\n}\n\n.ace-monokai .ace_string {\n  color: #E6DB74\n}\n\n.ace-monokai .ace_comment {\n  color: #75715E\n}\n\n.ace-monokai .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ0FD0ZXBzd/wPAAjVAoxeSgNeAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-monokai .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/monokai", ["require", "exports", "module", "ace/theme/monokai-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-monokai";
      exports2.cssText = require3("./monokai-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/monokai"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-nord_dark.js
var require_theme_nord_dark = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-nord_dark.js"(exports, module2) {
    ace.define("ace/theme/nord_dark-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-nord-dark .ace_gutter {\n  color: #616e88;\n}\n\n.ace-nord-dark .ace_print-margin {\n  width: 1px;\n  background: #4c566a;\n}\n\n.ace-nord-dark {\n  background-color: #2e3440;\n  color: #d8dee9;\n}\n\n.ace-nord-dark .ace_entity.ace_other.ace_attribute-name,\n.ace-nord-dark .ace_storage {\n  color: #d8dee9;\n}\n\n.ace-nord-dark .ace_cursor {\n  color: #d8dee9;\n}\n\n.ace-nord-dark .ace_string.ace_regexp {\n  color: #bf616a;\n}\n\n.ace-nord-dark .ace_marker-layer .ace_active-line {\n  background: #434c5ecc;\n}\n.ace-nord-dark .ace_marker-layer .ace_selection {\n  background: #434c5ecc;\n}\n\n.ace-nord-dark.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #2e3440;\n}\n\n.ace-nord-dark .ace_marker-layer .ace_step {\n  background: #ebcb8b;\n}\n\n.ace-nord-dark .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #88c0d066;\n}\n\n.ace-nord-dark .ace_gutter-active-line {\n  background-color: #434c5ecc;\n}\n\n.ace-nord-dark .ace_marker-layer .ace_selected-word {\n  border: 1px solid #88c0d066;\n}\n\n.ace-nord-dark .ace_invisible {\n  color: #4c566a;\n}\n\n.ace-nord-dark .ace_keyword,\n.ace-nord-dark .ace_meta,\n.ace-nord-dark .ace_support.ace_class,\n.ace-nord-dark .ace_support.ace_type {\n  color: #81a1c1;\n}\n\n.ace-nord-dark .ace_constant.ace_character,\n.ace-nord-dark .ace_constant.ace_other {\n  color: #d8dee9;\n}\n\n.ace-nord-dark .ace_constant.ace_language {\n  color: #5e81ac;\n}\n\n.ace-nord-dark .ace_constant.ace_escape {\n  color: #ebcB8b;\n}\n\n.ace-nord-dark .ace_constant.ace_numeric {\n  color: #b48ead;\n}\n\n.ace-nord-dark .ace_fold {\n  background-color: #4c566a;\n  border-color: #d8dee9;\n}\n\n.ace-nord-dark .ace_entity.ace_name.ace_function,\n.ace-nord-dark .ace_entity.ace_name.ace_tag,\n.ace-nord-dark .ace_support.ace_function,\n.ace-nord-dark .ace_variable,\n.ace-nord-dark .ace_variable.ace_language {\n  color: #8fbcbb;\n}\n\n.ace-nord-dark .ace_string {\n  color: #a3be8c;\n}\n\n.ace-nord-dark .ace_comment {\n  color: #616e88;\n}\n\n.ace-nord-dark .ace_indent-guide {\n  box-shadow: inset -1px 0 0 0 #434c5eb3;\n}\n\n.ace-nord-dark .ace_indent-guide-active {\n  box-shadow: inset -1px 0 0 0 #8395b8b3;\n}\n";
    });
    ace.define("ace/theme/nord_dark", ["require", "exports", "module", "ace/theme/nord_dark-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-nord-dark";
      exports2.cssText = require3("./nord_dark-css");
      exports2.$selectionColorConflict = true;
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/nord_dark"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-one_dark.js
var require_theme_one_dark = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-one_dark.js"(exports, module2) {
    ace.define("ace/theme/one_dark-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-one-dark .ace_gutter {\n    background: #282c34;\n    color: #6a6f7a\n}\n\n.ace-one-dark .ace_print-margin {\n    width: 1px;\n    background: #e8e8e8\n}\n\n.ace-one-dark {\n    background-color: #282c34;\n    color: #abb2bf\n}\n\n.ace-one-dark .ace_cursor {\n    color: #528bff\n}\n\n.ace-one-dark .ace_marker-layer .ace_selection {\n    background: #3d4350\n}\n\n.ace-one-dark.ace_multiselect .ace_selection.ace_start {\n    box-shadow: 0 0 3px 0 #282c34;\n    border-radius: 2px\n}\n\n.ace-one-dark .ace_marker-layer .ace_step {\n    background: #c6dbae\n}\n\n.ace-one-dark .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid #747369\n}\n\n.ace-one-dark .ace_marker-layer .ace_active-line {\n    background: rgba(76, 87, 103, .19)\n}\n\n.ace-one-dark .ace_gutter-active-line {\n    background-color: rgba(76, 87, 103, .19)\n}\n\n.ace-one-dark .ace_marker-layer .ace_selected-word {\n    border: 1px solid #3d4350\n}\n\n.ace-one-dark .ace_fold {\n    background-color: #61afef;\n    border-color: #abb2bf\n}\n\n.ace-one-dark .ace_keyword {\n    color: #c678dd\n}\n\n.ace-one-dark .ace_keyword.ace_operator {\n    color: #c678dd\n}\n\n.ace-one-dark .ace_keyword.ace_other.ace_unit {\n    color: #d19a66\n}\n\n.ace-one-dark .ace_constant.ace_language {\n    color: #d19a66\n}\n\n.ace-one-dark .ace_constant.ace_numeric {\n    color: #d19a66\n}\n\n.ace-one-dark .ace_constant.ace_character {\n    color: #56b6c2\n}\n\n.ace-one-dark .ace_constant.ace_other {\n    color: #56b6c2\n}\n\n.ace-one-dark .ace_support.ace_function {\n    color: #61afef\n}\n\n.ace-one-dark .ace_support.ace_constant {\n    color: #d19a66\n}\n\n.ace-one-dark .ace_support.ace_class {\n    color: #e5c07b\n}\n\n.ace-one-dark .ace_support.ace_type {\n    color: #e5c07b\n}\n\n.ace-one-dark .ace_storage {\n    color: #c678dd\n}\n\n.ace-one-dark .ace_storage.ace_type {\n    color: #c678dd\n}\n\n.ace-one-dark .ace_invalid {\n    color: #fff;\n    background-color: #f2777a\n}\n\n.ace-one-dark .ace_invalid.ace_deprecated {\n    color: #272b33;\n    background-color: #d27b53\n}\n\n.ace-one-dark .ace_string {\n    color: #98c379\n}\n\n.ace-one-dark .ace_string.ace_regexp {\n    color: #e06c75\n}\n\n.ace-one-dark .ace_comment {\n    font-style: italic;\n    color: #5c6370\n}\n\n.ace-one-dark .ace_variable {\n    color: #e06c75\n}\n\n.ace-one-dark .ace_variable.ace_parameter {\n    color: #d19a66\n}\n\n.ace-one-dark .ace_meta.ace_tag {\n    color: #e06c75\n}\n\n.ace-one-dark .ace_entity.ace_other.ace_attribute-name {\n    color: #e06c75\n}\n\n.ace-one-dark .ace_entity.ace_name.ace_function {\n    color: #61afef\n}\n\n.ace-one-dark .ace_entity.ace_name.ace_tag {\n    color: #e06c75\n}\n\n.ace-one-dark .ace_markup.ace_heading {\n    color: #98c379\n}\n\n.ace-one-dark .ace_indent-guide {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ09NrYAgMjP4PAAtGAwchHMyAAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-one-dark .ace_indent-guide-active {\n    background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/one_dark", ["require", "exports", "module", "ace/theme/one_dark-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-one-dark";
      exports2.cssText = require3("./one_dark-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/one_dark"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-pastel_on_dark.js
var require_theme_pastel_on_dark = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-pastel_on_dark.js"(exports, module2) {
    ace.define("ace/theme/pastel_on_dark-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-pastel-on-dark .ace_gutter {\n  background: #353030;\n  color: #8F938F\n}\n\n.ace-pastel-on-dark .ace_print-margin {\n  width: 1px;\n  background: #353030\n}\n\n.ace-pastel-on-dark {\n  background-color: #2C2828;\n  color: #8F938F\n}\n\n.ace-pastel-on-dark .ace_cursor {\n  color: #A7A7A7\n}\n\n.ace-pastel-on-dark .ace_marker-layer .ace_selection {\n  background: rgba(221, 240, 255, 0.20)\n}\n\n.ace-pastel-on-dark.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #2C2828;\n}\n\n.ace-pastel-on-dark .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-pastel-on-dark .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(255, 255, 255, 0.25)\n}\n\n.ace-pastel-on-dark .ace_marker-layer .ace_active-line {\n  background: rgba(255, 255, 255, 0.031)\n}\n\n.ace-pastel-on-dark .ace_gutter-active-line {\n  background-color: rgba(255, 255, 255, 0.031)\n}\n\n.ace-pastel-on-dark .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(221, 240, 255, 0.20)\n}\n\n.ace-pastel-on-dark .ace_invisible {\n  color: rgba(255, 255, 255, 0.25)\n}\n\n.ace-pastel-on-dark .ace_keyword,\n.ace-pastel-on-dark .ace_meta {\n  color: #757aD8\n}\n\n.ace-pastel-on-dark .ace_constant,\n.ace-pastel-on-dark .ace_constant.ace_character,\n.ace-pastel-on-dark .ace_constant.ace_character.ace_escape,\n.ace-pastel-on-dark .ace_constant.ace_other {\n  color: #4FB7C5\n}\n\n.ace-pastel-on-dark .ace_keyword.ace_operator {\n  color: #797878\n}\n\n.ace-pastel-on-dark .ace_constant.ace_character {\n  color: #AFA472\n}\n\n.ace-pastel-on-dark .ace_constant.ace_language {\n  color: #DE8E30\n}\n\n.ace-pastel-on-dark .ace_constant.ace_numeric {\n  color: #CCCCCC\n}\n\n.ace-pastel-on-dark .ace_invalid,\n.ace-pastel-on-dark .ace_invalid.ace_illegal {\n  color: #F8F8F8;\n  background-color: rgba(86, 45, 86, 0.75)\n}\n\n.ace-pastel-on-dark .ace_invalid.ace_deprecated {\n  text-decoration: underline;\n  font-style: italic;\n  color: #D2A8A1\n}\n\n.ace-pastel-on-dark .ace_fold {\n  background-color: #757aD8;\n  border-color: #8F938F\n}\n\n.ace-pastel-on-dark .ace_support.ace_function {\n  color: #AEB2F8\n}\n\n.ace-pastel-on-dark .ace_string {\n  color: #66A968\n}\n\n.ace-pastel-on-dark .ace_string.ace_regexp {\n  color: #E9C062\n}\n\n.ace-pastel-on-dark .ace_comment {\n  color: #A6C6FF\n}\n\n.ace-pastel-on-dark .ace_variable {\n  color: #BEBF55\n}\n\n.ace-pastel-on-dark .ace_variable.ace_language {\n  color: #C1C144\n}\n\n.ace-pastel-on-dark .ace_xml-pe {\n  color: #494949\n}\n\n.ace-pastel-on-dark .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYIiPj/8PAARgAh2NTMh8AAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-pastel-on-dark .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/pastel_on_dark", ["require", "exports", "module", "ace/theme/pastel_on_dark-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-pastel-on-dark";
      exports2.cssText = require3("./pastel_on_dark-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/pastel_on_dark"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-solarized_dark.js
var require_theme_solarized_dark = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-solarized_dark.js"(exports, module2) {
    ace.define("ace/theme/solarized_dark-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-solarized-dark .ace_gutter {\n  background: #01313f;\n  color: #d0edf7\n}\n\n.ace-solarized-dark .ace_print-margin {\n  width: 1px;\n  background: #33555E\n}\n\n.ace-solarized-dark {\n  background-color: #002B36;\n  color: #839496\n}\n\n.ace-solarized-dark .ace_entity.ace_other.ace_attribute-name,\n.ace-solarized-dark .ace_storage {\n  color: #839496\n}\n\n.ace-solarized-dark .ace_cursor,\n.ace-solarized-dark .ace_string.ace_regexp {\n  color: #D30102\n}\n\n.ace-solarized-dark .ace_marker-layer .ace_active-line,\n.ace-solarized-dark .ace_marker-layer .ace_selection {\n  background: rgba(255, 255, 255, 0.1)\n}\n\n.ace-solarized-dark.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #002B36;\n}\n\n.ace-solarized-dark .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-solarized-dark .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(147, 161, 161, 0.50)\n}\n\n.ace-solarized-dark .ace_gutter-active-line {\n  background-color: #0d3440\n}\n\n.ace-solarized-dark .ace_marker-layer .ace_selected-word {\n  border: 1px solid #073642\n}\n\n.ace-solarized-dark .ace_invisible {\n  color: rgba(147, 161, 161, 0.50)\n}\n\n.ace-solarized-dark .ace_keyword,\n.ace-solarized-dark .ace_meta,\n.ace-solarized-dark .ace_support.ace_class,\n.ace-solarized-dark .ace_support.ace_type {\n  color: #859900\n}\n\n.ace-solarized-dark .ace_constant.ace_character,\n.ace-solarized-dark .ace_constant.ace_other {\n  color: #CB4B16\n}\n\n.ace-solarized-dark .ace_constant.ace_language {\n  color: #B58900\n}\n\n.ace-solarized-dark .ace_constant.ace_numeric {\n  color: #D33682\n}\n\n.ace-solarized-dark .ace_fold {\n  background-color: #268BD2;\n  border-color: #93A1A1\n}\n\n.ace-solarized-dark .ace_entity.ace_name.ace_function,\n.ace-solarized-dark .ace_entity.ace_name.ace_tag,\n.ace-solarized-dark .ace_support.ace_function,\n.ace-solarized-dark .ace_variable,\n.ace-solarized-dark .ace_variable.ace_language {\n  color: #268BD2\n}\n\n.ace-solarized-dark .ace_string {\n  color: #2AA198\n}\n\n.ace-solarized-dark .ace_comment {\n  font-style: italic;\n  color: #657B83\n}\n\n.ace-solarized-dark .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNg0Db1ZVCxc/sPAAd4AlUHlLenAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-solarized-dark .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/solarized_dark", ["require", "exports", "module", "ace/theme/solarized_dark-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-solarized-dark";
      exports2.cssText = require3("./solarized_dark-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/solarized_dark"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-terminal.js
var require_theme_terminal = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-terminal.js"(exports, module2) {
    ace.define("ace/theme/terminal-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-terminal-theme .ace_gutter {\n  background: #1a0005;\n  color: steelblue\n}\n\n.ace-terminal-theme .ace_print-margin {\n  width: 1px;\n  background: #1a1a1a\n}\n\n.ace-terminal-theme {\n  background-color: black;\n  color: #DEDEDE\n}\n\n.ace-terminal-theme .ace_cursor {\n  color: #9F9F9F\n}\n\n.ace-terminal-theme .ace_marker-layer .ace_selection {\n  background: #424242\n}\n\n.ace-terminal-theme.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px black;\n}\n\n.ace-terminal-theme .ace_marker-layer .ace_step {\n  background: rgb(0, 0, 0)\n}\n\n.ace-terminal-theme .ace_marker-layer .ace_bracket {\n  background: #090;\n}\n\n.ace-terminal-theme .ace_marker-layer .ace_bracket-start {\n  background: #090;\n}\n\n.ace-terminal-theme .ace_marker-layer .ace_bracket-unmatched {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #900\n}\n\n.ace-terminal-theme .ace_marker-layer .ace_active-line {\n  background: #2A2A2A\n}\n\n.ace-terminal-theme .ace_gutter-active-line {\n  background-color: #2A112A\n}\n\n.ace-terminal-theme .ace_marker-layer .ace_selected-word {\n  border: 1px solid #424242\n}\n\n.ace-terminal-theme .ace_invisible {\n  color: #343434\n}\n\n.ace-terminal-theme .ace_keyword,\n.ace-terminal-theme .ace_meta,\n.ace-terminal-theme .ace_storage,\n.ace-terminal-theme .ace_storage.ace_type,\n.ace-terminal-theme .ace_support.ace_type {\n  color: tomato\n}\n\n.ace-terminal-theme .ace_keyword.ace_operator {\n  color: deeppink\n}\n\n.ace-terminal-theme .ace_constant.ace_character,\n.ace-terminal-theme .ace_constant.ace_language,\n.ace-terminal-theme .ace_constant.ace_numeric,\n.ace-terminal-theme .ace_keyword.ace_other.ace_unit,\n.ace-terminal-theme .ace_support.ace_constant,\n.ace-terminal-theme .ace_variable.ace_parameter {\n  color: #E78C45\n}\n\n.ace-terminal-theme .ace_constant.ace_other {\n  color: gold\n}\n\n.ace-terminal-theme .ace_invalid {\n  color: yellow;\n  background-color: red\n}\n\n.ace-terminal-theme .ace_invalid.ace_deprecated {\n  color: #CED2CF;\n  background-color: #B798BF\n}\n\n.ace-terminal-theme .ace_fold {\n  background-color: #7AA6DA;\n  border-color: #DEDEDE\n}\n\n.ace-terminal-theme .ace_entity.ace_name.ace_function,\n.ace-terminal-theme .ace_support.ace_function,\n.ace-terminal-theme .ace_variable {\n  color: #7AA6DA\n}\n\n.ace-terminal-theme .ace_support.ace_class,\n.ace-terminal-theme .ace_support.ace_type {\n  color: #E7C547\n}\n\n.ace-terminal-theme .ace_heading,\n.ace-terminal-theme .ace_string {\n  color: #B9CA4A\n}\n\n.ace-terminal-theme .ace_entity.ace_name.ace_tag,\n.ace-terminal-theme .ace_entity.ace_other.ace_attribute-name,\n.ace-terminal-theme .ace_meta.ace_tag,\n.ace-terminal-theme .ace_string.ace_regexp,\n.ace-terminal-theme .ace_variable {\n  color: #D54E53\n}\n\n.ace-terminal-theme .ace_comment {\n  color: orangered\n}\n\n.ace-terminal-theme .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYLBWV/8PAAK4AYnhiq+xAAAAAElFTkSuQmCC) right repeat-y;\n}\n\n.ace-terminal-theme .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/terminal", ["require", "exports", "module", "ace/theme/terminal-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-terminal-theme";
      exports2.cssText = require3("./terminal-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/terminal"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-tomorrow_night.js
var require_theme_tomorrow_night = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-tomorrow_night.js"(exports, module2) {
    ace.define("ace/theme/tomorrow_night-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-tomorrow-night .ace_gutter {\n  background: #25282c;\n  color: #C5C8C6\n}\n\n.ace-tomorrow-night .ace_print-margin {\n  width: 1px;\n  background: #25282c\n}\n\n.ace-tomorrow-night {\n  background-color: #1D1F21;\n  color: #C5C8C6\n}\n\n.ace-tomorrow-night .ace_cursor {\n  color: #AEAFAD\n}\n\n.ace-tomorrow-night .ace_marker-layer .ace_selection {\n  background: #373B41\n}\n\n.ace-tomorrow-night.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #1D1F21;\n}\n\n.ace-tomorrow-night .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-tomorrow-night .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #4B4E55\n}\n\n.ace-tomorrow-night .ace_marker-layer .ace_active-line {\n  background: #282A2E\n}\n\n.ace-tomorrow-night .ace_gutter-active-line {\n  background-color: #282A2E\n}\n\n.ace-tomorrow-night .ace_marker-layer .ace_selected-word {\n  border: 1px solid #373B41\n}\n\n.ace-tomorrow-night .ace_invisible {\n  color: #4B4E55\n}\n\n.ace-tomorrow-night .ace_keyword,\n.ace-tomorrow-night .ace_meta,\n.ace-tomorrow-night .ace_storage,\n.ace-tomorrow-night .ace_storage.ace_type,\n.ace-tomorrow-night .ace_support.ace_type {\n  color: #B294BB\n}\n\n.ace-tomorrow-night .ace_keyword.ace_operator {\n  color: #8ABEB7\n}\n\n.ace-tomorrow-night .ace_constant.ace_character,\n.ace-tomorrow-night .ace_constant.ace_language,\n.ace-tomorrow-night .ace_constant.ace_numeric,\n.ace-tomorrow-night .ace_keyword.ace_other.ace_unit,\n.ace-tomorrow-night .ace_support.ace_constant,\n.ace-tomorrow-night .ace_variable.ace_parameter {\n  color: #DE935F\n}\n\n.ace-tomorrow-night .ace_constant.ace_other {\n  color: #CED1CF\n}\n\n.ace-tomorrow-night .ace_invalid {\n  color: #CED2CF;\n  background-color: #DF5F5F\n}\n\n.ace-tomorrow-night .ace_invalid.ace_deprecated {\n  color: #CED2CF;\n  background-color: #B798BF\n}\n\n.ace-tomorrow-night .ace_fold {\n  background-color: #81A2BE;\n  border-color: #C5C8C6\n}\n\n.ace-tomorrow-night .ace_entity.ace_name.ace_function,\n.ace-tomorrow-night .ace_support.ace_function,\n.ace-tomorrow-night .ace_variable {\n  color: #81A2BE\n}\n\n.ace-tomorrow-night .ace_support.ace_class,\n.ace-tomorrow-night .ace_support.ace_type {\n  color: #F0C674\n}\n\n.ace-tomorrow-night .ace_heading,\n.ace-tomorrow-night .ace_markup.ace_heading,\n.ace-tomorrow-night .ace_string {\n  color: #B5BD68\n}\n\n.ace-tomorrow-night .ace_entity.ace_name.ace_tag,\n.ace-tomorrow-night .ace_entity.ace_other.ace_attribute-name,\n.ace-tomorrow-night .ace_meta.ace_tag,\n.ace-tomorrow-night .ace_string.ace_regexp,\n.ace-tomorrow-night .ace_variable {\n  color: #CC6666\n}\n\n.ace-tomorrow-night .ace_comment {\n  color: #969896\n}\n\n.ace-tomorrow-night .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHB3d/8PAAOIAdULw8qMAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-tomorrow-night .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/tomorrow_night", ["require", "exports", "module", "ace/theme/tomorrow_night-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-tomorrow-night";
      exports2.cssText = require3("./tomorrow_night-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/tomorrow_night"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-tomorrow_night_blue.js
var require_theme_tomorrow_night_blue = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-tomorrow_night_blue.js"(exports, module2) {
    ace.define("ace/theme/tomorrow_night_blue-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-tomorrow-night-blue .ace_gutter {\n  background: #00204b;\n  color: #7388b5\n}\n\n.ace-tomorrow-night-blue .ace_print-margin {\n  width: 1px;\n  background: #00204b\n}\n\n.ace-tomorrow-night-blue {\n  background-color: #002451;\n  color: #FFFFFF\n}\n\n.ace-tomorrow-night-blue .ace_constant.ace_other,\n.ace-tomorrow-night-blue .ace_cursor {\n  color: #FFFFFF\n}\n\n.ace-tomorrow-night-blue .ace_marker-layer .ace_selection {\n  background: #003F8E\n}\n\n.ace-tomorrow-night-blue.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #002451;\n}\n\n.ace-tomorrow-night-blue .ace_marker-layer .ace_step {\n  background: rgb(127, 111, 19)\n}\n\n.ace-tomorrow-night-blue .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #404F7D\n}\n\n.ace-tomorrow-night-blue .ace_marker-layer .ace_active-line {\n  background: #00346E\n}\n\n.ace-tomorrow-night-blue .ace_gutter-active-line {\n  background-color: #022040\n}\n\n.ace-tomorrow-night-blue .ace_marker-layer .ace_selected-word {\n  border: 1px solid #003F8E\n}\n\n.ace-tomorrow-night-blue .ace_invisible {\n  color: #404F7D\n}\n\n.ace-tomorrow-night-blue .ace_keyword,\n.ace-tomorrow-night-blue .ace_meta,\n.ace-tomorrow-night-blue .ace_storage,\n.ace-tomorrow-night-blue .ace_storage.ace_type,\n.ace-tomorrow-night-blue .ace_support.ace_type {\n  color: #EBBBFF\n}\n\n.ace-tomorrow-night-blue .ace_keyword.ace_operator {\n  color: #99FFFF\n}\n\n.ace-tomorrow-night-blue .ace_constant.ace_character,\n.ace-tomorrow-night-blue .ace_constant.ace_language,\n.ace-tomorrow-night-blue .ace_constant.ace_numeric,\n.ace-tomorrow-night-blue .ace_keyword.ace_other.ace_unit,\n.ace-tomorrow-night-blue .ace_support.ace_constant,\n.ace-tomorrow-night-blue .ace_variable.ace_parameter {\n  color: #FFC58F\n}\n\n.ace-tomorrow-night-blue .ace_invalid {\n  color: #FFFFFF;\n  background-color: #F99DA5\n}\n\n.ace-tomorrow-night-blue .ace_invalid.ace_deprecated {\n  color: #FFFFFF;\n  background-color: #EBBBFF\n}\n\n.ace-tomorrow-night-blue .ace_fold {\n  background-color: #BBDAFF;\n  border-color: #FFFFFF\n}\n\n.ace-tomorrow-night-blue .ace_entity.ace_name.ace_function,\n.ace-tomorrow-night-blue .ace_support.ace_function,\n.ace-tomorrow-night-blue .ace_variable {\n  color: #BBDAFF\n}\n\n.ace-tomorrow-night-blue .ace_support.ace_class,\n.ace-tomorrow-night-blue .ace_support.ace_type {\n  color: #FFEEAD\n}\n\n.ace-tomorrow-night-blue .ace_heading,\n.ace-tomorrow-night-blue .ace_markup.ace_heading,\n.ace-tomorrow-night-blue .ace_string {\n  color: #D1F1A9\n}\n\n.ace-tomorrow-night-blue .ace_entity.ace_name.ace_tag,\n.ace-tomorrow-night-blue .ace_entity.ace_other.ace_attribute-name,\n.ace-tomorrow-night-blue .ace_meta.ace_tag,\n.ace-tomorrow-night-blue .ace_string.ace_regexp,\n.ace-tomorrow-night-blue .ace_variable {\n  color: #FF9DA4\n}\n\n.ace-tomorrow-night-blue .ace_comment {\n  color: #7285B7\n}\n\n.ace-tomorrow-night-blue .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYJDzqfwPAANXAeNsiA+ZAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-tomorrow-night-blue .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/tomorrow_night_blue", ["require", "exports", "module", "ace/theme/tomorrow_night_blue-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-tomorrow-night-blue";
      exports2.cssText = require3("./tomorrow_night_blue-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/tomorrow_night_blue"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-tomorrow_night_bright.js
var require_theme_tomorrow_night_bright = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-tomorrow_night_bright.js"(exports, module2) {
    ace.define("ace/theme/tomorrow_night_bright-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-tomorrow-night-bright .ace_gutter {\n  background: #1a1a1a;\n  color: #DEDEDE\n}\n\n.ace-tomorrow-night-bright .ace_print-margin {\n  width: 1px;\n  background: #1a1a1a\n}\n\n.ace-tomorrow-night-bright {\n  background-color: #000000;\n  color: #DEDEDE\n}\n\n.ace-tomorrow-night-bright .ace_cursor {\n  color: #9F9F9F\n}\n\n.ace-tomorrow-night-bright .ace_marker-layer .ace_selection {\n  background: #424242\n}\n\n.ace-tomorrow-night-bright.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #000000;\n}\n\n.ace-tomorrow-night-bright .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-tomorrow-night-bright .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #888888\n}\n\n.ace-tomorrow-night-bright .ace_marker-layer .ace_highlight {\n  border: 1px solid rgb(110, 119, 0);\n  border-bottom: 0;\n  box-shadow: inset 0 -1px rgb(110, 119, 0);\n  margin: -1px 0 0 -1px;\n  background: rgba(255, 235, 0, 0.1)\n}\n\n.ace-tomorrow-night-bright .ace_marker-layer .ace_active-line {\n  background: #2A2A2A\n}\n\n.ace-tomorrow-night-bright .ace_gutter-active-line {\n  background-color: #2A2A2A\n}\n\n.ace-tomorrow-night-bright .ace_stack {\n  background-color: rgb(66, 90, 44)\n}\n\n.ace-tomorrow-night-bright .ace_marker-layer .ace_selected-word {\n  border: 1px solid #888888\n}\n\n.ace-tomorrow-night-bright .ace_invisible {\n  color: #343434\n}\n\n.ace-tomorrow-night-bright .ace_keyword,\n.ace-tomorrow-night-bright .ace_meta,\n.ace-tomorrow-night-bright .ace_storage,\n.ace-tomorrow-night-bright .ace_storage.ace_type,\n.ace-tomorrow-night-bright .ace_support.ace_type {\n  color: #C397D8\n}\n\n.ace-tomorrow-night-bright .ace_keyword.ace_operator {\n  color: #70C0B1\n}\n\n.ace-tomorrow-night-bright .ace_constant.ace_character,\n.ace-tomorrow-night-bright .ace_constant.ace_language,\n.ace-tomorrow-night-bright .ace_constant.ace_numeric,\n.ace-tomorrow-night-bright .ace_keyword.ace_other.ace_unit,\n.ace-tomorrow-night-bright .ace_support.ace_constant,\n.ace-tomorrow-night-bright .ace_variable.ace_parameter {\n  color: #E78C45\n}\n\n.ace-tomorrow-night-bright .ace_constant.ace_other {\n  color: #EEEEEE\n}\n\n.ace-tomorrow-night-bright .ace_invalid {\n  color: #CED2CF;\n  background-color: #DF5F5F\n}\n\n.ace-tomorrow-night-bright .ace_invalid.ace_deprecated {\n  color: #CED2CF;\n  background-color: #B798BF\n}\n\n.ace-tomorrow-night-bright .ace_fold {\n  background-color: #7AA6DA;\n  border-color: #DEDEDE\n}\n\n.ace-tomorrow-night-bright .ace_entity.ace_name.ace_function,\n.ace-tomorrow-night-bright .ace_support.ace_function,\n.ace-tomorrow-night-bright .ace_variable {\n  color: #7AA6DA\n}\n\n.ace-tomorrow-night-bright .ace_support.ace_class,\n.ace-tomorrow-night-bright .ace_support.ace_type {\n  color: #E7C547\n}\n\n.ace-tomorrow-night-bright .ace_heading,\n.ace-tomorrow-night-bright .ace_markup.ace_heading,\n.ace-tomorrow-night-bright .ace_string {\n  color: #B9CA4A\n}\n\n.ace-tomorrow-night-bright .ace_entity.ace_name.ace_tag,\n.ace-tomorrow-night-bright .ace_entity.ace_other.ace_attribute-name,\n.ace-tomorrow-night-bright .ace_meta.ace_tag,\n.ace-tomorrow-night-bright .ace_string.ace_regexp,\n.ace-tomorrow-night-bright .ace_variable {\n  color: #D54E53\n}\n\n.ace-tomorrow-night-bright .ace_comment {\n  color: #969896\n}\n\n.ace-tomorrow-night-bright .ace_c9searchresults.ace_keyword {\n  color: #C2C280\n}\n\n.ace-tomorrow-night-bright .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYFBXV/8PAAJoAXX4kT2EAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-tomorrow-night-bright .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/tomorrow_night_bright", ["require", "exports", "module", "ace/theme/tomorrow_night_bright-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-tomorrow-night-bright";
      exports2.cssText = require3("./tomorrow_night_bright-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/tomorrow_night_bright"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-tomorrow_night_eighties.js
var require_theme_tomorrow_night_eighties = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-tomorrow_night_eighties.js"(exports, module2) {
    ace.define("ace/theme/tomorrow_night_eighties-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-tomorrow-night-eighties .ace_gutter {\n  background: #272727;\n  color: #CCC\n}\n\n.ace-tomorrow-night-eighties .ace_print-margin {\n  width: 1px;\n  background: #272727\n}\n\n.ace-tomorrow-night-eighties {\n  background-color: #2D2D2D;\n  color: #CCCCCC\n}\n\n.ace-tomorrow-night-eighties .ace_constant.ace_other,\n.ace-tomorrow-night-eighties .ace_cursor {\n  color: #CCCCCC\n}\n\n.ace-tomorrow-night-eighties .ace_marker-layer .ace_selection {\n  background: #515151\n}\n\n.ace-tomorrow-night-eighties.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #2D2D2D;\n}\n\n.ace-tomorrow-night-eighties .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-tomorrow-night-eighties .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #6A6A6A\n}\n\n.ace-tomorrow-night-bright .ace_stack {\n  background: rgb(66, 90, 44)\n}\n\n.ace-tomorrow-night-eighties .ace_marker-layer .ace_active-line {\n  background: #393939\n}\n\n.ace-tomorrow-night-eighties .ace_gutter-active-line {\n  background-color: #393939\n}\n\n.ace-tomorrow-night-eighties .ace_marker-layer .ace_selected-word {\n  border: 1px solid #515151\n}\n\n.ace-tomorrow-night-eighties .ace_invisible {\n  color: #6A6A6A\n}\n\n.ace-tomorrow-night-eighties .ace_keyword,\n.ace-tomorrow-night-eighties .ace_meta,\n.ace-tomorrow-night-eighties .ace_storage,\n.ace-tomorrow-night-eighties .ace_storage.ace_type,\n.ace-tomorrow-night-eighties .ace_support.ace_type {\n  color: #CC99CC\n}\n\n.ace-tomorrow-night-eighties .ace_keyword.ace_operator {\n  color: #66CCCC\n}\n\n.ace-tomorrow-night-eighties .ace_constant.ace_character,\n.ace-tomorrow-night-eighties .ace_constant.ace_language,\n.ace-tomorrow-night-eighties .ace_constant.ace_numeric,\n.ace-tomorrow-night-eighties .ace_keyword.ace_other.ace_unit,\n.ace-tomorrow-night-eighties .ace_support.ace_constant,\n.ace-tomorrow-night-eighties .ace_variable.ace_parameter {\n  color: #F99157\n}\n\n.ace-tomorrow-night-eighties .ace_invalid {\n  color: #CDCDCD;\n  background-color: #F2777A\n}\n\n.ace-tomorrow-night-eighties .ace_invalid.ace_deprecated {\n  color: #CDCDCD;\n  background-color: #CC99CC\n}\n\n.ace-tomorrow-night-eighties .ace_fold {\n  background-color: #6699CC;\n  border-color: #CCCCCC\n}\n\n.ace-tomorrow-night-eighties .ace_entity.ace_name.ace_function,\n.ace-tomorrow-night-eighties .ace_support.ace_function,\n.ace-tomorrow-night-eighties .ace_variable {\n  color: #6699CC\n}\n\n.ace-tomorrow-night-eighties .ace_support.ace_class,\n.ace-tomorrow-night-eighties .ace_support.ace_type {\n  color: #FFCC66\n}\n\n.ace-tomorrow-night-eighties .ace_heading,\n.ace-tomorrow-night-eighties .ace_markup.ace_heading,\n.ace-tomorrow-night-eighties .ace_string {\n  color: #99CC99\n}\n\n.ace-tomorrow-night-eighties .ace_comment {\n  color: #999999\n}\n\n.ace-tomorrow-night-eighties .ace_entity.ace_name.ace_tag,\n.ace-tomorrow-night-eighties .ace_entity.ace_other.ace_attribute-name,\n.ace-tomorrow-night-eighties .ace_meta.ace_tag,\n.ace-tomorrow-night-eighties .ace_variable {\n  color: #F2777A\n}\n\n.ace-tomorrow-night-eighties .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ09NrYAgMjP4PAAtGAwchHMyAAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-tomorrow-night-eighties .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/tomorrow_night_eighties", ["require", "exports", "module", "ace/theme/tomorrow_night_eighties-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-tomorrow-night-eighties";
      exports2.cssText = require3("./tomorrow_night_eighties-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/tomorrow_night_eighties"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-twilight.js
var require_theme_twilight = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-twilight.js"(exports, module2) {
    ace.define("ace/theme/twilight-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-twilight .ace_gutter {\n  background: #232323;\n  color: #E2E2E2\n}\n\n.ace-twilight .ace_print-margin {\n  width: 1px;\n  background: #232323\n}\n\n.ace-twilight {\n  background-color: #141414;\n  color: #F8F8F8\n}\n\n.ace-twilight .ace_cursor {\n  color: #A7A7A7\n}\n\n.ace-twilight .ace_marker-layer .ace_selection {\n  background: rgba(221, 240, 255, 0.20)\n}\n\n.ace-twilight.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #141414;\n}\n\n.ace-twilight .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-twilight .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgba(255, 255, 255, 0.25)\n}\n\n.ace-twilight .ace_marker-layer .ace_active-line {\n  background: rgba(255, 255, 255, 0.031)\n}\n\n.ace-twilight .ace_gutter-active-line {\n  background-color: rgba(255, 255, 255, 0.031)\n}\n\n.ace-twilight .ace_marker-layer .ace_selected-word {\n  border: 1px solid rgba(221, 240, 255, 0.20)\n}\n\n.ace-twilight .ace_invisible {\n  color: rgba(255, 255, 255, 0.25)\n}\n\n.ace-twilight .ace_keyword,\n.ace-twilight .ace_meta {\n  color: #CDA869\n}\n\n.ace-twilight .ace_constant,\n.ace-twilight .ace_constant.ace_character,\n.ace-twilight .ace_constant.ace_character.ace_escape,\n.ace-twilight .ace_constant.ace_other,\n.ace-twilight .ace_heading,\n.ace-twilight .ace_markup.ace_heading,\n.ace-twilight .ace_support.ace_constant {\n  color: #CF6A4C\n}\n\n.ace-twilight .ace_invalid.ace_illegal {\n  color: #F8F8F8;\n  background-color: rgba(86, 45, 86, 0.75)\n}\n\n.ace-twilight .ace_invalid.ace_deprecated {\n  text-decoration: underline;\n  font-style: italic;\n  color: #D2A8A1\n}\n\n.ace-twilight .ace_support {\n  color: #9B859D\n}\n\n.ace-twilight .ace_fold {\n  background-color: #AC885B;\n  border-color: #F8F8F8\n}\n\n.ace-twilight .ace_support.ace_function {\n  color: #DAD085\n}\n\n.ace-twilight .ace_list,\n.ace-twilight .ace_markup.ace_list,\n.ace-twilight .ace_storage {\n  color: #F9EE98\n}\n\n.ace-twilight .ace_entity.ace_name.ace_function,\n.ace-twilight .ace_meta.ace_tag {\n  color: #AC885B\n}\n\n.ace-twilight .ace_string {\n  color: #8F9D6A\n}\n\n.ace-twilight .ace_string.ace_regexp {\n  color: #E9C062\n}\n\n.ace-twilight .ace_comment {\n  font-style: italic;\n  color: #5F5A60\n}\n\n.ace-twilight .ace_variable {\n  color: #7587A6\n}\n\n.ace-twilight .ace_xml-pe {\n  color: #494949\n}\n\n.ace-twilight .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWMQERFpYLC1tf0PAAgOAnPnhxyiAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-twilight .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/twilight", ["require", "exports", "module", "ace/theme/twilight-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-twilight";
      exports2.cssText = require3("./twilight-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/twilight"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/ace-builds/src-noconflict/theme-vibrant_ink.js
var require_theme_vibrant_ink = __commonJS({
  "node_modules/ace-builds/src-noconflict/theme-vibrant_ink.js"(exports, module2) {
    ace.define("ace/theme/vibrant_ink-css", ["require", "exports", "module"], function(require3, exports2, module3) {
      module3.exports = ".ace-vibrant-ink .ace_gutter {\n  background: #1a1a1a;\n  color: #BEBEBE\n}\n\n.ace-vibrant-ink .ace_print-margin {\n  width: 1px;\n  background: #1a1a1a\n}\n\n.ace-vibrant-ink {\n  background-color: #0F0F0F;\n  color: #FFFFFF\n}\n\n.ace-vibrant-ink .ace_cursor {\n  color: #FFFFFF\n}\n\n.ace-vibrant-ink .ace_marker-layer .ace_selection {\n  background: #6699CC\n}\n\n.ace-vibrant-ink.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px #0F0F0F;\n}\n\n.ace-vibrant-ink .ace_marker-layer .ace_step {\n  background: rgb(102, 82, 0)\n}\n\n.ace-vibrant-ink .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid #404040\n}\n\n.ace-vibrant-ink .ace_marker-layer .ace_active-line {\n  background: #333333\n}\n\n.ace-vibrant-ink .ace_gutter-active-line {\n  background-color: #333333\n}\n\n.ace-vibrant-ink .ace_marker-layer .ace_selected-word {\n  border: 1px solid #6699CC\n}\n\n.ace-vibrant-ink .ace_invisible {\n  color: #404040\n}\n\n.ace-vibrant-ink .ace_keyword,\n.ace-vibrant-ink .ace_meta {\n  color: #FF6600\n}\n\n.ace-vibrant-ink .ace_constant,\n.ace-vibrant-ink .ace_constant.ace_character,\n.ace-vibrant-ink .ace_constant.ace_character.ace_escape,\n.ace-vibrant-ink .ace_constant.ace_other {\n  color: #339999\n}\n\n.ace-vibrant-ink .ace_constant.ace_numeric {\n  color: #99CC99\n}\n\n.ace-vibrant-ink .ace_invalid,\n.ace-vibrant-ink .ace_invalid.ace_deprecated {\n  color: #CCFF33;\n  background-color: #000000\n}\n\n.ace-vibrant-ink .ace_fold {\n  background-color: #FFCC00;\n  border-color: #FFFFFF\n}\n\n.ace-vibrant-ink .ace_entity.ace_name.ace_function,\n.ace-vibrant-ink .ace_support.ace_function,\n.ace-vibrant-ink .ace_variable {\n  color: #FFCC00\n}\n\n.ace-vibrant-ink .ace_variable.ace_parameter {\n  font-style: italic\n}\n\n.ace-vibrant-ink .ace_string {\n  color: #66FF00\n}\n\n.ace-vibrant-ink .ace_string.ace_regexp {\n  color: #44B4CC\n}\n\n.ace-vibrant-ink .ace_comment {\n  color: #9933CC\n}\n\n.ace-vibrant-ink .ace_entity.ace_other.ace_attribute-name {\n  font-style: italic;\n  color: #99CC99\n}\n\n.ace-vibrant-ink .ace_indent-guide {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYNDTc/oPAALPAZ7hxlbYAAAAAElFTkSuQmCC) right repeat-y\n}\n\n.ace-vibrant-ink .ace_indent-guide-active {\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;\n}\n";
    });
    ace.define("ace/theme/vibrant_ink", ["require", "exports", "module", "ace/theme/vibrant_ink-css", "ace/lib/dom"], function(require3, exports2, module3) {
      exports2.isDark = true;
      exports2.cssClass = "ace-vibrant-ink";
      exports2.cssText = require3("./vibrant_ink-css");
      var dom = require3("../lib/dom");
      dom.importCssString(exports2.cssText, exports2.cssClass, false);
    });
    (function() {
      ace.require(["ace/theme/vibrant_ink"], function(m) {
        if (typeof module2 == "object" && typeof exports == "object" && module2) {
          module2.exports = m;
        }
      });
    })();
  }
});

// node_modules/file-saver/dist/FileSaver.min.js
var require_FileSaver_min = __commonJS({
  "node_modules/file-saver/dist/FileSaver.min.js"(exports, module2) {
    (function(a, b2) {
      if ("function" == typeof define && define.amd) define([], b2);
      else if ("undefined" != typeof exports) b2();
      else {
        b2(), a.FileSaver = { exports: {} }.exports;
      }
    })(exports, function() {
      "use strict";
      function b2(a2, b3) {
        return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
      }
      function c(a2, b3, c2) {
        var d2 = new XMLHttpRequest();
        d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
          g3(d2.response, b3, c2);
        }, d2.onerror = function() {
          console.error("could not download file");
        }, d2.send();
      }
      function d(a2) {
        var b3 = new XMLHttpRequest();
        b3.open("HEAD", a2, false);
        try {
          b3.send();
        } catch (a3) {
        }
        return 200 <= b3.status && 299 >= b3.status;
      }
      function e(a2) {
        try {
          a2.dispatchEvent(new MouseEvent("click"));
        } catch (c2) {
          var b3 = document.createEvent("MouseEvents");
          b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b3);
        }
      }
      var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g3 = f.saveAs || ("object" != typeof window || window !== f ? function() {
      } : "download" in HTMLAnchorElement.prototype && !a ? function(b3, g4, h) {
        var i = f.URL || f.webkitURL, j3 = document.createElement("a");
        g4 = g4 || b3.name || "download", j3.download = g4, j3.rel = "noopener", "string" == typeof b3 ? (j3.href = b3, j3.origin === location.origin ? e(j3) : d(j3.href) ? c(b3, g4, h) : e(j3, j3.target = "_blank")) : (j3.href = i.createObjectURL(b3), setTimeout(function() {
          i.revokeObjectURL(j3.href);
        }, 4e4), setTimeout(function() {
          e(j3);
        }, 0));
      } : "msSaveOrOpenBlob" in navigator ? function(f2, g4, h) {
        if (g4 = g4 || f2.name || "download", "string" != typeof f2) navigator.msSaveOrOpenBlob(b2(f2, h), g4);
        else if (d(f2)) c(f2, g4, h);
        else {
          var i = document.createElement("a");
          i.href = f2, i.target = "_blank", setTimeout(function() {
            e(i);
          });
        }
      } : function(b3, d2, e2, g4) {
        if (g4 = g4 || open("", "_blank"), g4 && (g4.document.title = g4.document.body.innerText = "downloading..."), "string" == typeof b3) return c(b3, d2, e2);
        var h = "application/octet-stream" === b3.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j3 = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j3 || h && i || a) && "undefined" != typeof FileReader) {
          var k2 = new FileReader();
          k2.onloadend = function() {
            var a2 = k2.result;
            a2 = j3 ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g4 ? g4.location.href = a2 : location = a2, g4 = null;
          }, k2.readAsDataURL(b3);
        } else {
          var l = f.URL || f.webkitURL, m = l.createObjectURL(b3);
          g4 ? g4.location = m : location.href = m, g4 = null, setTimeout(function() {
            l.revokeObjectURL(m);
          }, 4e4);
        }
      });
      f.saveAs = g3.saveAs = g3, "undefined" != typeof module2 && (module2.exports = g3);
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CustomThemeStudioPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian20 = require("obsidian");

// src/views/customThemeStudioView.ts
var import_obsidian17 = require("obsidian");

// src/managers/element/ElementSelectorManager.ts
var import_obsidian3 = require("obsidian");

// src/utils/index.ts
var import_obsidian = require("obsidian");

// src/constants.ts
var DEBOUNCE_DELAYS = {
  /** Delay for variable value updates */
  VARIABLE_UPDATE: 1e3,
  /** Delay for CSS editor change events */
  CSS_EDITOR_CHANGE: 500,
  /** Delay for search input changes */
  SEARCH_INPUT: 300
};
var TIMEOUT_DELAYS = {
  /** Delay before scrolling to element */
  SCROLL_DELAY: 100,
  /** Delay for element selection initialization */
  ELEMENT_SELECTION: 300
};
var NOTICE_DURATIONS = {
  /** Short notice duration for quick feedback */
  SHORT: 3e3,
  /** Standard notice duration */
  STANDARD: 5e3,
  /** Long notice duration for important messages */
  LONG: 1e4
};
var UI_CONSTANTS = {
  /** Scroll offset from top in pixels */
  SCROLL_OFFSET: 10
};

// src/utils/Logger.ts
var LOG_LEVEL_PRIORITY = {
  none: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
};
var Logger = class _Logger {
  /**
   * Initialize the logger with the plugin instance
   */
  static init(plugin) {
    _Logger.plugin = plugin;
  }
  /**
   * Check if a log level should be output based on current settings
   */
  static shouldLog(level) {
    if (!_Logger.plugin) return false;
    const currentLevel = _Logger.plugin.settings.debugLevel;
    return LOG_LEVEL_PRIORITY[level] <= LOG_LEVEL_PRIORITY[currentLevel];
  }
  /**
   * Format the log message with timestamp and location
   */
  static formatMessage(level, message, location2) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace("T", " ").substring(0, 19);
    const locationStr = location2 ? ` [${location2}]` : "";
    return `[CTS:${level}] ${timestamp}${locationStr} ${message}`;
  }
  /**
   * Get the calling location (file:line)
   */
  static getLocation() {
    try {
      const stack = new Error().stack;
      if (!stack) return "";
      const lines = stack.split("\n");
      const callerLine = lines[4];
      if (!callerLine) return "";
      const match = callerLine.match(/at\s+(?:.*\s+)?\(?(.+):(\d+):\d+\)?/);
      if (match) {
        const fullPath = match[1];
        const line = match[2];
        const filename = fullPath.split("/").pop() || fullPath;
        return `${filename}:${line}`;
      }
    } catch (e) {
    }
    return "";
  }
  /**
   * Log a debug message (most verbose)
   */
  static debug(message, data) {
    if (!_Logger.shouldLog("debug")) return;
    const location2 = _Logger.getLocation();
    const formattedMessage = _Logger.formatMessage("Debug", message, location2);
    if (data !== void 0) {
      console.log(formattedMessage, data);
    } else {
      console.log(formattedMessage);
    }
  }
  /**
   * Log an info message
   */
  static info(message, data) {
    if (!_Logger.shouldLog("info")) return;
    const location2 = _Logger.getLocation();
    const formattedMessage = _Logger.formatMessage("Info", message, location2);
    if (data !== void 0) {
      console.info(formattedMessage, data);
    } else {
      console.info(formattedMessage);
    }
  }
  /**
   * Log a warning message
   */
  static warn(message, data) {
    if (!_Logger.shouldLog("warn")) return;
    const location2 = _Logger.getLocation();
    const formattedMessage = _Logger.formatMessage("Warn", message, location2);
    if (data !== void 0) {
      console.warn(formattedMessage, data);
    } else {
      console.warn(formattedMessage);
    }
  }
  /**
   * Log an error message
   */
  static error(message, data) {
    if (!_Logger.shouldLog("error")) return;
    const location2 = _Logger.getLocation();
    const formattedMessage = _Logger.formatMessage("Error", message, location2);
    if (data !== void 0) {
      console.error(formattedMessage, data);
    } else {
      console.error(formattedMessage);
    }
  }
};

// src/utils/index.ts
async function copyStringToClipboard(text, topic = void 0) {
  try {
    await navigator.clipboard.writeText(text);
    showNotice('"' + (topic !== void 0 ? topic + '"' : "Text") + " copied to clipboard", NOTICE_DURATIONS.STANDARD, "success");
  } catch (error) {
    Logger.error("Failed to copy to clipboard: ", error);
  }
}
function showNotice(message, duration = 4e3, type) {
  const fragment = document.createDocumentFragment();
  let wrapper = fragment.createDiv({
    attr: {
      style: `display: flex; gap: .75em;`
    }
  });
  if (type === "error") {
    const header = wrapper.createDiv({
      attr: {
        style: `color: var(--color-red);`
      }
    });
    (0, import_obsidian.setIcon)(header, "alert-triangle");
  }
  if (type === "warning") {
    const header = wrapper.createDiv({
      attr: {
        style: `color: var(--color-yellow);`
      }
    });
    (0, import_obsidian.setIcon)(header, "alert-triangle");
  }
  if (type === "success") {
    const header = wrapper.createDiv({
      attr: {
        style: `color: var(--color-green);`
      }
    });
    (0, import_obsidian.setIcon)(header, "check-circle");
  }
  if (type === "info") {
    const header = wrapper.createDiv({
      attr: {
        // style: `color: var(--color-blue);`,
      }
    });
    (0, import_obsidian.setIcon)(header, "info");
  }
  wrapper.createDiv({
    text: message,
    attr: {
      style: ``
    }
  });
  new import_obsidian.Notice(fragment, duration);
}
function getCurrentTheme(app) {
  return app.getTheme() === "obsidian" ? "obsidian" : "moonstone";
}
function generateUniqueId() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return String(crypto.randomUUID());
  }
  let d = (/* @__PURE__ */ new Date()).getTime();
  let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    let r = Math.random() * 16;
    if (d > 0) {
      r = (d + r) % 16 | 0;
      d = Math.floor(d / 16);
    } else {
      r = (d2 + r) % 16 | 0;
      d2 = Math.floor(d2 / 16);
    }
    return (c === "x" ? r : r & 3 | 8).toString(16);
  });
}
function freezeTimer(delay) {
  const freezeNotice = new import_obsidian.Notice(`\u26A0 Will freeze Obsidian in ${delay}s`, (delay - 0.2) * 1e3);
  electronWindow.openDevTools();
  let passSecs = 0;
  const timer = window.setInterval(() => {
    const timePassed = (delay - passSecs).toFixed(1);
    freezeNotice.setMessage(`\u26A0 Will freeze Obsidian in ${timePassed}s`);
    passSecs += 0.1;
  }, 100);
  const timeoutId = window.setTimeout(() => {
    debugger;
    window.clearInterval(timer);
  }, delay * 1e3);
  return () => {
    window.clearInterval(timer);
    window.clearTimeout(timeoutId);
  };
}

// src/utils/uiHelpers.ts
var import_obsidian2 = require("obsidian");
function createCollapsibleSection(container, config) {
  const section = container.createDiv("collapsible");
  const header = section.createDiv("collapsible-header");
  header.createSpan({ text: config.title });
  const toggleIcon = header.createEl("button", {
    cls: "collapse-icon clickable-icon",
    attr: {
      tabindex: "0",
      "aria-label": config.expanded ? "Collapse section" : "Expand section",
      "data-tooltip-position": "top"
    }
  });
  const content = section.createDiv("collapsible-content");
  content.toggleClass("show", config.expanded);
  content.toggleClass("hide", !config.expanded);
  (0, import_obsidian2.setIcon)(toggleIcon, config.expanded ? "chevron-down" : "chevron-right");
  header.addEventListener("click", () => {
    const shouldExpand = content.hasClass("hide");
    content.toggleClass("show", shouldExpand);
    content.toggleClass("hide", !shouldExpand);
    (0, import_obsidian2.setIcon)(toggleIcon, shouldExpand ? "chevron-down" : "chevron-right");
    toggleIcon.setAttr("aria-label", shouldExpand ? "Collapse section" : "Expand section");
    config.onToggle(shouldExpand);
  });
  return { header, content, toggleIcon };
}
function createIconButton(container, config) {
  const button = container.createEl("button", {
    cls: ["clickable-icon", ...config.classes || []].join(" "),
    attr: {
      "aria-label": config.label,
      "data-tooltip-position": config.tooltip || "top",
      tabindex: "0"
    }
  });
  (0, import_obsidian2.setIcon)(button, config.icon);
  button.addEventListener("click", config.onClick);
  return button;
}
function createSearchInput(container, config) {
  const searchContainer = container.createDiv("search-container");
  const clearInputContainer = searchContainer.createDiv("clear-search-input");
  const searchInput = clearInputContainer.createEl("input", {
    cls: "search-input",
    attr: {
      type: "text",
      placeholder: config.placeholder
    }
  });
  searchInput.addEventListener("input", (e) => {
    const value = e.target.value.trim();
    config.onInput(value);
    if (value && !searchInput.classList.contains("clear-search-input--touched")) {
      searchInput.classList.add("clear-search-input--touched");
    } else if (!value && searchInput.classList.contains("clear-search-input--touched")) {
      searchInput.classList.remove("clear-search-input--touched");
    }
  });
  let clearButton;
  if (config.onClear) {
    clearButton = clearInputContainer.createEl("button", {
      cls: "clear-search-input-button",
      attr: {
        "aria-label": "Clear search",
        "data-tooltip-position": "top",
        tabindex: "0"
      }
    });
    clearButton.addEventListener("click", () => {
      searchInput.value = "";
      searchInput.focus();
      searchInput.trigger("input");
      searchInput.classList.remove("clear-search-input--touched");
      if (config.onClear) {
        config.onClear();
      }
    });
  }
  return { searchInput, clearButton };
}
function createToggleSwitch(container, id, label, checked, onChange) {
  const toggleContainer = container.createDiv("toggle-container");
  const toggle = toggleContainer.createEl("input", {
    attr: {
      type: "checkbox",
      id
    }
  });
  toggle.checked = checked;
  const labelEl = toggleContainer.createEl("label", {
    text: label
  });
  labelEl.setAttr("for", id);
  toggle.addEventListener("change", () => {
    onChange(toggle.checked);
  });
  return { toggle, label: labelEl };
}
function smoothScrollToElement(container, target, offset = UI_CONSTANTS.SCROLL_OFFSET) {
  const top = target.offsetTop - offset;
  container.scrollTo({
    top,
    behavior: "smooth"
  });
}

// src/managers/element/SelectorGenerator.ts
var SelectorGenerator = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Generate a CSS selector for an element.
   * @param element The element to generate a selector for
   * @param useSpecific Whether to include all possible attributes
   * @param includeParent Whether to include parent selector
   * @returns The generated CSS selector
   */
  generateSelector(element, useSpecific = false, includeParent = false) {
    const tagName = element.tagName.toLowerCase();
    const hasId = !!element.id;
    const hasAriaLabel = element.hasAttribute("aria-label");
    const classes = Array.from(element.classList).filter((cls) => !cls.includes("cts-element-selector-highlight") && !cls.includes("cts-element-selector-hover"));
    let effectiveStyle = this.plugin.settings.selectorStyle;
    if (useSpecific && effectiveStyle !== "specific") {
      effectiveStyle = "specific";
    }
    const dataAttrs = this.getDataAttributes(element, effectiveStyle);
    let selector = "";
    if (includeParent && element.parentElement) {
      const parent = element.parentElement;
      const parentClasses = Array.from(parent.classList).filter((cls) => !cls.includes("cts-element-selector-highlight")).map((cls) => `.${cls}`).join("");
      selector = `${parent.tagName.toLowerCase()}${parentClasses} > `;
    }
    if (hasId) {
      const idSelector = this.plugin.settings.selectorAlwaysIncludeTag ? `${tagName}#${element.id}` : `#${element.id}`;
      return selector + idSelector;
    }
    if (effectiveStyle === "specific") {
      return selector + this.generateSpecificSelector(element, tagName, hasAriaLabel, dataAttrs, classes);
    } else if (effectiveStyle === "balanced") {
      return selector + this.generateBalancedSelector(element, tagName, hasAriaLabel, dataAttrs, classes);
    } else {
      return selector + this.generateMinimalSelector(element, tagName, hasAriaLabel, dataAttrs, classes);
    }
  }
  /**
   * Generate a minimal selector (shortest possible)
   */
  generateMinimalSelector(element, tagName, hasAriaLabel, dataAttrs, classes) {
    const alwaysIncludeTag = this.plugin.settings.selectorAlwaysIncludeTag;
    const preferClasses = this.plugin.settings.selectorPreferClasses;
    if (preferClasses) {
      if (classes.length > 0) {
        const classSelector = classes.map((cls) => `.${cls}`).join("");
        return alwaysIncludeTag ? `${tagName}${classSelector}` : classSelector;
      }
      if (dataAttrs.length > 0) {
        const bestAttr = dataAttrs.sort((a, b2) => a.name.length - b2.name.length)[0];
        let attrSelector = "";
        if (this.shouldOmitAttributeValue(bestAttr.name, bestAttr.value)) {
          attrSelector = `[${bestAttr.name}]`;
        } else {
          const value = this.escapeAttributeValue(bestAttr.value);
          attrSelector = `[${bestAttr.name}="${value}"]`;
        }
        return alwaysIncludeTag ? `${tagName}${attrSelector}` : attrSelector;
      }
    } else {
      if (dataAttrs.length > 0) {
        const bestAttr = dataAttrs.sort((a, b2) => a.name.length - b2.name.length)[0];
        let attrSelector = "";
        if (this.shouldOmitAttributeValue(bestAttr.name, bestAttr.value)) {
          attrSelector = `[${bestAttr.name}]`;
        } else {
          const value = this.escapeAttributeValue(bestAttr.value);
          attrSelector = `[${bestAttr.name}="${value}"]`;
        }
        return alwaysIncludeTag ? `${tagName}${attrSelector}` : attrSelector;
      }
      if (classes.length > 0) {
        const classSelector = classes.map((cls) => `.${cls}`).join("");
        return alwaysIncludeTag ? `${tagName}${classSelector}` : classSelector;
      }
    }
    if (hasAriaLabel && !this.isAttributeExcluded("aria-label", "minimal")) {
      const ariaLabel = element.getAttribute("aria-label");
      const escapedAriaLabel = this.escapeAttributeValue(ariaLabel);
      if (escapedAriaLabel) {
        const ariaSelector = `[aria-label="${escapedAriaLabel}"]`;
        return alwaysIncludeTag ? `${tagName}${ariaSelector}` : ariaSelector;
      }
    }
    return tagName;
  }
  /**
   * Generate a balanced selector (tag + one primary attribute)
   * Balanced mode typically includes the tag, but respects alwaysIncludeTag=false for strong selectors like aria-label
   */
  generateBalancedSelector(element, tagName, hasAriaLabel, dataAttrs, classes) {
    const alwaysIncludeTag = this.plugin.settings.selectorAlwaysIncludeTag;
    const preferClasses = this.plugin.settings.selectorPreferClasses;
    let selectorParts = [tagName];
    if (preferClasses) {
      if (classes.length > 0) {
        selectorParts.push(classes.map((cls) => `.${cls}`).join(""));
        return selectorParts.join("");
      }
      if (dataAttrs.length > 0) {
        const bestAttr = dataAttrs.sort((a, b2) => a.name.length - b2.name.length)[0];
        if (this.shouldOmitAttributeValue(bestAttr.name, bestAttr.value)) {
          selectorParts.push(`[${bestAttr.name}]`);
        } else {
          const value = this.escapeAttributeValue(bestAttr.value);
          selectorParts.push(`[${bestAttr.name}="${value}"]`);
        }
        return selectorParts.join("");
      }
    } else {
      if (dataAttrs.length > 0) {
        const bestAttr = dataAttrs.sort((a, b2) => a.name.length - b2.name.length)[0];
        if (this.shouldOmitAttributeValue(bestAttr.name, bestAttr.value)) {
          selectorParts.push(`[${bestAttr.name}]`);
        } else {
          const value = this.escapeAttributeValue(bestAttr.value);
          selectorParts.push(`[${bestAttr.name}="${value}"]`);
        }
        return selectorParts.join("");
      }
      if (classes.length > 0) {
        selectorParts.push(classes.map((cls) => `.${cls}`).join(""));
        return selectorParts.join("");
      }
    }
    if (hasAriaLabel && !this.isAttributeExcluded("aria-label", "balanced")) {
      const ariaLabel = element.getAttribute("aria-label");
      const escapedAriaLabel = this.escapeAttributeValue(ariaLabel);
      if (escapedAriaLabel) {
        const ariaSelector = `[aria-label="${escapedAriaLabel}"]`;
        return alwaysIncludeTag ? `${tagName}${ariaSelector}` : ariaSelector;
      }
    }
    return selectorParts.join("");
  }
  /**
   * Generate a specific selector (all attributes)
   */
  generateSpecificSelector(element, tagName, hasAriaLabel, dataAttrs, classes) {
    const omitTag = !this.plugin.settings.selectorAlwaysIncludeTag && this.canOmitTagName(element, false, hasAriaLabel, dataAttrs);
    let selectorParts = [];
    if (!omitTag) {
      selectorParts.push(tagName);
    }
    if (classes.length > 0) {
      selectorParts.push(classes.map((cls) => `.${cls}`).join(""));
    }
    if (hasAriaLabel) {
      const ariaLabel = element.getAttribute("aria-label");
      const escapedAriaLabel = this.escapeAttributeValue(ariaLabel);
      if (escapedAriaLabel) {
        selectorParts.push(`[aria-label="${escapedAriaLabel}"]`);
      }
    }
    dataAttrs.sort((a, b2) => a.name.localeCompare(b2.name)).forEach((attr) => {
      if (this.shouldOmitAttributeValue(attr.name, attr.value)) {
        selectorParts.push(`[${attr.name}]`);
      } else {
        const value = this.escapeAttributeValue(attr.value);
        selectorParts.push(`[${attr.name}="${value}"]`);
      }
    });
    for (const attrName of ["role", "type", "name"]) {
      const value = element.getAttribute(attrName);
      if (value !== null) {
        const escaped = this.escapeAttributeValue(value);
        selectorParts.push(`[${attrName}="${escaped}"]`);
      }
    }
    return selectorParts.join("");
  }
  /**
   * Copy a comprehensive selector to clipboard with parent context
   */
  copySelectorToClipboard(element) {
    const selector = this.generateSelector(element, true, true);
    copyStringToClipboard(selector, selector);
  }
  /**
   * Format an attribute for display (used in tooltips)
   * @param attrName The attribute name
   * @param attrValue The attribute value
   * @returns Formatted string like "data-count" or "data-type=\"folder\""
   */
  formatAttributeForDisplay(attrName, attrValue) {
    if (this.shouldOmitAttributeValue(attrName, attrValue)) {
      return attrName;
    }
    return `${attrName}="${attrValue}"`;
  }
  /**
   * Check if an attribute name matches a wildcard pattern
   * Supports * as wildcard (e.g., "data-tooltip-*" matches "data-tooltip-position")
   * @param attributeName The attribute name to test
   * @param pattern The pattern with optional wildcards
   * @returns true if the attribute matches the pattern
   */
  matchesPattern(attributeName, pattern) {
    const regexPattern = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*");
    return new RegExp(`^${regexPattern}$`).test(attributeName);
  }
  /**
   * Check if an attribute should be excluded based on settings
   * Only applies exclusions in Minimal/Balanced modes
   * @param attrName The attribute name to check
   * @param effectiveStyle The current selector style
   * @returns true if the attribute should be excluded
   */
  isAttributeExcluded(attrName, effectiveStyle) {
    if (effectiveStyle === "specific") {
      return false;
    }
    const patterns = this.plugin.settings.selectorExcludedAttributes.split("\n").map((p) => p.trim()).filter((p) => p.length > 0);
    return patterns.some((pattern) => this.matchesPattern(attrName, pattern));
  }
  /**
   * Get all data-* attributes from an element
   * @param element The HTML element
   * @param effectiveStyle The current selector style (used for exclusion filtering)
   */
  getDataAttributes(element, effectiveStyle) {
    const dataAttributes = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.name.startsWith("data-") && attr.name !== "data-reactid" && !this.isAttributeExcluded(attr.name, effectiveStyle)) {
        dataAttributes.push({
          name: attr.name,
          value: attr.value
        });
      }
    }
    return dataAttributes;
  }
  /**
   * Escape special characters in attribute values for CSS selectors
   */
  escapeAttributeValue(value) {
    return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\A ").replace(/\r/g, "\\D ").replace(/\t/g, "\\9 ").replace(/\f/g, "\\C ");
  }
  /**
   * Determine if an attribute value should be omitted (dynamic/non-semantic values)
   * @param attrName The attribute name
   * @param attrValue The attribute value
   * @returns true if value should be omitted, false if value should be included
   */
  shouldOmitAttributeValue(attrName, attrValue) {
    if (attrName === "aria-label") {
      return false;
    }
    if (/^\d+$/.test(attrValue)) {
      return true;
    }
    if (/^[a-f0-9]{8,}(-[a-f0-9]{4,})*$/i.test(attrValue)) {
      return true;
    }
    const lowerAttrName = attrName.toLowerCase();
    const semanticPatterns = ["type", "mode", "state", "status", "variant", "theme", "view", "role", "path", "position"];
    if (semanticPatterns.some(
      (pattern) => lowerAttrName.endsWith(`-${pattern}`) || lowerAttrName === `data-${pattern}`
    )) {
      return false;
    }
    const dynamicPatterns = [
      "count",
      "index",
      "idx",
      "order",
      "number",
      "num",
      "id",
      "uuid",
      "guid",
      "key",
      "timestamp",
      "time"
    ];
    if (dynamicPatterns.some((pattern) => lowerAttrName.includes(pattern))) {
      return true;
    }
    return false;
  }
  /**
   * Determine if a selector is strong enough to omit the tag name
   * @param element The HTML element
   * @param hasId Whether element has an ID
   * @param hasAriaLabel Whether element has aria-label
   * @param dataAttrs Available data attributes
   * @returns true if tag name can be safely omitted
   */
  canOmitTagName(element, hasId, hasAriaLabel, dataAttrs) {
    if (hasId) {
      return true;
    }
    if (hasAriaLabel) {
      return true;
    }
    const uniquePatterns = ["section", "view", "panel", "modal", "dialog", "menu", "nav"];
    if (dataAttrs.some(
      (attr) => uniquePatterns.some((pattern) => attr.name.toLowerCase().includes(pattern))
    )) {
      return true;
    }
    return false;
  }
};

// src/managers/element/ElementHighlighter.ts
var ElementHighlighter = class {
  constructor(selectorGenerator) {
    this.highlightedElement = null;
    this.tooltip = null;
    this.selectorGenerator = selectorGenerator;
  }
  /**
   * Initialize the tooltip element
   */
  createTooltip() {
    this.tooltip = document.body.appendChild(
      createDiv("cts-element-selector-tooltip hide")
    );
    return this.tooltip;
  }
  /**
   * Highlight an element
   */
  highlightElement(element) {
    this.unhighlightElement();
    element.classList.add("cts-element-selector-highlight");
    this.highlightedElement = element;
  }
  /**
   * Remove highlight from the currently highlighted element
   */
  unhighlightElement() {
    if (this.highlightedElement) {
      this.highlightedElement.classList.remove("cts-element-selector-highlight");
      this.highlightedElement = null;
    }
  }
  /**
   * Update tooltip content and position
   */
  updateTooltip(element, event) {
    if (!this.tooltip) return;
    this.tooltip.empty();
    const defaultSelector = this.selectorGenerator.generateSelector(element, false);
    const specificSelector = this.selectorGenerator.generateSelector(element, true);
    const parentSelector = this.selectorGenerator.generateSelector(element, true, true);
    const tagName = element.tagName.toLowerCase();
    const classes = Array.from(element.classList).filter(
      (cls) => !cls.includes("cts-element-selector-highlight")
    ).join(".");
    const ariaLabel = element.getAttribute("aria-label");
    const dataAttributes = this.getDataAttributes(element);
    this.tooltip.createDiv().createEl(
      "strong",
      {
        text: "Tag: "
      }
    ).createEl(
      "code",
      {
        text: tagName
      }
    );
    if (ariaLabel) {
      this.tooltip.createDiv("attribute-highlight aria-label-highlight").createEl(
        "strong",
        {
          text: "aria-label: "
        }
      ).createSpan(
        {
          text: `"${ariaLabel}"`
        }
      ).createDiv(
        {
          cls: "attribute-note",
          text: "(High priority selector)"
        }
      );
    }
    if (dataAttributes.length > 0) {
      this.tooltip.createDiv("attribute-highlight").createEl(
        "strong",
        {
          text: "Data attributes:"
        }
      );
      let attrList = this.tooltip.createEl(
        "ul",
        {
          cls: "data-attributes-list"
        }
      );
      dataAttributes.forEach((attr) => {
        const formattedAttr = this.selectorGenerator.formatAttributeForDisplay(attr.name, attr.value);
        attrList.appendChild(
          attrList.createEl(
            "li",
            {
              text: formattedAttr
            }
          )
        );
      });
    }
    if (classes) {
      this.tooltip.createDiv("tooltip-classes").createEl(
        "strong",
        {
          text: "Classes: "
        }
      ).createSpan(
        {
          text: `${classes.replace(".cts-element-selector-hover", "")}`
        }
      );
    }
    const createSelectorLine = (label, value) => {
      const line = this.tooltip.createDiv();
      line.createEl(
        "strong",
        {
          text: `${label}: `
        }
      );
      line.createSpan(
        {
          cls: "selector-highlight",
          text: value
        }
      );
    };
    const createShortcutLine = (keys, description, isFirst = false) => {
      const line = this.tooltip.createDiv(
        {
          cls: isFirst ? "keys first" : "keys"
        }
      );
      keys.forEach((key, i) => {
        line.createEl(
          "kbd",
          {
            text: key
          }
        );
        if (i < keys.length - 1) {
          line.createSpan(
            {
              text: " + "
            }
          );
        }
      });
      line.createSpan(
        {
          text: ` ${description}`
        }
      );
    };
    createSelectorLine("Default selector", defaultSelector);
    createSelectorLine("Specific selector", specificSelector);
    createSelectorLine("Specific selector with parent", parentSelector);
    createShortcutLine(["Click"], "to select with default selector", true);
    createShortcutLine(["Alt", "Click"], "to select with specific selector");
    createShortcutLine(["Cmd/Ctrl", "Click"], "to select the specific selector with parent");
    createShortcutLine(["Shift", "Click"], "to copy the specific selector with parent to your clipboard");
    this.tooltip.classList.replace("hide", "show");
    const tooltipRect = this.tooltip.getBoundingClientRect();
    const mouseX = event.clientX;
    const mouseY = event.clientY;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    let left = mouseX + 10;
    let top = mouseY + 10;
    const MARGIN = 10;
    if (left + tooltipRect.width > windowWidth - MARGIN) {
      left = mouseX - tooltipRect.width - 10;
      if (left < MARGIN) {
        left = Math.max(MARGIN, (windowWidth - tooltipRect.width) / 2);
      }
    }
    if (top + tooltipRect.height > windowHeight - MARGIN) {
      top = mouseY - tooltipRect.height - 10;
      if (top < MARGIN) {
        top = Math.max(MARGIN, (windowHeight - tooltipRect.height) / 2);
      }
    }
    if (left < MARGIN) {
      left = MARGIN;
    }
    if (top < MARGIN) {
      top = MARGIN;
    }
    this.tooltip.style.left = `${left}px`;
    this.tooltip.style.top = `${top}px`;
  }
  /**
   * Hide and clean up tooltip
   */
  hideTooltip() {
    if (this.tooltip) {
      this.tooltip.classList.replace("show", "hide");
      this.tooltip.empty();
    }
  }
  /**
   * Remove tooltip from DOM
   */
  destroyTooltip() {
    if (this.tooltip) {
      this.tooltip.remove();
      this.tooltip = null;
    }
  }
  /**
   * Get the currently highlighted element
   */
  getHighlightedElement() {
    return this.highlightedElement;
  }
  /**
   * Get data attributes from an element (helper for tooltip)
   */
  getDataAttributes(element) {
    const dataAttributes = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.name.startsWith("data-") && attr.name !== "data-reactid") {
        dataAttributes.push({
          name: attr.name,
          value: attr.value
        });
      }
    }
    return dataAttributes;
  }
  /**
   * Clean up all DOM elements and references
   */
  destroy() {
    this.unhighlightElement();
    this.destroyTooltip();
  }
};

// src/managers/element/ElementSelectorManager.ts
var ElementSelectorManager = class {
  constructor(plugin, view) {
    this.isSelecting = false;
    this.handleMouseOver = (e) => {
      if (!this.isSelecting) return;
      const target = e.target;
      const tooltip = this.highlighter.getHighlightedElement();
      if (target.closest(".cts-element-selector-tooltip") || target.closest(".cts-element-selector-cancel")) {
        return;
      }
      if (target.closest(".cts-view")) {
        return;
      }
      this.highlighter.highlightElement(target);
      target.classList.add("cts-element-selector-hover");
      this.highlighter.updateTooltip(target, e);
    };
    this.handleMouseOut = (e) => {
      if (!this.isSelecting) return;
      const target = e.target;
      target.classList.remove("cts-element-selector-hover");
      this.highlighter.unhighlightElement();
      this.highlighter.hideTooltip();
    };
    this.handleClick = (e) => {
      if (this.isSelecting) {
        if (!e.target.hasClass("cts-element-selector-cancel")) {
          e.preventDefault();
          e.stopPropagation();
        }
      } else {
        return;
      }
      const target = e.target;
      if (target.closest(".cts-element-selector-tooltip")) {
        return;
      }
      if (target.closest(".cts-view")) {
        return;
      }
      if (!target.classList.contains("cts-element-selector-cancel")) {
        target.classList.remove("cts-element-selector-hover");
        this.selectElement(target, e);
      }
      this.stopElementSelection();
    };
    this.handleKeyDown = (e) => {
      if (!this.isSelecting) return;
      if (e.key === "Escape") {
        this.stopElementSelection();
        new import_obsidian3.Notice("Element selection cancelled");
      }
    };
    this.plugin = plugin;
    this.view = view;
    this.cancelButton = this.cancelButton;
    this.selectorGenerator = new SelectorGenerator(this.plugin);
    this.highlighter = new ElementHighlighter(this.selectorGenerator);
  }
  startElementSelection() {
    if (this.isSelecting) {
      return;
    }
    this.isSelecting = true;
    document.body.classList.add("cts-element-selector-active");
    this.highlighter.createTooltip();
    document.addEventListener("mouseover", this.handleMouseOver);
    document.addEventListener("mouseout", this.handleMouseOut);
    document.addEventListener("click", this.handleClick, true);
    document.addEventListener("keydown", this.handleKeyDown);
    this.noticeElement = this.noticeWithCancel({
      message: "Element selection mode active. Click on an element to select it, or press Escape to cancel.",
      cancelText: "Cancel",
      timeout: 0
    });
  }
  noticeWithCancel({
    message,
    cancelText = "Cancel",
    timeout
  }) {
    const notice = new import_obsidian3.Notice(
      createFragment((e) => {
        e.createDiv(
          {
            text: message,
            cls: "cts-notice-with-cancel"
          }
        );
        e.createDiv(
          {
            cls: "cts-notice-cancel-button"
          },
          (div) => {
            this.cancelButton = new import_obsidian3.ButtonComponent(div).setButtonText(cancelText).setClass("cts-element-selector-cancel").setTooltip("Stop element selection");
            this.cancelButton.onClick((e2) => {
              new import_obsidian3.Notice("Element selection cancelled");
            });
          }
        );
      }),
      timeout
    );
    notice.containerEl.setAttr("data-notice-element", "cts-element-selector-notice");
    return notice;
  }
  stopElementSelection() {
    if (!this.isSelecting) {
      return;
    }
    this.isSelecting = false;
    document.body.classList.remove("cts-element-selector-active");
    this.highlighter.destroy();
    document.querySelectorAll(".cts-element-selector-hover").forEach((el) => {
      el.classList.remove("cts-element-selector-hover");
    });
    document.removeEventListener("mouseover", this.handleMouseOver);
    document.removeEventListener("mouseout", this.handleMouseOut);
    document.removeEventListener("click", this.handleClick, true);
    document.removeEventListener("keydown", this.handleKeyDown);
    this.noticeElement.hide();
  }
  selectElement(element, evt) {
    if (evt.shiftKey) {
      this.selectorGenerator.copySelectorToClipboard(element);
      return;
    }
    let selector = "";
    if (evt.altKey) {
      selector = this.selectorGenerator.generateSelector(element, true);
    } else if (evt.ctrlKey || evt.metaKey) {
      selector = this.selectorGenerator.generateSelector(element, true, true);
    } else {
      selector = this.selectorGenerator.generateSelector(element, false);
    }
    const uuid = generateUniqueId();
    const ruleList = this.view.containerEl.querySelector(".css-rule");
    const leaves = this.plugin.app.workspace.getLeavesOfType("cts-view");
    if (leaves.length > 0) {
      const view = leaves[0].view;
      if (view == null ? void 0 : view.cssEditorManager) {
        const currentUUID = uuid;
        view.cssEditorManager.setRule(currentUUID, selector, false);
        view.cssEditorManager.showEditorSection(true);
        if (this.plugin.settings.viewScrollToTop) {
          window.setTimeout(() => {
            this.scrollToDivByUUID(uuid);
          }, TIMEOUT_DELAYS.SCROLL_DELAY);
        }
        const focusRuleInput = (0, import_obsidian3.debounce)(() => {
          view.cssEditorManager.focusRuleInput();
        }, 250, false);
        focusRuleInput();
      }
    }
  }
  // Scroll element to the top of view
  scrollToDivByUUID(uuid) {
    var _a2;
    const target = (_a2 = this.view.containerEl.querySelector(`input[value="${uuid}"]`)) == null ? void 0 : _a2.parentElement;
    if (target) {
      smoothScrollToElement(this.view.containerEl, target);
    }
  }
};

// src/managers/css/CSSEditorManager.ts
var import_obsidian7 = require("obsidian");

// src/ace/AceService.ts
var ace2 = __toESM(require_ace());
var import_mode_css = __toESM(require_mode_css());
var import_css = __toESM(require_css());

// src/ace/AceExtensions.ts
var import_ext_command_bar = __toESM(require_ext_command_bar());
var import_ext_elastic_tabstops_lite = __toESM(require_ext_elastic_tabstops_lite());
var import_ext_error_marker = __toESM(require_ext_error_marker());
var import_ext_hardwrap = __toESM(require_ext_hardwrap());
var import_ext_inline_autocomplete = __toESM(require_ext_inline_autocomplete());
var import_ext_keybinding_menu = __toESM(require_ext_keybinding_menu());
var import_ext_language_tools = __toESM(require_ext_language_tools());
var import_ext_linking = __toESM(require_ext_linking());
var import_ext_modelist = __toESM(require_ext_modelist());
var import_ext_options = __toESM(require_ext_options());
var import_ext_prompt = __toESM(require_ext_prompt());
var import_ext_rtl = __toESM(require_ext_rtl());
var import_ext_searchbox = __toESM(require_ext_searchbox());
var import_ext_settings_menu = __toESM(require_ext_settings_menu());
var import_ext_simple_tokenizer = __toESM(require_ext_simple_tokenizer());
var import_ext_spellcheck = __toESM(require_ext_spellcheck());
var import_ext_split = __toESM(require_ext_split());
var import_ext_textarea = __toESM(require_ext_textarea());
var import_ext_themelist = __toESM(require_ext_themelist());
var import_ext_whitespace = __toESM(require_ext_whitespace());

// src/ace/AceService.ts
var import_keybinding_emacs = __toESM(require_keybinding_emacs());
var import_keybinding_sublime = __toESM(require_keybinding_sublime());
var import_keybinding_vim = __toESM(require_keybinding_vim());
var import_keybinding_vscode = __toESM(require_keybinding_vscode());
var AceService = class {
  constructor(plugin) {
    this.editor = null;
    this.plugin = plugin;
  }
  createEditor(element) {
    this.editor = ace2.edit(element);
    return this.editor;
  }
  async configureEditor(config, fileExtension) {
    if (!this.editor) return;
    const languageMode = "css";
    const settings = this.getEditorSettings(languageMode, config, this.plugin);
    this.editor.setOptions(settings);
    this.editor.getSession().setMode(`ace/mode/${languageMode}`, () => {
      if (this.plugin.settings.enableAceColorPicker) {
        const AceColorPicker = require_ace_colorpicker();
        AceColorPicker.load(ace2, this.editor, {
          hideDelay: 2e3,
          showDelay: 500,
          type: "vscode"
        });
      }
    });
    if (this.plugin.settings.editorKeyboard === "default") {
      this.editor.setKeyboardHandler(null);
    } else {
      this.editor.setKeyboardHandler(`ace/keyboard/${this.plugin.settings.editorKeyboard}`);
    }
    this.updateTheme();
  }
  async updateTheme() {
    if (!this.editor) return;
    let themeName = this.plugin.settings.editorDarkTheme;
    let isObsidianThemeDark = () => document.body.classList.contains("theme-dark");
    if (this.plugin.settings.editorTheme === "Auto") {
      themeName = isObsidianThemeDark() ? this.plugin.settings.editorDarkTheme : this.plugin.settings.editorLightTheme;
    } else {
      if (this.plugin.settings.editorTheme === "Dark") {
        themeName = this.plugin.settings.editorDarkTheme;
      } else {
        themeName = this.plugin.settings.editorLightTheme;
      }
    }
    this.editor.setTheme(`ace/theme/${themeName}`);
  }
  getValue() {
    var _a2, _b;
    return (_b = (_a2 = this.editor) == null ? void 0 : _a2.getValue()) != null ? _b : "";
  }
  setValue(content, cursorPos) {
    if (!this.editor) return;
    if (cursorPos !== void 0) {
      const currentPos = this.editor.getCursorPosition();
      this.editor.setValue(content, cursorPos);
      if (cursorPos === -1) {
        this.editor.moveCursorToPosition(currentPos);
        this.editor.clearSelection();
      }
    } else {
      this.editor.setValue(content);
    }
    this.editor.getSession().getUndoManager().reset();
  }
  hasFocus() {
    var _a2, _b;
    return (_b = (_a2 = this.editor) == null ? void 0 : _a2.isFocused()) != null ? _b : false;
  }
  setKeyboardHandler(handler) {
    if (!this.editor) return;
    this.editor.setKeyboardHandler(handler);
  }
  getEditorSettings(languageMode, config, plugin) {
    return {
      showLineNumbers: this.plugin.settings.editorLineNumbers,
      fontSize: this.plugin.settings.editorFontSize,
      fontFamily: this.plugin.settings.editorFontFamily,
      useWorker: false,
      tabSize: Number(this.plugin.settings.editorTabWidth),
      wrap: this.plugin.settings.editorWordWrap,
      mode: `ace/mode/${languageMode}`,
      enableBasicAutocompletion: this.plugin.settings.enableAceAutoCompletion,
      enableSnippets: this.plugin.settings.enableAceSnippets,
      enableLiveAutocompletion: this.plugin.settings.enableAceAutoCompletion,
      enableMultiselect: true
    };
  }
};

// src/managers/css/CSSEditorManager.ts
var ace3 = __toESM(require_ace());

// src/managers/obsidianCSSVariables.json
var obsidianCSSVariables_default = {
  animation: {
    "--anim-duration-none": "0",
    "--anim-duration-superfast": "70ms",
    "--anim-duration-fast": "140ms",
    "--anim-duration-moderate": "300ms",
    "--anim-duration-slow": "560ms",
    "--anim-motion-smooth": "cubic-bezier(0.45, 0.05, 0.55, 0.95)",
    "--anim-motion-delay": "cubic-bezier(0.65, 0.05, 0.36, 1)",
    "--anim-motion-jumpy": "cubic-bezier(0.68, -0.55, 0.27, 1.55)",
    "--anim-motion-swing": "cubic-bezier(0, 0.55, 0.45, 1)"
  },
  bases: {
    "--bases-header-border-width": "0 0 1px 0",
    "--bases-header-height": "40px",
    "--bases-header-padding-start": "2px",
    "--bases-header-padding-end": "2px",
    "--bases-toolbar-label-display": "block",
    "--bases-toolbar-badge-display": "none",
    "--bases-embed-border-width": "0px",
    "--bases-embed-border-color": "var(--background-modifier-border)",
    "--bases-embed-border-radius": "var(--radius-s)",
    "--bases-filter-menu-width": "520px",
    "--bases-group-heading-property-size": "var(--font-ui-smaller)",
    "--bases-group-heading-property-weight": "var(--font-normal)",
    "--bases-group-heading-property-color": "var(--text-muted)",
    "--bases-group-heading-value-size": "var(--font-smaller)",
    "--bases-group-heading-value-weight": "var(--font-semibold)",
    "--bases-group-heading-property-display": "block",
    "--bases-table-container-border-width": "1px",
    "--bases-table-container-border-radius": "var(--radius-s)",
    "--bases-table-group-background": "var(--background-primary-alt)",
    "--bases-table-header-weight": "var(--font-weight)",
    "--bases-table-header-color": "var(--text-muted)",
    "--bases-table-header-icon-display": "flex",
    "--bases-table-header-background": "var(--background-primary)",
    "--bases-table-header-background-hover": "var(--background-modifier-hover)",
    "--bases-table-header-sort-mask": "linear-gradient(to left, transparent var(--size-4-6), black var(--size-4-6))",
    "--bases-table-summary-background": "var(--background-primary)",
    "--bases-table-summary-background-hover": "var(--background-modifier-hover)",
    "--bases-table-border-color": "var(--table-border-color)",
    "--bases-table-column-border-width": "1px",
    "--bases-table-group-gap": "10px",
    "--bases-table-row-border-width": "1px",
    "--bases-table-row-background-hover": "var(--table-row-background-hover)",
    "--bases-table-row-height": "30px",
    "--bases-table-font-size": "var(--font-smaller)",
    "--bases-table-column-max-width": "300",
    "--bases-table-column-min-width": "40",
    "--bases-table-cell-radius-active": "2px",
    "--bases-table-cell-shadow-active": "0 0 0 2px var(--background-modifier-border-focus)",
    "--bases-table-cell-radius-focus": "2px",
    "--bases-table-cell-shadow-focus": "0 0 0 2px var(--interactive-accent)",
    "--bases-table-cell-background-active": "var(--background-primary)",
    "--bases-table-cell-background-disabled": "var(--background-primary-alt)",
    "--bases-table-cell-background-selected": "var(--table-selection)",
    "--bases-cards-container-background": "transparent",
    "--bases-cards-background": "var(--background-primary)",
    "--bases-cards-cover-background": "var(--background-primary-alt)",
    "--bases-cards-scale": "1",
    "--bases-cards-line-height": "24px",
    "--bases-cards-border-width": "1px",
    "--bases-cards-shadow": "0 0 0 1px var(--background-modifier-border)",
    "--bases-cards-shadow-hover": "0 0 0 1px var(--background-modifier-border-hover)",
    "--bases-cards-font-size": "var(--font-smaller)"
  },
  blockquote: {
    "--blockquote-border-thickness": "2px",
    "--blockquote-border-color": "var(--interactive-accent)",
    "--blockquote-font-style": "normal",
    "--blockquote-color": "inherit",
    "--blockquote-background-color": "transparent"
  },
  borders: {
    "--border-width": "1px"
  },
  button: {
    "--button-radius": "var(--input-radius)",
    "--corner-smoothing": "0"
  },
  callout: {
    "--callout-border-width": "0px",
    "--callout-border-opacity": "0.25",
    "--callout-padding": "var(--size-4-3) var(--size-4-3) var(--size-4-3) var(--size-4-6)",
    "--callout-radius": "var(--radius-s)",
    "--callout-blend-mode": "var(--highlight-mix-blend-mode)",
    "--callout-title-color": "inherit",
    "--callout-title-padding": "0",
    "--callout-title-size": "inherit",
    "--callout-title-weight": "calc(var(--font-weight) + var(--bold-modifier))",
    "--callout-content-padding": "0",
    "--callout-content-background": "transparent",
    "--callout-bug": "var(--color-red-rgb)",
    "--callout-default": "var(--color-blue-rgb)",
    "--callout-error": "var(--color-red-rgb)",
    "--callout-example": "var(--color-purple-rgb)",
    "--callout-fail": "var(--color-red-rgb)",
    "--callout-important": "var(--color-cyan-rgb)",
    "--callout-info": "var(--color-blue-rgb)",
    "--callout-question": "var(--color-orange-rgb)",
    "--callout-success": "var(--color-green-rgb)",
    "--callout-summary": "var(--color-cyan-rgb)",
    "--callout-tip": "var(--color-cyan-rgb)",
    "--callout-todo": "var(--color-blue-rgb)",
    "--callout-warning": "var(--color-orange-rgb)",
    "--callout-quote": "158, 158, 158"
  },
  canvas: {
    "--canvas-background": "var(--background-primary)",
    "--canvas-card-label-color": "var(--text-faint)",
    "--canvas-color-1": "var(--color-red-rgb)",
    "--canvas-color-2": "var(--color-orange-rgb)",
    "--canvas-color-3": "var(--color-yellow-rgb)",
    "--canvas-color-4": "var(--color-green-rgb)",
    "--canvas-color-5": "var(--color-cyan-rgb)",
    "--canvas-color-6": "var(--color-purple-rgb)",
    "--canvas-dot-pattern": "var(--color-base-30)"
  },
  checkbox: {
    "--checkbox-radius": "var(--radius-s)",
    "--checkbox-size": "var(--font-text-size)",
    "--checkbox-marker-color": "var(--background-primary)",
    "--checkbox-color": "var(--interactive-accent)",
    "--checkbox-color-hover": "var(--interactive-accent-hover)",
    "--checkbox-border-color": "var(--text-faint)",
    "--checkbox-border-color-hover": "var(--text-muted)",
    "--checkbox-margin-inline-start": "0.85em",
    "--checklist-done-decoration": "line-through",
    "--checklist-done-color": "var(--text-muted)"
  },
  code: {
    "--code-white-space": "pre-wrap",
    "--code-border-width": "0px",
    "--code-border-color": "var(--background-modifier-border)",
    "--code-radius": "var(--radius-s)",
    "--code-bracket-background": "var(--background-modifier-hover)",
    "--code-size": "var(--font-smaller)",
    "--code-background": "var(--background-primary-alt)",
    "--code-normal": "var(--text-normal)",
    "--code-comment": "var(--text-faint)",
    "--code-function": "var(--color-yellow)",
    "--code-important": "var(--color-orange)",
    "--code-keyword": "var(--color-pink)",
    "--code-operator": "var(--color-red)",
    "--code-property": "var(--color-cyan)",
    "--code-punctuation": "var(--text-muted)",
    "--code-string": "var(--color-green)",
    "--code-tag": "var(--color-red)",
    "--code-value": "var(--color-purple)"
  },
  colorinput: {
    "--swatch-radius": "14px",
    "--swatch-height": "22px",
    "--swatch-width": "22px",
    "--swatch-shadow": "inset 0 0 0 1px rgba(var(--mono-rgb-100), 0.15)"
  },
  colors: {
    "--accent-h": "258",
    "--accent-s": "88%",
    "--accent-l": "66%",
    "--background-primary": "var(--color-base-00)",
    "--background-primary-alt": "var(--color-base-10)",
    "--background-secondary": "var(--color-base-20)",
    "--background-modifier-hover": "rgba(var(--mono-rgb-100), 0.067)",
    "--background-modifier-active-hover": "hsla(var(--interactive-accent-hsl), 0.1)",
    "--background-modifier-border": "var(--color-base-30)",
    "--background-modifier-border-hover": "var(--color-base-35)",
    "--background-modifier-border-focus": "var(--color-base-40)",
    "--background-modifier-error-rgb": "var(--color-red-rgb)",
    "--background-modifier-error": "var(--color-red)",
    "--background-modifier-error-hover": "var(--color-red)",
    "--background-modifier-success-rgb": "var(--color-green-rgb)",
    "--background-modifier-success": "var(--color-green)",
    "--background-modifier-message": "rgba(0, 0, 0, 0.9)",
    "--background-modifier-form-field": "var(--color-base-00)",
    "--background-modifier-form-field-hover": "var(--background-modifier-form-field)",
    "--interactive-normal": "var(--color-base-00)",
    "--interactive-hover": "var(--color-base-10)",
    "--interactive-accent-hsl": "var(--color-accent-hsl)",
    "--interactive-accent": "var(--color-accent-1)",
    "--interactive-accent-hover": "var(--color-accent-2)",
    "--text-normal": "var(--color-base-100)",
    "--text-muted": "var(--color-base-70)",
    "--text-faint": "var(--color-base-50)",
    "--text-on-accent": "white",
    "--text-on-accent-inverted": "black",
    "--text-error": "var(--color-red)",
    "--text-warning": "var(--color-orange)",
    "--text-success": "var(--color-green)",
    "--text-selection": "hsla(var(--color-accent-hsl), 0.2)",
    "--text-highlight-bg-rgb": "255, 208, 0",
    "--text-highlight-bg": "rgba(var(--text-highlight-bg-rgb), 0.4)",
    "--text-accent": "var(--color-accent)",
    "--text-accent-hover": "var(--color-accent-2)",
    "--caret-color": "var(--text-normal)"
  },
  cts: {
    "--element-selector-highlight-outline": "1px dashed var(--interactive-accent)",
    "--element-selector-highlight-background-color": "hsla(var(--interactive-accent-hsl), .1)",
    "--element-selector-tooltip-background-color": "var(--background-primary)",
    "--element-selector-tooltip-border": "1px solid var(--background-modifier-border)",
    "--element-selector-tooltip-border-radius": "var(--size-4-2)",
    "--element-selector-tooltip-font-size": "var(--font-smaller)",
    "--element-selector-tooltip-padding": "1em",
    "--element-selector-tooltip-max-width": "400px"
  },
  cursor: {
    "--cursor": "default",
    "--cursor-link": "pointer"
  },
  dialog: {
    "--dialog-width": "560px",
    "--dialog-max-width": "80vw",
    "--dialog-max-height": "85vh"
  },
  divider: {
    "--divider-color": "var(--background-modifier-border)",
    "--divider-color-hover": "var(--interactive-accent)",
    "--divider-width": "1px",
    "--divider-width-hover": "3px",
    "--divider-vertical-height": "calc(100% - var(--header-height))"
  },
  dragging: {
    "--drag-ghost-background": "rgba(0, 0, 0, 0.85)",
    "--drag-ghost-text-color": "#ffffff"
  },
  dropdowns: {
    "--dropdown-background-blend-mode": "hard-light",
    "--dropdown-background-position": "right 0.5em top 50%, 0 0",
    "--dropdown-background-size": "1em auto, 100%",
    "--dropdown-padding": "0 1.9em 0 0.8em"
  },
  embed: {
    "--embed-max-height": "4000px",
    "--embed-canvas-max-height": "400px",
    "--embed-background": "inherit",
    "--embed-border-start": "2px solid var(--interactive-accent)",
    "--embed-border-end": "none",
    "--embed-border-top": "none",
    "--embed-border-bottom": "none",
    "--embed-padding": "0 0 0 var(--size-4-6)",
    "--embed-font-style": "inherit"
  },
  file: {
    "--file-line-width": "700px",
    "--file-folding-offset": "24px",
    "--file-margins": "var(--size-4-8)",
    "--file-header-font": "var(--font-interface)",
    "--file-header-font-size": "var(--font-ui-small)",
    "--file-header-font-weight": "400",
    "--file-header-border": "var(--border-width) solid transparent",
    "--file-header-justify": "center"
  },
  fileexplorer: {
    "--vault-profile-display": "flex",
    "--vault-profile-actions-display": "flex",
    "--vault-profile-font-size": "var(--font-ui-small)",
    "--vault-profile-font-weight": "var(--font-medium)",
    "--vault-profile-color": "var(--text-normal)",
    "--vault-profile-color-hover": "var(--vault-profile-color)"
  },
  footnote: {
    "--footnote-divider-color-active": "var(--metadata-divider-color-focus)",
    "--footnote-divider-color": "var(--metadata-divider-color)",
    "--footnote-divider-width": "1px",
    "--footnote-gap": "var(--size-4-1)",
    "--footnote-id-color-no-occurrences": "var(--text-faint)",
    "--footnote-id-color": "var(--text-muted)",
    "--footnote-id-delimiter": ".",
    "--footnote-input-background-active": "var(--metadata-input-background-active)",
    "--footnote-input-background": "var(--metadata-input-background)",
    "--footnote-line-height": "var(--line-height-normal)",
    "--footnote-padding-block": "var(--size-2-3)",
    "--footnote-padding-inline": "var(--size-2-3)",
    "--footnote-radius": "var(--radius-s)",
    "--footnote-size": "var(--font-smaller)"
  },
  graph: {
    "--graph-controls-width": "240px",
    "--graph-text": "var(--text-normal)",
    "--graph-line": "var(--color-base-35, var(--background-modifier-border-focus))",
    "--graph-node": "var(--text-muted)",
    "--graph-node-unresolved": "var(--text-faint)",
    "--graph-node-focused": "var(--text-accent)",
    "--graph-node-tag": "var(--color-green)",
    "--graph-node-attachment": "var(--color-yellow)"
  },
  headings: {
    "--heading-formatting": "var(--text-faint)",
    "--heading-spacing": "calc(var(--p-spacing) * 2.5)",
    "--h1-color": "inherit",
    "--h2-color": "inherit",
    "--h3-color": "inherit",
    "--h4-color": "inherit",
    "--h5-color": "inherit",
    "--h6-color": "inherit",
    "--h1-font": "inherit",
    "--h2-font": "inherit",
    "--h3-font": "inherit",
    "--h4-font": "inherit",
    "--h5-font": "inherit",
    "--h6-font": "inherit",
    "--h1-line-height": "1.2",
    "--h2-line-height": "1.2",
    "--h3-line-height": "1.3",
    "--h4-line-height": "1.4",
    "--h5-line-height": "var(--line-height-normal)",
    "--h6-line-height": "var(--line-height-normal)",
    "--h1-size": "1.802em",
    "--h2-size": "1.602em",
    "--h3-size": "1.424em",
    "--h4-size": "1.266em",
    "--h5-size": "1.125em",
    "--h6-size": "1em",
    "--h1-style": "normal",
    "--h2-style": "normal",
    "--h3-style": "normal",
    "--h4-style": "normal",
    "--h5-style": "normal",
    "--h6-style": "normal",
    "--h1-variant": "normal",
    "--h2-variant": "normal",
    "--h3-variant": "normal",
    "--h4-variant": "normal",
    "--h5-variant": "normal",
    "--h6-variant": "normal",
    "--h1-weight": "700",
    "--h2-weight": "600",
    "--h3-weight": "600",
    "--h4-weight": "600",
    "--h5-weight": "600",
    "--h6-weight": "600"
  },
  horizontalrule: {
    "--hr-color": "var(--background-modifier-border)",
    "--hr-thickness": "2px"
  },
  icons: {
    "--icon-size": "var(--icon-m)",
    "--icon-stroke": "var(--icon-m-stroke-width)",
    "--icon-xs": "14px",
    "--icon-s": "16px",
    "--icon-m": "18px",
    "--icon-l": "18px",
    "--icon-xl": "32px",
    "--icon-xs-stroke-width": "2px",
    "--icon-s-stroke-width": "2px",
    "--icon-m-stroke-width": "1.75px",
    "--icon-l-stroke-width": "1.75px",
    "--icon-xl-stroke-width": "1.25px",
    "--icon-color": "var(--text-muted)",
    "--icon-color-hover": "var(--text-muted)",
    "--icon-color-active": "var(--text-accent)",
    "--icon-color-focused": "var(--text-normal)",
    "--icon-opacity": "0.85",
    "--icon-opacity-hover": "1",
    "--icon-opacity-active": "1",
    "--clickable-icon-radius": "var(--radius-s)"
  },
  indentation: {
    "--indent-size": "4",
    "--indent-unit": "0.5625em",
    "--indentation-guide-width": "1px",
    "--indentation-guide-width-active": "1px",
    "--indentation-guide-color": "rgba(var(--mono-rgb-100), 0.12)",
    "--indentation-guide-color-active": "rgba(var(--mono-rgb-100), 0.3)",
    "--indentation-guide-editing-indent": "0.85em",
    "--indentation-guide-reading-indent": "-0.85em",
    "--indentation-guide-source-indent": "0.25em"
  },
  inlinetitle: {
    "--inline-title-color": "var(--h1-color)",
    "--inline-title-font": "var(--h1-font)",
    "--inline-title-line-height": "var(--h1-line-height)",
    "--inline-title-size": "var(--h1-size)",
    "--inline-title-style": "var(--h1-style)",
    "--inline-title-variant": "var(--h1-variant)",
    "--inline-title-weight": "var(--h1-weight)",
    "--inline-title-margin-bottom": "0.5em"
  },
  layers: {
    "--layer-cover": "5",
    "--layer-sidedock": "10",
    "--layer-status-bar": "15",
    "--layer-popover": "30",
    "--layer-slides": "45",
    "--layer-modal": "50",
    "--layer-notice": "60",
    "--layer-menu": "65",
    "--layer-tooltip": "70",
    "--layer-dragged-item": "80"
  },
  link: {
    "--link-color": "var(--text-accent)",
    "--link-color-hover": "var(--text-accent-hover)",
    "--link-decoration": "underline",
    "--link-decoration-hover": "underline",
    "--link-decoration-thickness": "auto",
    "--link-weight": "var(--font-weight)",
    "--link-external-color": "var(--text-accent)",
    "--link-external-color-hover": "var(--text-accent-hover)",
    "--link-external-decoration": "underline",
    "--link-external-decoration-hover": "underline",
    "--link-external-filter": "none",
    "--link-unresolved-color": "var(--text-accent)",
    "--link-unresolved-opacity": "0.7",
    "--link-unresolved-filter": "none",
    "--link-unresolved-decoration-style": "solid",
    "--link-unresolved-decoration-color": "hsla(var(--interactive-accent-hsl), 0.3)"
  },
  list: {
    "--list-indent": "calc(var(--indent-unit) * var(--indent-size))",
    "--list-indent-editing": "0.75em",
    "--list-indent-source": "0",
    "--list-spacing": "0.075em",
    "--list-marker-color": "var(--text-faint)",
    "--list-marker-color-hover": "var(--text-muted)",
    "--list-marker-color-collapsed": "var(--text-accent)",
    "--list-bullet-border": "none",
    "--list-bullet-radius": "50%",
    "--list-bullet-size": "0.3em",
    "--list-bullet-transform": "none",
    "--list-numbered-style": "decimal",
    "--list-bullet-end-padding": "1.3rem"
  },
  modal: {
    "--modal-background": "var(--background-primary)",
    "--modal-width": "90vw",
    "--modal-height": "85vh",
    "--modal-max-width": "1100px",
    "--modal-max-height": "1000px",
    "--modal-max-width-narrow": "800px",
    "--modal-border-width": "var(--border-width)",
    "--modal-border-color": "var(--color-base-40, var(--background-modifier-border-focus))",
    "--modal-radius": "var(--radius-l)",
    "--modal-community-sidebar-width": "280px"
  },
  multiselect: {
    "--pill-color": "var(--text-muted)",
    "--pill-color-hover": "var(--text-normal)",
    "--pill-color-remove": "var(--text-faint)",
    "--pill-color-remove-hover": "var(--text-accent)",
    "--pill-decoration": "none",
    "--pill-decoration-hover": "none",
    "--pill-background": "transparent",
    "--pill-background-hover": "transparent",
    "--pill-border-color": "var(--background-modifier-border)",
    "--pill-border-color-hover": "var(--background-modifier-border-hover)",
    "--pill-border-width": "var(--border-width)",
    "--pill-padding-x": "0.65em",
    "--pill-padding-y": "0.25em",
    "--pill-radius": "2em",
    "--pill-weight": "inherit"
  },
  navigation: {
    "--nav-item-size": "var(--font-ui-small)",
    "--nav-item-color": "var(--text-muted)",
    "--nav-item-color-hover": "var(--text-normal)",
    "--nav-item-color-active": "var(--text-normal)",
    "--nav-item-color-selected": "var(--text-normal)",
    "--nav-item-color-highlighted": "var(--text-accent)",
    "--nav-item-background-hover": "var(--background-modifier-hover)",
    "--nav-item-background-active": "var(--background-modifier-hover)",
    "--nav-item-background-selected": "hsla(var(--color-accent-hsl), 0.15)",
    "--nav-item-padding": "var(--size-4-1) var(--size-4-2) var(--size-4-1) var(--size-4-6)",
    "--nav-item-parent-padding": "var(--nav-item-padding)",
    "--nav-item-children-padding-start": "var(--size-2-2)",
    "--nav-item-children-margin-start": "var(--size-4-3)",
    "--nav-item-weight": "inherit",
    "--nav-item-weight-hover": "inherit",
    "--nav-item-weight-active": "inherit",
    "--nav-item-white-space": "pre",
    "--nav-indentation-guide-width": "var(--indentation-guide-width)",
    "--nav-indentation-guide-color": "var(--indentation-guide-color)",
    "--nav-collapse-icon-color": "var(--collapse-icon-color)",
    "--nav-collapse-icon-color-collapsed": "var(--text-faint)",
    "--nav-heading-color": "var(--text-normal)",
    "--nav-heading-color-hover": "var(--text-normal)",
    "--nav-heading-color-collapsed": "var(--text-faint)",
    "--nav-heading-color-collapsed-hover": "var(--text-muted)",
    "--nav-heading-weight": "var(--font-medium)",
    "--nav-heading-weight-hover": "var(--font-medium)",
    "--nav-tag-background": "transparent;",
    "--nav-tag-radius": "var(--radius-s)",
    "--nav-tag-color": "var(--text-faint)",
    "--nav-tag-color-hover": "var(--text-muted)",
    "--nav-tag-color-active": "var(--text-muted)",
    "--nav-tag-weight": "var(--font-semibold)"
  },
  popover: {
    "--popover-width": "450px",
    "--popover-height": "400px",
    "--popover-max-height": "95vh",
    "--popover-pdf-width": "450px",
    "--popover-pdf-height": "400px",
    "--popover-font-size": "var(--font-text-size)"
  },
  prompt: {
    "--prompt-input-height": "40px",
    "--prompt-width": "700px",
    "--prompt-max-width": "80vw",
    "--prompt-max-height": "70vh",
    "--prompt-border-width": "var(--border-width)",
    "--prompt-border-color": "var(--color-base-40, var(--background-modifier-border-focus))"
  },
  properties: {
    "--metadata-background": "transparent",
    "--metadata-display-reading": "block",
    "--metadata-display-editing": "block",
    "--metadata-max-width": "none",
    "--metadata-padding": "var(--size-4-2) 0",
    "--metadata-border-color": "var(--background-modifier-border)",
    "--metadata-border-radius": "0",
    "--metadata-border-width": "0",
    "--metadata-divider-color": "var(--background-modifier-border)",
    "--metadata-divider-color-hover": "transparent",
    "--metadata-divider-color-focus": "transparent",
    "--metadata-divider-width": "0",
    "--metadata-gap": "3px",
    "--metadata-property-padding": "0",
    "--metadata-property-radius": "6px",
    "--metadata-property-radius-hover": "6px",
    "--metadata-property-radius-focus": "6px",
    "--metadata-property-background": "transparent",
    "--metadata-property-background-hover": "transparent",
    "--metadata-property-background-active": "var(--background-modifier-hover)",
    "--metadata-property-box-shadow-hover": "0 0 0 1px var(--background-modifier-border-hover)",
    "--metadata-property-box-shadow-focus": "0 0 0 2px var(--background-modifier-border-focus)",
    "--metadata-label-background": "transparent",
    "--metadata-label-background-hover": "transparent",
    "--metadata-label-background-active": "var(--background-modifier-hover)",
    "--metadata-label-font": "var(--font-interface)",
    "--metadata-label-font-size": "var(--font-smaller)",
    "--metadata-label-font-weight": "inherit",
    "--metadata-label-text-color": "var(--text-muted)",
    "--metadata-label-text-color-hover": "var(--text-muted)",
    "--metadata-label-width": "9em",
    "--metadata-input-height": "calc(var(--font-text-size) * 1.75)",
    "--metadata-input-text-color": "var(--text-normal)",
    "--metadata-input-font": "var(--font-interface)",
    "--metadata-input-font-size": "var(--font-smaller)",
    "--metadata-input-background": "transparent",
    "--metadata-input-background-hover": "transparent",
    "--metadata-input-background-active": "var(--background-modifier-hover)",
    "--metadata-input-longtext-lines": "3",
    "--metadata-sidebar-label-font-size": "var(--font-ui-small)",
    "--metadata-sidebar-input-font-size": "var(--font-ui-small)"
  },
  radiuses: {
    "--radius-s": "4px",
    "--radius-m": "8px",
    "--radius-l": "12px",
    "--radius-xl": "16px"
  },
  ribbon: {
    "--ribbon-background": "var(--background-secondary)",
    "--ribbon-background-collapsed": "var(--background-primary)",
    "--ribbon-width": "44px",
    "--ribbon-padding": "var(--size-4-2) var(--size-4-1) var(--size-4-3)"
  },
  scrollbar: {
    "--scrollbar-width": "12px",
    "--scrollbar-height": "12px",
    "--scrollbar-border-width": "3px 3px 3px 2px",
    "--scrollbar-radius": "var(--radius-l)",
    "--scrollbar-active-thumb-bg": "rgba(var(--mono-rgb-100), 0.2)",
    "--scrollbar-bg": "rgba(var(--mono-rgb-100), 0.05)",
    "--scrollbar-thumb-bg": "rgba(var(--mono-rgb-100), 0.1)"
  },
  search: {
    "--search-clear-button-color": "var(--text-muted)",
    "--search-clear-button-size": "13px",
    "--search-icon-color": "var(--text-muted)",
    "--search-icon-size": "18px",
    "--search-result-background": "var(--background-primary)"
  },
  sidebar: {
    "--sidebar-markdown-font-size": "calc(var(--font-text-size) * 0.9)",
    "--sidebar-tab-text-display": "none"
  },
  slider: {
    "--slider-thumb-border-width": "1px",
    "--slider-thumb-border-color": "var(--background-modifier-border-hover)",
    "--slider-thumb-height": "18px",
    "--slider-thumb-width": "18px",
    "--slider-thumb-y": "-6px",
    "--slider-thumb-radius": "50%",
    "--slider-s-thumb-size": "15px",
    "--slider-s-thumb-position": "-5px",
    "--slider-track-background": "var(--background-modifier-border)",
    "--slider-track-height": "3px"
  },
  spacing: {
    "--size-2-1": "2px",
    "--size-2-2": "4px",
    "--size-2-3": "6px",
    "--size-4-1": "4px",
    "--size-4-2": "8px",
    "--size-4-3": "12px",
    "--size-4-4": "16px",
    "--size-4-5": "20px",
    "--size-4-6": "24px",
    "--size-4-8": "32px",
    "--size-4-9": "36px",
    "--size-4-10": "40px",
    "--size-4-12": "48px",
    "--size-4-16": "64px",
    "--size-4-18": "72px"
  },
  statusbar: {
    "--status-bar-background": "var(--background-secondary)",
    "--status-bar-border-color": "var(--divider-color)",
    "--status-bar-border-width": "1px 0 0 1px",
    "--status-bar-font-size": "var(--font-ui-smaller)",
    "--status-bar-text-color": "var(--text-muted)",
    "--status-bar-position": "fixed",
    "--status-bar-radius": "var(--radius-m) 0 0 0"
  },
  sync: {
    "--sync-avatar-color-current-user": "transparent",
    "--sync-avatar-color-1": "var(--color-red)",
    "--sync-avatar-color-2": "var(--color-orange)",
    "--sync-avatar-color-3": "var(--color-yellow)",
    "--sync-avatar-color-4": "var(--color-green)",
    "--sync-avatar-color-5": "var(--color-cyan)",
    "--sync-avatar-color-6": "var(--color-blue)",
    "--sync-avatar-color-7": "var(--color-purple)",
    "--sync-avatar-color-8": "var(--color-pink)"
  },
  table: {
    "--table-background": "transparent",
    "--table-border-width": "1px",
    "--table-border-color": "var(--background-modifier-border)",
    "--table-white-space": "break-spaces",
    "--table-header-background": "var(--table-background)",
    "--table-header-background-hover": "inherit",
    "--table-header-border-width": "var(--table-border-width)",
    "--table-header-border-color": "var(--table-border-color)",
    "--table-header-font": "inherit",
    "--table-header-size": "var(--table-text-size)",
    "--table-header-weight": "calc(var(--font-weight) + var(--bold-modifier))",
    "--table-header-color": "var(--text-normal)",
    "--table-line-height": "var(--line-height-tight)",
    "--table-text-size": "var(--font-text-size)",
    "--table-text-color": "inherit",
    "--table-column-min-width": "6ch",
    "--table-column-max-width": "none",
    "--table-column-alt-background": "var(--table-background)",
    "--table-column-first-border-width": "var(--table-border-width)",
    "--table-column-last-border-width": "var(--table-border-width)",
    "--table-row-background-hover": "var(--table-background)",
    "--table-row-alt-background": "var(--table-background)",
    "--table-row-alt-background-hover": "var(--table-background)",
    "--table-row-last-border-width": "var(--table-border-width)",
    "--table-selection": "hsla(var(--color-accent-hsl), 0.1)",
    "--table-selection-blend-mode": "var(--highlight-mix-blend-mode)",
    "--table-selection-border-color": "var(--interactive-accent)",
    "--table-selection-border-width": "2px",
    "--table-selection-border-radius": "4px",
    "--table-cell-vertical-alignment": "top",
    "--table-drag-handle-background": "transparent",
    "--table-drag-handle-background-active": "var(--table-selection-border-color)",
    "--table-drag-handle-color": "var(--text-faint)",
    "--table-drag-handle-color-active": "var(--text-on-accent)",
    "--table-drop-indicator-half-width": "2px",
    "--table-add-button-background": "transparent",
    "--table-add-button-border-width": "var(--table-border-width)",
    "--table-add-button-border-color": "var(--background-modifier-border)"
  },
  tabs: {
    "--tab-background-active": "var(--background-primary)",
    "--tab-text-color": "var(--text-faint)",
    "--tab-text-color-active": "var(--text-muted)",
    "--tab-text-color-focused": "var(--text-muted)",
    "--tab-text-color-focused-active": "var(--text-muted)",
    "--tab-text-color-focused-highlighted": "var(--text-accent)",
    "--tab-text-color-focused-active-current": "var(--text-normal)",
    "--tab-font-size": "var(--font-ui-small)",
    "--tab-font-weight": "inherit",
    "--tab-container-background": "var(--background-secondary)",
    "--tab-divider-color": "var(--background-modifier-border-hover)",
    "--tab-outline-color": "var(--divider-color)",
    "--tab-outline-width": "1px",
    "--tab-curve": "6px",
    "--tab-radius": "var(--radius-s)",
    "--tab-radius-active": "6px 6px 0 0",
    "--tab-width": "200px",
    "--tab-max-width": "320px",
    "--tab-stacked-pane-width": "700px",
    "--tab-stacked-header-width": "var(--header-height)",
    "--tab-stacked-font-size": "var(--font-ui-small)",
    "--tab-stacked-font-weight": "400",
    "--tab-stacked-text-align": "start",
    "--tab-stacked-text-transform": "rotate(0deg)",
    "--tab-stacked-text-writing-mode": "vertical-lr",
    "--tab-stacked-shadow": "-8px 0 8px 0 rgba(0, 0, 0, 0.05)"
  },
  tag: {
    "--tag-size": "var(--font-smaller)",
    "--tag-color": "var(--text-accent)",
    "--tag-color-hover": "var(--text-accent)",
    "--tag-decoration": "none",
    "--tag-decoration-hover": "none",
    "--tag-background": "hsla(var(--interactive-accent-hsl), 0.1)",
    "--tag-background-hover": "hsla(var(--interactive-accent-hsl), 0.2)",
    "--tag-border-color": "hsla(var(--interactive-accent-hsl), 0.15)",
    "--tag-border-color-hover": "hsla(var(--interactive-accent-hsl), 0.15)",
    "--tag-border-width": "0px",
    "--tag-padding-x": "0.65em",
    "--tag-padding-y": "0.25em",
    "--tag-radius": "2em",
    "--tag-weight": "inherit"
  },
  textinput: {
    "--input-height": "30px",
    "--input-padding": "var(--size-4-1) var(--size-4-2)",
    "--input-radius": "5px",
    "--input-font-weight": "var(--font-normal)",
    "--input-border-width": "1px",
    "--input-border-width-focus": "2px",
    "--input-placeholder-color": "var(--text-faint)",
    "--input-date-separator": "var(--text-faint)"
  },
  toggle: {
    "--toggle-border-width": "2px",
    "--toggle-width": "40px",
    "--toggle-radius": "18px",
    "--toggle-thumb-color": "white",
    "--toggle-thumb-radius": "18px",
    "--toggle-thumb-height": "18px",
    "--toggle-thumb-width": "18px",
    "--toggle-s-border-width": "2px",
    "--toggle-s-width": "34px",
    "--toggle-s-thumb-height": "15px",
    "--toggle-s-thumb-width": "15px"
  },
  themelight: {
    "--highlight-mix-blend-mode": "darken",
    "--mono-rgb-0": "255, 255, 255",
    "--mono-rgb-100": "0, 0, 0",
    "--color-red-rgb": "233, 49, 71",
    "--color-red": "#e93147",
    "--color-orange-rgb": "236, 117, 0",
    "--color-orange": "#ec7500",
    "--color-yellow-rgb": "224, 172, 0",
    "--color-yellow": "#e0ac00",
    "--color-green-rgb": "8, 185, 78",
    "--color-green": "#08b94e",
    "--color-cyan-rgb": "0, 191, 188",
    "--color-cyan": "#00bfbc",
    "--color-blue-rgb": "8, 109, 221",
    "--color-blue": "#086ddd",
    "--color-purple-rgb": "120, 82, 238",
    "--color-purple": "#7852ee",
    "--color-pink-rgb": "213, 57, 132",
    "--color-pink": "#d53984",
    "--color-base-00": "#ffffff",
    "--color-base-05": "#fcfcfc",
    "--color-base-10": "#fafafa",
    "--color-base-20": "#f6f6f6",
    "--color-base-25": "#e3e3e3",
    "--color-base-30": "#e0e0e0",
    "--color-base-35": "#d4d4d4",
    "--color-base-40": "#bdbdbd",
    "--color-base-50": "#ababab",
    "--color-base-60": "#707070",
    "--color-base-70": "#5c5c5c",
    "--color-base-100": "#222222",
    "--color-accent-hsl": "var(--accent-h), var(--accent-s), var(--accent-l)",
    "--color-accent": "hsl(var(--accent-h), var(--accent-s), var(--accent-l))",
    "--color-accent-1": "hsl(calc(var(--accent-h) - 1), calc(var(--accent-s) * 1.01), calc(var(--accent-l) * 1.075))",
    "--color-accent-2": "hsl(calc(var(--accent-h) - 3), calc(var(--accent-s) * 1.02), calc(var(--accent-l) * 1.15))",
    "--background-secondary-alt": "var(--color-base-05)",
    "--background-modifier-box-shadow": "rgba(0, 0, 0, 0.1)",
    "--background-modifier-cover": "rgba(220, 220, 220, 0.4)",
    "--input-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.12), 0 2px 3px 0 rgba(0, 0, 0, 0.05), 0 1px 1.5px 0 rgba(0, 0, 0, 0.03), 0 1px 2px 0 rgba(0, 0, 0, 0.04), 0 0 0 0 transparent",
    "--input-shadow-hover": "inset 0 0 0 1px rgba(0, 0, 0, 0.17), 0 2px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 1.5px 0 rgba(0, 0, 0, 0.03), 0 1px 2px 0 rgba(0, 0, 0, 0.04), 0 0 0 0 transparent",
    "--shadow-s": "0px 1px 2px rgba(0, 0, 0, 0.028), 0px 3.4px 6.7px rgba(0, 0, 0, 0.042), 0px 15px 30px rgba(0, 0, 0, 0.07)",
    "--shadow-l": "0px 1.8px 7.3px rgba(0, 0, 0, 0.071), 0px 6.3px 24.7px rgba(0, 0, 0, 0.112), 0px 15px 30px rgba(0, 0, 0, 0.1)"
  },
  themedark: {
    "--highlight-mix-blend-mode": "lighten",
    "--mono-rgb-0": "0, 0, 0",
    "--mono-rgb-100": "255, 255, 255",
    "--color-red-rgb": "251, 70, 76",
    "--color-red": "#fb464c",
    "--color-orange-rgb": "233, 151, 63",
    "--color-orange": "#e9973f",
    "--color-yellow-rgb": "224, 222, 113",
    "--color-yellow": "#e0de71",
    "--color-green-rgb": "68, 207, 110",
    "--color-green": "#44cf6e",
    "--color-cyan-rgb": "83, 223, 221",
    "--color-cyan": "#53dfdd",
    "--color-blue-rgb": "2, 122, 255",
    "--color-blue": "#027aff",
    "--color-purple-rgb": "168, 130, 255",
    "--color-purple": "#a882ff",
    "--color-pink-rgb": "250, 153, 205",
    "--color-pink": "#fa99cd",
    "--color-base-00": "#1e1e1e",
    "--color-base-05": "#212121",
    "--color-base-10": "#242424",
    "--color-base-20": "#262626",
    "--color-base-25": "#2a2a2a",
    "--color-base-30": "#363636",
    "--color-base-35": "#3f3f3f",
    "--color-base-40": "#555555",
    "--color-base-50": "#666666",
    "--color-base-60": "#999999",
    "--color-base-70": "#b3b3b3",
    "--color-base-100": "#dadada",
    "--color-accent-hsl": "var(--accent-h), var(--accent-s), var(--accent-l)",
    "--color-accent": "hsl(var(--accent-h), var(--accent-s), var(--accent-l))",
    "--color-accent-1": "hsl(calc(var(--accent-h) - 3), calc(var(--accent-s) * 1.02), calc(var(--accent-l) * 1.15))",
    "--color-accent-2": "hsl(calc(var(--accent-h) - 5), calc(var(--accent-s) * 1.05), calc(var(--accent-l) * 1.29))",
    "--background-modifier-form-field": "var(--color-base-25)",
    "--background-secondary-alt": "var(--color-base-30)",
    "--interactive-normal": "var(--color-base-30)",
    "--interactive-hover": "var(--color-base-35)",
    "--text-accent": "var(--color-accent-1)",
    "--interactive-accent": "var(--color-accent)",
    "--interactive-accent-hover": "var(--color-accent-1)",
    "--background-modifier-box-shadow": "rgba(0, 0, 0, 0.3)",
    "--background-modifier-cover": "rgba(10, 10, 10, 0.4)",
    "--text-selection": "hsla(var(--interactive-accent-hsl), 0.33)",
    "--input-shadow": "inset 0 0.5px 0.5px 0.5px rgba(255, 255, 255, 0.09), 0 2px 4px 0 rgba(0, 0, 0, 0.15), 0 1px 1.5px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.2), 0 0 0 0 transparent",
    "--input-shadow-hover": "inset 0 0.5px 1px 0.5px rgba(255, 255, 255, 0.16), 0 2px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 1.5px 0 rgba(0, 0, 0, 0.2), 0 1px 2px 0 rgba(0, 0, 0, 0.4), 0 0 0 0 transparent",
    "--shadow-s": "0px 1px 2px rgba(0, 0, 0, 0.121), 0px 3.4px 6.7px rgba(0, 0, 0, 0.179), 0px 15px 30px rgba(0, 0, 0, 0.3)",
    "--shadow-l": "0px 1.8px 7.3px rgba(0, 0, 0, 0.071), 0px 6.3px 24.7px rgba(0, 0, 0, 0.112), 0px 30px 90px rgba(0, 0, 0, 0.2)",
    "--pdf-shadow": "0 0 0 1px var(--background-modifier-border)",
    "--pdf-thumbnail-shadow": "0 0 0 1px var(--background-modifier-border)"
  },
  typography: {
    "--font-default": 'ui-sans-serif, -apple-system, BlinkMacSystemFont, system-ui, "Segoe UI", Roboto, "Inter", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif',
    "--font-monospace-default": 'ui-monospace, SFMono-Regular, "Cascadia Mono", "Roboto Mono", "DejaVu Sans Mono", "Liberation Mono", Menlo, Monaco, "Consolas", "Source Code Pro", monospace',
    "--font-interface-override": "'??'",
    "--font-interface-theme": "'??'",
    "--font-interface": "var(--font-interface-override), var(--font-interface-theme), var(--default-font, '??'), var(--font-default)",
    "--font-text-override": "'??'",
    "--font-text-theme": "'??'",
    "--font-text": "var(--font-text-override), var(--font-text-theme), var(--font-default)",
    "--font-print-override": "'??'",
    "--font-print": "var(--font-print-override), var(--font-text-override), var(--font-text-theme), 'Arial'",
    "--font-monospace-override": "'??'",
    "--font-monospace-theme": "'??'",
    "--font-monospace": "var(--font-monospace-override), var(--font-monospace-theme), var(--font-monospace-default)",
    "--font-mermaid": "var(--font-text)",
    "--font-text-size": "16px",
    "--font-smallest": "0.8em",
    "--font-smaller": "0.875em",
    "--font-small": "0.933em",
    "--font-ui-smaller": "12px",
    "--font-ui-small": "13px",
    "--font-ui-medium": "15px",
    "--font-ui-large": "20px",
    "--font-weight": "var(--font-normal)",
    "--font-thin": "100",
    "--font-extralight": "200",
    "--font-light": "300",
    "--font-normal": "400",
    "--font-medium": "500",
    "--font-semibold": "600",
    "--font-bold": "700",
    "--font-extrabold": "800",
    "--font-black": "900",
    "--bold-modifier": "200",
    "--bold-color": "inherit",
    "--bold-weight": "calc(var(--font-weight) + var(--bold-modifier))",
    "--italic-color": "inherit",
    "--italic-weight": "inherit",
    "--line-height-normal": "1.5",
    "--line-height-tight": "1.3",
    "--heading-spacing": "calc(var(--p-spacing) * 2.5)",
    "--p-spacing": "1rem",
    "--p-spacing-empty": "0rem"
  },
  vaultprofile: {
    "--vault-profile-display": "flex",
    "--vault-profile-actions-display": "flex",
    "--vault-profile-font-size": "var(--font-ui-small)",
    "--vault-profile-font-weight": "var(--font-medium)",
    "--vault-profile-color": "var(--text-normal)",
    "--vault-profile-color-hover": "var(--vault-profile-color)"
  },
  windowframe: {
    "--titlebar-background": "var(--background-secondary)",
    "--titlebar-background-focused": "var(--background-secondary-alt)",
    "--titlebar-border-width": "0px",
    "--titlebar-border-color": "var(--background-modifier-border)",
    "--titlebar-text-color": "var(--text-muted)",
    "--titlebar-text-color-focused": "var(--text-normal)",
    "--titlebar-text-weight": "var(--font-bold)",
    "--header-height": "40px"
  },
  workspace: {
    "--workspace-background-translucent": "rgba(var(--mono-rgb-0), 0.6)"
  }
};

// src/managers/cssVariabManager.ts
function createHelpFragment(text, parent = "", category = "") {
  const helpFragment = document.createDocumentFragment();
  if (text !== "") {
    helpFragment.append(text);
    return helpFragment;
  }
  if (parent && category) {
    const link = helpFragment.createEl("a");
    link.className = "external-link";
    link.href = `https://docs.obsidian.md/Reference/CSS+variables/${parent}/${category}`;
    link.textContent = `${category} - Developer Documentation`;
    link.setAttribute("aria-label", `https://docs.obsidian.md/Reference/${parent}/${category}`);
    link.setAttribute("data-tooltip-position", "top");
    link.setAttribute("tabindex", "0");
    helpFragment.appendChild(link);
  }
  return helpFragment;
}
var variableCategories = {
  animation: { parent: "Foundations", category: "Animation", text: "Animation variables" },
  bases: { parent: "Editor", category: "Bases" },
  blockquote: { parent: "Editor", category: "Blockquote" },
  borders: { parent: "Foundations", category: "Borders" },
  button: { parent: "Components", category: "Button" },
  callout: { parent: "Editor", category: "Callout" },
  canvas: { parent: "Plugins", category: "Canvas" },
  checkbox: { parent: "Components", category: "Checkbox" },
  code: { parent: "Editor", category: "Code" },
  colorinput: { parent: "Components", category: "Color+input" },
  colors: { parent: "Foundations", category: "Colors" },
  cts: { parent: "CTS", category: "Custom Theme Studio plugin", text: "Variables for the element selector and highlighted element" },
  cursor: { parent: "Foundations", category: "Cursor" },
  custom: { parent: "CTS", category: "Custom variables", text: "Custom variables" },
  dialog: { parent: "Components", category: "Dialog" },
  divider: { parent: "Window", category: "Dividers", text: "Dividers between panes" },
  dragging: { parent: "Components", category: "Dragging" },
  dropdowns: { parent: "Components", category: "Dropdowns" },
  embed: { parent: "Editor", category: "Embed" },
  file: { parent: "Editor", category: "File" },
  fileexplorer: { parent: "Plugins", category: "File+explorer" },
  footnote: { parent: "Editor", category: "Footnote" },
  graph: { parent: "Plugins", category: "Graph" },
  headings: { parent: "Editor", category: "Headings" },
  horizontalrule: { parent: "Editor", category: "Horizontal+rule" },
  icons: { parent: "Foundations", category: "Icons" },
  indentation: { parent: "Components", category: "Indentation+guides" },
  inlinetitle: { parent: "Editor", category: "Inline+title" },
  layers: { parent: "Foundations", category: "Layers" },
  link: { parent: "Editor", category: "Link" },
  list: { parent: "Editor", category: "List" },
  modal: { parent: "Components", category: "Modal" },
  multiselect: { parent: "Components", category: "Multi-select" },
  navigation: { parent: "Components", category: "Navigation" },
  popover: { parent: "Components", category: "Popover" },
  prompt: { parent: "Components", category: "Prompt" },
  properties: { parent: "Editor", category: "Properties" },
  radiuses: { parent: "Foundations", category: "Radiuses" },
  ribbon: { parent: "Window", category: "Ribbon" },
  scrollbar: { parent: "Window", category: "Scrollbar" },
  search: { parent: "Plugins", category: "Search" },
  sidebar: { parent: "Window", category: "Sidebar" },
  slider: { parent: "Components", category: "Slider" },
  spacing: { parent: "Foundations", category: "Spacing" },
  statusbar: { parent: "Window", category: "Status+bar" },
  sync: { parent: "Plugins", category: "Sync" },
  table: { parent: "Editor", category: "Table" },
  tabs: { parent: "Components", category: "Tabs" },
  tag: { parent: "Editor", category: "Tag" },
  textinput: { parent: "Components", category: "Text+input" },
  toggle: { parent: "Components", category: "Toggle" },
  themelight: { parent: "Theme-light", category: "Theme - light", text: "Variables specifically for light theme" },
  themedark: { parent: "Theme-dark", category: "Theme - dark", text: "Variables specifically for dark theme" },
  typography: { parent: "Foundations", category: "Typography" },
  vaultprofile: { parent: "Window", category: "Vault+profile" },
  windowframe: { parent: "Window", category: "Window+frame" },
  workspace: { parent: "Window", category: "Workspace" }
};
var dynamicCategories = Object.entries(variableCategories).map(
  ([key, { text = "", parent = "", category = "" }]) => ({
    category: key,
    title: category,
    tag: parent.toLowerCase(),
    help: createHelpFragment(text, parent, category)
  })
);
var allCategories = dynamicCategories.sort(
  (a, b2) => a.title.localeCompare(b2.title)
);
var cssVariableDefaults = Object.entries(obsidianCSSVariables_default).flatMap(
  ([cat, group]) => Object.entries(group).map(([variable, defaultVal]) => ({
    cat,
    variable,
    default: defaultVal
  }))
);
var CSSVariableManager = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Update a CSS variable value
   */
  updateVariable(uuid, name, value, parent) {
    let customVars = this.plugin.settings.cssVariables;
    if (!customVars) {
      this.plugin.settings.cssVariables = [];
    }
    const updateVar = (target, name2, value2) => {
      target.variable = name2;
      target.value = value2;
    };
    const removeVarByUUID = (uuid2) => {
      const index = customVars.findIndex((el) => el.uuid === uuid2);
      if (index !== -1) customVars.splice(index, 1);
    };
    if (uuid) {
      const existing = customVars.find((el) => el.uuid === uuid);
      if (!existing) return;
      if (value !== "") {
        updateVar(existing, name, value);
      } else {
        removeVarByUUID(uuid);
      }
    } else {
      const existing = customVars.find((el) => el.variable === name && el.parent === parent);
      if (existing) {
        if (value !== "") {
          updateVar(existing, name, value);
        } else {
          removeVarByUUID(existing.uuid);
        }
      } else if (value !== "") {
        const obj = {
          uuid: generateUniqueId(),
          parent,
          variable: name,
          value
        };
        customVars.push(obj);
      }
    }
    this.plugin.saveSettings();
  }
  snippetManagerVars() {
    let snippetContent = "";
    cssVariableDefaults.forEach((variable) => {
      snippetContent += "snippet " + variable.variable + "\n";
      snippetContent += "	" + variable.variable + "\n";
    });
    return snippetContent;
  }
};

// src/managers/css/CSSRuleItemRenderer.ts
var import_obsidian5 = require("obsidian");
init_confirmModal();
var CSSRuleItemRenderer = class {
  constructor(config) {
    this.config = config;
  }
  /**
   * Creates a complete rule item DOM element with buttons and event handlers
   */
  createRuleItem(containerEl, rule) {
    const item = containerEl.createDiv({
      cls: "rule-item",
      attr: {
        "data-cts-uuid": rule.uuid,
        "data-tooltip-position": "top"
      }
    });
    const ruleHeader = item.createDiv("rule-item-header");
    this.createTitle(ruleHeader, rule);
    this.createActions(ruleHeader, rule, item);
    return item;
  }
  /**
   * Updates the content of an existing rule item without re-creating it
   */
  updateRuleItemContent(item, rule) {
    item.setAttr("data-cts-uuid", rule.uuid);
    const titleEl = item.querySelector(".rule-item-title div");
    if (titleEl) {
      titleEl.textContent = rule.rule;
    }
    const enabledButton = item.querySelector(".rule-item-actions button:nth-child(2)");
    if (enabledButton) {
      if (rule.enabled) {
        (0, import_obsidian5.setIcon)(enabledButton, "eye");
        enabledButton.setAttr("aria-label", "Disable this rule");
      } else {
        (0, import_obsidian5.setIcon)(enabledButton, "eye-off");
        enabledButton.setAttr("aria-label", "Enable this rule");
      }
    }
  }
  createTitle(ruleHeader, rule) {
    const titleEl = ruleHeader.createDiv("rule-item-title");
    titleEl.createDiv({ text: rule.rule });
  }
  createActions(ruleHeader, rule, item) {
    const actionsEl = ruleHeader.createDiv("rule-item-actions");
    this.createEditButton(actionsEl, rule, item);
    this.createEnabledButton(actionsEl, rule, item);
    this.createDeleteButton(actionsEl, rule, item);
  }
  createEditButton(actionsEl, rule, item) {
    const editButton = actionsEl.createEl("button", { cls: "clickable-icon" });
    editButton.setAttr("aria-label", "Edit this rule");
    editButton.setAttr("data-tooltip-position", "top");
    editButton.setAttr("tabindex", "0");
    (0, import_obsidian5.setIcon)(editButton, "edit");
    editButton.addEventListener("click", async () => {
      const editorSection = this.config.view.containerEl.querySelector(".css-editor-section");
      const isEditorVisible = editorSection && getComputedStyle(editorSection).display !== "none";
      if (isEditorVisible && this.config.plugin.settings.showConfirmation) {
        if (!await confirm("You have an unsaved CSS rule form open. Editing another rule will discard your changes. Continue?", this.config.plugin.app)) {
          return;
        }
      }
      const uuid = item.getAttribute("data-cts-uuid");
      const freshRule = this.config.plugin.settings.cssRules.find((r) => r.uuid === uuid);
      if (freshRule) {
        this.config.onEdit(freshRule, item);
      }
    });
  }
  createEnabledButton(actionsEl, rule, item) {
    const enabledButton = actionsEl.createEl("button", { cls: "clickable-icon" });
    enabledButton.setAttr("data-tooltip-position", "top");
    enabledButton.setAttr("tabindex", "0");
    if (rule.enabled) {
      (0, import_obsidian5.setIcon)(enabledButton, "eye");
      enabledButton.setAttr("aria-label", "Disable this rule");
    } else {
      (0, import_obsidian5.setIcon)(enabledButton, "eye-off");
      enabledButton.setAttr("aria-label", "Enable this rule");
    }
    enabledButton.addEventListener("click", async () => {
      const uuid = item.getAttribute("data-cts-uuid");
      const freshRule = this.config.plugin.settings.cssRules.find((r) => r.uuid === uuid);
      if (freshRule) {
        await this.config.onToggle(freshRule, enabledButton);
      }
    });
  }
  createDeleteButton(actionsEl, rule, item) {
    const deleteButton = actionsEl.createEl("button", {
      cls: "rule-item-delete-button clickable-icon mod-destructive"
    });
    deleteButton.setAttr("aria-label", "Delete this rule");
    deleteButton.setAttr("data-tooltip-position", "top");
    deleteButton.setAttr("tabindex", "0");
    (0, import_obsidian5.setIcon)(deleteButton, "trash");
    deleteButton.addEventListener("click", async () => {
      deleteButton.addClass("mod-loading");
      const uuid = item.getAttribute("data-cts-uuid");
      const freshRule = this.config.plugin.settings.cssRules.find((r) => r.uuid === uuid);
      if (freshRule && await confirm(`Are you sure you want to delete the rule "${freshRule.rule}"?`, this.config.plugin.app)) {
        await this.config.onDelete(freshRule, item);
        showNotice("CSS rule deleted", NOTICE_DURATIONS.STANDARD, "success");
      }
      deleteButton.removeClass("mod-loading");
    });
  }
};

// src/managers/css/CSSRuleListManager.ts
var import_obsidian6 = require("obsidian");
var CSSRuleListManager = class {
  constructor(plugin, view, renderer, container) {
    this.plugin = plugin;
    this.view = view;
    this.renderer = renderer;
    this.container = container;
  }
  /**
   * Add a new rule item to the list in sorted position.
   * INCREMENTAL UPDATE: Only creates and inserts the new item, no full rebuild.
   * @returns The created DOM element for scrolling/animation
   */
  addRuleItem(rule) {
    const sortedRules = [...this.plugin.settings.cssRules].sort(
      (a, b2) => a.rule.localeCompare(b2.rule)
    );
    const position = sortedRules.findIndex((r) => r.uuid === rule.uuid);
    const existingItems = this.container.querySelectorAll(".rule-item");
    let item;
    if (position === 0 || existingItems.length === 0) {
      item = this.renderer.createRuleItem(this.container, rule);
      if (existingItems.length > 0) {
        this.container.insertBefore(item, existingItems[0]);
      }
    } else if (position >= existingItems.length) {
      item = this.renderer.createRuleItem(this.container, rule);
    } else {
      item = this.renderer.createRuleItem(this.container, rule);
      this.container.insertBefore(item, existingItems[position]);
    }
    return item;
  }
  /**
   * Update an existing rule item in place.
   * INCREMENTAL UPDATE: Only updates the specific item, no full rebuild.
   * @returns The updated DOM element for scrolling/animation
   */
  updateRuleItem(uuid, rule) {
    const item = this.container.querySelector(`[data-cts-uuid="${uuid}"]`);
    if (!item) return null;
    const sortedRules = [...this.plugin.settings.cssRules].sort(
      (a, b2) => a.rule.localeCompare(b2.rule)
    );
    const newPosition = sortedRules.findIndex((r) => r.uuid === uuid);
    const currentPosition = Array.from(this.container.querySelectorAll(".rule-item")).indexOf(item);
    if (newPosition !== currentPosition) {
      item.remove();
      const existingItems = this.container.querySelectorAll(".rule-item");
      if (newPosition === 0) {
        this.container.insertBefore(item, existingItems[0]);
      } else if (newPosition >= existingItems.length) {
        this.container.appendChild(item);
      } else {
        this.container.insertBefore(item, existingItems[newPosition]);
      }
    }
    this.renderer.updateRuleItemContent(item, rule);
    return item;
  }
  /**
   * Remove a rule item from the list.
   * INCREMENTAL UPDATE: Only removes the specific item, no full rebuild.
   */
  removeRuleItem(uuid) {
    const item = this.container.querySelector(`[data-cts-uuid="${uuid}"]`);
    if (item) {
      item.remove();
    }
  }
  /**
   * Toggle a rule's enabled state without re-rendering.
   * INCREMENTAL UPDATE: Only updates the button icon, no full rebuild.
   */
  toggleRuleEnabled(uuid, enabled) {
    const item = this.container.querySelector(`[data-cts-uuid="${uuid}"]`);
    if (!item) return;
    const enabledButton = item.querySelector(".rule-item-actions button:nth-child(2)");
    if (!enabledButton) return;
    const { setIcon: setIcon10 } = require("obsidian");
    if (enabled) {
      setIcon10(enabledButton, "eye");
      enabledButton.setAttr("aria-label", "Disable this rule");
    } else {
      setIcon10(enabledButton, "eye-off");
      enabledButton.setAttr("aria-label", "Enable this rule");
    }
  }
  /**
   * Scroll to an element and apply highlight animation.
   * Unified method to eliminate duplication and timing workarounds.
   */
  scrollToAndHighlight(element) {
    if (!this.plugin.settings.viewScrollToTop) return;
    const scrollDelayed = (0, import_obsidian6.debounce)(() => {
      this.scrollToElement(element);
    }, 100, false);
    scrollDelayed();
    element.addClass("blinking-effect");
    const removeHighlight = (0, import_obsidian6.debounce)(() => {
      element.removeClass("blinking-effect");
    }, 3e3, false);
    removeHighlight();
  }
  /**
   * Scroll to a specific element in the view
   */
  scrollToElement(target) {
    const container = this.view.containerEl;
    if (container && target) {
      smoothScrollToElement(container, target);
    }
  }
  /**
   * Populate the entire list (used for initial render only).
   * After initial render, use incremental methods.
   */
  populateList() {
    this.container.empty();
    const sortedRules = [...this.plugin.settings.cssRules].sort(
      (a, b2) => a.rule.localeCompare(b2.rule)
    );
    sortedRules.forEach((rule) => {
      this.renderer.createRuleItem(this.container, rule);
    });
  }
  /**
   * Get the container element
   */
  getContainer() {
    return this.container;
  }
};

// node_modules/prettier/standalone.mjs
var Fu = Object.create;
var pt = Object.defineProperty;
var pu = Object.getOwnPropertyDescriptor;
var du = Object.getOwnPropertyNames;
var mu = Object.getPrototypeOf;
var Eu = Object.prototype.hasOwnProperty;
var er = (e) => {
  throw TypeError(e);
};
var Cu = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var dt = (e, t) => {
  for (var r in t) pt(e, r, { get: t[r], enumerable: true });
};
var hu = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function") for (let u of du(t)) !Eu.call(e, u) && u !== r && pt(e, u, { get: () => t[u], enumerable: !(n = pu(t, u)) || n.enumerable });
  return e;
};
var gu = (e, t, r) => (r = e != null ? Fu(mu(e)) : {}, hu(t || !e || !e.__esModule ? pt(r, "default", { value: e, enumerable: true }) : r, e));
var yu = (e, t, r) => t.has(e) || er("Cannot " + r);
var tr = (e, t, r) => t.has(e) ? er("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
var fe = (e, t, r) => (yu(e, t, "access private method"), r);
var Pn = Cu((Mt2) => {
  "use strict";
  Object.defineProperty(Mt2, "__esModule", { value: true });
  function Co() {
    return new Proxy({}, { get: () => (e) => e });
  }
  var On2 = /\r\n|[\n\r\u2028\u2029]/;
  function ho(e, t, r) {
    let n = Object.assign({ column: 0, line: -1 }, e.start), u = Object.assign({}, n, e.end), { linesAbove: o = 2, linesBelow: i = 3 } = r || {}, s = n.line, a = n.column, c = u.line, D2 = u.column, p = Math.max(s - (o + 1), 0), l = Math.min(t.length, c + i);
    s === -1 && (p = 0), c === -1 && (l = t.length);
    let F = c - s, f = {};
    if (F) for (let d = 0; d <= F; d++) {
      let m = d + s;
      if (!a) f[m] = true;
      else if (d === 0) {
        let C = t[m - 1].length;
        f[m] = [a, C - a + 1];
      } else if (d === F) f[m] = [0, D2];
      else {
        let C = t[m - d].length;
        f[m] = [0, C];
      }
    }
    else a === D2 ? a ? f[s] = [a, 0] : f[s] = true : f[s] = [a, D2 - a];
    return { start: p, end: l, markerLines: f };
  }
  function go2(e, t, r = {}) {
    let u = Co(false), o = e.split(On2), { start: i, end: s, markerLines: a } = ho(t, o, r), c = t.start && typeof t.start.column == "number", D2 = String(s).length, l = e.split(On2, s).slice(i, s).map((F, f) => {
      let d = i + 1 + f, C = ` ${` ${d}`.slice(-D2)} |`, E2 = a[d], h = !a[d + 1];
      if (E2) {
        let x = "";
        if (Array.isArray(E2)) {
          let A2 = F.slice(0, Math.max(E2[0] - 1, 0)).replace(/[^\t]/g, " "), $2 = E2[1] || 1;
          x = [`
 `, u.gutter(C.replace(/\d/g, " ")), " ", A2, u.marker("^").repeat($2)].join(""), h && r.message && (x += " " + u.message(r.message));
        }
        return [u.marker(">"), u.gutter(C), F.length > 0 ? ` ${F}` : "", x].join("");
      } else return ` ${u.gutter(C)}${F.length > 0 ? ` ${F}` : ""}`;
    }).join(`
`);
    return r.message && !c && (l = `${" ".repeat(D2 + 1)}${r.message}
${l}`), l;
  }
  Mt2.codeFrameColumns = go2;
});
var Zt = {};
dt(Zt, { __debug: () => ui, check: () => ri, doc: () => qt, format: () => fu, formatWithCursor: () => cu, getSupportInfo: () => ni, util: () => Qt, version: () => tu });
var Au = (e, t, r, n) => {
  if (!(e && t == null)) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
};
var te = Au;
var _e = class {
  diff(t, r, n = {}) {
    let u;
    typeof n == "function" ? (u = n, n = {}) : "callback" in n && (u = n.callback);
    let o = this.castInput(t, n), i = this.castInput(r, n), s = this.removeEmpty(this.tokenize(o, n)), a = this.removeEmpty(this.tokenize(i, n));
    return this.diffWithOptionsObj(s, a, n, u);
  }
  diffWithOptionsObj(t, r, n, u) {
    var o;
    let i = (E2) => {
      if (E2 = this.postProcess(E2, n), u) {
        setTimeout(function() {
          u(E2);
        }, 0);
        return;
      } else return E2;
    }, s = r.length, a = t.length, c = 1, D2 = s + a;
    n.maxEditLength != null && (D2 = Math.min(D2, n.maxEditLength));
    let p = (o = n.timeout) !== null && o !== void 0 ? o : 1 / 0, l = Date.now() + p, F = [{ oldPos: -1, lastComponent: void 0 }], f = this.extractCommon(F[0], r, t, 0, n);
    if (F[0].oldPos + 1 >= a && f + 1 >= s) return i(this.buildValues(F[0].lastComponent, r, t));
    let d = -1 / 0, m = 1 / 0, C = () => {
      for (let E2 = Math.max(d, -c); E2 <= Math.min(m, c); E2 += 2) {
        let h, x = F[E2 - 1], A2 = F[E2 + 1];
        x && (F[E2 - 1] = void 0);
        let $2 = false;
        if (A2) {
          let Be2 = A2.oldPos - E2;
          $2 = A2 && 0 <= Be2 && Be2 < s;
        }
        let ue2 = x && x.oldPos + 1 < a;
        if (!$2 && !ue2) {
          F[E2] = void 0;
          continue;
        }
        if (!ue2 || $2 && x.oldPos < A2.oldPos ? h = this.addToPath(A2, true, false, 0, n) : h = this.addToPath(x, false, true, 1, n), f = this.extractCommon(h, r, t, E2, n), h.oldPos + 1 >= a && f + 1 >= s) return i(this.buildValues(h.lastComponent, r, t)) || true;
        F[E2] = h, h.oldPos + 1 >= a && (m = Math.min(m, E2 - 1)), f + 1 >= s && (d = Math.max(d, E2 + 1));
      }
      c++;
    };
    if (u) (function E2() {
      setTimeout(function() {
        if (c > D2 || Date.now() > l) return u(void 0);
        C() || E2();
      }, 0);
    })();
    else for (; c <= D2 && Date.now() <= l; ) {
      let E2 = C();
      if (E2) return E2;
    }
  }
  addToPath(t, r, n, u, o) {
    let i = t.lastComponent;
    return i && !o.oneChangePerToken && i.added === r && i.removed === n ? { oldPos: t.oldPos + u, lastComponent: { count: i.count + 1, added: r, removed: n, previousComponent: i.previousComponent } } : { oldPos: t.oldPos + u, lastComponent: { count: 1, added: r, removed: n, previousComponent: i } };
  }
  extractCommon(t, r, n, u, o) {
    let i = r.length, s = n.length, a = t.oldPos, c = a - u, D2 = 0;
    for (; c + 1 < i && a + 1 < s && this.equals(n[a + 1], r[c + 1], o); ) c++, a++, D2++, o.oneChangePerToken && (t.lastComponent = { count: 1, previousComponent: t.lastComponent, added: false, removed: false });
    return D2 && !o.oneChangePerToken && (t.lastComponent = { count: D2, previousComponent: t.lastComponent, added: false, removed: false }), t.oldPos = a, c;
  }
  equals(t, r, n) {
    return n.comparator ? n.comparator(t, r) : t === r || !!n.ignoreCase && t.toLowerCase() === r.toLowerCase();
  }
  removeEmpty(t) {
    let r = [];
    for (let n = 0; n < t.length; n++) t[n] && r.push(t[n]);
    return r;
  }
  castInput(t, r) {
    return t;
  }
  tokenize(t, r) {
    return Array.from(t);
  }
  join(t) {
    return t.join("");
  }
  postProcess(t, r) {
    return t;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(t, r, n) {
    let u = [], o;
    for (; t; ) u.push(t), o = t.previousComponent, delete t.previousComponent, t = o;
    u.reverse();
    let i = u.length, s = 0, a = 0, c = 0;
    for (; s < i; s++) {
      let D2 = u[s];
      if (D2.removed) D2.value = this.join(n.slice(c, c + D2.count)), c += D2.count;
      else {
        if (!D2.added && this.useLongestToken) {
          let p = r.slice(a, a + D2.count);
          p = p.map(function(l, F) {
            let f = n[c + F];
            return f.length > l.length ? f : l;
          }), D2.value = this.join(p);
        } else D2.value = this.join(r.slice(a, a + D2.count));
        a += D2.count, D2.added || (c += D2.count);
      }
    }
    return u;
  }
};
var mt = class extends _e {
  tokenize(t) {
    return t.slice();
  }
  join(t) {
    return t;
  }
  removeEmpty(t) {
    return t;
  }
};
var rr = new mt();
function Et(e, t, r) {
  return rr.diff(e, t, r);
}
function nr(e) {
  let t = e.indexOf("\r");
  return t !== -1 ? e.charAt(t + 1) === `
` ? "crlf" : "cr" : "lf";
}
function xe(e) {
  switch (e) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Ct(e, t) {
  let r;
  switch (t) {
    case `
`:
      r = /\n/gu;
      break;
    case "\r":
      r = /\r/gu;
      break;
    case `\r
`:
      r = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
  }
  let n = e.match(r);
  return n ? n.length : 0;
}
function ur(e) {
  return te(false, e, /\r\n?/gu, `
`);
}
var W = "string";
var Y = "array";
var j = "cursor";
var N = "indent";
var O = "align";
var P = "trim";
var B = "group";
var k = "fill";
var _ = "if-break";
var v = "indent-if-break";
var L = "line-suffix";
var I = "line-suffix-boundary";
var g = "line";
var S = "label";
var w = "break-parent";
var Ue = /* @__PURE__ */ new Set([j, N, O, P, B, k, _, v, L, I, g, S, w]);
var Bu = (e, t, r) => {
  if (!(e && t == null)) return Array.isArray(t) || typeof t == "string" ? t[r < 0 ? t.length + r : r] : t.at(r);
};
var y = Bu;
function or(e) {
  let t = e.length;
  for (; t > 0 && (e[t - 1] === "\r" || e[t - 1] === `
`); ) t--;
  return t < e.length ? e.slice(0, t) : e;
}
function _u(e) {
  if (typeof e == "string") return W;
  if (Array.isArray(e)) return Y;
  if (!e) return;
  let { type: t } = e;
  if (Ue.has(t)) return t;
}
var M = _u;
var xu = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
function wu(e) {
  let t = e === null ? "null" : typeof e;
  if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
  if (M(e)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(e);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let n = xu([...Ue].map((u) => `'${u}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
}
var ht = class extends Error {
  constructor(t) {
    super(wu(t));
    __publicField(this, "name", "InvalidDocError");
    this.doc = t;
  }
};
var q = ht;
var ir = {};
function bu(e, t, r, n) {
  let u = [e];
  for (; u.length > 0; ) {
    let o = u.pop();
    if (o === ir) {
      r(u.pop());
      continue;
    }
    r && u.push(o, ir);
    let i = M(o);
    if (!i) throw new q(o);
    if ((t == null ? void 0 : t(o)) !== false) switch (i) {
      case Y:
      case k: {
        let s = i === Y ? o : o.parts;
        for (let a = s.length, c = a - 1; c >= 0; --c) u.push(s[c]);
        break;
      }
      case _:
        u.push(o.flatContents, o.breakContents);
        break;
      case B:
        if (n && o.expandedStates) for (let s = o.expandedStates.length, a = s - 1; a >= 0; --a) u.push(o.expandedStates[a]);
        else u.push(o.contents);
        break;
      case O:
      case N:
      case v:
      case S:
      case L:
        u.push(o.contents);
        break;
      case W:
      case j:
      case P:
      case I:
      case g:
      case w:
        break;
      default:
        throw new q(o);
    }
  }
}
var le = bu;
function be(e, t) {
  if (typeof e == "string") return t(e);
  let r = /* @__PURE__ */ new Map();
  return n(e);
  function n(o) {
    if (r.has(o)) return r.get(o);
    let i = u(o);
    return r.set(o, i), i;
  }
  function u(o) {
    switch (M(o)) {
      case Y:
        return t(o.map(n));
      case k:
        return t({ ...o, parts: o.parts.map(n) });
      case _:
        return t({ ...o, breakContents: n(o.breakContents), flatContents: n(o.flatContents) });
      case B: {
        let { expandedStates: i, contents: s } = o;
        return i ? (i = i.map(n), s = i[0]) : s = n(s), t({ ...o, contents: s, expandedStates: i });
      }
      case O:
      case N:
      case v:
      case S:
      case L:
        return t({ ...o, contents: n(o.contents) });
      case W:
      case j:
      case P:
      case I:
      case g:
      case w:
        return t(o);
      default:
        throw new q(o);
    }
  }
}
function Ve(e, t, r) {
  let n = r, u = false;
  function o(i) {
    if (u) return false;
    let s = t(i);
    s !== void 0 && (u = true, n = s);
  }
  return le(e, o), n;
}
function ku(e) {
  if (e.type === B && e.break || e.type === g && e.hard || e.type === w) return true;
}
function Dr(e) {
  return Ve(e, ku, false);
}
function sr(e) {
  if (e.length > 0) {
    let t = y(false, e, -1);
    !t.expandedStates && !t.break && (t.break = "propagated");
  }
  return null;
}
function cr(e) {
  let t = /* @__PURE__ */ new Set(), r = [];
  function n(o) {
    if (o.type === w && sr(r), o.type === B) {
      if (r.push(o), t.has(o)) return false;
      t.add(o);
    }
  }
  function u(o) {
    o.type === B && r.pop().break && sr(r);
  }
  le(e, n, u, true);
}
function Su(e) {
  return e.type === g && !e.hard ? e.soft ? "" : " " : e.type === _ ? e.flatContents : e;
}
function fr(e) {
  return be(e, Su);
}
function ar(e) {
  for (e = [...e]; e.length >= 2 && y(false, e, -2).type === g && y(false, e, -1).type === w; ) e.length -= 2;
  if (e.length > 0) {
    let t = we(y(false, e, -1));
    e[e.length - 1] = t;
  }
  return e;
}
function we(e) {
  switch (M(e)) {
    case N:
    case v:
    case B:
    case L:
    case S: {
      let t = we(e.contents);
      return { ...e, contents: t };
    }
    case _:
      return { ...e, breakContents: we(e.breakContents), flatContents: we(e.flatContents) };
    case k:
      return { ...e, parts: ar(e.parts) };
    case Y:
      return ar(e);
    case W:
      return or(e);
    case O:
    case j:
    case P:
    case I:
    case g:
    case w:
      break;
    default:
      throw new q(e);
  }
  return e;
}
function $e(e) {
  return we(Nu(e));
}
function Tu(e) {
  switch (M(e)) {
    case k:
      if (e.parts.every((t) => t === "")) return "";
      break;
    case B:
      if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
      if (e.contents.type === B && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
      break;
    case O:
    case N:
    case v:
    case L:
      if (!e.contents) return "";
      break;
    case _:
      if (!e.flatContents && !e.breakContents) return "";
      break;
    case Y: {
      let t = [];
      for (let r of e) {
        if (!r) continue;
        let [n, ...u] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof y(false, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...u);
      }
      return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
    }
    case W:
    case j:
    case P:
    case I:
    case g:
    case S:
    case w:
      break;
    default:
      throw new q(e);
  }
  return e;
}
function Nu(e) {
  return be(e, (t) => Tu(t));
}
function lr(e, t = We) {
  return be(e, (r) => typeof r == "string" ? ke(t, r.split(`
`)) : r);
}
function Ou(e) {
  if (e.type === g) return true;
}
function Fr(e) {
  return Ve(e, Ou, false);
}
function Fe(e, t) {
  return e.type === S ? { ...e, contents: t(e.contents) } : t(e);
}
var gt = () => {
};
var K = gt;
var yt = gt;
var pr = gt;
function ie(e) {
  return K(e), { type: N, contents: e };
}
function oe(e, t) {
  return K(t), { type: O, contents: t, n: e };
}
function At(e, t = {}) {
  return K(e), yt(t.expandedStates, true), { type: B, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
}
function dr(e) {
  return oe(Number.NEGATIVE_INFINITY, e);
}
function mr(e) {
  return oe({ type: "root" }, e);
}
function Er(e) {
  return oe(-1, e);
}
function Cr(e, t) {
  return At(e[0], { ...t, expandedStates: e });
}
function hr(e) {
  return pr(e), { type: k, parts: e };
}
function gr(e, t = "", r = {}) {
  return K(e), t !== "" && K(t), { type: _, breakContents: e, flatContents: t, groupId: r.groupId };
}
function yr(e, t) {
  return K(e), { type: v, contents: e, groupId: t.groupId, negate: t.negate };
}
function Se(e) {
  return K(e), { type: L, contents: e };
}
var Ar = { type: I };
var pe = { type: w };
var Br = { type: P };
var Te = { type: g, hard: true };
var Bt = { type: g, hard: true, literal: true };
var Me = { type: g };
var _r = { type: g, soft: true };
var z = [Te, pe];
var We = [Bt, pe];
var X = { type: j };
function ke(e, t) {
  K(e), yt(t);
  let r = [];
  for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
  return r;
}
function Ge(e, t, r) {
  K(e);
  let n = e;
  if (t > 0) {
    for (let u = 0; u < Math.floor(t / r); ++u) n = ie(n);
    n = oe(t % r, n), n = oe(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function xr(e, t) {
  return K(t), e ? { type: S, label: e, contents: t } : t;
}
function Q(e) {
  var t;
  if (!e) return "";
  if (Array.isArray(e)) {
    let r = [];
    for (let n of e) if (Array.isArray(n)) r.push(...Q(n));
    else {
      let u = Q(n);
      u !== "" && r.push(u);
    }
    return r;
  }
  return e.type === _ ? { ...e, breakContents: Q(e.breakContents), flatContents: Q(e.flatContents) } : e.type === B ? { ...e, contents: Q(e.contents), expandedStates: (t = e.expandedStates) == null ? void 0 : t.map(Q) } : e.type === k ? { type: "fill", parts: e.parts.map(Q) } : e.contents ? { ...e, contents: Q(e.contents) } : e;
}
function wr(e) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return n(Q(e));
  function n(o, i, s) {
    var a, c;
    if (typeof o == "string") return JSON.stringify(o);
    if (Array.isArray(o)) {
      let D2 = o.map(n).filter(Boolean);
      return D2.length === 1 ? D2[0] : `[${D2.join(", ")}]`;
    }
    if (o.type === g) {
      let D2 = ((a = s == null ? void 0 : s[i + 1]) == null ? void 0 : a.type) === w;
      return o.literal ? D2 ? "literalline" : "literallineWithoutBreakParent" : o.hard ? D2 ? "hardline" : "hardlineWithoutBreakParent" : o.soft ? "softline" : "line";
    }
    if (o.type === w) return ((c = s == null ? void 0 : s[i - 1]) == null ? void 0 : c.type) === g && s[i - 1].hard ? void 0 : "breakParent";
    if (o.type === P) return "trim";
    if (o.type === N) return "indent(" + n(o.contents) + ")";
    if (o.type === O) return o.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(o.contents) + ")" : o.n < 0 ? "dedent(" + n(o.contents) + ")" : o.n.type === "root" ? "markAsRoot(" + n(o.contents) + ")" : "align(" + JSON.stringify(o.n) + ", " + n(o.contents) + ")";
    if (o.type === _) return "ifBreak(" + n(o.breakContents) + (o.flatContents ? ", " + n(o.flatContents) : "") + (o.groupId ? (o.flatContents ? "" : ', ""') + `, { groupId: ${u(o.groupId)} }` : "") + ")";
    if (o.type === v) {
      let D2 = [];
      o.negate && D2.push("negate: true"), o.groupId && D2.push(`groupId: ${u(o.groupId)}`);
      let p = D2.length > 0 ? `, { ${D2.join(", ")} }` : "";
      return `indentIfBreak(${n(o.contents)}${p})`;
    }
    if (o.type === B) {
      let D2 = [];
      o.break && o.break !== "propagated" && D2.push("shouldBreak: true"), o.id && D2.push(`id: ${u(o.id)}`);
      let p = D2.length > 0 ? `, { ${D2.join(", ")} }` : "";
      return o.expandedStates ? `conditionalGroup([${o.expandedStates.map((l) => n(l)).join(",")}]${p})` : `group(${n(o.contents)}${p})`;
    }
    if (o.type === k) return `fill([${o.parts.map((D2) => n(D2)).join(", ")}])`;
    if (o.type === L) return "lineSuffix(" + n(o.contents) + ")";
    if (o.type === I) return "lineSuffixBoundary";
    if (o.type === S) return `label(${JSON.stringify(o.label)}, ${n(o.contents)})`;
    if (o.type === j) return "cursor";
    throw new Error("Unknown doc type " + o.type);
  }
  function u(o) {
    if (typeof o != "symbol") return JSON.stringify(String(o));
    if (o in t) return t[o];
    let i = o.description || "symbol";
    for (let s = 0; ; s++) {
      let a = i + (s > 0 ? ` #${s}` : "");
      if (!r.has(a)) return r.add(a), t[o] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
var br = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function kr(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function Sr(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101631 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129673 || e >= 129679 && e <= 129734 || e >= 129742 && e <= 129756 || e >= 129759 && e <= 129769 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
var Tr = (e) => !(kr(e) || Sr(e));
var Pu = /[^\x20-\x7F]/u;
function vu(e) {
  if (!e) return 0;
  if (!Pu.test(e)) return e.length;
  e = e.replace(br(), "  ");
  let t = 0;
  for (let r of e) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t += Tr(n) ? 1 : 2);
  }
  return t;
}
var Ne = vu;
var R = Symbol("MODE_BREAK");
var H = Symbol("MODE_FLAT");
var de = Symbol("cursor");
var _t = Symbol("DOC_FILL_PRINTED_LENGTH");
function Nr() {
  return { value: "", length: 0, queue: [] };
}
function Lu(e, t) {
  return xt(e, { type: "indent" }, t);
}
function Iu(e, t, r) {
  return t === Number.NEGATIVE_INFINITY ? e.root || Nr() : t < 0 ? xt(e, { type: "dedent" }, r) : t ? t.type === "root" ? { ...e, root: e } : xt(e, { type: typeof t == "string" ? "stringAlign" : "numberAlign", n: t }, r) : e;
}
function xt(e, t, r) {
  let n = t.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t], u = "", o = 0, i = 0, s = 0;
  for (let f of n) switch (f.type) {
    case "indent":
      D2(), r.useTabs ? a(1) : c(r.tabWidth);
      break;
    case "stringAlign":
      D2(), u += f.n, o += f.n.length;
      break;
    case "numberAlign":
      i += 1, s += f.n;
      break;
    default:
      throw new Error(`Unexpected type '${f.type}'`);
  }
  return l(), { ...e, value: u, length: o, queue: n };
  function a(f) {
    u += "	".repeat(f), o += r.tabWidth * f;
  }
  function c(f) {
    u += " ".repeat(f), o += f;
  }
  function D2() {
    r.useTabs ? p() : l();
  }
  function p() {
    i > 0 && a(i), F();
  }
  function l() {
    s > 0 && c(s), F();
  }
  function F() {
    i = 0, s = 0;
  }
}
function wt(e) {
  let t = 0, r = 0, n = e.length;
  e: for (; n--; ) {
    let u = e[n];
    if (u === de) {
      r++;
      continue;
    }
    for (let o = u.length - 1; o >= 0; o--) {
      let i = u[o];
      if (i === " " || i === "	") t++;
      else {
        e[n] = u.slice(0, o + 1);
        break e;
      }
    }
  }
  if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(de);
  return t;
}
function Ke(e, t, r, n, u, o) {
  var _a2;
  if (r === Number.POSITIVE_INFINITY) return true;
  let i = t.length, s = [e], a = [];
  for (; r >= 0; ) {
    if (s.length === 0) {
      if (i === 0) return true;
      s.push(t[--i]);
      continue;
    }
    let { mode: c, doc: D2 } = s.pop(), p = M(D2);
    switch (p) {
      case W:
        a.push(D2), r -= Ne(D2);
        break;
      case Y:
      case k: {
        let l = p === Y ? D2 : D2.parts, F = (_a2 = D2[_t]) != null ? _a2 : 0;
        for (let f = l.length - 1; f >= F; f--) s.push({ mode: c, doc: l[f] });
        break;
      }
      case N:
      case O:
      case v:
      case S:
        s.push({ mode: c, doc: D2.contents });
        break;
      case P:
        r += wt(a);
        break;
      case B: {
        if (o && D2.break) return false;
        let l = D2.break ? R : c, F = D2.expandedStates && l === R ? y(false, D2.expandedStates, -1) : D2.contents;
        s.push({ mode: l, doc: F });
        break;
      }
      case _: {
        let F = (D2.groupId ? u[D2.groupId] || H : c) === R ? D2.breakContents : D2.flatContents;
        F && s.push({ mode: c, doc: F });
        break;
      }
      case g:
        if (c === R || D2.hard) return true;
        D2.soft || (a.push(" "), r--);
        break;
      case L:
        n = true;
        break;
      case I:
        if (n) return false;
        break;
    }
  }
  return false;
}
function me(e, t) {
  var _a2;
  let r = {}, n = t.printWidth, u = xe(t.endOfLine), o = 0, i = [{ ind: Nr(), mode: R, doc: e }], s = [], a = false, c = [], D2 = 0;
  for (cr(e); i.length > 0; ) {
    let { ind: l, mode: F, doc: f } = i.pop();
    switch (M(f)) {
      case W: {
        let d = u !== `
` ? te(false, f, `
`, u) : f;
        s.push(d), i.length > 0 && (o += Ne(d));
        break;
      }
      case Y:
        for (let d = f.length - 1; d >= 0; d--) i.push({ ind: l, mode: F, doc: f[d] });
        break;
      case j:
        if (D2 >= 2) throw new Error("There are too many 'cursor' in doc.");
        s.push(de), D2++;
        break;
      case N:
        i.push({ ind: Lu(l, t), mode: F, doc: f.contents });
        break;
      case O:
        i.push({ ind: Iu(l, f.n, t), mode: F, doc: f.contents });
        break;
      case P:
        o -= wt(s);
        break;
      case B:
        switch (F) {
          case H:
            if (!a) {
              i.push({ ind: l, mode: f.break ? R : H, doc: f.contents });
              break;
            }
          case R: {
            a = false;
            let d = { ind: l, mode: H, doc: f.contents }, m = n - o, C = c.length > 0;
            if (!f.break && Ke(d, i, m, C, r)) i.push(d);
            else if (f.expandedStates) {
              let E2 = y(false, f.expandedStates, -1);
              if (f.break) {
                i.push({ ind: l, mode: R, doc: E2 });
                break;
              } else for (let h = 1; h < f.expandedStates.length + 1; h++) if (h >= f.expandedStates.length) {
                i.push({ ind: l, mode: R, doc: E2 });
                break;
              } else {
                let x = f.expandedStates[h], A2 = { ind: l, mode: H, doc: x };
                if (Ke(A2, i, m, C, r)) {
                  i.push(A2);
                  break;
                }
              }
            } else i.push({ ind: l, mode: R, doc: f.contents });
            break;
          }
        }
        f.id && (r[f.id] = y(false, i, -1).mode);
        break;
      case k: {
        let d = n - o, m = (_a2 = f[_t]) != null ? _a2 : 0, { parts: C } = f, E2 = C.length - m;
        if (E2 === 0) break;
        let h = C[m + 0], x = C[m + 1], A2 = { ind: l, mode: H, doc: h }, $2 = { ind: l, mode: R, doc: h }, ue2 = Ke(A2, [], d, c.length > 0, r, true);
        if (E2 === 1) {
          ue2 ? i.push(A2) : i.push($2);
          break;
        }
        let Be2 = { ind: l, mode: H, doc: x }, lt2 = { ind: l, mode: R, doc: x };
        if (E2 === 2) {
          ue2 ? i.push(Be2, A2) : i.push(lt2, $2);
          break;
        }
        let lu = C[m + 2], Ft2 = { ind: l, mode: F, doc: { ...f, [_t]: m + 2 } };
        Ke({ ind: l, mode: H, doc: [h, x, lu] }, [], d, c.length > 0, r, true) ? i.push(Ft2, Be2, A2) : ue2 ? i.push(Ft2, lt2, A2) : i.push(Ft2, lt2, $2);
        break;
      }
      case _:
      case v: {
        let d = f.groupId ? r[f.groupId] : F;
        if (d === R) {
          let m = f.type === _ ? f.breakContents : f.negate ? f.contents : ie(f.contents);
          m && i.push({ ind: l, mode: F, doc: m });
        }
        if (d === H) {
          let m = f.type === _ ? f.flatContents : f.negate ? ie(f.contents) : f.contents;
          m && i.push({ ind: l, mode: F, doc: m });
        }
        break;
      }
      case L:
        c.push({ ind: l, mode: F, doc: f.contents });
        break;
      case I:
        c.length > 0 && i.push({ ind: l, mode: F, doc: Te });
        break;
      case g:
        switch (F) {
          case H:
            if (f.hard) a = true;
            else {
              f.soft || (s.push(" "), o += 1);
              break;
            }
          case R:
            if (c.length > 0) {
              i.push({ ind: l, mode: F, doc: f }, ...c.reverse()), c.length = 0;
              break;
            }
            f.literal ? l.root ? (s.push(u, l.root.value), o = l.root.length) : (s.push(u), o = 0) : (o -= wt(s), s.push(u + l.value), o = l.length);
            break;
        }
        break;
      case S:
        i.push({ ind: l, mode: F, doc: f.contents });
        break;
      case w:
        break;
      default:
        throw new q(f);
    }
    i.length === 0 && c.length > 0 && (i.push(...c.reverse()), c.length = 0);
  }
  let p = s.indexOf(de);
  if (p !== -1) {
    let l = s.indexOf(de, p + 1);
    if (l === -1) return { formatted: s.filter((m) => m !== de).join("") };
    let F = s.slice(0, p).join(""), f = s.slice(p + 1, l).join(""), d = s.slice(l + 1).join("");
    return { formatted: F + f + d, cursorNodeStart: F.length, cursorNodeText: f };
  }
  return { formatted: s.join("") };
}
function Ru(e, t, r = 0) {
  let n = 0;
  for (let u = r; u < e.length; ++u) e[u] === "	" ? n = n + t - n % t : n++;
  return n;
}
var Ee = Ru;
var Z;
var kt;
var ze;
var bt = class {
  constructor(t) {
    tr(this, Z);
    this.stack = [t];
  }
  get key() {
    var _a2;
    let { stack: t, siblings: r } = this;
    return (_a2 = y(false, t, r === null ? -2 : -4)) != null ? _a2 : null;
  }
  get index() {
    return this.siblings === null ? null : y(false, this.stack, -2);
  }
  get node() {
    return y(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t } = this, r = y(false, t, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index + 1];
  }
  get previous() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t, index: r } = this;
    return t !== null && r === t.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...fe(this, Z, ze).call(this)];
  }
  getName() {
    let { stack: t } = this, { length: r } = t;
    return r > 1 ? y(false, t, -2) : null;
  }
  getValue() {
    return y(false, this.stack, -1);
  }
  getNode(t = 0) {
    let r = fe(this, Z, kt).call(this, t);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(t = 0) {
    return this.getNode(t + 1);
  }
  call(t, ...r) {
    let { stack: n } = this, { length: u } = n, o = y(false, n, -1);
    for (let i of r) o = o[i], n.push(i, o);
    try {
      return t(this);
    } finally {
      n.length = u;
    }
  }
  callParent(t, r = 0) {
    let n = fe(this, Z, kt).call(this, r + 1), u = this.stack.splice(n + 1);
    try {
      return t(this);
    } finally {
      this.stack.push(...u);
    }
  }
  each(t, ...r) {
    let { stack: n } = this, { length: u } = n, o = y(false, n, -1);
    for (let i of r) o = o[i], n.push(i, o);
    try {
      for (let i = 0; i < o.length; ++i) n.push(i, o[i]), t(this, i, o), n.length -= 2;
    } finally {
      n.length = u;
    }
  }
  map(t, ...r) {
    let n = [];
    return this.each((u, o, i) => {
      n[o] = t(u, o, i);
    }, ...r), n;
  }
  match(...t) {
    let r = this.stack.length - 1, n = null, u = this.stack[r--];
    for (let o of t) {
      if (u === void 0) return false;
      let i = null;
      if (typeof n == "number" && (i = n, n = this.stack[r--], u = this.stack[r--]), o && !o(u, n, i)) return false;
      n = this.stack[r--], u = this.stack[r--];
    }
    return true;
  }
  findAncestor(t) {
    for (let r of fe(this, Z, ze).call(this)) if (t(r)) return r;
  }
  hasAncestor(t) {
    for (let r of fe(this, Z, ze).call(this)) if (t(r)) return true;
    return false;
  }
};
Z = /* @__PURE__ */ new WeakSet(), kt = function(t) {
  let { stack: r } = this;
  for (let n = r.length - 1; n >= 0; n -= 2) if (!Array.isArray(r[n]) && --t < 0) return n;
  return -1;
}, ze = function* () {
  let { stack: t } = this;
  for (let r = t.length - 3; r >= 0; r -= 2) {
    let n = t[r];
    Array.isArray(n) || (yield n);
  }
};
var Or = bt;
var Pr = new Proxy(() => {
}, { get: () => Pr });
var Oe = Pr;
function Yu(e) {
  return e !== null && typeof e == "object";
}
var vr = Yu;
function* Ce(e, t) {
  let { getVisitorKeys: r, filter: n = () => true } = t, u = (o) => vr(o) && n(o);
  for (let o of r(e)) {
    let i = e[o];
    if (Array.isArray(i)) for (let s of i) u(s) && (yield s);
    else u(i) && (yield i);
  }
}
function* Lr(e, t) {
  let r = [e];
  for (let n = 0; n < r.length; n++) {
    let u = r[n];
    for (let o of Ce(u, t)) yield o, r.push(o);
  }
}
function Ir(e, t) {
  return Ce(e, t).next().done;
}
function he(e) {
  return (t, r, n) => {
    let u = !!(n != null && n.backwards);
    if (r === false) return false;
    let { length: o } = t, i = r;
    for (; i >= 0 && i < o; ) {
      let s = t.charAt(i);
      if (e instanceof RegExp) {
        if (!e.test(s)) return i;
      } else if (!e.includes(s)) return i;
      u ? i-- : i++;
    }
    return i === -1 || i === o ? i : false;
  };
}
var Rr = he(/\s/u);
var T = he(" 	");
var He = he(",; 	");
var Je = he(/[^\n\r]/u);
function ju(e, t, r) {
  let n = !!(r != null && r.backwards);
  if (t === false) return false;
  let u = e.charAt(t);
  if (n) {
    if (e.charAt(t - 1) === "\r" && u === `
`) return t - 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t - 1;
  } else {
    if (u === "\r" && e.charAt(t + 1) === `
`) return t + 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t + 1;
  }
  return t;
}
var U = ju;
function Uu(e, t, r = {}) {
  let n = T(e, r.backwards ? t - 1 : t, r), u = U(e, n, r);
  return n !== u;
}
var G = Uu;
function Vu(e) {
  return Array.isArray(e) && e.length > 0;
}
var qe = Vu;
var Yr = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var $u = (e) => Object.keys(e).filter((t) => !Yr.has(t));
function Wu(e) {
  return e ? (t) => e(t, Yr) : $u;
}
var J = Wu;
function Mu(e) {
  let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t + (r ? " " + r : "");
}
function St(e, t) {
  var _a2;
  ((_a2 = e.comments) != null ? _a2 : e.comments = []).push(t), t.printed = false, t.nodeDescription = Mu(e);
}
function se(e, t) {
  t.leading = true, t.trailing = false, St(e, t);
}
function ee(e, t, r) {
  t.leading = false, t.trailing = false, r && (t.marker = r), St(e, t);
}
function ae(e, t) {
  t.leading = false, t.trailing = true, St(e, t);
}
var Tt = /* @__PURE__ */ new WeakMap();
function Xe(e, t) {
  var _a2;
  if (Tt.has(e)) return Tt.get(e);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: u }, locStart: o, locEnd: i } = t;
  if (!n) return [];
  let s = ((_a2 = r == null ? void 0 : r(e, t)) != null ? _a2 : [...Ce(e, { getVisitorKeys: J(u) })]).flatMap((a) => n(a) ? [a] : Xe(a, t));
  return s.sort((a, c) => o(a) - o(c) || i(a) - i(c)), Tt.set(e, s), s;
}
function Ur(e, t, r, n) {
  let { locStart: u, locEnd: o } = r, i = u(t), s = o(t), a = Xe(e, r), c, D2, p = 0, l = a.length;
  for (; p < l; ) {
    let F = p + l >> 1, f = a[F], d = u(f), m = o(f);
    if (d <= i && s <= m) return Ur(f, t, r, f);
    if (m <= i) {
      c = f, p = F + 1;
      continue;
    }
    if (s <= d) {
      D2 = f, l = F;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
    let { quasis: F } = n, f = Ot(F, t, r);
    c && Ot(F, c, r) !== f && (c = null), D2 && Ot(F, D2, r) !== f && (D2 = null);
  }
  return { enclosingNode: n, precedingNode: c, followingNode: D2 };
}
var Nt = () => false;
function Vr(e, t) {
  let { comments: r } = e;
  if (delete e.comments, !qe(r) || !t.printer.canAttachComment) return;
  let n = [], { printer: { experimentalFeatures: { avoidAstMutation: u = false } = {}, handleComments: o = {} }, originalText: i } = t, { ownLine: s = Nt, endOfLine: a = Nt, remaining: c = Nt } = o, D2 = r.map((p, l) => ({ ...Ur(e, p, t), comment: p, text: i, options: t, ast: e, isLastComment: r.length - 1 === l }));
  for (let [p, l] of D2.entries()) {
    let { comment: F, precedingNode: f, enclosingNode: d, followingNode: m, text: C, options: E2, ast: h, isLastComment: x } = l, A2;
    if (u ? A2 = [l] : (F.enclosingNode = d, F.precedingNode = f, F.followingNode = m, A2 = [F, C, E2, h, x]), Gu(C, E2, D2, p)) F.placement = "ownLine", s(...A2) || (m ? se(m, F) : f ? ae(f, F) : d ? ee(d, F) : ee(h, F));
    else if (Ku(C, E2, D2, p)) F.placement = "endOfLine", a(...A2) || (f ? ae(f, F) : m ? se(m, F) : d ? ee(d, F) : ee(h, F));
    else if (F.placement = "remaining", !c(...A2)) if (f && m) {
      let $2 = n.length;
      $2 > 0 && n[$2 - 1].followingNode !== m && jr(n, E2), n.push(l);
    } else f ? ae(f, F) : m ? se(m, F) : d ? ee(d, F) : ee(h, F);
  }
  if (jr(n, t), !u) for (let p of r) delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
}
var $r2 = (e) => !/[\S\n\u2028\u2029]/u.test(e);
function Gu(e, t, r, n) {
  let { comment: u, precedingNode: o } = r[n], { locStart: i, locEnd: s } = t, a = i(u);
  if (o) for (let c = n - 1; c >= 0; c--) {
    let { comment: D2, precedingNode: p } = r[c];
    if (p !== o || !$r2(e.slice(s(D2), a))) break;
    a = i(D2);
  }
  return G(e, a, { backwards: true });
}
function Ku(e, t, r, n) {
  let { comment: u, followingNode: o } = r[n], { locStart: i, locEnd: s } = t, a = s(u);
  if (o) for (let c = n + 1; c < r.length; c++) {
    let { comment: D2, followingNode: p } = r[c];
    if (p !== o || !$r2(e.slice(a, i(D2)))) break;
    a = s(D2);
  }
  return G(e, a);
}
function jr(e, t) {
  var _a2;
  var s, a;
  let r = e.length;
  if (r === 0) return;
  let { precedingNode: n, followingNode: u } = e[0], o = t.locStart(u), i;
  for (i = r; i > 0; --i) {
    let { comment: c, precedingNode: D2, followingNode: p } = e[i - 1];
    Oe.strictEqual(D2, n), Oe.strictEqual(p, u);
    let l = t.originalText.slice(t.locEnd(c), o);
    if ((_a2 = (a = (s = t.printer).isGap) == null ? void 0 : a.call(s, l, t)) != null ? _a2 : /^[\s(]*$/u.test(l)) o = t.locStart(c);
    else break;
  }
  for (let [c, { comment: D2 }] of e.entries()) c < i ? ae(n, D2) : se(u, D2);
  for (let c of [n, u]) c.comments && c.comments.length > 1 && c.comments.sort((D2, p) => t.locStart(D2) - t.locStart(p));
  e.length = 0;
}
function Ot(e, t, r) {
  let n = r.locStart(t) - 1;
  for (let u = 1; u < e.length; ++u) if (n < r.locStart(e[u])) return u - 1;
  return 0;
}
function zu(e, t) {
  let r = t - 1;
  r = T(e, r, { backwards: true }), r = U(e, r, { backwards: true }), r = T(e, r, { backwards: true });
  let n = U(e, r, { backwards: true });
  return r !== n;
}
var Pe = zu;
function Wr(e, t) {
  let r = e.node;
  return r.printed = true, t.printer.printComment(e, t);
}
function Hu(e, t) {
  var D2;
  let r = e.node, n = [Wr(e, t)], { printer: u, originalText: o, locStart: i, locEnd: s } = t;
  if ((D2 = u.isBlockComment) == null ? void 0 : D2.call(u, r)) {
    let p = G(o, s(r)) ? G(o, i(r), { backwards: true }) ? z : Me : " ";
    n.push(p);
  } else n.push(z);
  let c = U(o, T(o, s(r)));
  return c !== false && G(o, c) && n.push(z), n;
}
function Ju(e, t, r) {
  var c;
  let n = e.node, u = Wr(e, t), { printer: o, originalText: i, locStart: s } = t, a = (c = o.isBlockComment) == null ? void 0 : c.call(o, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || G(i, s(n), { backwards: true })) {
    let D2 = Pe(i, s(n));
    return { doc: Se([z, D2 ? z : "", u]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r != null && r.hasLineSuffix ? { doc: [Se([" ", u]), pe], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
}
function qu(e, t) {
  let r = e.node;
  if (!r) return {};
  let n = t[Symbol.for("printedComments")];
  if ((r.comments || []).filter((a) => !n.has(a)).length === 0) return { leading: "", trailing: "" };
  let o = [], i = [], s;
  return e.each(() => {
    let a = e.node;
    if (n != null && n.has(a)) return;
    let { leading: c, trailing: D2 } = a;
    c ? o.push(Hu(e, t)) : D2 && (s = Ju(e, t, s), i.push(s.doc));
  }, "comments"), { leading: o, trailing: i };
}
function Mr(e, t, r) {
  let { leading: n, trailing: u } = qu(e, r);
  return !n && !u ? t : Fe(t, (o) => [n, o, u]);
}
function Gr(e) {
  let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: r } = e;
  for (let n of t) {
    if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
function Xu(e) {
  return () => {
  };
}
var Kr = Xu;
var ve = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConfigError");
  }
};
var Le = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UndefinedParserError");
  }
};
var zr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function Qe({ plugins: e = [], showDeprecated: t = false } = {}) {
  let r = e.flatMap((u) => {
    var _a2;
    return (_a2 = u.languages) != null ? _a2 : [];
  }), n = [];
  for (let u of Zu(Object.assign({}, ...e.map(({ options: o }) => o), zr))) !t && u.deprecated || (Array.isArray(u.choices) && (t || (u.choices = u.choices.filter((o) => !o.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...Qu(u.choices, r, e)])), u.pluginDefaults = Object.fromEntries(e.filter((o) => {
    var i;
    return ((i = o.defaultOptions) == null ? void 0 : i[u.name]) !== void 0;
  }).map((o) => [o.name, o.defaultOptions[u.name]])), n.push(u));
  return { languages: r, options: n };
}
function* Qu(e, t, r) {
  let n = new Set(e.map((u) => u.value));
  for (let u of t) if (u.parsers) {
    for (let o of u.parsers) if (!n.has(o)) {
      n.add(o);
      let i = r.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, o)), s = u.name;
      i != null && i.name && (s += ` (plugin: ${i.name})`), yield { value: o, description: s };
    }
  }
}
function Zu(e) {
  let t = [];
  for (let [r, n] of Object.entries(e)) {
    let u = { name: r, ...n };
    Array.isArray(u.default) && (u.default = y(false, u.default, -1).value), t.push(u);
  }
  return t;
}
var eo = (e, t) => {
  if (!(e && t == null)) return t.toReversed || !Array.isArray(t) ? t.toReversed() : [...t].reverse();
};
var Hr = eo;
var Jr;
var qr;
var Xr;
var Qr;
var Zr;
var to = ((Jr = globalThis.Deno) == null ? void 0 : Jr.build.os) === "windows" || ((Xr = (qr = globalThis.navigator) == null ? void 0 : qr.platform) == null ? void 0 : Xr.startsWith("Win")) || ((Zr = (Qr = globalThis.process) == null ? void 0 : Qr.platform) == null ? void 0 : Zr.startsWith("win")) || false;
function en(e) {
  if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
  return e;
}
function ro(e) {
  return e = en(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function no(e) {
  e = en(e);
  let t = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e.hostname !== "" && (t = `\\\\${e.hostname}${t}`), t;
}
function tn(e) {
  return to ? no(e) : ro(e);
}
var rn = tn;
var uo = (e) => String(e).split(/[/\\]/u).pop();
function nn(e, t) {
  var _a2;
  if (!t) return;
  let r = uo(t).toLowerCase();
  return (_a2 = e.find(({ filenames: n }) => n == null ? void 0 : n.some((u) => u.toLowerCase() === r))) != null ? _a2 : e.find(({ extensions: n }) => n == null ? void 0 : n.some((u) => r.endsWith(u)));
}
function oo(e, t) {
  var _a2, _b;
  if (t) return (_b = (_a2 = e.find(({ name: r }) => r.toLowerCase() === t)) != null ? _a2 : e.find(({ aliases: r }) => r == null ? void 0 : r.includes(t))) != null ? _b : e.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${t}`));
}
function un(e, t) {
  if (t) {
    if (String(t).startsWith("file:")) try {
      t = rn(t);
    } catch (e2) {
      return;
    }
    if (typeof t == "string") return e.find(({ isSupported: r }) => r == null ? void 0 : r({ filepath: t }));
  }
}
function io(e, t) {
  var _a2, _b, _c2, _d, _e3;
  let r = Hr(false, e.plugins).flatMap((u) => {
    var _a3;
    return (_a3 = u.languages) != null ? _a3 : [];
  }), n = (_e3 = (_d = (_c2 = (_b = (_a2 = oo(r, t.language)) != null ? _a2 : nn(r, t.physicalFile)) != null ? _b : nn(r, t.file)) != null ? _c2 : un(r, t.physicalFile)) != null ? _d : un(r, t.file)) != null ? _e3 : (t.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var on = io;
var re = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
  if (e === null || typeof e != "object") return JSON.stringify(e);
  if (Array.isArray(e)) return `[${e.map((r) => re.value(r)).join(", ")}]`;
  let t = Object.keys(e);
  return t.length === 0 ? "{}" : `{ ${t.map((r) => `${re.key(r)}: ${re.value(e[r])}`).join(", ")} }`;
}, pair: ({ key: e, value: t }) => re.value({ [e]: t }) };
var sn = new Proxy(String, { get: () => sn });
var V = sn;
var an = (e, t, { descriptor: r }) => {
  let n = [`${V.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
  return t && n.push(`we now treat it as ${V.blue(typeof t == "string" ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
};
var Ze = Symbol.for("vnopts.VALUE_NOT_EXIST");
var ge = Symbol.for("vnopts.VALUE_UNCHANGED");
var Dn = " ".repeat(2);
var fn = (e, t, r) => {
  let { text: n, list: u } = r.normalizeExpectedResult(r.schemas[e].expected(r)), o = [];
  return n && o.push(cn(e, t, n, r.descriptor)), u && o.push([cn(e, t, u.title, r.descriptor)].concat(u.values.map((i) => ln(i, r.loggerPrintWidth))).join(`
`)), Fn(o, r.loggerPrintWidth);
};
function cn(e, t, r, n) {
  return [`Invalid ${V.red(n.key(e))} value.`, `Expected ${V.blue(r)},`, `but received ${t === Ze ? V.gray("nothing") : V.red(n.value(t))}.`].join(" ");
}
function ln({ text: e, list: t }, r) {
  let n = [];
  return e && n.push(`- ${V.blue(e)}`), t && n.push([`- ${V.blue(t.title)}:`].concat(t.values.map((u) => ln(u, r - Dn.length).replace(/^|\n/g, `$&${Dn}`))).join(`
`)), Fn(n, r);
}
function Fn(e, t) {
  if (e.length === 1) return e[0];
  let [r, n] = e, [u, o] = e.map((i) => i.split(`
`, 1)[0].length);
  return u > t && u > o ? n : r;
}
var Pt = [];
var pn = [];
function vt(e, t) {
  if (e === t) return 0;
  let r = e;
  e.length > t.length && (e = t, t = r);
  let n = e.length, u = t.length;
  for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-u); ) n--, u--;
  let o = 0;
  for (; o < n && e.charCodeAt(o) === t.charCodeAt(o); ) o++;
  if (n -= o, u -= o, n === 0) return u;
  let i, s, a, c, D2 = 0, p = 0;
  for (; D2 < n; ) pn[D2] = e.charCodeAt(o + D2), Pt[D2] = ++D2;
  for (; p < u; ) for (i = t.charCodeAt(o + p), a = p++, s = p, D2 = 0; D2 < n; D2++) c = i === pn[D2] ? a : a + 1, a = Pt[D2], s = Pt[D2] = a > s ? c > s ? s + 1 : c : c > a ? a + 1 : c;
  return s;
}
var et = (e, t, { descriptor: r, logger: n, schemas: u }) => {
  let o = [`Ignored unknown option ${V.yellow(r.pair({ key: e, value: t }))}.`], i = Object.keys(u).sort().find((s) => vt(e, s) < 3);
  i && o.push(`Did you mean ${V.blue(r.key(i))}?`), n.warn(o.join(" "));
};
var so = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function ao(e, t) {
  let r = new e(t), n = Object.create(r);
  for (let u of so) u in t && (n[u] = Do(t[u], r, b.prototype[u].length));
  return n;
}
var b = class {
  static create(t) {
    return ao(this, t);
  }
  constructor(t) {
    this.name = t.name;
  }
  default(t) {
  }
  expected(t) {
    return "nothing";
  }
  validate(t, r) {
    return false;
  }
  deprecated(t, r) {
    return false;
  }
  forward(t, r) {
  }
  redirect(t, r) {
  }
  overlap(t, r, n) {
    return t;
  }
  preprocess(t, r) {
    return t;
  }
  postprocess(t, r) {
    return ge;
  }
};
function Do(e, t, r) {
  return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
}
var tt = class extends b {
  constructor(t) {
    super(t), this._sourceName = t.sourceName;
  }
  expected(t) {
    return t.schemas[this._sourceName].expected(t);
  }
  validate(t, r) {
    return r.schemas[this._sourceName].validate(t, r);
  }
  redirect(t, r) {
    return this._sourceName;
  }
};
var rt = class extends b {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var nt = class extends b {
  constructor({ valueSchema: t, name: r = t.name, ...n }) {
    super({ ...n, name: r }), this._valueSchema = t;
  }
  expected(t) {
    let { text: r, list: n } = t.normalizeExpectedResult(this._valueSchema.expected(t));
    return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
  }
  validate(t, r) {
    if (!Array.isArray(t)) return false;
    let n = [];
    for (let u of t) {
      let o = r.normalizeValidateResult(this._valueSchema.validate(u, r), u);
      o !== true && n.push(o.value);
    }
    return n.length === 0 ? true : { value: n };
  }
  deprecated(t, r) {
    let n = [];
    for (let u of t) {
      let o = r.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r), u);
      o !== false && n.push(...o.map(({ value: i }) => ({ value: [i] })));
    }
    return n;
  }
  forward(t, r) {
    let n = [];
    for (let u of t) {
      let o = r.normalizeForwardResult(this._valueSchema.forward(u, r), u);
      n.push(...o.map(dn));
    }
    return n;
  }
  redirect(t, r) {
    let n = [], u = [];
    for (let o of t) {
      let i = r.normalizeRedirectResult(this._valueSchema.redirect(o, r), o);
      "remain" in i && n.push(i.remain), u.push(...i.redirect.map(dn));
    }
    return n.length === 0 ? { redirect: u } : { redirect: u, remain: n };
  }
  overlap(t, r) {
    return t.concat(r);
  }
};
function dn({ from: e, to: t }) {
  return { from: [e], to: t };
}
var ut = class extends b {
  expected() {
    return "true or false";
  }
  validate(t) {
    return typeof t == "boolean";
  }
};
function En(e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of e) {
    let u = n[t];
    if (r[u]) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
    r[u] = n;
  }
  return r;
}
function Cn(e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let n of e) {
    let u = n[t];
    if (r.has(u)) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
    r.set(u, n);
  }
  return r;
}
function hn() {
  let e = /* @__PURE__ */ Object.create(null);
  return (t) => {
    let r = JSON.stringify(t);
    return e[r] ? true : (e[r] = true, false);
  };
}
function gn(e, t) {
  let r = [], n = [];
  for (let u of e) t(u) ? r.push(u) : n.push(u);
  return [r, n];
}
function yn(e) {
  return e === Math.floor(e);
}
function An(e, t) {
  if (e === t) return 0;
  let r = typeof e, n = typeof t, u = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? u.indexOf(r) - u.indexOf(n) : r !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
}
function Bn(e) {
  return (...t) => {
    let r = e(...t);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function Lt(e) {
  return e === void 0 ? {} : e;
}
function It(e) {
  if (typeof e == "string") return { text: e };
  let { text: t, list: r } = e;
  return co((t || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: t, list: { title: r.title, values: r.values.map(It) } } : { text: t };
}
function Rt(e, t) {
  return e === true ? true : e === false ? { value: t } : e;
}
function Yt(e, t, r = false) {
  return e === false ? false : e === true ? r ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
}
function mn(e, t) {
  return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
}
function ot(e, t) {
  return e === void 0 ? [] : Array.isArray(e) ? e.map((r) => mn(r, t)) : [mn(e, t)];
}
function jt(e, t) {
  let r = ot(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
  return r.length === 0 ? { remain: t, redirect: r } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r };
}
function co(e, t) {
  if (!e) throw new Error(t);
}
var it = class extends b {
  constructor(t) {
    super(t), this._choices = Cn(t.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: t }) {
    let r = Array.from(this._choices.keys()).map((i) => this._choices.get(i)).filter(({ hidden: i }) => !i).map((i) => i.value).sort(An).map(t.value), n = r.slice(0, -2), u = r.slice(-2);
    return { text: n.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(t) {
    return this._choices.has(t);
  }
  deprecated(t) {
    let r = this._choices.get(t);
    return r && r.deprecated ? { value: t } : false;
  }
  forward(t) {
    let r = this._choices.get(t);
    return r ? r.forward : void 0;
  }
  redirect(t) {
    let r = this._choices.get(t);
    return r ? r.redirect : void 0;
  }
};
var st = class extends b {
  expected() {
    return "a number";
  }
  validate(t, r) {
    return typeof t == "number";
  }
};
var at = class extends st {
  expected() {
    return "an integer";
  }
  validate(t, r) {
    return r.normalizeValidateResult(super.validate(t, r), t) === true && yn(t);
  }
};
var Ie = class extends b {
  expected() {
    return "a string";
  }
  validate(t) {
    return typeof t == "string";
  }
};
var _n = re;
var xn = et;
var wn = fn;
var bn = an;
var Dt = class {
  constructor(t, r) {
    let { logger: n = console, loggerPrintWidth: u = 80, descriptor: o = _n, unknown: i = xn, invalid: s = wn, deprecated: a = bn, missing: c = () => false, required: D2 = () => false, preprocess: p = (F) => F, postprocess: l = () => ge } = r || {};
    this._utils = { descriptor: o, logger: n || { warn: () => {
    } }, loggerPrintWidth: u, schemas: En(t, "name"), normalizeDefaultResult: Lt, normalizeExpectedResult: It, normalizeDeprecatedResult: Yt, normalizeForwardResult: ot, normalizeRedirectResult: jt, normalizeValidateResult: Rt }, this._unknownHandler = i, this._invalidHandler = Bn(s), this._deprecatedHandler = a, this._identifyMissing = (F, f) => !(F in f) || c(F, f), this._identifyRequired = D2, this._preprocess = p, this._postprocess = l, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = hn();
  }
  normalize(t) {
    let r = {}, u = [this._preprocess(t, this._utils)], o = () => {
      for (; u.length !== 0; ) {
        let i = u.shift(), s = this._applyNormalization(i, r);
        u.push(...s);
      }
    };
    o();
    for (let i of Object.keys(this._utils.schemas)) {
      let s = this._utils.schemas[i];
      if (!(i in r)) {
        let a = Lt(s.default(this._utils));
        "value" in a && u.push({ [i]: a.value });
      }
    }
    o();
    for (let i of Object.keys(this._utils.schemas)) {
      if (!(i in r)) continue;
      let s = this._utils.schemas[i], a = r[i], c = s.postprocess(a, this._utils);
      c !== ge && (this._applyValidation(c, i, s), r[i] = c);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(t, r) {
    let n = [], { knownKeys: u, unknownKeys: o } = this._partitionOptionKeys(t);
    for (let i of u) {
      let s = this._utils.schemas[i], a = s.preprocess(t[i], this._utils);
      this._applyValidation(a, i, s);
      let c = ({ from: F, to: f }) => {
        n.push(typeof f == "string" ? { [f]: F } : { [f.key]: f.value });
      }, D2 = ({ value: F, redirectTo: f }) => {
        let d = Yt(s.deprecated(F, this._utils), a, true);
        if (d !== false) if (d === true) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, f, this._utils));
        else for (let { value: m } of d) {
          let C = { key: i, value: m };
          if (!this._hasDeprecationWarned(C)) {
            let E2 = typeof f == "string" ? { key: f, value: m } : f;
            this._utils.logger.warn(this._deprecatedHandler(C, E2, this._utils));
          }
        }
      };
      ot(s.forward(a, this._utils), a).forEach(c);
      let l = jt(s.redirect(a, this._utils), a);
      if (l.redirect.forEach(c), "remain" in l) {
        let F = l.remain;
        r[i] = i in r ? s.overlap(r[i], F, this._utils) : F, D2({ value: F });
      }
      for (let { from: F, to: f } of l.redirect) D2({ value: F, redirectTo: f });
    }
    for (let i of o) {
      let s = t[i];
      this._applyUnknownHandler(i, s, r, (a, c) => {
        n.push({ [a]: c });
      });
    }
    return n;
  }
  _applyRequiredCheck(t) {
    for (let r of Object.keys(this._utils.schemas)) if (this._identifyMissing(r, t) && this._identifyRequired(r)) throw this._invalidHandler(r, Ze, this._utils);
  }
  _partitionOptionKeys(t) {
    let [r, n] = gn(Object.keys(t).filter((u) => !this._identifyMissing(u, t)), (u) => u in this._utils.schemas);
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(t, r, n) {
    let u = Rt(n.validate(t, this._utils), t);
    if (u !== true) throw this._invalidHandler(r, u.value, this._utils);
  }
  _applyUnknownHandler(t, r, n, u) {
    let o = this._unknownHandler(t, r, this._utils);
    if (o) for (let i of Object.keys(o)) {
      if (this._identifyMissing(i, o)) continue;
      let s = o[i];
      i in this._utils.schemas ? u(i, s) : n[i] = s;
    }
  }
  _applyPostprocess(t) {
    let r = this._postprocess(t, this._utils);
    if (r !== ge) {
      if (r.delete) for (let n of r.delete) delete t[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: u } = this._partitionOptionKeys(r.override);
        for (let o of n) {
          let i = r.override[o];
          this._applyValidation(i, o, this._utils.schemas[o]), t[o] = i;
        }
        for (let o of u) {
          let i = r.override[o];
          this._applyUnknownHandler(o, i, t, (s, a) => {
            let c = this._utils.schemas[s];
            this._applyValidation(a, s, c), t[s] = a;
          });
        }
      }
    }
  }
};
var Ut;
function lo(e, t, { logger: r = false, isCLI: n = false, passThrough: u = false, FlagSchema: o, descriptor: i } = {}) {
  if (n) {
    if (!o) throw new Error("'FlagSchema' option is required.");
    if (!i) throw new Error("'descriptor' option is required.");
  } else i = re;
  let s = u ? Array.isArray(u) ? (l, F) => u.includes(l) ? { [l]: F } : void 0 : (l, F) => ({ [l]: F }) : (l, F, f) => {
    let { _: d, ...m } = f.schemas;
    return et(l, F, { ...f, schemas: m });
  }, a = Fo(t, { isCLI: n, FlagSchema: o }), c = new Dt(a, { logger: r, unknown: s, descriptor: i }), D2 = r !== false;
  D2 && Ut && (c._hasDeprecationWarned = Ut);
  let p = c.normalize(e);
  return D2 && (Ut = c._hasDeprecationWarned), p;
}
function Fo(e, { isCLI: t, FlagSchema: r }) {
  let n = [];
  t && n.push(rt.create({ name: "_" }));
  for (let u of e) n.push(po(u, { isCLI: t, optionInfos: e, FlagSchema: r })), u.alias && t && n.push(tt.create({ name: u.alias, sourceName: u.name }));
  return n;
}
function po(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
  let { name: u } = e, o = { name: u }, i, s = {};
  switch (e.type) {
    case "int":
      i = at, t && (o.preprocess = Number);
      break;
    case "string":
      i = Ie;
      break;
    case "choice":
      i = it, o.choices = e.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      i = ut;
      break;
    case "flag":
      i = n, o.flags = r.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      i = Ie;
      break;
    default:
      throw new Error(`Unexpected type ${e.type}`);
  }
  if (e.exception ? o.validate = (a, c, D2) => e.exception(a) || c.validate(a, D2) : o.validate = (a, c, D2) => a === void 0 || c.validate(a, D2), e.redirect && (s.redirect = (a) => a ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
    let a = o.preprocess || ((c) => c);
    o.preprocess = (c, D2, p) => D2.preprocess(a(Array.isArray(c) ? y(false, c, -1) : c), p);
  }
  return e.array ? nt.create({ ...t ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s, valueSchema: i.create(o) }) : i.create({ ...o, ...s });
}
var kn = lo;
var mo = (e, t, r) => {
  if (!(e && t == null)) {
    if (t.findLast) return t.findLast(r);
    for (let n = t.length - 1; n >= 0; n--) {
      let u = t[n];
      if (r(u, n, t)) return u;
    }
  }
};
var Vt = mo;
function $t(e, t) {
  if (!t) throw new Error("parserName is required.");
  let r = Vt(false, e, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t));
  if (r) return r;
  let n = `Couldn't resolve parser "${t}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new ve(n);
}
function Sn(e, t) {
  if (!t) throw new Error("astFormat is required.");
  let r = Vt(false, e, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t));
  if (r) return r;
  let n = `Couldn't find plugin for AST format "${t}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new ve(n);
}
function Re({ plugins: e, parser: t }) {
  let r = $t(e, t);
  return Wt(r, t);
}
function Wt(e, t) {
  let r = e.parsers[t];
  return typeof r == "function" ? r() : r;
}
function Tn(e, t) {
  let r = e.printers[t];
  return typeof r == "function" ? r() : r;
}
var Nn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function Eo(e, t = {}) {
  var p;
  let r = { ...e };
  if (!r.parser) if (r.filepath) {
    if (r.parser = on(r, { physicalFile: r.filepath }), !r.parser) throw new Le(`No parser could be inferred for file "${r.filepath}".`);
  } else throw new Le("No parser and no file path given, couldn't infer a parser.");
  let n = Qe({ plugins: e.plugins, showDeprecated: true }).options, u = { ...Nn, ...Object.fromEntries(n.filter((l) => l.default !== void 0).map((l) => [l.name, l.default])) }, o = $t(r.plugins, r.parser), i = await Wt(o, r.parser);
  r.astFormat = i.astFormat, r.locEnd = i.locEnd, r.locStart = i.locStart;
  let s = (p = o.printers) != null && p[i.astFormat] ? o : Sn(r.plugins, i.astFormat), a = await Tn(s, i.astFormat);
  r.printer = a;
  let c = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, l]) => l !== void 0)) : {}, D2 = { ...u, ...c };
  for (let [l, F] of Object.entries(D2)) (r[l] === null || r[l] === void 0) && (r[l] = F);
  return r.parser === "json" && (r.trailingComma = "none"), kn(r, n, { passThrough: Object.keys(Nn), ...t });
}
var ne = Eo;
var vn = gu(Pn(), 1);
async function yo(e, t) {
  let r = await Re(t), n = r.preprocess ? r.preprocess(e, t) : e;
  t.originalText = n;
  let u;
  try {
    u = await r.parse(n, t, t);
  } catch (o) {
    Ao(o, e);
  }
  return { text: n, ast: u };
}
function Ao(e, t) {
  let { loc: r } = e;
  if (r) {
    let n = (0, vn.codeFrameColumns)(t, r, { highlightCode: true });
    throw e.message += `
` + n, e.codeFrame = n, e;
  }
  throw e;
}
var De = yo;
async function Ln(e, t, r, n, u) {
  var _a2;
  let { embeddedLanguageFormatting: o, printer: { embed: i, hasPrettierIgnore: s = () => false, getVisitorKeys: a } } = r;
  if (!i || o !== "auto") return;
  if (i.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let c = J((_a2 = i.getVisitorKeys) != null ? _a2 : a), D2 = [];
  F();
  let p = e.stack;
  for (let { print: f, node: d, pathStack: m } of D2) try {
    e.stack = m;
    let C = await f(l, t, e, r);
    C && u.set(d, C);
  } catch (C) {
    if (globalThis.PRETTIER_DEBUG) throw C;
  }
  e.stack = p;
  function l(f, d) {
    return Bo(f, d, r, n);
  }
  function F() {
    let { node: f } = e;
    if (f === null || typeof f != "object" || s(e)) return;
    for (let m of c(f)) Array.isArray(f[m]) ? e.each(F, m) : e.call(F, m);
    let d = i(e, r);
    if (d) {
      if (typeof d == "function") {
        D2.push({ print: d, node: f, pathStack: [...e.stack] });
        return;
      }
      u.set(f, d);
    }
  }
}
async function Bo(e, t, r, n) {
  let u = await ne({ ...r, ...t, parentParser: r.parser, originalText: e, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: true }), { ast: o } = await De(e, u), i = await n(o, u);
  return $e(i);
}
function _o(e, t) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: u, locEnd: o, [Symbol.for("printedComments")]: i } = t, { node: s } = e, a = u(s), c = o(s);
  for (let D2 of n) u(D2) >= a && o(D2) <= c && i.add(D2);
  return r.slice(a, c);
}
var In = _o;
async function Ye(e, t) {
  ({ ast: e } = await Gt(e, t));
  let r = /* @__PURE__ */ new Map(), n = new Or(e), u = Kr(t), o = /* @__PURE__ */ new Map();
  await Ln(n, s, t, Ye, o);
  let i = await Rn(n, t, s, void 0, o);
  if (Gr(t), t.cursorOffset >= 0) {
    if (t.nodeAfterCursor && !t.nodeBeforeCursor) return [X, i];
    if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [i, X];
  }
  return i;
  function s(c, D2) {
    return c === void 0 || c === n ? a(D2) : Array.isArray(c) ? n.call(() => a(D2), ...c) : n.call(() => a(D2), c);
  }
  function a(c) {
    u(n);
    let D2 = n.node;
    if (D2 == null) return "";
    let p = D2 && typeof D2 == "object" && c === void 0;
    if (p && r.has(D2)) return r.get(D2);
    let l = Rn(n, t, s, c, o);
    return p && r.set(D2, l), l;
  }
}
function Rn(e, t, r, n, u) {
  var a;
  let { node: o } = e, { printer: i } = t, s;
  switch ((a = i.hasPrettierIgnore) != null && a.call(i, e) ? s = In(e, t) : u.has(o) ? s = u.get(o) : s = i.print(e, t, r, n), o) {
    case t.cursorNode:
      s = Fe(s, (c) => [X, c, X]);
      break;
    case t.nodeBeforeCursor:
      s = Fe(s, (c) => [c, X]);
      break;
    case t.nodeAfterCursor:
      s = Fe(s, (c) => [X, c]);
      break;
  }
  return i.printComment && (!i.willPrintOwnComments || !i.willPrintOwnComments(e, t)) && (s = Mr(e, s, t)), s;
}
async function Gt(e, t) {
  var _a2;
  let r = (_a2 = e.comments) != null ? _a2 : [];
  t[Symbol.for("comments")] = r, t[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Vr(e, t);
  let { printer: { preprocess: n } } = t;
  return e = n ? await n(e, t) : e, { ast: e, comments: r };
}
function xo(e, t) {
  let { cursorOffset: r, locStart: n, locEnd: u } = t, o = J(t.printer.getVisitorKeys), i = (F) => n(F) <= r && u(F) >= r, s = e, a = [e];
  for (let F of Lr(e, { getVisitorKeys: o, filter: i })) a.push(F), s = F;
  if (Ir(s, { getVisitorKeys: o })) return { cursorNode: s };
  let c, D2, p = -1, l = Number.POSITIVE_INFINITY;
  for (; a.length > 0 && (c === void 0 || D2 === void 0); ) {
    s = a.pop();
    let F = c !== void 0, f = D2 !== void 0;
    for (let d of Ce(s, { getVisitorKeys: o })) {
      if (!F) {
        let m = u(d);
        m <= r && m > p && (c = d, p = m);
      }
      if (!f) {
        let m = n(d);
        m >= r && m < l && (D2 = d, l = m);
      }
    }
  }
  return { nodeBeforeCursor: c, nodeAfterCursor: D2 };
}
var Kt = xo;
function wo(e, t) {
  var _a2;
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = t;
  if (!r) return e;
  let u = J(n), o = (_a2 = r.ignoredProperties) != null ? _a2 : /* @__PURE__ */ new Set();
  return i(e);
  function i(s, a) {
    if (!(s !== null && typeof s == "object")) return s;
    if (Array.isArray(s)) return s.map((l) => i(l, a)).filter(Boolean);
    let c = {}, D2 = new Set(u(s));
    for (let l in s) !Object.prototype.hasOwnProperty.call(s, l) || o.has(l) || (D2.has(l) ? c[l] = i(s[l], s) : c[l] = s[l]);
    let p = r(s, c, a);
    if (p !== null) return p != null ? p : c;
  }
}
var Yn = wo;
var bo = (e, t, r) => {
  if (!(e && t == null)) {
    if (t.findLastIndex) return t.findLastIndex(r);
    for (let n = t.length - 1; n >= 0; n--) {
      let u = t[n];
      if (r(u, n, t)) return n;
    }
    return -1;
  }
};
var jn = bo;
var ko = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
function So(e, t) {
  let r = [e.node, ...e.parentNodes], n = /* @__PURE__ */ new Set([t.node, ...t.parentNodes]);
  return r.find((u) => $n.has(u.type) && n.has(u));
}
function Un(e) {
  let t = jn(false, e, (r) => r.type !== "Program" && r.type !== "File");
  return t === -1 ? e : e.slice(0, t + 1);
}
function To(e, t, { locStart: r, locEnd: n }) {
  let u = e.node, o = t.node;
  if (u === o) return { startNode: u, endNode: o };
  let i = r(e.node);
  for (let a of Un(t.parentNodes)) if (r(a) >= i) o = a;
  else break;
  let s = n(t.node);
  for (let a of Un(e.parentNodes)) {
    if (n(a) <= s) u = a;
    else break;
    if (u === o) break;
  }
  return { startNode: u, endNode: o };
}
function zt(e, t, r, n, u = [], o) {
  let { locStart: i, locEnd: s } = r, a = i(e), c = s(e);
  if (!(t > c || t < a || o === "rangeEnd" && t === a || o === "rangeStart" && t === c)) {
    for (let D2 of Xe(e, r)) {
      let p = zt(D2, t, r, n, [e, ...u], o);
      if (p) return p;
    }
    if (!n || n(e, u[0])) return { node: e, parentNodes: u };
  }
}
function No(e, t) {
  return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
}
var $n = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Oo = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function Vn(e, t, r) {
  if (!t) return false;
  switch (e.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return No(t.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return $n.has(t.type);
    case "graphql":
      return Oo.has(t.kind);
    case "vue":
      return t.tag !== "root";
  }
  return false;
}
function Wn(e, t, r) {
  let { rangeStart: n, rangeEnd: u, locStart: o, locEnd: i } = t;
  Oe.ok(u > n);
  let s = e.slice(n, u).search(/\S/u), a = s === -1;
  if (!a) for (n += s; u > n && !/\S/u.test(e[u - 1]); --u) ;
  let c = zt(r, n, t, (F, f) => Vn(t, F, f), [], "rangeStart"), D2 = a ? c : zt(r, u, t, (F) => Vn(t, F), [], "rangeEnd");
  if (!c || !D2) return { rangeStart: 0, rangeEnd: 0 };
  let p, l;
  if (ko(t)) {
    let F = So(c, D2);
    p = F, l = F;
  } else ({ startNode: p, endNode: l } = To(c, D2, t));
  return { rangeStart: Math.min(o(p), o(l)), rangeEnd: Math.max(i(p), i(l)) };
}
var zn = "\uFEFF";
var Mn = Symbol("cursor");
async function Hn(e, t, r = 0) {
  if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: u } = await De(e, t);
  t.cursorOffset >= 0 && (t = { ...t, ...Kt(n, t) });
  let o = await Ye(n, t, r);
  r > 0 && (o = Ge([z, o], r, t.tabWidth));
  let i = me(o, t);
  if (r > 0) {
    let a = i.formatted.trim();
    i.cursorNodeStart !== void 0 && (i.cursorNodeStart -= i.formatted.indexOf(a), i.cursorNodeStart < 0 && (i.cursorNodeStart = 0, i.cursorNodeText = i.cursorNodeText.trimStart()), i.cursorNodeStart + i.cursorNodeText.length > a.length && (i.cursorNodeText = i.cursorNodeText.trimEnd())), i.formatted = a + xe(t.endOfLine);
  }
  let s = t[Symbol.for("comments")];
  if (t.cursorOffset >= 0) {
    let a, c, D2, p;
    if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && i.cursorNodeText) if (D2 = i.cursorNodeStart, p = i.cursorNodeText, t.cursorNode) a = t.locStart(t.cursorNode), c = u.slice(a, t.locEnd(t.cursorNode));
    else {
      if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
      a = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
      let C = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : u.length;
      c = u.slice(a, C);
    }
    else a = 0, c = u, D2 = 0, p = i.formatted;
    let l = t.cursorOffset - a;
    if (c === p) return { formatted: i.formatted, cursorOffset: D2 + l, comments: s };
    let F = c.split("");
    F.splice(l, 0, Mn);
    let f = p.split(""), d = Et(F, f), m = D2;
    for (let C of d) if (C.removed) {
      if (C.value.includes(Mn)) break;
    } else m += C.count;
    return { formatted: i.formatted, cursorOffset: m, comments: s };
  }
  return { formatted: i.formatted, cursorOffset: -1, comments: s };
}
async function Po(e, t) {
  let { ast: r, text: n } = await De(e, t), { rangeStart: u, rangeEnd: o } = Wn(n, t, r), i = n.slice(u, o), s = Math.min(u, n.lastIndexOf(`
`, u) + 1), a = n.slice(s, u).match(/^\s*/u)[0], c = Ee(a, t.tabWidth), D2 = await Hn(i, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > u && t.cursorOffset <= o ? t.cursorOffset - u : -1, endOfLine: "lf" }, c), p = D2.formatted.trimEnd(), { cursorOffset: l } = t;
  l > o ? l += p.length - i.length : D2.cursorOffset >= 0 && (l = D2.cursorOffset + u);
  let F = n.slice(0, u) + p + n.slice(o);
  if (t.endOfLine !== "lf") {
    let f = xe(t.endOfLine);
    l >= 0 && f === `\r
` && (l += Ct(F.slice(0, l), `
`)), F = te(false, F, `
`, f);
  }
  return { formatted: F, cursorOffset: l, comments: D2.comments };
}
function Ht(e, t, r) {
  return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
}
function Gn(e, t) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t;
  return r = Ht(e, r, -1), n = Ht(e, n, 0), u = Ht(e, u, e.length), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u };
}
function Jn(e, t) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: o } = Gn(e, t), i = e.charAt(0) === zn;
  if (i && (e = e.slice(1), r--, n--, u--), o === "auto" && (o = nr(e)), e.includes("\r")) {
    let s = (a) => Ct(e.slice(0, Math.max(a, 0)), `\r
`);
    r -= s(r), n -= s(n), u -= s(u), e = ur(e);
  }
  return { hasBOM: i, text: e, options: Gn(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: o }) };
}
async function Kn(e, t) {
  let r = await Re(t);
  return !r.hasPragma || r.hasPragma(e);
}
async function vo(e, t) {
  var n;
  let r = await Re(t);
  return (n = r.hasIgnorePragma) == null ? void 0 : n.call(r, e);
}
async function Jt(e, t) {
  let { hasBOM: r, text: n, options: u } = Jn(e, await ne(t));
  if (u.rangeStart >= u.rangeEnd && n !== "" || u.requirePragma && !await Kn(n, u) || u.checkIgnorePragma && await vo(n, u)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
  let o;
  return u.rangeStart > 0 || u.rangeEnd < n.length ? o = await Po(n, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await Kn(n, u) && (n = u.printer.insertPragma(n)), o = await Hn(n, u)), r && (o.formatted = zn + o.formatted, o.cursorOffset >= 0 && o.cursorOffset++), o;
}
async function qn(e, t, r) {
  let { text: n, options: u } = Jn(e, await ne(t)), o = await De(n, u);
  return r && (r.preprocessForPrint && (o.ast = await Gt(o.ast, u)), r.massage && (o.ast = Yn(o.ast, u))), o;
}
async function Xn(e, t) {
  t = await ne(t);
  let r = await Ye(e, t);
  return me(r, t);
}
async function Qn(e, t) {
  let r = wr(e), { formatted: n } = await Jt(r, { ...t, parser: "__js_expression" });
  return n;
}
async function Zn(e, t) {
  t = await ne(t);
  let { ast: r } = await De(e, t);
  return t.cursorOffset >= 0 && (t = { ...t, ...Kt(r, t) }), Ye(r, t);
}
async function eu(e, t) {
  return me(e, await ne(t));
}
var qt = {};
dt(qt, { builders: () => Io, printer: () => Ro, utils: () => Yo });
var Io = { join: ke, line: Me, softline: _r, hardline: z, literalline: We, group: At, conditionalGroup: Cr, fill: hr, lineSuffix: Se, lineSuffixBoundary: Ar, cursor: X, breakParent: pe, ifBreak: gr, trim: Br, indent: ie, indentIfBreak: yr, align: oe, addAlignmentToDoc: Ge, markAsRoot: mr, dedentToRoot: dr, dedent: Er, hardlineWithoutBreakParent: Te, literallineWithoutBreakParent: Bt, label: xr, concat: (e) => e };
var Ro = { printDocToString: me };
var Yo = { willBreak: Dr, traverseDoc: le, findInDoc: Ve, mapDoc: be, removeLines: fr, stripTrailingHardline: $e, replaceEndOfLine: lr, canBreak: Fr };
var tu = "3.6.2";
var Qt = {};
dt(Qt, { addDanglingComment: () => ee, addLeadingComment: () => se, addTrailingComment: () => ae, getAlignmentSize: () => Ee, getIndentSize: () => ru, getMaxContinuousCount: () => nu, getNextNonSpaceNonCommentCharacter: () => uu, getNextNonSpaceNonCommentCharacterIndex: () => Xo, getPreferredQuote: () => iu, getStringWidth: () => Ne, hasNewline: () => G, hasNewlineInRange: () => su, hasSpaces: () => au, isNextLineEmpty: () => ti, isNextLineEmptyAfterIndex: () => ct, isPreviousLineEmpty: () => Zo, makeString: () => Du, skip: () => he, skipEverythingButNewLine: () => Je, skipInlineComment: () => ye, skipNewline: () => U, skipSpaces: () => T, skipToLineEnd: () => He, skipTrailingComment: () => Ae, skipWhitespace: () => Rr });
function jo(e, t) {
  if (t === false) return false;
  if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
    for (let r = t + 2; r < e.length; ++r) if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
  }
  return t;
}
var ye = jo;
function Uo(e, t) {
  return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? Je(e, t) : t;
}
var Ae = Uo;
function Vo(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = T(e, n), n = ye(e, n), n = Ae(e, n), n = U(e, n);
  return n;
}
var je = Vo;
function $o(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = He(e, n), n = ye(e, n), n = T(e, n);
  return n = Ae(e, n), n = U(e, n), n !== false && G(e, n);
}
var ct = $o;
function Wo(e, t) {
  let r = e.lastIndexOf(`
`);
  return r === -1 ? 0 : Ee(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
}
var ru = Wo;
function Xt(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Mo(e, t) {
  let r = e.match(new RegExp(`(${Xt(t)})+`, "gu"));
  return r === null ? 0 : r.reduce((n, u) => Math.max(n, u.length / t.length), 0);
}
var nu = Mo;
function Go(e, t) {
  let r = je(e, t);
  return r === false ? "" : e.charAt(r);
}
var uu = Go;
var ft = "'";
var ou = '"';
function Ko(e, t) {
  let r = t === true || t === ft ? ft : ou, n = r === ft ? ou : ft, u = 0, o = 0;
  for (let i of e) i === r ? u++ : i === n && o++;
  return u > o ? n : r;
}
var iu = Ko;
function zo(e, t, r) {
  for (let n = t; n < r; ++n) if (e.charAt(n) === `
`) return true;
  return false;
}
var su = zo;
function Ho(e, t, r = {}) {
  return T(e, r.backwards ? t - 1 : t, r) !== t;
}
var au = Ho;
function Jo(e, t, r) {
  let n = t === '"' ? "'" : '"', o = te(false, e, /\\(.)|(["'])/gsu, (i, s, a) => s === n ? s : a === t ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
  return t + o + t;
}
var Du = Jo;
function qo(e, t, r) {
  return je(e, r(t));
}
function Xo(e, t) {
  return arguments.length === 2 || typeof t == "number" ? je(e, t) : qo(...arguments);
}
function Qo(e, t, r) {
  return Pe(e, r(t));
}
function Zo(e, t) {
  return arguments.length === 2 || typeof t == "number" ? Pe(e, t) : Qo(...arguments);
}
function ei(e, t, r) {
  return ct(e, r(t));
}
function ti(e, t) {
  return arguments.length === 2 || typeof t == "number" ? ct(e, t) : ei(...arguments);
}
function ce(e, t = 1) {
  return async (...r) => {
    var _a2, _b;
    let n = (_a2 = r[t]) != null ? _a2 : {}, u = (_b = n.plugins) != null ? _b : [];
    return r[t] = { ...n, plugins: Array.isArray(u) ? u : Object.values(u) }, e(...r);
  };
}
var cu = ce(Jt);
async function fu(e, t) {
  let { formatted: r } = await cu(e, { ...t, cursorOffset: -1 });
  return r;
}
async function ri(e, t) {
  return await fu(e, t) === e;
}
var ni = ce(Qe, 0);
var ui = { parse: ce(qn), formatAST: ce(Xn), formatDoc: ce(Qn), printToDoc: ce(Zn), printDocToString: ce(eu) };

// node_modules/prettier/plugins/postcss.mjs
var postcss_exports = {};
__export(postcss_exports, {
  default: () => s_,
  languages: () => Ei,
  options: () => Si,
  parsers: () => Zs,
  printers: () => Fy
});
var xl = Object.create;
var Wr2 = Object.defineProperty;
var bl = Object.getOwnPropertyDescriptor;
var _l = Object.getOwnPropertyNames;
var El = Object.getPrototypeOf;
var kl = Object.prototype.hasOwnProperty;
var g2 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var rn2 = (t, e) => {
  for (var s in e) Wr2(t, s, { get: e[s], enumerable: true });
};
var Sl = (t, e, s, r) => {
  if (e && typeof e == "object" || typeof e == "function") for (let n of _l(e)) !kl.call(t, n) && n !== s && Wr2(t, n, { get: () => e[n], enumerable: !(r = bl(e, n)) || r.enumerable });
  return t;
};
var be2 = (t, e, s) => (s = t != null ? xl(El(t)) : {}, Sl(e || !t || !t.__esModule ? Wr2(s, "default", { value: t, enumerable: true }) : s, t));
var Oi = g2((Pv, is) => {
  var _2 = String, Ti = function() {
    return { isColorSupported: false, reset: _2, bold: _2, dim: _2, italic: _2, underline: _2, inverse: _2, hidden: _2, strikethrough: _2, black: _2, red: _2, green: _2, yellow: _2, blue: _2, magenta: _2, cyan: _2, white: _2, gray: _2, bgBlack: _2, bgRed: _2, bgGreen: _2, bgYellow: _2, bgBlue: _2, bgMagenta: _2, bgCyan: _2, bgWhite: _2, blackBright: _2, redBright: _2, greenBright: _2, yellowBright: _2, blueBright: _2, magentaBright: _2, cyanBright: _2, whiteBright: _2, bgBlackBright: _2, bgRedBright: _2, bgGreenBright: _2, bgYellowBright: _2, bgBlueBright: _2, bgMagentaBright: _2, bgCyanBright: _2, bgWhiteBright: _2 };
  };
  is.exports = Ti();
  is.exports.createColors = Ti;
});
var os = g2(() => {
});
var Gt2 = g2((qv, Ni) => {
  "use strict";
  var Ci = Oi(), Ai = os(), at2 = class t extends Error {
    constructor(e, s, r, n, i, o) {
      super(e), this.name = "CssSyntaxError", this.reason = e, i && (this.file = i), n && (this.source = n), o && (this.plugin = o), typeof s < "u" && typeof r < "u" && (typeof s == "number" ? (this.line = s, this.column = r) : (this.line = s.line, this.column = s.column, this.endLine = r.line, this.endColumn = r.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, t);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e) {
      if (!this.source) return "";
      let s = this.source;
      e == null && (e = Ci.isColorSupported);
      let r = (f) => f, n = (f) => f, i = (f) => f;
      if (e) {
        let { bold: f, gray: p, red: l } = Ci.createColors(true);
        n = (d) => f(l(d)), r = (d) => p(d), Ai && (i = (d) => Ai(d));
      }
      let o = s.split(/\r?\n/), u = Math.max(this.line - 3, 0), a = Math.min(this.line + 2, o.length), c = String(a).length;
      return o.slice(u, a).map((f, p) => {
        let l = u + 1 + p, d = " " + (" " + l).slice(-c) + " | ";
        if (l === this.line) {
          if (f.length > 160) {
            let h = 20, m = Math.max(0, this.column - h), y2 = Math.max(this.column + h, this.endColumn + h), b2 = f.slice(m, y2), w2 = r(d.replace(/\d/g, " ")) + f.slice(0, Math.min(this.column - 1, h - 1)).replace(/[^\t]/g, " ");
            return n(">") + r(d) + i(b2) + `
 ` + w2 + n("^");
          }
          let x = r(d.replace(/\d/g, " ")) + f.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return n(">") + r(d) + i(f) + `
 ` + x + n("^");
        }
        return " " + r(d) + i(f);
      }).join(`
`);
    }
    toString() {
      let e = this.showSourceCode();
      return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
    }
  };
  Ni.exports = at2;
  at2.default = at2;
});
var Yt2 = g2((Lv, Ri) => {
  "use strict";
  var Pi = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  function Sc(t) {
    return t[0].toUpperCase() + t.slice(1);
  }
  var ut2 = class {
    constructor(e) {
      this.builder = e;
    }
    atrule(e, s) {
      let r = "@" + e.name, n = e.params ? this.rawValue(e, "params") : "";
      if (typeof e.raws.afterName < "u" ? r += e.raws.afterName : n && (r += " "), e.nodes) this.block(e, r + n);
      else {
        let i = (e.raws.between || "") + (s ? ";" : "");
        this.builder(r + n + i, e);
      }
    }
    beforeAfter(e, s) {
      let r;
      e.type === "decl" ? r = this.raw(e, null, "beforeDecl") : e.type === "comment" ? r = this.raw(e, null, "beforeComment") : s === "before" ? r = this.raw(e, null, "beforeRule") : r = this.raw(e, null, "beforeClose");
      let n = e.parent, i = 0;
      for (; n && n.type !== "root"; ) i += 1, n = n.parent;
      if (r.includes(`
`)) {
        let o = this.raw(e, null, "indent");
        if (o.length) for (let u = 0; u < i; u++) r += o;
      }
      return r;
    }
    block(e, s) {
      let r = this.raw(e, "between", "beforeOpen");
      this.builder(s + r + "{", e, "start");
      let n;
      e.nodes && e.nodes.length ? (this.body(e), n = this.raw(e, "after")) : n = this.raw(e, "after", "emptyBody"), n && this.builder(n), this.builder("}", e, "end");
    }
    body(e) {
      let s = e.nodes.length - 1;
      for (; s > 0 && e.nodes[s].type === "comment"; ) s -= 1;
      let r = this.raw(e, "semicolon");
      for (let n = 0; n < e.nodes.length; n++) {
        let i = e.nodes[n], o = this.raw(i, "before");
        o && this.builder(o), this.stringify(i, s !== n || r);
      }
    }
    comment(e) {
      let s = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
      this.builder("/*" + s + e.text + r + "*/", e);
    }
    decl(e, s) {
      let r = this.raw(e, "between", "colon"), n = e.prop + r + this.rawValue(e, "value");
      e.important && (n += e.raws.important || " !important"), s && (n += ";"), this.builder(n, e);
    }
    document(e) {
      this.body(e);
    }
    raw(e, s, r) {
      let n;
      if (r || (r = s), s && (n = e.raws[s], typeof n < "u")) return n;
      let i = e.parent;
      if (r === "before" && (!i || i.type === "root" && i.first === e || i && i.type === "document")) return "";
      if (!i) return Pi[r];
      let o = e.root();
      if (o.rawCache || (o.rawCache = {}), typeof o.rawCache[r] < "u") return o.rawCache[r];
      if (r === "before" || r === "after") return this.beforeAfter(e, r);
      {
        let u = "raw" + Sc(r);
        this[u] ? n = this[u](o, e) : o.walk((a) => {
          if (n = a.raws[s], typeof n < "u") return false;
        });
      }
      return typeof n > "u" && (n = Pi[r]), o.rawCache[r] = n, n;
    }
    rawBeforeClose(e) {
      let s;
      return e.walk((r) => {
        if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u") return s = r.raws.after, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), false;
      }), s && (s = s.replace(/\S/g, "")), s;
    }
    rawBeforeComment(e, s) {
      let r;
      return e.walkComments((n) => {
        if (typeof n.raws.before < "u") return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
      }), typeof r > "u" ? r = this.raw(s, null, "beforeDecl") : r && (r = r.replace(/\S/g, "")), r;
    }
    rawBeforeDecl(e, s) {
      let r;
      return e.walkDecls((n) => {
        if (typeof n.raws.before < "u") return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
      }), typeof r > "u" ? r = this.raw(s, null, "beforeRule") : r && (r = r.replace(/\S/g, "")), r;
    }
    rawBeforeOpen(e) {
      let s;
      return e.walk((r) => {
        if (r.type !== "decl" && (s = r.raws.between, typeof s < "u")) return false;
      }), s;
    }
    rawBeforeRule(e) {
      let s;
      return e.walk((r) => {
        if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < "u") return s = r.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), false;
      }), s && (s = s.replace(/\S/g, "")), s;
    }
    rawColon(e) {
      let s;
      return e.walkDecls((r) => {
        if (typeof r.raws.between < "u") return s = r.raws.between.replace(/[^\s:]/g, ""), false;
      }), s;
    }
    rawEmptyBody(e) {
      let s;
      return e.walk((r) => {
        if (r.nodes && r.nodes.length === 0 && (s = r.raws.after, typeof s < "u")) return false;
      }), s;
    }
    rawIndent(e) {
      if (e.raws.indent) return e.raws.indent;
      let s;
      return e.walk((r) => {
        let n = r.parent;
        if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before < "u") {
          let i = r.raws.before.split(`
`);
          return s = i[i.length - 1], s = s.replace(/\S/g, ""), false;
        }
      }), s;
    }
    rawSemicolon(e) {
      let s;
      return e.walk((r) => {
        if (r.nodes && r.nodes.length && r.last.type === "decl" && (s = r.raws.semicolon, typeof s < "u")) return false;
      }), s;
    }
    rawValue(e, s) {
      let r = e[s], n = e.raws[s];
      return n && n.value === r ? n.raw : r;
    }
    root(e) {
      this.body(e), e.raws.after && this.builder(e.raws.after);
    }
    rule(e) {
      this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
    }
    stringify(e, s) {
      if (!this[e.type]) throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
      this[e.type](e, s);
    }
  };
  Ri.exports = ut2;
  ut2.default = ut2;
});
var lt = g2((Dv, Ii) => {
  "use strict";
  var Tc = Yt2();
  function as(t, e) {
    new Tc(e).stringify(t);
  }
  Ii.exports = as;
  as.default = as;
});
var Vt2 = g2((Mv, us) => {
  "use strict";
  us.exports.isClean = Symbol("isClean");
  us.exports.my = Symbol("my");
});
var pt2 = g2((Bv, qi) => {
  "use strict";
  var Oc = Gt2(), Cc = Yt2(), Ac = lt(), { isClean: ct2, my: Nc } = Vt2();
  function ls(t, e) {
    let s = new t.constructor();
    for (let r in t) {
      if (!Object.prototype.hasOwnProperty.call(t, r) || r === "proxyCache") continue;
      let n = t[r], i = typeof n;
      r === "parent" && i === "object" ? e && (s[r] = e) : r === "source" ? s[r] = n : Array.isArray(n) ? s[r] = n.map((o) => ls(o, s)) : (i === "object" && n !== null && (n = ls(n)), s[r] = n);
    }
    return s;
  }
  function J2(t, e) {
    if (e && typeof e.offset < "u") return e.offset;
    let s = 1, r = 1, n = 0;
    for (let i = 0; i < t.length; i++) {
      if (r === e.line && s === e.column) {
        n = i;
        break;
      }
      t[i] === `
` ? (s = 1, r += 1) : s += 1;
    }
    return n;
  }
  var ft2 = class {
    get proxyOf() {
      return this;
    }
    constructor(e = {}) {
      this.raws = {}, this[ct2] = false, this[Nc] = true;
      for (let s in e) if (s === "nodes") {
        this.nodes = [];
        for (let r of e[s]) typeof r.clone == "function" ? this.append(r.clone()) : this.append(r);
      } else this[s] = e[s];
    }
    addToError(e) {
      if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
        let s = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
      }
      return e;
    }
    after(e) {
      return this.parent.insertAfter(this, e), this;
    }
    assign(e = {}) {
      for (let s in e) this[s] = e[s];
      return this;
    }
    before(e) {
      return this.parent.insertBefore(this, e), this;
    }
    cleanRaws(e) {
      delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
    }
    clone(e = {}) {
      let s = ls(this);
      for (let r in e) s[r] = e[r];
      return s;
    }
    cloneAfter(e = {}) {
      let s = this.clone(e);
      return this.parent.insertAfter(this, s), s;
    }
    cloneBefore(e = {}) {
      let s = this.clone(e);
      return this.parent.insertBefore(this, s), s;
    }
    error(e, s = {}) {
      if (this.source) {
        let { end: r, start: n } = this.rangeBy(s);
        return this.source.input.error(e, { column: n.column, line: n.line }, { column: r.column, line: r.line }, s);
      }
      return new Oc(e);
    }
    getProxyProcessor() {
      return { get(e, s) {
        return s === "proxyOf" ? e : s === "root" ? () => e.root().toProxy() : e[s];
      }, set(e, s, r) {
        return e[s] === r || (e[s] = r, (s === "prop" || s === "value" || s === "name" || s === "params" || s === "important" || s === "text") && e.markDirty()), true;
      } };
    }
    markClean() {
      this[ct2] = true;
    }
    markDirty() {
      if (this[ct2]) {
        this[ct2] = false;
        let e = this;
        for (; e = e.parent; ) e[ct2] = false;
      }
    }
    next() {
      if (!this.parent) return;
      let e = this.parent.index(this);
      return this.parent.nodes[e + 1];
    }
    positionBy(e = {}) {
      let s = this.source.start;
      if (e.index) s = this.positionInside(e.index);
      else if (e.word) {
        let r = "document" in this.source.input ? this.source.input.document : this.source.input.css, i = r.slice(J2(r, this.source.start), J2(r, this.source.end)).indexOf(e.word);
        i !== -1 && (s = this.positionInside(i));
      }
      return s;
    }
    positionInside(e) {
      let s = this.source.start.column, r = this.source.start.line, n = "document" in this.source.input ? this.source.input.document : this.source.input.css, i = J2(n, this.source.start), o = i + e;
      for (let u = i; u < o; u++) n[u] === `
` ? (s = 1, r += 1) : s += 1;
      return { column: s, line: r, offset: o };
    }
    prev() {
      if (!this.parent) return;
      let e = this.parent.index(this);
      return this.parent.nodes[e - 1];
    }
    rangeBy(e = {}) {
      let s = "document" in this.source.input ? this.source.input.document : this.source.input.css, r = { column: this.source.start.column, line: this.source.start.line, offset: J2(s, this.source.start) }, n = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line, offset: typeof this.source.end.offset == "number" ? this.source.end.offset : J2(s, this.source.end) + 1 } : { column: r.column + 1, line: r.line, offset: r.offset + 1 };
      if (e.word) {
        let o = s.slice(J2(s, this.source.start), J2(s, this.source.end)).indexOf(e.word);
        o !== -1 && (r = this.positionInside(o), n = this.positionInside(o + e.word.length));
      } else e.start ? r = { column: e.start.column, line: e.start.line, offset: J2(s, e.start) } : e.index && (r = this.positionInside(e.index)), e.end ? n = { column: e.end.column, line: e.end.line, offset: J2(s, e.end) } : typeof e.endIndex == "number" ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
      return (n.line < r.line || n.line === r.line && n.column <= r.column) && (n = { column: r.column + 1, line: r.line, offset: r.offset + 1 }), { end: n, start: r };
    }
    raw(e, s) {
      return new Cc().raw(this, e, s);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...e) {
      if (this.parent) {
        let s = this, r = false;
        for (let n of e) n === this ? r = true : r ? (this.parent.insertAfter(s, n), s = n) : this.parent.insertBefore(s, n);
        r || this.remove();
      }
      return this;
    }
    root() {
      let e = this;
      for (; e.parent && e.parent.type !== "document"; ) e = e.parent;
      return e;
    }
    toJSON(e, s) {
      let r = {}, n = s == null;
      s = s || /* @__PURE__ */ new Map();
      let i = 0;
      for (let o in this) {
        if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache") continue;
        let u = this[o];
        if (Array.isArray(u)) r[o] = u.map((a) => typeof a == "object" && a.toJSON ? a.toJSON(null, s) : a);
        else if (typeof u == "object" && u.toJSON) r[o] = u.toJSON(null, s);
        else if (o === "source") {
          if (u == null) continue;
          let a = s.get(u.input);
          a == null && (a = i, s.set(u.input, i), i++), r[o] = { end: u.end, inputId: a, start: u.start };
        } else r[o] = u;
      }
      return n && (r.inputs = [...s.keys()].map((o) => o.toJSON())), r;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e = Ac) {
      e.stringify && (e = e.stringify);
      let s = "";
      return e(this, (r) => {
        s += r;
      }), s;
    }
    warn(e, s, r = {}) {
      let n = { node: this };
      for (let i in r) n[i] = r[i];
      return e.warn(s, n);
    }
  };
  qi.exports = ft2;
  ft2.default = ft2;
});
var qe2 = g2((Uv, Li) => {
  "use strict";
  var Pc = pt2(), ht2 = class extends Pc {
    constructor(e) {
      super(e), this.type = "comment";
    }
  };
  Li.exports = ht2;
  ht2.default = ht2;
});
var mt2 = g2((Fv, Di) => {
  "use strict";
  var Rc = pt2(), dt2 = class extends Rc {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(e) {
      e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
    }
  };
  Di.exports = dt2;
  dt2.default = dt2;
});
var le2 = g2(($v, Vi) => {
  "use strict";
  var Mi = qe2(), Bi = mt2(), Ic = pt2(), { isClean: Ui, my: Fi } = Vt2(), cs, $i, Wi, fs2;
  function Gi(t) {
    return t.map((e) => (e.nodes && (e.nodes = Gi(e.nodes)), delete e.source, e));
  }
  function Yi(t) {
    if (t[Ui] = false, t.proxyOf.nodes) for (let e of t.proxyOf.nodes) Yi(e);
  }
  var V2 = class t extends Ic {
    get first() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...e) {
      for (let s of e) {
        let r = this.normalize(s, this.last);
        for (let n of r) this.proxyOf.nodes.push(n);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e) {
      if (super.cleanRaws(e), this.nodes) for (let s of this.nodes) s.cleanRaws(e);
    }
    each(e) {
      if (!this.proxyOf.nodes) return;
      let s = this.getIterator(), r, n;
      for (; this.indexes[s] < this.proxyOf.nodes.length && (r = this.indexes[s], n = e(this.proxyOf.nodes[r], r), n !== false); ) this.indexes[s] += 1;
      return delete this.indexes[s], n;
    }
    every(e) {
      return this.nodes.every(e);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e = this.lastEach;
      return this.indexes[e] = 0, e;
    }
    getProxyProcessor() {
      return { get(e, s) {
        return s === "proxyOf" ? e : e[s] ? s === "each" || typeof s == "string" && s.startsWith("walk") ? (...r) => e[s](...r.map((n) => typeof n == "function" ? (i, o) => n(i.toProxy(), o) : n)) : s === "every" || s === "some" ? (r) => e[s]((n, ...i) => r(n.toProxy(), ...i)) : s === "root" ? () => e.root().toProxy() : s === "nodes" ? e.nodes.map((r) => r.toProxy()) : s === "first" || s === "last" ? e[s].toProxy() : e[s] : e[s];
      }, set(e, s, r) {
        return e[s] === r || (e[s] = r, (s === "name" || s === "params" || s === "selector") && e.markDirty()), true;
      } };
    }
    index(e) {
      return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
    }
    insertAfter(e, s) {
      let r = this.index(e), n = this.normalize(s, this.proxyOf.nodes[r]).reverse();
      r = this.index(e);
      for (let o of n) this.proxyOf.nodes.splice(r + 1, 0, o);
      let i;
      for (let o in this.indexes) i = this.indexes[o], r < i && (this.indexes[o] = i + n.length);
      return this.markDirty(), this;
    }
    insertBefore(e, s) {
      let r = this.index(e), n = r === 0 ? "prepend" : false, i = this.normalize(s, this.proxyOf.nodes[r], n).reverse();
      r = this.index(e);
      for (let u of i) this.proxyOf.nodes.splice(r, 0, u);
      let o;
      for (let u in this.indexes) o = this.indexes[u], r <= o && (this.indexes[u] = o + i.length);
      return this.markDirty(), this;
    }
    normalize(e, s) {
      if (typeof e == "string") e = Gi($i(e).nodes);
      else if (typeof e > "u") e = [];
      else if (Array.isArray(e)) {
        e = e.slice(0);
        for (let n of e) n.parent && n.parent.removeChild(n, "ignore");
      } else if (e.type === "root" && this.type !== "document") {
        e = e.nodes.slice(0);
        for (let n of e) n.parent && n.parent.removeChild(n, "ignore");
      } else if (e.type) e = [e];
      else if (e.prop) {
        if (typeof e.value > "u") throw new Error("Value field is missed in node creation");
        typeof e.value != "string" && (e.value = String(e.value)), e = [new Bi(e)];
      } else if (e.selector || e.selectors) e = [new fs2(e)];
      else if (e.name) e = [new cs(e)];
      else if (e.text) e = [new Mi(e)];
      else throw new Error("Unknown node type in node creation");
      return e.map((n) => (n[Fi] || t.rebuild(n), n = n.proxyOf, n.parent && n.parent.removeChild(n), n[Ui] && Yi(n), n.raws || (n.raws = {}), typeof n.raws.before > "u" && s && typeof s.raws.before < "u" && (n.raws.before = s.raws.before.replace(/\S/g, "")), n.parent = this.proxyOf, n));
    }
    prepend(...e) {
      e = e.reverse();
      for (let s of e) {
        let r = this.normalize(s, this.first, "prepend").reverse();
        for (let n of r) this.proxyOf.nodes.unshift(n);
        for (let n in this.indexes) this.indexes[n] = this.indexes[n] + r.length;
      }
      return this.markDirty(), this;
    }
    push(e) {
      return e.parent = this, this.proxyOf.nodes.push(e), this;
    }
    removeAll() {
      for (let e of this.proxyOf.nodes) e.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e) {
      e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
      let s;
      for (let r in this.indexes) s = this.indexes[r], s >= e && (this.indexes[r] = s - 1);
      return this.markDirty(), this;
    }
    replaceValues(e, s, r) {
      return r || (r = s, s = {}), this.walkDecls((n) => {
        s.props && !s.props.includes(n.prop) || s.fast && !n.value.includes(s.fast) || (n.value = n.value.replace(e, r));
      }), this.markDirty(), this;
    }
    some(e) {
      return this.nodes.some(e);
    }
    walk(e) {
      return this.each((s, r) => {
        let n;
        try {
          n = e(s, r);
        } catch (i) {
          throw s.addToError(i);
        }
        return n !== false && s.walk && (n = s.walk(e)), n;
      });
    }
    walkAtRules(e, s) {
      return s ? e instanceof RegExp ? this.walk((r, n) => {
        if (r.type === "atrule" && e.test(r.name)) return s(r, n);
      }) : this.walk((r, n) => {
        if (r.type === "atrule" && r.name === e) return s(r, n);
      }) : (s = e, this.walk((r, n) => {
        if (r.type === "atrule") return s(r, n);
      }));
    }
    walkComments(e) {
      return this.walk((s, r) => {
        if (s.type === "comment") return e(s, r);
      });
    }
    walkDecls(e, s) {
      return s ? e instanceof RegExp ? this.walk((r, n) => {
        if (r.type === "decl" && e.test(r.prop)) return s(r, n);
      }) : this.walk((r, n) => {
        if (r.type === "decl" && r.prop === e) return s(r, n);
      }) : (s = e, this.walk((r, n) => {
        if (r.type === "decl") return s(r, n);
      }));
    }
    walkRules(e, s) {
      return s ? e instanceof RegExp ? this.walk((r, n) => {
        if (r.type === "rule" && e.test(r.selector)) return s(r, n);
      }) : this.walk((r, n) => {
        if (r.type === "rule" && r.selector === e) return s(r, n);
      }) : (s = e, this.walk((r, n) => {
        if (r.type === "rule") return s(r, n);
      }));
    }
  };
  V2.registerParse = (t) => {
    $i = t;
  };
  V2.registerRule = (t) => {
    fs2 = t;
  };
  V2.registerAtRule = (t) => {
    cs = t;
  };
  V2.registerRoot = (t) => {
    Wi = t;
  };
  Vi.exports = V2;
  V2.default = V2;
  V2.rebuild = (t) => {
    t.type === "atrule" ? Object.setPrototypeOf(t, cs.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, fs2.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, Bi.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, Mi.prototype) : t.type === "root" && Object.setPrototypeOf(t, Wi.prototype), t[Fi] = true, t.nodes && t.nodes.forEach((e) => {
      V2.rebuild(e);
    });
  };
});
var Hi = g2((Wv, zi) => {
  var qc = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Lc = (t, e = 21) => (s = e) => {
    let r = "", n = s | 0;
    for (; n--; ) r += t[Math.random() * t.length | 0];
    return r;
  }, Dc = (t = 21) => {
    let e = "", s = t | 0;
    for (; s--; ) e += qc[Math.random() * 64 | 0];
    return e;
  };
  zi.exports = { nanoid: Dc, customAlphabet: Lc };
});
var ji = g2(() => {
});
var ps = g2((Vv, Ki) => {
  Ki.exports = class {
  };
});
var De2 = g2((Hv, eo2) => {
  "use strict";
  var { nanoid: Mc } = Hi(), { isAbsolute: ms, resolve: ys } = {}, { SourceMapConsumer: Bc, SourceMapGenerator: Uc } = ji(), { fileURLToPath: Qi, pathToFileURL: zt2 } = {}, Xi = Gt2(), Fc = ps(), hs = os(), ds = Symbol("lineToIndexCache"), $c = !!(Bc && Uc), Ji = !!(ys && ms);
  function Zi(t) {
    if (t[ds]) return t[ds];
    let e = t.css.split(`
`), s = new Array(e.length), r = 0;
    for (let n = 0, i = e.length; n < i; n++) s[n] = r, r += e[n].length + 1;
    return t[ds] = s, s;
  }
  var Le2 = class {
    get from() {
      return this.file || this.id;
    }
    constructor(e, s = {}) {
      if (e === null || typeof e > "u" || typeof e == "object" && !e.toString) throw new Error(`PostCSS received ${e} instead of CSS string`);
      if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, this.document = this.css, s.document && (this.document = s.document.toString()), s.from && (!Ji || /^\w+:\/\//.test(s.from) || ms(s.from) ? this.file = s.from : this.file = ys(s.from)), Ji && $c) {
        let r = new Fc(this.css, s);
        if (r.text) {
          this.map = r;
          let n = r.consumer().file;
          !this.file && n && (this.file = this.mapResolve(n));
        }
      }
      this.file || (this.id = "<input css " + Mc(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e, s, r, n = {}) {
      let i, o, u, a, c;
      if (s && typeof s == "object") {
        let p = s, l = r;
        if (typeof p.offset == "number") {
          a = p.offset;
          let d = this.fromOffset(a);
          s = d.line, r = d.col;
        } else s = p.line, r = p.column, a = this.fromLineAndColumn(s, r);
        if (typeof l.offset == "number") {
          u = l.offset;
          let d = this.fromOffset(u);
          o = d.line, i = d.col;
        } else o = l.line, i = l.column, u = this.fromLineAndColumn(l.line, l.column);
      } else if (r) a = this.fromLineAndColumn(s, r);
      else {
        a = s;
        let p = this.fromOffset(a);
        s = p.line, r = p.col;
      }
      let f = this.origin(s, r, o, i);
      return f ? c = new Xi(e, f.endLine === void 0 ? f.line : { column: f.column, line: f.line }, f.endLine === void 0 ? f.column : { column: f.endColumn, line: f.endLine }, f.source, f.file, n.plugin) : c = new Xi(e, o === void 0 ? s : { column: r, line: s }, o === void 0 ? r : { column: i, line: o }, this.css, this.file, n.plugin), c.input = { column: r, endColumn: i, endLine: o, endOffset: u, line: s, offset: a, source: this.css }, this.file && (zt2 && (c.input.url = zt2(this.file).toString()), c.input.file = this.file), c;
    }
    fromLineAndColumn(e, s) {
      return Zi(this)[e - 1] + s - 1;
    }
    fromOffset(e) {
      let s = Zi(this), r = s[s.length - 1], n = 0;
      if (e >= r) n = s.length - 1;
      else {
        let i = s.length - 2, o;
        for (; n < i; ) if (o = n + (i - n >> 1), e < s[o]) i = o - 1;
        else if (e >= s[o + 1]) n = o + 1;
        else {
          n = o;
          break;
        }
      }
      return { col: e - s[n] + 1, line: n + 1 };
    }
    mapResolve(e) {
      return /^\w+:\/\//.test(e) ? e : ys(this.map.consumer().sourceRoot || this.map.root || ".", e);
    }
    origin(e, s, r, n) {
      if (!this.map) return false;
      let i = this.map.consumer(), o = i.originalPositionFor({ column: s, line: e });
      if (!o.source) return false;
      let u;
      typeof r == "number" && (u = i.originalPositionFor({ column: n, line: r }));
      let a;
      ms(o.source) ? a = zt2(o.source) : a = new URL(o.source, this.map.consumer().sourceRoot || zt2(this.map.mapFile));
      let c = { column: o.column, endColumn: u && u.column, endLine: u && u.line, line: o.line, url: a.toString() };
      if (a.protocol === "file:") if (Qi) c.file = Qi(a);
      else throw new Error("file: protocol is not available in this PostCSS build");
      let f = i.sourceContentFor(o.source);
      return f && (c.source = f), c;
    }
    toJSON() {
      let e = {};
      for (let s of ["hasBOM", "css", "file", "id"]) this[s] != null && (e[s] = this[s]);
      return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
    }
  };
  eo2.exports = Le2;
  Le2.default = Le2;
  hs && hs.registerInput && hs.registerInput(Le2);
});
var Ht2 = g2((jv, ro2) => {
  "use strict";
  var to2 = le2(), Me2 = class extends to2 {
    constructor(e) {
      super(e), this.type = "atrule";
    }
    append(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
    }
    prepend(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
    }
  };
  ro2.exports = Me2;
  Me2.default = Me2;
  to2.registerAtRule(Me2);
});
var Be = g2((Kv, oo2) => {
  "use strict";
  var so2 = le2(), no2, io2, ce2 = class extends so2 {
    constructor(e) {
      super(e), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e, s, r) {
      let n = super.normalize(e);
      if (s) {
        if (r === "prepend") this.nodes.length > 1 ? s.raws.before = this.nodes[1].raws.before : delete s.raws.before;
        else if (this.first !== s) for (let i of n) i.raws.before = s.raws.before;
      }
      return n;
    }
    removeChild(e, s) {
      let r = this.index(e);
      return !s && r === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
    }
    toResult(e = {}) {
      return new no2(new io2(), this, e).stringify();
    }
  };
  ce2.registerLazyResult = (t) => {
    no2 = t;
  };
  ce2.registerProcessor = (t) => {
    io2 = t;
  };
  oo2.exports = ce2;
  ce2.default = ce2;
  so2.registerRoot(ce2);
});
var gs = g2((Qv, ao2) => {
  "use strict";
  var yt2 = { comma(t) {
    return yt2.split(t, [","], true);
  }, space(t) {
    let e = [" ", `
`, "	"];
    return yt2.split(t, e);
  }, split(t, e, s) {
    let r = [], n = "", i = false, o = 0, u = false, a = "", c = false;
    for (let f of t) c ? c = false : f === "\\" ? c = true : u ? f === a && (u = false) : f === '"' || f === "'" ? (u = true, a = f) : f === "(" ? o += 1 : f === ")" ? o > 0 && (o -= 1) : o === 0 && e.includes(f) && (i = true), i ? (n !== "" && r.push(n.trim()), n = "", i = false) : n += f;
    return (s || n !== "") && r.push(n.trim()), r;
  } };
  ao2.exports = yt2;
  yt2.default = yt2;
});
var jt2 = g2((Xv, lo2) => {
  "use strict";
  var uo2 = le2(), Wc = gs(), Ue2 = class extends uo2 {
    get selectors() {
      return Wc.comma(this.selector);
    }
    set selectors(e) {
      let s = this.selector ? this.selector.match(/,\s*/) : null, r = s ? s[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e.join(r);
    }
    constructor(e) {
      super(e), this.type = "rule", this.nodes || (this.nodes = []);
    }
  };
  lo2.exports = Ue2;
  Ue2.default = Ue2;
  uo2.registerRule(Ue2);
});
var Xt2 = g2((Jv, fo) => {
  "use strict";
  var Kt2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, Qt2 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Gc = /.[\r\n"'(/\\]/, co2 = /[\da-f]/i;
  fo.exports = function(e, s = {}) {
    let r = e.css.valueOf(), n = s.ignoreErrors, i, o, u, a, c, f, p, l, d, x, h = r.length, m = 0, y2 = [], b2 = [];
    function w2() {
      return m;
    }
    function v2(W2) {
      throw e.error("Unclosed " + W2, m);
    }
    function R2() {
      return b2.length === 0 && m >= h;
    }
    function F(W2) {
      if (b2.length) return b2.pop();
      if (m >= h) return;
      let T2 = W2 ? W2.ignoreUnclosed : false;
      switch (i = r.charCodeAt(m), i) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          a = m;
          do
            a += 1, i = r.charCodeAt(a);
          while (i === 32 || i === 10 || i === 9 || i === 13 || i === 12);
          f = ["space", r.slice(m, a)], m = a - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let O2 = String.fromCharCode(i);
          f = [O2, O2, m];
          break;
        }
        case 40: {
          if (x = y2.length ? y2.pop()[1] : "", d = r.charCodeAt(m + 1), x === "url" && d !== 39 && d !== 34 && d !== 32 && d !== 10 && d !== 9 && d !== 12 && d !== 13) {
            a = m;
            do {
              if (p = false, a = r.indexOf(")", a + 1), a === -1) if (n || T2) {
                a = m;
                break;
              } else v2("bracket");
              for (l = a; r.charCodeAt(l - 1) === 92; ) l -= 1, p = !p;
            } while (p);
            f = ["brackets", r.slice(m, a + 1), m, a], m = a;
          } else a = r.indexOf(")", m + 1), o = r.slice(m, a + 1), a === -1 || Gc.test(o) ? f = ["(", "(", m] : (f = ["brackets", o, m, a], m = a);
          break;
        }
        case 39:
        case 34: {
          c = i === 39 ? "'" : '"', a = m;
          do {
            if (p = false, a = r.indexOf(c, a + 1), a === -1) if (n || T2) {
              a = m + 1;
              break;
            } else v2("string");
            for (l = a; r.charCodeAt(l - 1) === 92; ) l -= 1, p = !p;
          } while (p);
          f = ["string", r.slice(m, a + 1), m, a], m = a;
          break;
        }
        case 64: {
          Kt2.lastIndex = m + 1, Kt2.test(r), Kt2.lastIndex === 0 ? a = r.length - 1 : a = Kt2.lastIndex - 2, f = ["at-word", r.slice(m, a + 1), m, a], m = a;
          break;
        }
        case 92: {
          for (a = m, u = true; r.charCodeAt(a + 1) === 92; ) a += 1, u = !u;
          if (i = r.charCodeAt(a + 1), u && i !== 47 && i !== 32 && i !== 10 && i !== 9 && i !== 13 && i !== 12 && (a += 1, co2.test(r.charAt(a)))) {
            for (; co2.test(r.charAt(a + 1)); ) a += 1;
            r.charCodeAt(a + 1) === 32 && (a += 1);
          }
          f = ["word", r.slice(m, a + 1), m, a], m = a;
          break;
        }
        default: {
          i === 47 && r.charCodeAt(m + 1) === 42 ? (a = r.indexOf("*/", m + 2) + 1, a === 0 && (n || T2 ? a = r.length : v2("comment")), f = ["comment", r.slice(m, a + 1), m, a], m = a) : (Qt2.lastIndex = m + 1, Qt2.test(r), Qt2.lastIndex === 0 ? a = r.length - 1 : a = Qt2.lastIndex - 2, f = ["word", r.slice(m, a + 1), m, a], y2.push(f), m = a);
          break;
        }
      }
      return m++, f;
    }
    function Q2(W2) {
      b2.push(W2);
    }
    return { back: Q2, endOfFile: R2, nextToken: F, position: w2 };
  };
});
var Jt2 = g2((Zv, mo2) => {
  "use strict";
  var Yc = Ht2(), Vc = qe2(), zc = mt2(), Hc = Be(), po2 = jt2(), jc = Xt2(), ho = { empty: true, space: true };
  function Kc(t) {
    for (let e = t.length - 1; e >= 0; e--) {
      let s = t[e], r = s[3] || s[2];
      if (r) return r;
    }
  }
  var ws = class {
    constructor(e) {
      this.input = e, this.root = new Hc(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e) {
      let s = new Yc();
      s.name = e[1].slice(1), s.name === "" && this.unnamedAtrule(s, e), this.init(s, e[2]);
      let r, n, i, o = false, u = false, a = [], c = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (e = this.tokenizer.nextToken(), r = e[0], r === "(" || r === "[" ? c.push(r === "(" ? ")" : "]") : r === "{" && c.length > 0 ? c.push("}") : r === c[c.length - 1] && c.pop(), c.length === 0) if (r === ";") {
          s.source.end = this.getPosition(e[2]), s.source.end.offset++, this.semicolon = true;
          break;
        } else if (r === "{") {
          u = true;
          break;
        } else if (r === "}") {
          if (a.length > 0) {
            for (i = a.length - 1, n = a[i]; n && n[0] === "space"; ) n = a[--i];
            n && (s.source.end = this.getPosition(n[3] || n[2]), s.source.end.offset++);
          }
          this.end(e);
          break;
        } else a.push(e);
        else a.push(e);
        if (this.tokenizer.endOfFile()) {
          o = true;
          break;
        }
      }
      s.raws.between = this.spacesAndCommentsFromEnd(a), a.length ? (s.raws.afterName = this.spacesAndCommentsFromStart(a), this.raw(s, "params", a), o && (e = a[a.length - 1], s.source.end = this.getPosition(e[3] || e[2]), s.source.end.offset++, this.spaces = s.raws.between, s.raws.between = "")) : (s.raws.afterName = "", s.params = ""), u && (s.nodes = [], this.current = s);
    }
    checkMissedSemicolon(e) {
      let s = this.colon(e);
      if (s === false) return;
      let r = 0, n;
      for (let i = s - 1; i >= 0 && (n = e[i], !(n[0] !== "space" && (r += 1, r === 2))); i--) ;
      throw this.input.error("Missed semicolon", n[0] === "word" ? n[3] + 1 : n[2]);
    }
    colon(e) {
      let s = 0, r, n, i;
      for (let [o, u] of e.entries()) {
        if (n = u, i = n[0], i === "(" && (s += 1), i === ")" && (s -= 1), s === 0 && i === ":") if (!r) this.doubleColon(n);
        else {
          if (r[0] === "word" && r[1] === "progid") continue;
          return o;
        }
        r = n;
      }
      return false;
    }
    comment(e) {
      let s = new Vc();
      this.init(s, e[2]), s.source.end = this.getPosition(e[3] || e[2]), s.source.end.offset++;
      let r = e[1].slice(2, -2);
      if (/^\s*$/.test(r)) s.text = "", s.raws.left = r, s.raws.right = "";
      else {
        let n = r.match(/^(\s*)([^]*\S)(\s*)$/);
        s.text = n[2], s.raws.left = n[1], s.raws.right = n[3];
      }
    }
    createTokenizer() {
      this.tokenizer = jc(this.input);
    }
    decl(e, s) {
      let r = new zc();
      this.init(r, e[0][2]);
      let n = e[e.length - 1];
      for (n[0] === ";" && (this.semicolon = true, e.pop()), r.source.end = this.getPosition(n[3] || n[2] || Kc(e)), r.source.end.offset++; e[0][0] !== "word"; ) e.length === 1 && this.unknownWord(e), r.raws.before += e.shift()[1];
      for (r.source.start = this.getPosition(e[0][2]), r.prop = ""; e.length; ) {
        let c = e[0][0];
        if (c === ":" || c === "space" || c === "comment") break;
        r.prop += e.shift()[1];
      }
      r.raws.between = "";
      let i;
      for (; e.length; ) if (i = e.shift(), i[0] === ":") {
        r.raws.between += i[1];
        break;
      } else i[0] === "word" && /\w/.test(i[1]) && this.unknownWord([i]), r.raws.between += i[1];
      (r.prop[0] === "_" || r.prop[0] === "*") && (r.raws.before += r.prop[0], r.prop = r.prop.slice(1));
      let o = [], u;
      for (; e.length && (u = e[0][0], !(u !== "space" && u !== "comment")); ) o.push(e.shift());
      this.precheckMissedSemicolon(e);
      for (let c = e.length - 1; c >= 0; c--) {
        if (i = e[c], i[1].toLowerCase() === "!important") {
          r.important = true;
          let f = this.stringFrom(e, c);
          f = this.spacesFromEnd(e) + f, f !== " !important" && (r.raws.important = f);
          break;
        } else if (i[1].toLowerCase() === "important") {
          let f = e.slice(0), p = "";
          for (let l = c; l > 0; l--) {
            let d = f[l][0];
            if (p.trim().startsWith("!") && d !== "space") break;
            p = f.pop()[1] + p;
          }
          p.trim().startsWith("!") && (r.important = true, r.raws.important = p, e = f);
        }
        if (i[0] !== "space" && i[0] !== "comment") break;
      }
      e.some((c) => c[0] !== "space" && c[0] !== "comment") && (r.raws.between += o.map((c) => c[1]).join(""), o = []), this.raw(r, "value", o.concat(e), s), r.value.includes(":") && !s && this.checkMissedSemicolon(e);
    }
    doubleColon(e) {
      throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length });
    }
    emptyRule(e) {
      let s = new po2();
      this.init(s, e[2]), s.selector = "", s.raws.between = "", this.current = s;
    }
    end(e) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e) {
      if (this.spaces += e[1], this.current.nodes) {
        let s = this.current.nodes[this.current.nodes.length - 1];
        s && s.type === "rule" && !s.raws.ownSemicolon && (s.raws.ownSemicolon = this.spaces, this.spaces = "", s.source.end = this.getPosition(e[2]), s.source.end.offset += s.raws.ownSemicolon.length);
      }
    }
    getPosition(e) {
      let s = this.input.fromOffset(e);
      return { column: s.col, line: s.line, offset: e };
    }
    init(e, s) {
      this.current.push(e), e.source = { input: this.input, start: this.getPosition(s) }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = false);
    }
    other(e) {
      let s = false, r = null, n = false, i = null, o = [], u = e[1].startsWith("--"), a = [], c = e;
      for (; c; ) {
        if (r = c[0], a.push(c), r === "(" || r === "[") i || (i = c), o.push(r === "(" ? ")" : "]");
        else if (u && n && r === "{") i || (i = c), o.push("}");
        else if (o.length === 0) if (r === ";") if (n) {
          this.decl(a, u);
          return;
        } else break;
        else if (r === "{") {
          this.rule(a);
          return;
        } else if (r === "}") {
          this.tokenizer.back(a.pop()), s = true;
          break;
        } else r === ":" && (n = true);
        else r === o[o.length - 1] && (o.pop(), o.length === 0 && (i = null));
        c = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (s = true), o.length > 0 && this.unclosedBracket(i), s && n) {
        if (!u) for (; a.length && (c = a[a.length - 1][0], !(c !== "space" && c !== "comment")); ) this.tokenizer.back(a.pop());
        this.decl(a, u);
      } else this.unknownWord(a);
    }
    parse() {
      let e;
      for (; !this.tokenizer.endOfFile(); ) switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(e, s, r, n) {
      let i, o, u = r.length, a = "", c = true, f, p;
      for (let l = 0; l < u; l += 1) i = r[l], o = i[0], o === "space" && l === u - 1 && !n ? c = false : o === "comment" ? (p = r[l - 1] ? r[l - 1][0] : "empty", f = r[l + 1] ? r[l + 1][0] : "empty", !ho[p] && !ho[f] ? a.slice(-1) === "," ? c = false : a += i[1] : c = false) : a += i[1];
      if (!c) {
        let l = r.reduce((d, x) => d + x[1], "");
        e.raws[s] = { raw: l, value: a };
      }
      e[s] = a;
    }
    rule(e) {
      e.pop();
      let s = new po2();
      this.init(s, e[0][2]), s.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(s, "selector", e), this.current = s;
    }
    spacesAndCommentsFromEnd(e) {
      let s, r = "";
      for (; e.length && (s = e[e.length - 1][0], !(s !== "space" && s !== "comment")); ) r = e.pop()[1] + r;
      return r;
    }
    spacesAndCommentsFromStart(e) {
      let s, r = "";
      for (; e.length && (s = e[0][0], !(s !== "space" && s !== "comment")); ) r += e.shift()[1];
      return r;
    }
    spacesFromEnd(e) {
      let s, r = "";
      for (; e.length && (s = e[e.length - 1][0], s === "space"); ) r = e.pop()[1] + r;
      return r;
    }
    stringFrom(e, s) {
      let r = "";
      for (let n = s; n < e.length; n++) r += e[n][1];
      return e.splice(s, e.length - s), r;
    }
    unclosedBlock() {
      let e = this.current.source.start;
      throw this.input.error("Unclosed block", e.line, e.column);
    }
    unclosedBracket(e) {
      throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unexpectedClose(e) {
      throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unknownWord(e) {
      throw this.input.error("Unknown word " + e[0][1], { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
    }
    unnamedAtrule(e, s) {
      throw this.input.error("At-rule without name", { offset: s[2] }, { offset: s[2] + s[1].length });
    }
  };
  mo2.exports = ws;
});
var gt2 = g2((ex, yo2) => {
  "use strict";
  var Qc = le2(), Xc = De2(), Jc = Jt2();
  function Zt2(t, e) {
    let s = new Xc(t, e), r = new Jc(s);
    try {
      r.parse();
    } catch (n) {
      throw n;
    }
    return r.root;
  }
  yo2.exports = Zt2;
  Zt2.default = Zt2;
  Qc.registerParse(Zt2);
});
var go = g2((tx, vs) => {
  var Zc = Xt2(), ef = De2();
  vs.exports = { isInlineComment(t) {
    if (t[0] === "word" && t[1].slice(0, 2) === "//") {
      let e = t, s = [], r, n;
      for (; t; ) {
        if (/\r?\n/.test(t[1])) {
          if (/['"].*\r?\n/.test(t[1])) {
            s.push(t[1].substring(0, t[1].indexOf(`
`))), n = t[1].substring(t[1].indexOf(`
`));
            let o = this.input.css.valueOf().substring(this.tokenizer.position());
            n += o, r = t[3] + o.length - n.length;
          } else this.tokenizer.back(t);
          break;
        }
        s.push(t[1]), r = t[2], t = this.tokenizer.nextToken({ ignoreUnclosed: true });
      }
      let i = ["comment", s.join(""), e[2], r];
      return this.inlineComment(i), n && (this.input = new ef(n), this.tokenizer = Zc(this.input)), true;
    } else if (t[1] === "/") {
      let e = this.tokenizer.nextToken({ ignoreUnclosed: true });
      if (e[0] === "comment" && /^\/\*/.test(e[1])) return e[0] = "word", e[1] = e[1].slice(1), t[1] = "//", this.tokenizer.back(e), vs.exports.isInlineComment.bind(this)(t);
    }
    return false;
  } };
});
var vo2 = g2((rx, wo2) => {
  wo2.exports = { interpolation(t) {
    let e = [t, this.tokenizer.nextToken()], s = ["word", "}"];
    if (e[0][1].length > 1 || e[1][0] !== "{") return this.tokenizer.back(e[1]), false;
    for (t = this.tokenizer.nextToken(); t && s.includes(t[0]); ) e.push(t), t = this.tokenizer.nextToken();
    let r = e.map((u) => u[1]), [n] = e, i = e.pop(), o = ["word", r.join(""), n[2], i[2]];
    return this.tokenizer.back(t), this.tokenizer.back(o), true;
  } };
});
var bo2 = g2((sx, xo2) => {
  var tf = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, rf = /\.[0-9]/, sf = (t) => {
    let [, e] = t, [s] = e;
    return (s === "." || s === "#") && tf.test(e) === false && rf.test(e) === false;
  };
  xo2.exports = { isMixinToken: sf };
});
var Eo2 = g2((nx, _o2) => {
  var nf = Xt2(), of = /^url\((.+)\)/;
  _o2.exports = (t) => {
    let { name: e, params: s = "" } = t;
    if (e === "import" && s.length) {
      t.import = true;
      let r = nf({ css: s });
      for (t.filename = s.replace(of, "$1"); !r.endOfFile(); ) {
        let [n, i] = r.nextToken();
        if (n === "word" && i === "url") return;
        if (n === "brackets") {
          t.options = i, t.filename = s.replace(i, "").trim();
          break;
        }
      }
    }
  };
});
var Oo2 = g2((ix, To2) => {
  var ko2 = /:$/, So2 = /^:(\s+)?/;
  To2.exports = (t) => {
    let { name: e, params: s = "" } = t;
    if (t.name.slice(-1) === ":") {
      if (ko2.test(e)) {
        let [r] = e.match(ko2);
        t.name = e.replace(r, ""), t.raws.afterName = r + (t.raws.afterName || ""), t.variable = true, t.value = t.params;
      }
      if (So2.test(s)) {
        let [r] = s.match(So2);
        t.value = s.replace(r, ""), t.raws.afterName = (t.raws.afterName || "") + r, t.variable = true;
      }
    }
  };
});
var No2 = g2((ax, Ao2) => {
  var af = qe2(), uf = Jt2(), { isInlineComment: lf } = go(), { interpolation: Co } = vo2(), { isMixinToken: cf } = bo2(), ff = Eo2(), pf = Oo2(), hf = /(!\s*important)$/i;
  Ao2.exports = class extends uf {
    constructor(...e) {
      super(...e), this.lastNode = null;
    }
    atrule(e) {
      Co.bind(this)(e) || (super.atrule(e), ff(this.lastNode), pf(this.lastNode));
    }
    decl(...e) {
      super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
    }
    each(e) {
      e[0][1] = ` ${e[0][1]}`;
      let s = e.findIndex((u) => u[0] === "("), r = e.reverse().find((u) => u[0] === ")"), n = e.reverse().indexOf(r), o = e.splice(s, n).map((u) => u[1]).join("");
      for (let u of e.reverse()) this.tokenizer.back(u);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = o;
    }
    init(e, s, r) {
      super.init(e, s, r), this.lastNode = e;
    }
    inlineComment(e) {
      let s = new af(), r = e[1].slice(2);
      if (this.init(s, e[2]), s.source.end = this.getPosition(e[3] || e[2]), s.inline = true, s.raws.begin = "//", /^\s*$/.test(r)) s.text = "", s.raws.left = r, s.raws.right = "";
      else {
        let n = r.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, s.raws.left, s.text, s.raws.right] = n;
      }
    }
    mixin(e) {
      let [s] = e, r = s[1].slice(0, 1), n = e.findIndex((c) => c[0] === "brackets"), i = e.findIndex((c) => c[0] === "("), o = "";
      if ((n < 0 || n > 3) && i > 0) {
        let c = e.reduce((w2, v2, R2) => v2[0] === ")" ? R2 : w2), p = e.slice(i, c + i).map((w2) => w2[1]).join(""), [l] = e.slice(i), d = [l[2], l[3]], [x] = e.slice(c, c + 1), h = [x[2], x[3]], m = ["brackets", p].concat(d, h), y2 = e.slice(0, i), b2 = e.slice(c + 1);
        e = y2, e.push(m), e = e.concat(b2);
      }
      let u = [];
      for (let c of e) if ((c[1] === "!" || u.length) && u.push(c), c[1] === "important") break;
      if (u.length) {
        let [c] = u, f = e.indexOf(c), p = u[u.length - 1], l = [c[2], c[3]], d = [p[4], p[5]], h = ["word", u.map((m) => m[1]).join("")].concat(l, d);
        e.splice(f, u.length, h);
      }
      let a = e.findIndex((c) => hf.test(c[1]));
      a > 0 && ([, o] = e[a], e.splice(a, 1));
      for (let c of e.reverse()) this.tokenizer.back(c);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = r, o && (this.lastNode.important = true, this.lastNode.raws.important = o);
    }
    other(e) {
      lf.bind(this)(e) || super.other(e);
    }
    rule(e) {
      let s = e[e.length - 1], r = e[e.length - 2];
      if (r[0] === "at-word" && s[0] === "{" && (this.tokenizer.back(s), Co.bind(this)(r))) {
        let i = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([i]);
        for (let o of e.reverse()) this.tokenizer.back(o);
        return;
      }
      super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
    }
    unknownWord(e) {
      let [s] = e;
      if (e[0][1] === "each" && e[1][0] === "(") {
        this.each(e);
        return;
      }
      if (cf(s)) {
        this.mixin(e);
        return;
      }
      super.unknownWord(e);
    }
  };
});
var Ro2 = g2((lx, Po2) => {
  var df = Yt2();
  Po2.exports = class extends df {
    atrule(e, s) {
      if (!e.mixin && !e.variable && !e.function) {
        super.atrule(e, s);
        return;
      }
      let n = `${e.function ? "" : e.raws.identifier || "@"}${e.name}`, i = e.params ? this.rawValue(e, "params") : "", o = e.raws.important || "";
      if (e.variable && (i = e.value), typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes) this.block(e, n + i + o);
      else {
        let u = (e.raws.between || "") + o + (s ? ";" : "");
        this.builder(n + i + u, e);
      }
    }
    comment(e) {
      if (e.inline) {
        let s = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
        this.builder(`//${s}${e.text}${r}`, e);
      } else super.comment(e);
    }
  };
});
var Io2 = g2((cx, xs) => {
  var mf = De2(), yf = No2(), gf = Ro2();
  xs.exports = { parse(t, e) {
    let s = new mf(t, e), r = new yf(s);
    return r.parse(), r.root.walk((n) => {
      let i = s.css.lastIndexOf(n.source.input.css);
      if (i === 0) return;
      if (i + n.source.input.css.length !== s.css.length) throw new Error("Invalid state detected in postcss-less");
      let o = i + n.source.start.offset, u = s.fromOffset(i + n.source.start.offset);
      if (n.source.start = { offset: o, line: u.line, column: u.col }, n.source.end) {
        let a = i + n.source.end.offset, c = s.fromOffset(i + n.source.end.offset);
        n.source.end = { offset: a, line: c.line, column: c.col };
      }
    }), r.root;
  }, stringify(t, e) {
    new gf(e).stringify(t);
  }, nodeToString(t) {
    let e = "";
    return xs.exports.stringify(t, (s) => {
      e += s;
    }), e;
  } };
});
var er2 = g2((fx, Do2) => {
  "use strict";
  var wf = le2(), qo2, Lo, ge2 = class extends wf {
    constructor(e) {
      super({ type: "document", ...e }), this.nodes || (this.nodes = []);
    }
    toResult(e = {}) {
      return new qo2(new Lo(), this, e).stringify();
    }
  };
  ge2.registerLazyResult = (t) => {
    qo2 = t;
  };
  ge2.registerProcessor = (t) => {
    Lo = t;
  };
  Do2.exports = ge2;
  ge2.default = ge2;
});
var Bo2 = g2((px, Mo2) => {
  "use strict";
  var vf = Ht2(), xf = qe2(), bf = mt2(), _f = De2(), Ef = ps(), kf = Be(), Sf = jt2();
  function wt2(t, e) {
    if (Array.isArray(t)) return t.map((n) => wt2(n));
    let { inputs: s, ...r } = t;
    if (s) {
      e = [];
      for (let n of s) {
        let i = { ...n, __proto__: _f.prototype };
        i.map && (i.map = { ...i.map, __proto__: Ef.prototype }), e.push(i);
      }
    }
    if (r.nodes && (r.nodes = t.nodes.map((n) => wt2(n, e))), r.source) {
      let { inputId: n, ...i } = r.source;
      r.source = i, n != null && (r.source.input = e[n]);
    }
    if (r.type === "root") return new kf(r);
    if (r.type === "decl") return new bf(r);
    if (r.type === "rule") return new Sf(r);
    if (r.type === "comment") return new xf(r);
    if (r.type === "atrule") return new vf(r);
    throw new Error("Unknown node type: " + t.type);
  }
  Mo2.exports = wt2;
  wt2.default = wt2;
});
var bs = g2((hx, Uo2) => {
  Uo2.exports = class {
    generate() {
    }
  };
});
var _s = g2((mx, Fo2) => {
  "use strict";
  var vt2 = class {
    constructor(e, s = {}) {
      if (this.type = "warning", this.text = e, s.node && s.node.source) {
        let r = s.node.rangeBy(s);
        this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
      }
      for (let r in s) this[r] = s[r];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  Fo2.exports = vt2;
  vt2.default = vt2;
});
var tr2 = g2((yx, $o2) => {
  "use strict";
  var Tf = _s(), xt2 = class {
    get content() {
      return this.css;
    }
    constructor(e, s, r) {
      this.processor = e, this.messages = [], this.root = s, this.opts = r, this.css = "", this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(e, s = {}) {
      s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
      let r = new Tf(e, s);
      return this.messages.push(r), r;
    }
    warnings() {
      return this.messages.filter((e) => e.type === "warning");
    }
  };
  $o2.exports = xt2;
  xt2.default = xt2;
});
var Es = g2((gx, Go2) => {
  "use strict";
  var Wo2 = {};
  Go2.exports = function(e) {
    Wo2[e] || (Wo2[e] = true, typeof console < "u" && console.warn && console.warn(e));
  };
});
var Ts = g2((vx, Ho2) => {
  "use strict";
  var Of = le2(), Cf = er2(), Af = bs(), Nf = gt2(), Yo2 = tr2(), Pf = Be(), Rf = lt(), { isClean: K2, my: If } = Vt2(), wx = Es(), qf = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, Lf = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, Df = { Once: true, postcssPlugin: true, prepare: true }, Fe2 = 0;
  function bt2(t) {
    return typeof t == "object" && typeof t.then == "function";
  }
  function zo2(t) {
    let e = false, s = qf[t.type];
    return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [s, s + "-" + e, Fe2, s + "Exit", s + "Exit-" + e] : e ? [s, s + "-" + e, s + "Exit", s + "Exit-" + e] : t.append ? [s, Fe2, s + "Exit"] : [s, s + "Exit"];
  }
  function Vo2(t) {
    let e;
    return t.type === "document" ? e = ["Document", Fe2, "DocumentExit"] : t.type === "root" ? e = ["Root", Fe2, "RootExit"] : e = zo2(t), { eventIndex: 0, events: e, iterator: 0, node: t, visitorIndex: 0, visitors: [] };
  }
  function ks(t) {
    return t[K2] = false, t.nodes && t.nodes.forEach((e) => ks(e)), t;
  }
  var Ss = {}, fe2 = class t {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(e, s, r) {
      this.stringified = false, this.processed = false;
      let n;
      if (typeof s == "object" && s !== null && (s.type === "root" || s.type === "document")) n = ks(s);
      else if (s instanceof t || s instanceof Yo2) n = ks(s.root), s.map && (typeof r.map > "u" && (r.map = {}), r.map.inline || (r.map.inline = false), r.map.prev = s.map);
      else {
        let i = Nf;
        r.syntax && (i = r.syntax.parse), r.parser && (i = r.parser), i.parse && (i = i.parse);
        try {
          n = i(s, r);
        } catch (o) {
          this.processed = true, this.error = o;
        }
        n && !n[If] && Of.rebuild(n);
      }
      this.result = new Yo2(e, n, r), this.helpers = { ...Ss, postcss: Ss, result: this.result }, this.plugins = this.processor.plugins.map((i) => typeof i == "object" && i.prepare ? { ...i, ...i.prepare(this.result) } : i);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e, s) {
      let r = this.result.lastPlugin;
      try {
        s && s.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = r.postcssPlugin, e.setMessage()) : r.postcssVersion;
      } catch (n) {
        console && console.error && console.error(n);
      }
      return e;
    }
    prepareVisitors() {
      this.listeners = {};
      let e = (s, r, n) => {
        this.listeners[r] || (this.listeners[r] = []), this.listeners[r].push([s, n]);
      };
      for (let s of this.plugins) if (typeof s == "object") for (let r in s) {
        if (!Lf[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${s.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
        if (!Df[r]) if (typeof s[r] == "object") for (let n in s[r]) n === "*" ? e(s, r, s[r][n]) : e(s, r + "-" + n.toLowerCase(), s[r][n]);
        else typeof s[r] == "function" && e(s, r, s[r]);
      }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e = 0; e < this.plugins.length; e++) {
        let s = this.plugins[e], r = this.runOnRoot(s);
        if (bt2(r)) try {
          await r;
        } catch (n) {
          throw this.handleError(n);
        }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[K2]; ) {
          e[K2] = true;
          let s = [Vo2(e)];
          for (; s.length > 0; ) {
            let r = this.visitTick(s);
            if (bt2(r)) try {
              await r;
            } catch (n) {
              let i = s[s.length - 1].node;
              throw this.handleError(n, i);
            }
          }
        }
        if (this.listeners.OnceExit) for (let [s, r] of this.listeners.OnceExit) {
          this.result.lastPlugin = s;
          try {
            if (e.type === "document") {
              let n = e.nodes.map((i) => r(i, this.helpers));
              await Promise.all(n);
            } else await r(e, this.helpers);
          } catch (n) {
            throw this.handleError(n);
          }
        }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e) {
      this.result.lastPlugin = e;
      try {
        if (typeof e == "object" && e.Once) {
          if (this.result.root.type === "document") {
            let s = this.result.root.nodes.map((r) => e.Once(r, this.helpers));
            return bt2(s[0]) ? Promise.all(s) : s;
          }
          return e.Once(this.result.root, this.helpers);
        } else if (typeof e == "function") return e(this.result.root, this.result);
      } catch (s) {
        throw this.handleError(s);
      }
    }
    stringify() {
      if (this.error) throw this.error;
      if (this.stringified) return this.result;
      this.stringified = true, this.sync();
      let e = this.result.opts, s = Rf;
      e.syntax && (s = e.syntax.stringify), e.stringifier && (s = e.stringifier), s.stringify && (s = s.stringify);
      let n = new Af(s, this.result.root, this.result.opts).generate();
      return this.result.css = n[0], this.result.map = n[1], this.result;
    }
    sync() {
      if (this.error) throw this.error;
      if (this.processed) return this.result;
      if (this.processed = true, this.processing) throw this.getAsyncError();
      for (let e of this.plugins) {
        let s = this.runOnRoot(e);
        if (bt2(s)) throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (; !e[K2]; ) e[K2] = true, this.walkSync(e);
        if (this.listeners.OnceExit) if (e.type === "document") for (let s of e.nodes) this.visitSync(this.listeners.OnceExit, s);
        else this.visitSync(this.listeners.OnceExit, e);
      }
      return this.result;
    }
    then(e, s) {
      return this.async().then(e, s);
    }
    toString() {
      return this.css;
    }
    visitSync(e, s) {
      for (let [r, n] of e) {
        this.result.lastPlugin = r;
        let i;
        try {
          i = n(s, this.helpers);
        } catch (o) {
          throw this.handleError(o, s.proxyOf);
        }
        if (s.type !== "root" && s.type !== "document" && !s.parent) return true;
        if (bt2(i)) throw this.getAsyncError();
      }
    }
    visitTick(e) {
      let s = e[e.length - 1], { node: r, visitors: n } = s;
      if (r.type !== "root" && r.type !== "document" && !r.parent) {
        e.pop();
        return;
      }
      if (n.length > 0 && s.visitorIndex < n.length) {
        let [o, u] = n[s.visitorIndex];
        s.visitorIndex += 1, s.visitorIndex === n.length && (s.visitors = [], s.visitorIndex = 0), this.result.lastPlugin = o;
        try {
          return u(r.toProxy(), this.helpers);
        } catch (a) {
          throw this.handleError(a, r);
        }
      }
      if (s.iterator !== 0) {
        let o = s.iterator, u;
        for (; u = r.nodes[r.indexes[o]]; ) if (r.indexes[o] += 1, !u[K2]) {
          u[K2] = true, e.push(Vo2(u));
          return;
        }
        s.iterator = 0, delete r.indexes[o];
      }
      let i = s.events;
      for (; s.eventIndex < i.length; ) {
        let o = i[s.eventIndex];
        if (s.eventIndex += 1, o === Fe2) {
          r.nodes && r.nodes.length && (r[K2] = true, s.iterator = r.getIterator());
          return;
        } else if (this.listeners[o]) {
          s.visitors = this.listeners[o];
          return;
        }
      }
      e.pop();
    }
    walkSync(e) {
      e[K2] = true;
      let s = zo2(e);
      for (let r of s) if (r === Fe2) e.nodes && e.each((n) => {
        n[K2] || this.walkSync(n);
      });
      else {
        let n = this.listeners[r];
        if (n && this.visitSync(n, e.toProxy())) return;
      }
    }
    warnings() {
      return this.sync().warnings();
    }
  };
  fe2.registerPostcss = (t) => {
    Ss = t;
  };
  Ho2.exports = fe2;
  fe2.default = fe2;
  Pf.registerLazyResult(fe2);
  Cf.registerLazyResult(fe2);
});
var Ko2 = g2((bx, jo2) => {
  "use strict";
  var Mf = bs(), Bf = gt2(), Uf = tr2(), Ff = lt(), xx = Es(), _t2 = class {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root) return this._root;
      let e, s = Bf;
      try {
        e = s(this._css, this._opts);
      } catch (r) {
        this.error = r;
      }
      if (this.error) throw this.error;
      return this._root = e, e;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(e, s, r) {
      s = s.toString(), this.stringified = false, this._processor = e, this._css = s, this._opts = r, this._map = void 0;
      let n, i = Ff;
      this.result = new Uf(this._processor, n, this._opts), this.result.css = s;
      let o = this;
      Object.defineProperty(this.result, "root", { get() {
        return o.root;
      } });
      let u = new Mf(i, n, this._opts, s);
      if (u.isMap()) {
        let [a, c] = u.generate();
        a && (this.result.css = a), c && (this.result.map = c);
      } else u.clearAnnotation(), this.result.css = u.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    sync() {
      if (this.error) throw this.error;
      return this.result;
    }
    then(e, s) {
      return this.async().then(e, s);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  };
  jo2.exports = _t2;
  _t2.default = _t2;
});
var Xo2 = g2((_x, Qo2) => {
  "use strict";
  var $f = er2(), Wf = Ts(), Gf = Ko2(), Yf = Be(), we2 = class {
    constructor(e = []) {
      this.version = "8.5.6", this.plugins = this.normalize(e);
    }
    normalize(e) {
      let s = [];
      for (let r of e) if (r.postcss === true ? r = r() : r.postcss && (r = r.postcss), typeof r == "object" && Array.isArray(r.plugins)) s = s.concat(r.plugins);
      else if (typeof r == "object" && r.postcssPlugin) s.push(r);
      else if (typeof r == "function") s.push(r);
      else if (!(typeof r == "object" && (r.parse || r.stringify))) throw new Error(r + " is not a PostCSS plugin");
      return s;
    }
    process(e, s = {}) {
      return !this.plugins.length && !s.parser && !s.stringifier && !s.syntax ? new Gf(this, e, s) : new Wf(this, e, s);
    }
    use(e) {
      return this.plugins = this.plugins.concat(this.normalize([e])), this;
    }
  };
  Qo2.exports = we2;
  we2.default = we2;
  Yf.registerProcessor(we2);
  $f.registerProcessor(we2);
});
var rr2 = g2((Ex, na) => {
  "use strict";
  var Jo2 = Ht2(), Zo2 = qe2(), Vf = le2(), zf = Gt2(), ea = mt2(), ta = er2(), Hf = Bo2(), jf = De2(), Kf = Ts(), Qf = gs(), Xf = pt2(), Jf = gt2(), Os = Xo2(), Zf = tr2(), ra = Be(), sa = jt2(), ep = lt(), tp = _s();
  function k2(...t) {
    return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new Os(t);
  }
  k2.plugin = function(e, s) {
    let r = false;
    function n(...o) {
      console && console.warn && !r && (r = true, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
      let u = s(...o);
      return u.postcssPlugin = e, u.postcssVersion = new Os().version, u;
    }
    let i;
    return Object.defineProperty(n, "postcss", { get() {
      return i || (i = n()), i;
    } }), n.process = function(o, u, a) {
      return k2([n(a)]).process(o, u);
    }, n;
  };
  k2.stringify = ep;
  k2.parse = Jf;
  k2.fromJSON = Hf;
  k2.list = Qf;
  k2.comment = (t) => new Zo2(t);
  k2.atRule = (t) => new Jo2(t);
  k2.decl = (t) => new ea(t);
  k2.rule = (t) => new sa(t);
  k2.root = (t) => new ra(t);
  k2.document = (t) => new ta(t);
  k2.CssSyntaxError = zf;
  k2.Declaration = ea;
  k2.Container = Vf;
  k2.Processor = Os;
  k2.Document = ta;
  k2.Comment = Zo2;
  k2.Warning = tp;
  k2.AtRule = Jo2;
  k2.Result = Zf;
  k2.Input = jf;
  k2.Rule = sa;
  k2.Root = ra;
  k2.Node = Xf;
  Kf.registerPostcss(k2);
  na.exports = k2;
  k2.default = k2;
});
var oa = g2((kx, ia) => {
  var { Container: rp } = rr2(), Cs = class extends rp {
    constructor(e) {
      super(e), this.type = "decl", this.isNested = true, this.nodes || (this.nodes = []);
    }
  };
  ia.exports = Cs;
});
var la = g2((Sx, ua) => {
  "use strict";
  var sr2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, nr2 = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, sp = /.[\r\n"'(/\\]/, aa = /[\da-f]/i, ir2 = /[\n\f\r]/g;
  ua.exports = function(e, s = {}) {
    let r = e.css.valueOf(), n = s.ignoreErrors, i, o, u, a, c, f, p, l, d, x = r.length, h = 0, m = [], y2 = [], b2;
    function w2() {
      return h;
    }
    function v2(T2) {
      throw e.error("Unclosed " + T2, h);
    }
    function R2() {
      return y2.length === 0 && h >= x;
    }
    function F() {
      let T2 = 1, O2 = false, C = false;
      for (; T2 > 0; ) o += 1, r.length <= o && v2("interpolation"), i = r.charCodeAt(o), l = r.charCodeAt(o + 1), O2 ? !C && i === O2 ? (O2 = false, C = false) : i === 92 ? C = !C : C && (C = false) : i === 39 || i === 34 ? O2 = i : i === 125 ? T2 -= 1 : i === 35 && l === 123 && (T2 += 1);
    }
    function Q2(T2) {
      if (y2.length) return y2.pop();
      if (h >= x) return;
      let O2 = T2 ? T2.ignoreUnclosed : false;
      switch (i = r.charCodeAt(h), i) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          o = h;
          do
            o += 1, i = r.charCodeAt(o);
          while (i === 32 || i === 10 || i === 9 || i === 13 || i === 12);
          d = ["space", r.slice(h, o)], h = o - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let C = String.fromCharCode(i);
          d = [C, C, h];
          break;
        }
        case 44: {
          d = ["word", ",", h, h + 1];
          break;
        }
        case 40: {
          if (p = m.length ? m.pop()[1] : "", l = r.charCodeAt(h + 1), p === "url" && l !== 39 && l !== 34) {
            for (b2 = 1, f = false, o = h + 1; o <= r.length - 1; ) {
              if (l = r.charCodeAt(o), l === 92) f = !f;
              else if (l === 40) b2 += 1;
              else if (l === 41 && (b2 -= 1, b2 === 0)) break;
              o += 1;
            }
            a = r.slice(h, o + 1), d = ["brackets", a, h, o], h = o;
          } else o = r.indexOf(")", h + 1), a = r.slice(h, o + 1), o === -1 || sp.test(a) ? d = ["(", "(", h] : (d = ["brackets", a, h, o], h = o);
          break;
        }
        case 39:
        case 34: {
          for (u = i, o = h, f = false; o < x && (o++, o === x && v2("string"), i = r.charCodeAt(o), l = r.charCodeAt(o + 1), !(!f && i === u)); ) i === 92 ? f = !f : f ? f = false : i === 35 && l === 123 && F();
          d = ["string", r.slice(h, o + 1), h, o], h = o;
          break;
        }
        case 64: {
          sr2.lastIndex = h + 1, sr2.test(r), sr2.lastIndex === 0 ? o = r.length - 1 : o = sr2.lastIndex - 2, d = ["at-word", r.slice(h, o + 1), h, o], h = o;
          break;
        }
        case 92: {
          for (o = h, c = true; r.charCodeAt(o + 1) === 92; ) o += 1, c = !c;
          if (i = r.charCodeAt(o + 1), c && i !== 47 && i !== 32 && i !== 10 && i !== 9 && i !== 13 && i !== 12 && (o += 1, aa.test(r.charAt(o)))) {
            for (; aa.test(r.charAt(o + 1)); ) o += 1;
            r.charCodeAt(o + 1) === 32 && (o += 1);
          }
          d = ["word", r.slice(h, o + 1), h, o], h = o;
          break;
        }
        default:
          l = r.charCodeAt(h + 1), i === 35 && l === 123 ? (o = h, F(), a = r.slice(h, o + 1), d = ["word", a, h, o], h = o) : i === 47 && l === 42 ? (o = r.indexOf("*/", h + 2) + 1, o === 0 && (n || O2 ? o = r.length : v2("comment")), d = ["comment", r.slice(h, o + 1), h, o], h = o) : i === 47 && l === 47 ? (ir2.lastIndex = h + 1, ir2.test(r), ir2.lastIndex === 0 ? o = r.length - 1 : o = ir2.lastIndex - 2, a = r.slice(h, o + 1), d = ["comment", a, h, o, "inline"], h = o) : (nr2.lastIndex = h + 1, nr2.test(r), nr2.lastIndex === 0 ? o = r.length - 1 : o = nr2.lastIndex - 2, d = ["word", r.slice(h, o + 1), h, o], m.push(d), h = o);
          break;
      }
      return h++, d;
    }
    function W2(T2) {
      y2.push(T2);
    }
    return { back: W2, endOfFile: R2, nextToken: Q2, position: w2 };
  };
});
var fa = g2((Tx, ca) => {
  var { Comment: np } = rr2(), ip = Jt2(), op = oa(), ap = la(), As = class extends ip {
    atrule(e) {
      let s = e[1], r = e;
      for (; !this.tokenizer.endOfFile(); ) {
        let n = this.tokenizer.nextToken();
        if (n[0] === "word" && n[2] === r[3] + 1) s += n[1], r = n;
        else {
          this.tokenizer.back(n);
          break;
        }
      }
      super.atrule(["at-word", s, e[2], r[3]]);
    }
    comment(e) {
      if (e[4] === "inline") {
        let s = new np();
        this.init(s, e[2]), s.raws.inline = true;
        let r = this.input.fromOffset(e[3]);
        s.source.end = { column: r.col, line: r.line, offset: e[3] + 1 };
        let n = e[1].slice(2);
        if (/^\s*$/.test(n)) s.text = "", s.raws.left = n, s.raws.right = "";
        else {
          let i = n.match(/^(\s*)([^]*\S)(\s*)$/), o = i[2].replace(/(\*\/|\/\*)/g, "*//*");
          s.text = o, s.raws.left = i[1], s.raws.right = i[3], s.raws.text = i[2];
        }
      } else super.comment(e);
    }
    createTokenizer() {
      this.tokenizer = ap(this.input);
    }
    raw(e, s, r, n) {
      if (super.raw(e, s, r, n), e.raws[s]) {
        let i = e.raws[s].raw;
        e.raws[s].raw = r.reduce((o, u) => {
          if (u[0] === "comment" && u[4] === "inline") {
            let a = u[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return o + "/*" + a + "*/";
          } else return o + u[1];
        }, ""), i !== e.raws[s].raw && (e.raws[s].scss = i);
      }
    }
    rule(e) {
      let s = false, r = 0, n = "";
      for (let i of e) if (s) i[0] !== "comment" && i[0] !== "{" && (n += i[1]);
      else {
        if (i[0] === "space" && i[1].includes(`
`)) break;
        i[0] === "(" ? r += 1 : i[0] === ")" ? r -= 1 : r === 0 && i[0] === ":" && (s = true);
      }
      if (!s || n.trim() === "" || /^[#:A-Za-z-]/.test(n)) super.rule(e);
      else {
        e.pop();
        let i = new op();
        this.init(i, e[0][2]);
        let o;
        for (let a = e.length - 1; a >= 0; a--) if (e[a][0] !== "space") {
          o = e[a];
          break;
        }
        if (o[3]) {
          let a = this.input.fromOffset(o[3]);
          i.source.end = { column: a.col, line: a.line, offset: o[3] + 1 };
        } else {
          let a = this.input.fromOffset(o[2]);
          i.source.end = { column: a.col, line: a.line, offset: o[2] + 1 };
        }
        for (; e[0][0] !== "word"; ) i.raws.before += e.shift()[1];
        if (e[0][2]) {
          let a = this.input.fromOffset(e[0][2]);
          i.source.start = { column: a.col, line: a.line, offset: e[0][2] };
        }
        for (i.prop = ""; e.length; ) {
          let a = e[0][0];
          if (a === ":" || a === "space" || a === "comment") break;
          i.prop += e.shift()[1];
        }
        i.raws.between = "";
        let u;
        for (; e.length; ) if (u = e.shift(), u[0] === ":") {
          i.raws.between += u[1];
          break;
        } else i.raws.between += u[1];
        (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1)), i.raws.between += this.spacesAndCommentsFromStart(e), this.precheckMissedSemicolon(e);
        for (let a = e.length - 1; a > 0; a--) {
          if (u = e[a], u[1] === "!important") {
            i.important = true;
            let c = this.stringFrom(e, a);
            c = this.spacesFromEnd(e) + c, c !== " !important" && (i.raws.important = c);
            break;
          } else if (u[1] === "important") {
            let c = e.slice(0), f = "";
            for (let p = a; p > 0; p--) {
              let l = c[p][0];
              if (f.trim().indexOf("!") === 0 && l !== "space") break;
              f = c.pop()[1] + f;
            }
            f.trim().indexOf("!") === 0 && (i.important = true, i.raws.important = f, e = c);
          }
          if (u[0] !== "space" && u[0] !== "comment") break;
        }
        this.raw(i, "value", e), i.value.includes(":") && this.checkMissedSemicolon(e), this.current = i;
      }
    }
  };
  ca.exports = As;
});
var ha = g2((Ox, pa) => {
  var { Input: up } = rr2(), lp = fa();
  pa.exports = function(e, s) {
    let r = new up(e, s), n = new lp(r);
    return n.parse(), n.root;
  };
});
var Ps = g2((Ns) => {
  "use strict";
  Object.defineProperty(Ns, "__esModule", { value: true });
  function fp(t) {
    this.after = t.after, this.before = t.before, this.type = t.type, this.value = t.value, this.sourceIndex = t.sourceIndex;
  }
  Ns.default = fp;
});
var Is = g2((Rs) => {
  "use strict";
  Object.defineProperty(Rs, "__esModule", { value: true });
  var pp = Ps(), ma = hp(pp);
  function hp(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Et2(t) {
    var e = this;
    this.constructor(t), this.nodes = t.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(s) {
      s.parent = e;
    });
  }
  Et2.prototype = Object.create(ma.default.prototype);
  Et2.constructor = ma.default;
  Et2.prototype.walk = function(e, s) {
    for (var r = typeof e == "string" || e instanceof RegExp, n = r ? s : e, i = typeof e == "string" ? new RegExp(e) : e, o = 0; o < this.nodes.length; o++) {
      var u = this.nodes[o], a = r ? i.test(u.type) : true;
      if (a && n && n(u, o, this.nodes) === false || u.nodes && u.walk(e, s) === false) return false;
    }
    return true;
  };
  Et2.prototype.each = function() {
    for (var e = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], s = 0; s < this.nodes.length; s++) {
      var r = this.nodes[s];
      if (e(r, s, this.nodes) === false) return false;
    }
    return true;
  };
  Rs.default = Et2;
});
var va = g2((kt2) => {
  "use strict";
  Object.defineProperty(kt2, "__esModule", { value: true });
  kt2.parseMediaFeature = wa;
  kt2.parseMediaQuery = Ls;
  kt2.parseMediaList = yp;
  var dp = Ps(), ya = ga(dp), mp = Is(), qs = ga(mp);
  function ga(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function wa(t) {
    var e = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], s = [{ mode: "normal", character: null }], r = [], n = 0, i = "", o = null, u = null, a = e, c = t;
    t[0] === "(" && t[t.length - 1] === ")" && (c = t.substring(1, t.length - 1), a++);
    for (var f = 0; f < c.length; f++) {
      var p = c[f];
      if ((p === "'" || p === '"') && (s[n].isCalculationEnabled === true ? (s.push({ mode: "string", isCalculationEnabled: false, character: p }), n++) : s[n].mode === "string" && s[n].character === p && c[f - 1] !== "\\" && (s.pop(), n--)), p === "{" ? (s.push({ mode: "interpolation", isCalculationEnabled: true }), n++) : p === "}" && (s.pop(), n--), s[n].mode === "normal" && p === ":") {
        var l = c.substring(f + 1);
        u = { type: "value", before: /^(\s*)/.exec(l)[1], after: /(\s*)$/.exec(l)[1], value: l.trim() }, u.sourceIndex = u.before.length + f + 1 + a, o = { type: "colon", sourceIndex: f + a, after: u.before, value: ":" };
        break;
      }
      i += p;
    }
    return i = { type: "media-feature", before: /^(\s*)/.exec(i)[1], after: /(\s*)$/.exec(i)[1], value: i.trim() }, i.sourceIndex = i.before.length + a, r.push(i), o !== null && (o.before = i.after, r.push(o)), u !== null && r.push(u), r;
  }
  function Ls(t) {
    var e = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], s = [], r = 0, n = false, i = void 0;
    function o() {
      return { before: "", after: "", value: "" };
    }
    i = o();
    for (var u = 0; u < t.length; u++) {
      var a = t[u];
      n ? (i.value += a, (a === "{" || a === "(") && r++, (a === ")" || a === "}") && r--) : a.search(/\s/) !== -1 ? i.before += a : (a === "(" && (i.type = "media-feature-expression", r++), i.value = a, i.sourceIndex = e + u, n = true), n && r === 0 && (a === ")" || u === t.length - 1 || t[u + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(i.value) !== -1 && (i.type = "keyword"), i.type === "media-feature-expression" && (i.nodes = wa(i.value, i.sourceIndex)), s.push(Array.isArray(i.nodes) ? new qs.default(i) : new ya.default(i)), i = o(), n = false);
    }
    for (var c = 0; c < s.length; c++) if (i = s[c], c > 0 && (s[c - 1].after = i.before), i.type === void 0) {
      if (c > 0) {
        if (s[c - 1].type === "media-feature-expression") {
          i.type = "keyword";
          continue;
        }
        if (s[c - 1].value === "not" || s[c - 1].value === "only") {
          i.type = "media-type";
          continue;
        }
        if (s[c - 1].value === "and") {
          i.type = "media-feature-expression";
          continue;
        }
        s[c - 1].type === "media-type" && (s[c + 1] ? i.type = s[c + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : i.type = "media-feature-expression");
      }
      if (c === 0) {
        if (!s[c + 1]) {
          i.type = "media-type";
          continue;
        }
        if (s[c + 1] && (s[c + 1].type === "media-feature-expression" || s[c + 1].type === "keyword")) {
          i.type = "media-type";
          continue;
        }
        if (s[c + 2]) {
          if (s[c + 2].type === "media-feature-expression") {
            i.type = "media-type", s[c + 1].type = "keyword";
            continue;
          }
          if (s[c + 2].type === "keyword") {
            i.type = "keyword", s[c + 1].type = "media-type";
            continue;
          }
        }
        if (s[c + 3] && s[c + 3].type === "media-feature-expression") {
          i.type = "keyword", s[c + 1].type = "media-type", s[c + 2].type = "keyword";
          continue;
        }
      }
    }
    return s;
  }
  function yp(t) {
    var e = [], s = 0, r = 0, n = /^(\s*)url\s*\(/.exec(t);
    if (n !== null) {
      for (var i = n[0].length, o = 1; o > 0; ) {
        var u = t[i];
        u === "(" && o++, u === ")" && o--, i++;
      }
      e.unshift(new ya.default({ type: "url", value: t.substring(0, i).trim(), sourceIndex: n[1].length, before: n[1], after: /^(\s*)/.exec(t.substring(i))[1] })), s = i;
    }
    for (var a = s; a < t.length; a++) {
      var c = t[a];
      if (c === "(" && r++, c === ")" && r--, r === 0 && c === ",") {
        var f = t.substring(s, a), p = /^(\s*)/.exec(f)[1];
        e.push(new qs.default({ type: "media-query", value: f.trim(), sourceIndex: s + p.length, nodes: Ls(f, s), before: p, after: /(\s*)$/.exec(f)[1] })), s = a + 1;
      }
    }
    var l = t.substring(s), d = /^(\s*)/.exec(l)[1];
    return e.push(new qs.default({ type: "media-query", value: l.trim(), sourceIndex: s + d.length, nodes: Ls(l, s), before: d, after: /(\s*)$/.exec(l)[1] })), e;
  }
});
var xa = g2((Ds) => {
  "use strict";
  Object.defineProperty(Ds, "__esModule", { value: true });
  Ds.default = bp;
  var gp = Is(), wp = xp(gp), vp = va();
  function xp(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function bp(t) {
    return new wp.default({ nodes: (0, vp.parseMediaList)(t), type: "media-query-list", value: t.trim() });
  }
});
var Bs = g2((Dx, Ea) => {
  Ea.exports = function(e, s) {
    if (s = typeof s == "number" ? s : 1 / 0, !s) return Array.isArray(e) ? e.map(function(n) {
      return n;
    }) : e;
    return r(e, 1);
    function r(n, i) {
      return n.reduce(function(o, u) {
        return Array.isArray(u) && i < s ? o.concat(r(u, i + 1)) : o.concat(u);
      }, []);
    }
  };
});
var Us = g2((Mx, ka) => {
  ka.exports = function(t, e) {
    for (var s = -1, r = []; (s = t.indexOf(e, s + 1)) !== -1; ) r.push(s);
    return r;
  };
});
var Fs = g2((Bx, Sa) => {
  "use strict";
  function kp(t, e) {
    for (var s = 1, r = t.length, n = t[0], i = t[0], o = 1; o < r; ++o) if (i = n, n = t[o], e(n, i)) {
      if (o === s) {
        s++;
        continue;
      }
      t[s++] = n;
    }
    return t.length = s, t;
  }
  function Sp(t) {
    for (var e = 1, s = t.length, r = t[0], n = t[0], i = 1; i < s; ++i, n = r) if (n = r, r = t[i], r !== n) {
      if (i === e) {
        e++;
        continue;
      }
      t[e++] = r;
    }
    return t.length = e, t;
  }
  function Tp(t, e, s) {
    return t.length === 0 ? t : e ? (s || t.sort(e), kp(t, e)) : (s || t.sort(), Sp(t));
  }
  Sa.exports = Tp;
});
var ve2 = g2((or2, Oa) => {
  "use strict";
  or2.__esModule = true;
  var Ta = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  };
  function Op(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  var Cp = function t(e, s) {
    if ((typeof e > "u" ? "undefined" : Ta(e)) !== "object") return e;
    var r = new e.constructor();
    for (var n in e) if (e.hasOwnProperty(n)) {
      var i = e[n], o = typeof i > "u" ? "undefined" : Ta(i);
      n === "parent" && o === "object" ? s && (r[n] = s) : i instanceof Array ? r[n] = i.map(function(u) {
        return t(u, r);
      }) : r[n] = t(i, r);
    }
    return r;
  }, Ap = function() {
    function t() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Op(this, t);
      for (var s in e) this[s] = e[s];
      var r = e.spaces;
      r = r === void 0 ? {} : r;
      var n = r.before, i = n === void 0 ? "" : n, o = r.after, u = o === void 0 ? "" : o;
      this.spaces = { before: i, after: u };
    }
    return t.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, t.prototype.replaceWith = function() {
      if (this.parent) {
        for (var s in arguments) this.parent.insertBefore(this, arguments[s]);
        this.remove();
      }
      return this;
    }, t.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, t.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, t.prototype.clone = function() {
      var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = Cp(this);
      for (var n in s) r[n] = s[n];
      return r;
    }, t.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, t;
  }();
  or2.default = Ap;
  Oa.exports = or2.default;
});
var M2 = g2((B2) => {
  "use strict";
  B2.__esModule = true;
  var Ux = B2.TAG = "tag", Fx = B2.STRING = "string", $x = B2.SELECTOR = "selector", Wx = B2.ROOT = "root", Gx = B2.PSEUDO = "pseudo", Yx = B2.NESTING = "nesting", Vx = B2.ID = "id", zx = B2.COMMENT = "comment", Hx = B2.COMBINATOR = "combinator", jx = B2.CLASS = "class", Kx = B2.ATTRIBUTE = "attribute", Qx = B2.UNIVERSAL = "universal";
});
var ur2 = g2((ar2, Ca) => {
  "use strict";
  ar2.__esModule = true;
  var Np = /* @__PURE__ */ function() {
    function t(e, s) {
      for (var r = 0; r < s.length; r++) {
        var n = s[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    return function(e, s, r) {
      return s && t(e.prototype, s), r && t(e, r), e;
    };
  }(), Pp = ve2(), Rp = Lp(Pp), Ip = M2(), ee2 = qp(Ip);
  function qp(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null) for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    return e.default = t, e;
  }
  function Lp(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Dp(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Mp(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function Bp(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var Up = function(t) {
    Bp(e, t);
    function e(s) {
      Dp(this, e);
      var r = Mp(this, t.call(this, s));
      return r.nodes || (r.nodes = []), r;
    }
    return e.prototype.append = function(r) {
      return r.parent = this, this.nodes.push(r), this;
    }, e.prototype.prepend = function(r) {
      return r.parent = this, this.nodes.unshift(r), this;
    }, e.prototype.at = function(r) {
      return this.nodes[r];
    }, e.prototype.index = function(r) {
      return typeof r == "number" ? r : this.nodes.indexOf(r);
    }, e.prototype.removeChild = function(r) {
      r = this.index(r), this.at(r).parent = void 0, this.nodes.splice(r, 1);
      var n = void 0;
      for (var i in this.indexes) n = this.indexes[i], n >= r && (this.indexes[i] = n - 1);
      return this;
    }, e.prototype.removeAll = function() {
      for (var i = this.nodes, r = Array.isArray(i), n = 0, i = r ? i : i[Symbol.iterator](); ; ) {
        var o;
        if (r) {
          if (n >= i.length) break;
          o = i[n++];
        } else {
          if (n = i.next(), n.done) break;
          o = n.value;
        }
        var u = o;
        u.parent = void 0;
      }
      return this.nodes = [], this;
    }, e.prototype.empty = function() {
      return this.removeAll();
    }, e.prototype.insertAfter = function(r, n) {
      var i = this.index(r);
      this.nodes.splice(i + 1, 0, n);
      var o = void 0;
      for (var u in this.indexes) o = this.indexes[u], i <= o && (this.indexes[u] = o + this.nodes.length);
      return this;
    }, e.prototype.insertBefore = function(r, n) {
      var i = this.index(r);
      this.nodes.splice(i, 0, n);
      var o = void 0;
      for (var u in this.indexes) o = this.indexes[u], i <= o && (this.indexes[u] = o + this.nodes.length);
      return this;
    }, e.prototype.each = function(r) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var n = this.lastEach;
      if (this.indexes[n] = 0, !!this.length) {
        for (var i = void 0, o = void 0; this.indexes[n] < this.length && (i = this.indexes[n], o = r(this.at(i), i), o !== false); ) this.indexes[n] += 1;
        if (delete this.indexes[n], o === false) return false;
      }
    }, e.prototype.walk = function(r) {
      return this.each(function(n, i) {
        var o = r(n, i);
        if (o !== false && n.length && (o = n.walk(r)), o === false) return false;
      });
    }, e.prototype.walkAttributes = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.ATTRIBUTE) return r.call(n, i);
      });
    }, e.prototype.walkClasses = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.CLASS) return r.call(n, i);
      });
    }, e.prototype.walkCombinators = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.COMBINATOR) return r.call(n, i);
      });
    }, e.prototype.walkComments = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.COMMENT) return r.call(n, i);
      });
    }, e.prototype.walkIds = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.ID) return r.call(n, i);
      });
    }, e.prototype.walkNesting = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.NESTING) return r.call(n, i);
      });
    }, e.prototype.walkPseudos = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.PSEUDO) return r.call(n, i);
      });
    }, e.prototype.walkTags = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.TAG) return r.call(n, i);
      });
    }, e.prototype.walkUniversals = function(r) {
      var n = this;
      return this.walk(function(i) {
        if (i.type === ee2.UNIVERSAL) return r.call(n, i);
      });
    }, e.prototype.split = function(r) {
      var n = this, i = [];
      return this.reduce(function(o, u, a) {
        var c = r.call(n, u);
        return i.push(u), c ? (o.push(i), i = []) : a === n.length - 1 && o.push(i), o;
      }, []);
    }, e.prototype.map = function(r) {
      return this.nodes.map(r);
    }, e.prototype.reduce = function(r, n) {
      return this.nodes.reduce(r, n);
    }, e.prototype.every = function(r) {
      return this.nodes.every(r);
    }, e.prototype.some = function(r) {
      return this.nodes.some(r);
    }, e.prototype.filter = function(r) {
      return this.nodes.filter(r);
    }, e.prototype.sort = function(r) {
      return this.nodes.sort(r);
    }, e.prototype.toString = function() {
      return this.map(String).join("");
    }, Np(e, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), e;
  }(Rp.default);
  ar2.default = Up;
  Ca.exports = ar2.default;
});
var Na = g2((lr2, Aa) => {
  "use strict";
  lr2.__esModule = true;
  var Fp = ur2(), $p = Gp(Fp), Wp = M2();
  function Gp(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Yp(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Vp(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function zp(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var Hp = function(t) {
    zp(e, t);
    function e(s) {
      Yp(this, e);
      var r = Vp(this, t.call(this, s));
      return r.type = Wp.ROOT, r;
    }
    return e.prototype.toString = function() {
      var r = this.reduce(function(n, i) {
        var o = String(i);
        return o ? n + o + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? r + "," : r;
    }, e;
  }($p.default);
  lr2.default = Hp;
  Aa.exports = lr2.default;
});
var Ra = g2((cr2, Pa) => {
  "use strict";
  cr2.__esModule = true;
  var jp = ur2(), Kp = Xp(jp), Qp = M2();
  function Xp(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Jp(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Zp(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function eh(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var th = function(t) {
    eh(e, t);
    function e(s) {
      Jp(this, e);
      var r = Zp(this, t.call(this, s));
      return r.type = Qp.SELECTOR, r;
    }
    return e;
  }(Kp.default);
  cr2.default = th;
  Pa.exports = cr2.default;
});
var $e2 = g2((fr2, Ia) => {
  "use strict";
  fr2.__esModule = true;
  var rh = /* @__PURE__ */ function() {
    function t(e, s) {
      for (var r = 0; r < s.length; r++) {
        var n = s[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    return function(e, s, r) {
      return s && t(e.prototype, s), r && t(e, r), e;
    };
  }(), sh = ve2(), nh = ih(sh);
  function ih(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function oh(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function ah(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function uh(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var lh = function(t) {
    uh(e, t);
    function e() {
      return oh(this, e), ah(this, t.apply(this, arguments));
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, rh(e, [{ key: "ns", get: function() {
      var r = this.namespace;
      return r ? (typeof r == "string" ? r : "") + "|" : "";
    } }]), e;
  }(nh.default);
  fr2.default = lh;
  Ia.exports = fr2.default;
});
var La = g2((pr2, qa) => {
  "use strict";
  pr2.__esModule = true;
  var ch = $e2(), fh = hh(ch), ph = M2();
  function hh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function dh(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function mh(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function yh(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var gh = function(t) {
    yh(e, t);
    function e(s) {
      dh(this, e);
      var r = mh(this, t.call(this, s));
      return r.type = ph.CLASS, r;
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
    }, e;
  }(fh.default);
  pr2.default = gh;
  qa.exports = pr2.default;
});
var Ma = g2((hr2, Da) => {
  "use strict";
  hr2.__esModule = true;
  var wh = ve2(), vh = bh(wh), xh = M2();
  function bh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function _h(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Eh(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function kh(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var Sh = function(t) {
    kh(e, t);
    function e(s) {
      _h(this, e);
      var r = Eh(this, t.call(this, s));
      return r.type = xh.COMMENT, r;
    }
    return e;
  }(vh.default);
  hr2.default = Sh;
  Da.exports = hr2.default;
});
var Ua = g2((dr2, Ba) => {
  "use strict";
  dr2.__esModule = true;
  var Th = $e2(), Oh = Ah(Th), Ch = M2();
  function Ah(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Nh(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Ph(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function Rh(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var Ih = function(t) {
    Rh(e, t);
    function e(s) {
      Nh(this, e);
      var r = Ph(this, t.call(this, s));
      return r.type = Ch.ID, r;
    }
    return e.prototype.toString = function() {
      return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
    }, e;
  }(Oh.default);
  dr2.default = Ih;
  Ba.exports = dr2.default;
});
var $a = g2((mr2, Fa) => {
  "use strict";
  mr2.__esModule = true;
  var qh = $e2(), Lh = Mh(qh), Dh = M2();
  function Mh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Bh(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Uh(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function Fh(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var $h = function(t) {
    Fh(e, t);
    function e(s) {
      Bh(this, e);
      var r = Uh(this, t.call(this, s));
      return r.type = Dh.TAG, r;
    }
    return e;
  }(Lh.default);
  mr2.default = $h;
  Fa.exports = mr2.default;
});
var Ga = g2((yr2, Wa) => {
  "use strict";
  yr2.__esModule = true;
  var Wh = ve2(), Gh = Vh(Wh), Yh = M2();
  function Vh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function zh(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Hh(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function jh(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var Kh = function(t) {
    jh(e, t);
    function e(s) {
      zh(this, e);
      var r = Hh(this, t.call(this, s));
      return r.type = Yh.STRING, r;
    }
    return e;
  }(Gh.default);
  yr2.default = Kh;
  Wa.exports = yr2.default;
});
var Va = g2((gr2, Ya) => {
  "use strict";
  gr2.__esModule = true;
  var Qh = ur2(), Xh = Zh(Qh), Jh = M2();
  function Zh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function ed(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function td(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function rd(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var sd = function(t) {
    rd(e, t);
    function e(s) {
      ed(this, e);
      var r = td(this, t.call(this, s));
      return r.type = Jh.PSEUDO, r;
    }
    return e.prototype.toString = function() {
      var r = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), r, this.spaces.after].join("");
    }, e;
  }(Xh.default);
  gr2.default = sd;
  Ya.exports = gr2.default;
});
var Ha = g2((wr2, za) => {
  "use strict";
  wr2.__esModule = true;
  var nd = $e2(), id = ad(nd), od = M2();
  function ad(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function ud(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function ld(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function cd(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var fd = function(t) {
    cd(e, t);
    function e(s) {
      ud(this, e);
      var r = ld(this, t.call(this, s));
      return r.type = od.ATTRIBUTE, r.raws = {}, r;
    }
    return e.prototype.toString = function() {
      var r = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && r.push(this.operator), this.value && r.push(this.value), this.raws.insensitive ? r.push(this.raws.insensitive) : this.insensitive && r.push(" i"), r.push("]"), r.concat(this.spaces.after).join("");
    }, e;
  }(id.default);
  wr2.default = fd;
  za.exports = wr2.default;
});
var Ka = g2((vr2, ja) => {
  "use strict";
  vr2.__esModule = true;
  var pd = $e2(), hd = md(pd), dd = M2();
  function md(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function yd(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function gd(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function wd(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var vd = function(t) {
    wd(e, t);
    function e(s) {
      yd(this, e);
      var r = gd(this, t.call(this, s));
      return r.type = dd.UNIVERSAL, r.value = "*", r;
    }
    return e;
  }(hd.default);
  vr2.default = vd;
  ja.exports = vr2.default;
});
var Xa = g2((xr2, Qa) => {
  "use strict";
  xr2.__esModule = true;
  var xd = ve2(), bd = Ed(xd), _d = M2();
  function Ed(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function kd(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Sd(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function Td(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var Od = function(t) {
    Td(e, t);
    function e(s) {
      kd(this, e);
      var r = Sd(this, t.call(this, s));
      return r.type = _d.COMBINATOR, r;
    }
    return e;
  }(bd.default);
  xr2.default = Od;
  Qa.exports = xr2.default;
});
var Za = g2((br2, Ja) => {
  "use strict";
  br2.__esModule = true;
  var Cd = ve2(), Ad = Pd(Cd), Nd = M2();
  function Pd(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Rd(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function Id(t, e) {
    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : t;
  }
  function qd(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
  }
  var Ld = function(t) {
    qd(e, t);
    function e(s) {
      Rd(this, e);
      var r = Id(this, t.call(this, s));
      return r.type = Nd.NESTING, r.value = "&", r;
    }
    return e;
  }(Ad.default);
  br2.default = Ld;
  Ja.exports = br2.default;
});
var tu2 = g2((_r2, eu2) => {
  "use strict";
  _r2.__esModule = true;
  _r2.default = Dd;
  function Dd(t) {
    return t.sort(function(e, s) {
      return e - s;
    });
  }
  eu2.exports = _r2.default;
});
var cu2 = g2((Sr2, lu) => {
  "use strict";
  Sr2.__esModule = true;
  Sr2.default = Hd;
  var ru2 = 39, Md = 34, $s = 92, su2 = 47, St2 = 10, Ws = 32, Gs = 12, Ys = 9, Vs = 13, nu2 = 43, iu2 = 62, ou2 = 126, au2 = 124, Bd = 44, Ud = 40, Fd = 41, $d = 91, Wd = 93, Gd = 59, uu2 = 42, Yd = 58, Vd = 38, zd = 64, Er2 = /[ \n\t\r\{\(\)'"\\;/]/g, kr2 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function Hd(t) {
    for (var e = [], s = t.css.valueOf(), r = void 0, n = void 0, i = void 0, o = void 0, u = void 0, a = void 0, c = void 0, f = void 0, p = void 0, l = void 0, d = void 0, x = s.length, h = -1, m = 1, y2 = 0, b2 = function(v2, R2) {
      if (t.safe) s += R2, n = s.length - 1;
      else throw t.error("Unclosed " + v2, m, y2 - h, y2);
    }; y2 < x; ) {
      switch (r = s.charCodeAt(y2), r === St2 && (h = y2, m += 1), r) {
        case St2:
        case Ws:
        case Ys:
        case Vs:
        case Gs:
          n = y2;
          do
            n += 1, r = s.charCodeAt(n), r === St2 && (h = n, m += 1);
          while (r === Ws || r === St2 || r === Ys || r === Vs || r === Gs);
          e.push(["space", s.slice(y2, n), m, y2 - h, y2]), y2 = n - 1;
          break;
        case nu2:
        case iu2:
        case ou2:
        case au2:
          n = y2;
          do
            n += 1, r = s.charCodeAt(n);
          while (r === nu2 || r === iu2 || r === ou2 || r === au2);
          e.push(["combinator", s.slice(y2, n), m, y2 - h, y2]), y2 = n - 1;
          break;
        case uu2:
          e.push(["*", "*", m, y2 - h, y2]);
          break;
        case Vd:
          e.push(["&", "&", m, y2 - h, y2]);
          break;
        case Bd:
          e.push([",", ",", m, y2 - h, y2]);
          break;
        case $d:
          e.push(["[", "[", m, y2 - h, y2]);
          break;
        case Wd:
          e.push(["]", "]", m, y2 - h, y2]);
          break;
        case Yd:
          e.push([":", ":", m, y2 - h, y2]);
          break;
        case Gd:
          e.push([";", ";", m, y2 - h, y2]);
          break;
        case Ud:
          e.push(["(", "(", m, y2 - h, y2]);
          break;
        case Fd:
          e.push([")", ")", m, y2 - h, y2]);
          break;
        case ru2:
        case Md:
          i = r === ru2 ? "'" : '"', n = y2;
          do
            for (l = false, n = s.indexOf(i, n + 1), n === -1 && b2("quote", i), d = n; s.charCodeAt(d - 1) === $s; ) d -= 1, l = !l;
          while (l);
          e.push(["string", s.slice(y2, n + 1), m, y2 - h, m, n - h, y2]), y2 = n;
          break;
        case zd:
          Er2.lastIndex = y2 + 1, Er2.test(s), Er2.lastIndex === 0 ? n = s.length - 1 : n = Er2.lastIndex - 2, e.push(["at-word", s.slice(y2, n + 1), m, y2 - h, m, n - h, y2]), y2 = n;
          break;
        case $s:
          for (n = y2, c = true; s.charCodeAt(n + 1) === $s; ) n += 1, c = !c;
          r = s.charCodeAt(n + 1), c && r !== su2 && r !== Ws && r !== St2 && r !== Ys && r !== Vs && r !== Gs && (n += 1), e.push(["word", s.slice(y2, n + 1), m, y2 - h, m, n - h, y2]), y2 = n;
          break;
        default:
          r === su2 && s.charCodeAt(y2 + 1) === uu2 ? (n = s.indexOf("*/", y2 + 2) + 1, n === 0 && b2("comment", "*/"), a = s.slice(y2, n + 1), o = a.split(`
`), u = o.length - 1, u > 0 ? (f = m + u, p = n - o[u].length) : (f = m, p = h), e.push(["comment", a, m, y2 - h, f, n - p, y2]), h = p, m = f, y2 = n) : (kr2.lastIndex = y2 + 1, kr2.test(s), kr2.lastIndex === 0 ? n = s.length - 1 : n = kr2.lastIndex - 2, e.push(["word", s.slice(y2, n + 1), m, y2 - h, m, n - h, y2]), y2 = n);
          break;
      }
      y2++;
    }
    return e;
  }
  lu.exports = Sr2.default;
});
var hu2 = g2((Tr2, pu2) => {
  "use strict";
  Tr2.__esModule = true;
  var jd = /* @__PURE__ */ function() {
    function t(e, s) {
      for (var r = 0; r < s.length; r++) {
        var n = s[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    return function(e, s, r) {
      return s && t(e.prototype, s), r && t(e, r), e;
    };
  }(), Kd = Bs(), Qd = I2(Kd), Xd = Us(), zs = I2(Xd), Jd = Fs(), Zd = I2(Jd), em = Na(), tm = I2(em), rm = Ra(), Hs = I2(rm), sm = La(), nm = I2(sm), im = Ma(), om = I2(im), am = Ua(), um = I2(am), lm = $a(), cm = I2(lm), fm = Ga(), pm = I2(fm), hm = Va(), dm = I2(hm), mm = Ha(), ym = I2(mm), gm = Ka(), wm = I2(gm), vm = Xa(), xm = I2(vm), bm = Za(), _m = I2(bm), Em = tu2(), km = I2(Em), Sm = cu2(), fu2 = I2(Sm), Tm = M2(), Om = Cm(Tm);
  function Cm(t) {
    if (t && t.__esModule) return t;
    var e = {};
    if (t != null) for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    return e.default = t, e;
  }
  function I2(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Am(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  var Nm = function() {
    function t(e) {
      Am(this, t), this.input = e, this.lossy = e.options.lossless === false, this.position = 0, this.root = new tm.default();
      var s = new Hs.default();
      return this.root.append(s), this.current = s, this.lossy ? this.tokens = (0, fu2.default)({ safe: e.safe, css: e.css.trim() }) : this.tokens = (0, fu2.default)(e), this.loop();
    }
    return t.prototype.attribute = function() {
      var s = "", r = void 0, n = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; ) s += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~s.indexOf("]") && this.error("Expected a closing square bracket.");
      var i = s.split(/((?:[*~^$|]?=))([^]*)/), o = i[0].split(/(\|)/g), u = { operator: i[1], value: i[2], source: { start: { line: n[2], column: n[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: n[4] };
      if (o.length > 1 ? (o[0] === "" && (o[0] = true), u.attribute = this.parseValue(o[2]), u.namespace = this.parseNamespace(o[0])) : u.attribute = this.parseValue(i[0]), r = new ym.default(u), i[2]) {
        var a = i[2].split(/(\s+i\s*?)$/), c = a[0].trim();
        r.value = this.lossy ? c : a[0], a[1] && (r.insensitive = true, this.lossy || (r.raws.insensitive = a[1])), r.quoted = c[0] === "'" || c[0] === '"', r.raws.unquoted = r.quoted ? c.slice(1, -1) : c;
      }
      this.newNode(r), this.position++;
    }, t.prototype.combinator = function() {
      if (this.currToken[1] === "|") return this.namespace();
      for (var s = new xm.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); ) this.nextToken && this.nextToken[0] === "combinator" ? (s.spaces.before = this.parseSpace(this.currToken[1]), s.source.start.line = this.nextToken[2], s.source.start.column = this.nextToken[3], s.source.end.column = this.nextToken[3], s.source.end.line = this.nextToken[2], s.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? s.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? s.value = this.currToken[1] : this.currToken[0] === "space" && (s.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(s);
    }, t.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      var s = new Hs.default();
      this.current.parent.append(s), this.current = s, this.position++;
    }, t.prototype.comment = function() {
      var s = new om.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(s), this.position++;
    }, t.prototype.error = function(s) {
      throw new this.input.error(s);
    }, t.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, t.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, t.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, t.prototype.namespace = function() {
      var s = this.prevToken && this.prevToken[1] || true;
      if (this.nextToken[0] === "word") return this.position++, this.word(s);
      if (this.nextToken[0] === "*") return this.position++, this.universal(s);
    }, t.prototype.nesting = function() {
      this.newNode(new _m.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, t.prototype.parentheses = function() {
      var s = this.current.last;
      if (s && s.type === Om.PSEUDO) {
        var r = new Hs.default(), n = this.current;
        s.append(r), this.current = r;
        var i = 1;
        for (this.position++; this.position < this.tokens.length && i; ) this.currToken[0] === "(" && i++, this.currToken[0] === ")" && i--, i ? this.parse() : (r.parent.source.end.line = this.currToken[2], r.parent.source.end.column = this.currToken[3], this.position++);
        i && this.error("Expected closing parenthesis."), this.current = n;
      } else {
        var o = 1;
        for (this.position++, s.value += "("; this.position < this.tokens.length && o; ) this.currToken[0] === "(" && o++, this.currToken[0] === ")" && o--, s.value += this.parseParenthesisToken(this.currToken), this.position++;
        o && this.error("Expected closing parenthesis.");
      }
    }, t.prototype.pseudo = function() {
      for (var s = this, r = "", n = this.currToken; this.currToken && this.currToken[0] === ":"; ) r += this.currToken[1], this.position++;
      if (!this.currToken) return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var i = void 0;
        this.splitWord(false, function(o, u) {
          r += o, i = new dm.default({ value: r, source: { start: { line: n[2], column: n[3] }, end: { line: s.currToken[4], column: s.currToken[5] } }, sourceIndex: n[4] }), s.newNode(i), u > 1 && s.nextToken && s.nextToken[0] === "(" && s.error("Misplaced parenthesis.");
        });
      } else this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, t.prototype.space = function() {
      var s = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(s[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(s[1]), this.position++) : this.combinator();
    }, t.prototype.string = function() {
      var s = this.currToken;
      this.newNode(new pm.default({ value: this.currToken[1], source: { start: { line: s[2], column: s[3] }, end: { line: s[4], column: s[5] } }, sourceIndex: s[6] })), this.position++;
    }, t.prototype.universal = function(s) {
      var r = this.nextToken;
      if (r && r[1] === "|") return this.position++, this.namespace();
      this.newNode(new wm.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), s), this.position++;
    }, t.prototype.splitWord = function(s, r) {
      for (var n = this, i = this.nextToken, o = this.currToken[1]; i && i[0] === "word"; ) {
        this.position++;
        var u = this.currToken[1];
        if (o += u, u.lastIndexOf("\\") === u.length - 1) {
          var a = this.nextToken;
          a && a[0] === "space" && (o += this.parseSpace(a[1], " "), this.position++);
        }
        i = this.nextToken;
      }
      var c = (0, zs.default)(o, "."), f = (0, zs.default)(o, "#"), p = (0, zs.default)(o, "#{");
      p.length && (f = f.filter(function(d) {
        return !~p.indexOf(d);
      }));
      var l = (0, km.default)((0, Zd.default)((0, Qd.default)([[0], c, f])));
      l.forEach(function(d, x) {
        var h = l[x + 1] || o.length, m = o.slice(d, h);
        if (x === 0 && r) return r.call(n, m, l.length);
        var y2 = void 0;
        ~c.indexOf(d) ? y2 = new nm.default({ value: m.slice(1), source: { start: { line: n.currToken[2], column: n.currToken[3] + d }, end: { line: n.currToken[4], column: n.currToken[3] + (h - 1) } }, sourceIndex: n.currToken[6] + l[x] }) : ~f.indexOf(d) ? y2 = new um.default({ value: m.slice(1), source: { start: { line: n.currToken[2], column: n.currToken[3] + d }, end: { line: n.currToken[4], column: n.currToken[3] + (h - 1) } }, sourceIndex: n.currToken[6] + l[x] }) : y2 = new cm.default({ value: m, source: { start: { line: n.currToken[2], column: n.currToken[3] + d }, end: { line: n.currToken[4], column: n.currToken[3] + (h - 1) } }, sourceIndex: n.currToken[6] + l[x] }), n.newNode(y2, s);
      }), this.position++;
    }, t.prototype.word = function(s) {
      var r = this.nextToken;
      return r && r[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(s);
    }, t.prototype.loop = function() {
      for (; this.position < this.tokens.length; ) this.parse(true);
      return this.root;
    }, t.prototype.parse = function(s) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          s && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, t.prototype.parseNamespace = function(s) {
      if (this.lossy && typeof s == "string") {
        var r = s.trim();
        return r.length ? r : true;
      }
      return s;
    }, t.prototype.parseSpace = function(s, r) {
      return this.lossy ? r || "" : s;
    }, t.prototype.parseValue = function(s) {
      return this.lossy && s && typeof s == "string" ? s.trim() : s;
    }, t.prototype.parseParenthesisToken = function(s) {
      return this.lossy ? s[0] === "space" ? this.parseSpace(s[1], " ") : this.parseValue(s[1]) : s[1];
    }, t.prototype.newNode = function(s, r) {
      return r && (s.namespace = this.parseNamespace(r)), this.spaces && (s.spaces.before = this.spaces, this.spaces = ""), this.current.append(s);
    }, jd(t, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), t;
  }();
  Tr2.default = Nm;
  pu2.exports = Tr2.default;
});
var mu2 = g2((Or2, du2) => {
  "use strict";
  Or2.__esModule = true;
  var Pm = /* @__PURE__ */ function() {
    function t(e, s) {
      for (var r = 0; r < s.length; r++) {
        var n = s[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    return function(e, s, r) {
      return s && t(e.prototype, s), r && t(e, r), e;
    };
  }(), Rm = hu2(), Im = qm(Rm);
  function qm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Lm(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  var Dm = function() {
    function t(e) {
      return Lm(this, t), this.func = e || function() {
      }, this;
    }
    return t.prototype.process = function(s) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = new Im.default({ css: s, error: function(o) {
        throw new Error(o);
      }, options: r });
      return this.res = n, this.func(n), this;
    }, Pm(t, [{ key: "result", get: function() {
      return String(this.res);
    } }]), t;
  }();
  Or2.default = Dm;
  du2.exports = Or2.default;
});
var z2 = g2((tb, gu2) => {
  "use strict";
  var js = function(t, e) {
    let s = new t.constructor();
    for (let r in t) {
      if (!t.hasOwnProperty(r)) continue;
      let n = t[r], i = typeof n;
      r === "parent" && i === "object" ? e && (s[r] = e) : r === "source" ? s[r] = n : n instanceof Array ? s[r] = n.map((o) => js(o, s)) : r !== "before" && r !== "after" && r !== "between" && r !== "semicolon" && (i === "object" && n !== null && (n = js(n)), s[r] = n);
    }
    return s;
  };
  gu2.exports = class {
    constructor(e) {
      e = e || {}, this.raws = { before: "", after: "" };
      for (let s in e) this[s] = e[s];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(e) {
      e = e || {};
      let s = js(this);
      for (let r in e) s[r] = e[r];
      return s;
    }
    cloneBefore(e) {
      e = e || {};
      let s = this.clone(e);
      return this.parent.insertBefore(this, s), s;
    }
    cloneAfter(e) {
      e = e || {};
      let s = this.clone(e);
      return this.parent.insertAfter(this, s), s;
    }
    replaceWith() {
      let e = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let s of e) this.parent.insertBefore(this, s);
        this.remove();
      }
      return this;
    }
    moveTo(e) {
      return this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this;
    }
    moveBefore(e) {
      return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this;
    }
    moveAfter(e) {
      return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this;
    }
    next() {
      let e = this.parent.index(this);
      return this.parent.nodes[e + 1];
    }
    prev() {
      let e = this.parent.index(this);
      return this.parent.nodes[e - 1];
    }
    toJSON() {
      let e = {};
      for (let s in this) {
        if (!this.hasOwnProperty(s) || s === "parent") continue;
        let r = this[s];
        r instanceof Array ? e[s] = r.map((n) => typeof n == "object" && n.toJSON ? n.toJSON() : n) : typeof r == "object" && r.toJSON ? e[s] = r.toJSON() : e[s] = r;
      }
      return e;
    }
    root() {
      let e = this;
      for (; e.parent; ) e = e.parent;
      return e;
    }
    cleanRaws(e) {
      delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
    }
    positionInside(e) {
      let s = this.toString(), r = this.source.start.column, n = this.source.start.line;
      for (let i = 0; i < e; i++) s[i] === `
` ? (r = 1, n += 1) : r += 1;
      return { line: n, column: r };
    }
    positionBy(e) {
      let s = this.source.start;
      if (Object(e).index) s = this.positionInside(e.index);
      else if (Object(e).word) {
        let r = this.toString().indexOf(e.word);
        r !== -1 && (s = this.positionInside(r));
      }
      return s;
    }
  };
});
var U2 = g2((rb, wu2) => {
  "use strict";
  var Bm = z2(), We2 = class extends Bm {
    constructor(e) {
      super(e), this.nodes || (this.nodes = []);
    }
    push(e) {
      return e.parent = this, this.nodes.push(e), this;
    }
    each(e) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let s = this.lastEach, r, n;
      if (this.indexes[s] = 0, !!this.nodes) {
        for (; this.indexes[s] < this.nodes.length && (r = this.indexes[s], n = e(this.nodes[r], r), n !== false); ) this.indexes[s] += 1;
        return delete this.indexes[s], n;
      }
    }
    walk(e) {
      return this.each((s, r) => {
        let n = e(s, r);
        return n !== false && s.walk && (n = s.walk(e)), n;
      });
    }
    walkType(e, s) {
      if (!e || !s) throw new Error("Parameters {type} and {callback} are required.");
      let r = typeof e == "function";
      return this.walk((n, i) => {
        if (r && n instanceof e || !r && n.type === e) return s.call(this, n, i);
      });
    }
    append(e) {
      return e.parent = this, this.nodes.push(e), this;
    }
    prepend(e) {
      return e.parent = this, this.nodes.unshift(e), this;
    }
    cleanRaws(e) {
      if (super.cleanRaws(e), this.nodes) for (let s of this.nodes) s.cleanRaws(e);
    }
    insertAfter(e, s) {
      let r = this.index(e), n;
      this.nodes.splice(r + 1, 0, s);
      for (let i in this.indexes) n = this.indexes[i], r <= n && (this.indexes[i] = n + this.nodes.length);
      return this;
    }
    insertBefore(e, s) {
      let r = this.index(e), n;
      this.nodes.splice(r, 0, s);
      for (let i in this.indexes) n = this.indexes[i], r <= n && (this.indexes[i] = n + this.nodes.length);
      return this;
    }
    removeChild(e) {
      e = this.index(e), this.nodes[e].parent = void 0, this.nodes.splice(e, 1);
      let s;
      for (let r in this.indexes) s = this.indexes[r], s >= e && (this.indexes[r] = s - 1);
      return this;
    }
    removeAll() {
      for (let e of this.nodes) e.parent = void 0;
      return this.nodes = [], this;
    }
    every(e) {
      return this.nodes.every(e);
    }
    some(e) {
      return this.nodes.some(e);
    }
    index(e) {
      return typeof e == "number" ? e : this.nodes.indexOf(e);
    }
    get first() {
      if (this.nodes) return this.nodes[0];
    }
    get last() {
      if (this.nodes) return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let e = this.nodes.map(String).join("");
      return this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e;
    }
  };
  We2.registerWalker = (t) => {
    let e = "walk" + t.name;
    e.lastIndexOf("s") !== e.length - 1 && (e += "s"), !We2.prototype[e] && (We2.prototype[e] = function(s) {
      return this.walkType(t, s);
    });
  };
  wu2.exports = We2;
});
var xu2 = g2((nb, vu2) => {
  "use strict";
  var Um = U2();
  vu2.exports = class extends Um {
    constructor(e) {
      super(e), this.type = "root";
    }
  };
});
var _u2 = g2((ob, bu2) => {
  "use strict";
  var Fm = U2();
  bu2.exports = class extends Fm {
    constructor(e) {
      super(e), this.type = "value", this.unbalanced = 0;
    }
  };
});
var Su2 = g2((ab, ku2) => {
  "use strict";
  var Eu2 = U2(), Cr2 = class extends Eu2 {
    constructor(e) {
      super(e), this.type = "atword";
    }
    toString() {
      let e = this.quoted ? this.raws.quote : "";
      return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  Eu2.registerWalker(Cr2);
  ku2.exports = Cr2;
});
var Ou2 = g2((ub, Tu2) => {
  "use strict";
  var $m = U2(), Wm = z2(), Ar2 = class extends Wm {
    constructor(e) {
      super(e), this.type = "colon";
    }
  };
  $m.registerWalker(Ar2);
  Tu2.exports = Ar2;
});
var Au2 = g2((lb, Cu2) => {
  "use strict";
  var Gm = U2(), Ym = z2(), Nr2 = class extends Ym {
    constructor(e) {
      super(e), this.type = "comma";
    }
  };
  Gm.registerWalker(Nr2);
  Cu2.exports = Nr2;
});
var Pu2 = g2((cb, Nu2) => {
  "use strict";
  var Vm = U2(), zm = z2(), Pr2 = class extends zm {
    constructor(e) {
      super(e), this.type = "comment", this.inline = Object(e).inline || false;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  Vm.registerWalker(Pr2);
  Nu2.exports = Pr2;
});
var qu2 = g2((fb, Iu2) => {
  "use strict";
  var Ru2 = U2(), Rr2 = class extends Ru2 {
    constructor(e) {
      super(e), this.type = "func", this.unbalanced = -1;
    }
  };
  Ru2.registerWalker(Rr2);
  Iu2.exports = Rr2;
});
var Du2 = g2((pb, Lu2) => {
  "use strict";
  var Hm = U2(), jm = z2(), Ir2 = class extends jm {
    constructor(e) {
      super(e), this.type = "number", this.unit = Object(e).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  Hm.registerWalker(Ir2);
  Lu2.exports = Ir2;
});
var Bu2 = g2((hb, Mu2) => {
  "use strict";
  var Km = U2(), Qm = z2(), qr2 = class extends Qm {
    constructor(e) {
      super(e), this.type = "operator";
    }
  };
  Km.registerWalker(qr2);
  Mu2.exports = qr2;
});
var Fu2 = g2((db, Uu2) => {
  "use strict";
  var Xm = U2(), Jm = z2(), Lr2 = class extends Jm {
    constructor(e) {
      super(e), this.type = "paren", this.parenType = "";
    }
  };
  Xm.registerWalker(Lr2);
  Uu2.exports = Lr2;
});
var Wu2 = g2((mb, $u2) => {
  "use strict";
  var Zm = U2(), ey = z2(), Dr2 = class extends ey {
    constructor(e) {
      super(e), this.type = "string";
    }
    toString() {
      let e = this.quoted ? this.raws.quote : "";
      return [this.raws.before, e, this.value + "", e, this.raws.after].join("");
    }
  };
  Zm.registerWalker(Dr2);
  $u2.exports = Dr2;
});
var Yu2 = g2((yb, Gu2) => {
  "use strict";
  var ty = U2(), ry = z2(), Mr2 = class extends ry {
    constructor(e) {
      super(e), this.type = "word";
    }
  };
  ty.registerWalker(Mr2);
  Gu2.exports = Mr2;
});
var zu2 = g2((gb, Vu2) => {
  "use strict";
  var sy = U2(), ny = z2(), Br2 = class extends ny {
    constructor(e) {
      super(e), this.type = "unicode-range";
    }
  };
  sy.registerWalker(Br2);
  Vu2.exports = Br2;
});
var ju2 = g2((wb, Hu2) => {
  "use strict";
  var Ks = class extends Error {
    constructor(e) {
      super(e), this.name = this.constructor.name, this.message = e || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e).stack;
    }
  };
  Hu2.exports = Ks;
});
var Xu2 = g2((vb, Qu2) => {
  "use strict";
  var Ur2 = /[ \n\t\r\{\(\)'"\\;,/]/g, iy = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, Ge2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, oy = /^[a-z0-9]/i, ay = /^[a-f0-9?\-]/i, Ku2 = ju2();
  Qu2.exports = function(e, s) {
    s = s || {};
    let r = [], n = e.valueOf(), i = n.length, o = -1, u = 1, a = 0, c = 0, f = null, p, l, d, x, h, m, y2, b2, w2, v2, R2, F;
    function Q2(T2) {
      let O2 = `Unclosed ${T2} at line: ${u}, column: ${a - o}, token: ${a}`;
      throw new Ku2(O2);
    }
    function W2() {
      let T2 = `Syntax error at line: ${u}, column: ${a - o}, token: ${a}`;
      throw new Ku2(T2);
    }
    for (; a < i; ) {
      switch (p = n.charCodeAt(a), p === 10 && (o = a, u += 1), p) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
          l = a;
          do
            l += 1, p = n.charCodeAt(l), p === 10 && (o = l, u += 1);
          while (p === 32 || p === 10 || p === 9 || p === 13 || p === 12);
          r.push(["space", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
          break;
        case 58:
          l = a + 1, r.push(["colon", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
          break;
        case 44:
          l = a + 1, r.push(["comma", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
          break;
        case 123:
          r.push(["{", "{", u, a - o, u, l - o, a]);
          break;
        case 125:
          r.push(["}", "}", u, a - o, u, l - o, a]);
          break;
        case 40:
          c++, f = !f && c === 1 && r.length > 0 && r[r.length - 1][0] === "word" && r[r.length - 1][1] === "url", r.push(["(", "(", u, a - o, u, l - o, a]);
          break;
        case 41:
          c--, f = f && c > 0, r.push([")", ")", u, a - o, u, l - o, a]);
          break;
        case 39:
        case 34:
          d = p === 39 ? "'" : '"', l = a;
          do
            for (v2 = false, l = n.indexOf(d, l + 1), l === -1 && Q2("quote", d), R2 = l; n.charCodeAt(R2 - 1) === 92; ) R2 -= 1, v2 = !v2;
          while (v2);
          r.push(["string", n.slice(a, l + 1), u, a - o, u, l - o, a]), a = l;
          break;
        case 64:
          Ur2.lastIndex = a + 1, Ur2.test(n), Ur2.lastIndex === 0 ? l = n.length - 1 : l = Ur2.lastIndex - 2, r.push(["atword", n.slice(a, l + 1), u, a - o, u, l - o, a]), a = l;
          break;
        case 92:
          l = a, p = n.charCodeAt(l + 1), y2 && p !== 47 && p !== 32 && p !== 10 && p !== 9 && p !== 13 && p !== 12 && (l += 1), r.push(["word", n.slice(a, l + 1), u, a - o, u, l - o, a]), a = l;
          break;
        case 43:
        case 45:
        case 42:
          l = a + 1, F = n.slice(a + 1, l + 1);
          let T2 = n.slice(a - 1, a);
          if (p === 45 && F.charCodeAt(0) === 45) {
            l++, r.push(["word", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
            break;
          }
          r.push(["operator", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
          break;
        default:
          if (p === 47 && (n.charCodeAt(a + 1) === 42 || s.loose && !f && n.charCodeAt(a + 1) === 47)) {
            if (n.charCodeAt(a + 1) === 42) l = n.indexOf("*/", a + 2) + 1, l === 0 && Q2("comment", "*/");
            else {
              let C = n.indexOf(`
`, a + 2);
              l = C !== -1 ? C - 1 : i;
            }
            m = n.slice(a, l + 1), x = m.split(`
`), h = x.length - 1, h > 0 ? (b2 = u + h, w2 = l - x[h].length) : (b2 = u, w2 = o), r.push(["comment", m, u, a - o, b2, l - w2, a]), o = w2, u = b2, a = l;
          } else if (p === 35 && !oy.test(n.slice(a + 1, a + 2))) l = a + 1, r.push(["#", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
          else if ((p === 117 || p === 85) && n.charCodeAt(a + 1) === 43) {
            l = a + 2;
            do
              l += 1, p = n.charCodeAt(l);
            while (l < i && ay.test(n.slice(l, l + 1)));
            r.push(["unicoderange", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
          } else if (p === 47) l = a + 1, r.push(["operator", n.slice(a, l), u, a - o, u, l - o, a]), a = l - 1;
          else {
            let O2 = iy;
            if (p >= 48 && p <= 57 && (O2 = Ge2), O2.lastIndex = a + 1, O2.test(n), O2.lastIndex === 0 ? l = n.length - 1 : l = O2.lastIndex - 2, O2 === Ge2 || p === 46) {
              let C = n.charCodeAt(l), xe2 = n.charCodeAt(l + 1), tn2 = n.charCodeAt(l + 2);
              (C === 101 || C === 69) && (xe2 === 45 || xe2 === 43) && tn2 >= 48 && tn2 <= 57 && (Ge2.lastIndex = l + 2, Ge2.test(n), Ge2.lastIndex === 0 ? l = n.length - 1 : l = Ge2.lastIndex - 2);
            }
            r.push(["word", n.slice(a, l + 1), u, a - o, u, l - o, a]), a = l;
          }
          break;
      }
      a++;
    }
    return r;
  };
});
var Zu2 = g2((xb, Ju2) => {
  "use strict";
  var Qs = class extends Error {
    constructor(e) {
      super(e), this.name = this.constructor.name, this.message = e || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e).stack;
    }
  };
  Ju2.exports = Qs;
});
var sl = g2((_b, rl) => {
  "use strict";
  var uy = xu2(), ly = _u2(), cy = Su2(), fy = Ou2(), py = Au2(), hy = Pu2(), dy = qu2(), my = Du2(), yy = Bu2(), el = Fu2(), gy = Wu2(), tl = Yu2(), wy = zu2(), vy = Xu2(), xy = Bs(), by = Us(), _y = Fs(), Ey = Zu2();
  function ky(t) {
    return t.sort((e, s) => e - s);
  }
  rl.exports = class {
    constructor(e, s) {
      let r = { loose: false };
      this.cache = [], this.input = e, this.options = Object.assign({}, r, s), this.position = 0, this.unbalanced = 0, this.root = new uy();
      let n = new ly();
      this.root.append(n), this.current = n, this.tokens = vy(e, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let e = this.currToken;
      this.newNode(new fy({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
    }
    comma() {
      let e = this.currToken;
      this.newNode(new py({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
    }
    comment() {
      let e = false, s = this.currToken[1].replace(/\/\*|\*\//g, ""), r;
      this.options.loose && s.startsWith("//") && (s = s.substring(2), e = true), r = new hy({ value: s, inline: e, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(r), this.position++;
    }
    error(e, s) {
      throw new Ey(e + ` at line: ${s[2]}, column ${s[3]}`);
    }
    loop() {
      for (; this.position < this.tokens.length; ) this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let e = this.currToken[1], s;
      if (e === "+" || e === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word") return this.word();
        } else if (this.nextToken[0] === "word") return this.word();
      }
      return s = new yy({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(s);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let e = 1, s = this.position + 1, r = this.currToken, n;
      for (; s < this.tokens.length && e; ) {
        let i = this.tokens[s];
        i[0] === "(" && e++, i[0] === ")" && e--, s++;
      }
      if (e && this.error("Expected closing parenthesis", r), n = this.current.last, n && n.type === "func" && n.unbalanced < 0 && (n.unbalanced = 0, this.current = n), this.current.unbalanced++, this.newNode(new el({ value: r[1], source: { start: { line: r[2], column: r[3] }, end: { line: r[4], column: r[5] } }, sourceIndex: r[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let i = this.nextToken, o = this.currToken[1], u = { line: this.currToken[2], column: this.currToken[3] };
        for (; i && i[0] !== ")" && this.current.unbalanced; ) this.position++, o += this.currToken[1], i = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new tl({ value: o, source: { start: u, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let e = this.currToken;
      this.newNode(new el({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let e = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += e[1], this.position++) : (this.spaces = e[1], this.position++);
    }
    unicodeRange() {
      let e = this.currToken;
      this.newNode(new wy({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
    }
    splitWord() {
      let e = this.nextToken, s = this.currToken[1], r = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, n = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, i, o;
      if (!n.test(s)) for (; e && e[0] === "word"; ) {
        this.position++;
        let u = this.currToken[1];
        s += u, e = this.nextToken;
      }
      i = by(s, "@"), o = ky(_y(xy([[0], i]))), o.forEach((u, a) => {
        let c = o[a + 1] || s.length, f = s.slice(u, c), p;
        if (~i.indexOf(u)) p = new cy({ value: f.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + u }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + o[a] });
        else if (r.test(this.currToken[1])) {
          let l = f.replace(r, "");
          p = new my({ value: f.replace(l, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + u }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + o[a], unit: l });
        } else p = new (e && e[0] === "(" ? dy : tl)({ value: f, source: { start: { line: this.currToken[2], column: this.currToken[3] + u }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + o[a] }), p.type === "word" ? (p.isHex = /^#(.+)/.test(f), p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(f)) : this.cache.push(this.current);
        this.newNode(p);
      }), this.position++;
    }
    string() {
      let e = this.currToken, s = this.currToken[1], r = /^(\"|\')/, n = r.test(s), i = "", o;
      n && (i = s.match(r)[0], s = s.slice(1, s.length - 1)), o = new gy({ value: s, source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6], quoted: n }), o.raws.quote = i, this.newNode(o), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(e) {
      return this.spaces && (e.raws.before += this.spaces, this.spaces = ""), this.current.append(e);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
});
var en2 = {};
rn2(en2, { languages: () => Ei, options: () => Si, parsers: () => Zs, printers: () => Fy });
var Tl = (t, e, s, r) => {
  if (!(t && e == null)) return e.replaceAll ? e.replaceAll(s, r) : s.global ? e.replace(s, r) : e.split(s).join(r);
};
var E = Tl;
var _e2 = "string";
var Ye2 = "array";
var Ve2 = "cursor";
var re2 = "indent";
var Ee2 = "align";
var ze2 = "trim";
var se2 = "group";
var ne2 = "fill";
var ie2 = "if-break";
var He2 = "indent-if-break";
var ke2 = "line-suffix";
var je2 = "line-suffix-boundary";
var H2 = "line";
var Ke2 = "label";
var Se2 = "break-parent";
var Tt2 = /* @__PURE__ */ new Set([Ve2, re2, Ee2, ze2, se2, ne2, ie2, He2, ke2, je2, H2, Ke2, Se2]);
var Ol = (t, e, s) => {
  if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[s < 0 ? e.length + s : s] : e.at(s);
};
var $ = Ol;
function Cl(t) {
  if (typeof t == "string") return _e2;
  if (Array.isArray(t)) return Ye2;
  if (!t) return;
  let { type: e } = t;
  if (Tt2.has(e)) return e;
}
var j2 = Cl;
var Al = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function Nl(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (j2(t)) throw new Error("doc is valid.");
  let s = Object.prototype.toString.call(t);
  if (s !== "[object Object]") return `Unexpected doc '${s}'.`;
  let r = Al([...Tt2].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${r}.`;
}
var Gr2 = class extends Error {
  constructor(e) {
    super(Nl(e));
    __publicField(this, "name", "InvalidDocError");
    this.doc = e;
  }
};
var Yr2 = Gr2;
function Rl(t, e) {
  if (typeof t == "string") return e(t);
  let s = /* @__PURE__ */ new Map();
  return r(t);
  function r(i) {
    if (s.has(i)) return s.get(i);
    let o = n(i);
    return s.set(i, o), o;
  }
  function n(i) {
    switch (j2(i)) {
      case Ye2:
        return e(i.map(r));
      case ne2:
        return e({ ...i, parts: i.parts.map(r) });
      case ie2:
        return e({ ...i, breakContents: r(i.breakContents), flatContents: r(i.flatContents) });
      case se2: {
        let { expandedStates: o, contents: u } = i;
        return o ? (o = o.map(r), u = o[0]) : u = r(u), e({ ...i, contents: u, expandedStates: o });
      }
      case Ee2:
      case re2:
      case He2:
      case Ke2:
      case ke2:
        return e({ ...i, contents: r(i.contents) });
      case _e2:
      case Ve2:
      case ze2:
      case je2:
      case H2:
      case Se2:
        return e(i);
      default:
        throw new Yr2(i);
    }
  }
}
function Il(t) {
  return t.type === H2 && !t.hard ? t.soft ? "" : " " : t.type === ie2 ? t.flatContents : t;
}
function sn2(t) {
  return Rl(t, Il);
}
var Vr2 = () => {
};
var oe2 = Vr2;
var Qe2 = Vr2;
var nn2 = Vr2;
function q2(t) {
  return oe2(t), { type: re2, contents: t };
}
function on2(t, e) {
  return oe2(e), { type: Ee2, contents: e, n: t };
}
function L2(t, e = {}) {
  return oe2(t), Qe2(e.expandedStates, true), { type: se2, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function an2(t) {
  return on2({ type: "root" }, t);
}
function ae2(t) {
  return on2(-1, t);
}
function Te2(t) {
  return nn2(t), { type: ne2, parts: t };
}
function Ot2(t, e = "", s = {}) {
  return oe2(t), e !== "" && oe2(e), { type: ie2, breakContents: t, flatContents: e, groupId: s.groupId };
}
function un2(t) {
  return oe2(t), { type: ke2, contents: t };
}
var Xe2 = { type: Se2 };
var ql = { type: H2, hard: true };
var A = { type: H2 };
var D = { type: H2, soft: true };
var S2 = [ql, Xe2];
function G2(t, e) {
  oe2(t), Qe2(e);
  let s = [];
  for (let r = 0; r < e.length; r++) r !== 0 && s.push(t), s.push(e[r]);
  return s;
}
function Ll(t) {
  return Array.isArray(t) && t.length > 0;
}
var ue = Ll;
var ln2 = new Proxy(() => {
}, { get: () => ln2 });
var cn2 = ln2;
var Ct2 = "'";
var fn2 = '"';
function Dl(t, e) {
  let s = e === true || e === Ct2 ? Ct2 : fn2, r = s === Ct2 ? fn2 : Ct2, n = 0, i = 0;
  for (let o of t) o === s ? n++ : o === r && i++;
  return n > i ? r : s;
}
var pn2 = Dl;
function Ml(t, e, s) {
  let r = e === '"' ? "'" : '"', i = E(false, t, /\\(.)|(["'])/gsu, (o, u, a) => u === r ? u : a === e ? "\\" + a : a || (s && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(u) ? u : "\\" + u));
  return e + i + e;
}
var hn2 = Ml;
function Bl(t, e) {
  cn2.ok(/^(?<quote>["']).*\k<quote>$/su.test(t));
  let s = t.slice(1, -1), r = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : pn2(s, e.singleQuote);
  return t.charAt(0) === r ? t : hn2(s, r, false);
}
var At2 = Bl;
var zr2 = class extends Error {
  constructor(e, s, r = "type") {
    super(`Unexpected ${s} node ${r}: ${JSON.stringify(e[r])}.`);
    __publicField(this, "name", "UnexpectedNodeError");
    this.node = e;
  }
};
var dn2 = zr2;
function Ul(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var Oe2 = Ul;
var Fl = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
function mn2(t, e, s) {
  if (Oe2(t) && t.language === "yaml" && delete e.value, t.type === "css-comment" && s.type === "css-root" && s.nodes.length > 0 && ((s.nodes[0] === t || Oe2(s.nodes[0]) && s.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/u.test(t.text)) || s.type === "css-root" && $(false, s.nodes, -1) === t)) return null;
  if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && t.value && (e.value = $l(t.value)), t.type === "selector-combinator" && (e.value = E(false, e.value, /\s+/gu, " ")), t.type === "media-feature" && (e.value = E(false, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || ["initial", "inherit", "unset", "revert"].includes(t.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = t.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = t.name.toLowerCase()), t.type === "value-number" && (e.unit = t.unit.toLowerCase()), t.type === "value-unknown" && (e.value = E(false, e.value, /;$/gu, "")), t.type === "selector-attribute" && (e.attribute = t.attribute.trim(), t.namespace && typeof t.namespace == "string" && (e.namespace = t.namespace.trim() || true), t.value && (e.value = E(false, e.value.trim(), /^["']|["']$/gu, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && t.value && (e.value = E(false, e.value, /([\d+.e-]+)([a-z]*)/giu, (r, n, i) => {
    let o = Number(n);
    return Number.isNaN(o) ? r : o + i.toLowerCase();
  })), t.type === "selector-tag") {
    let r = e.value.toLowerCase();
    ["from", "to"].includes(r) && (e.value = r);
  }
  if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
    let r = t.groups.findIndex((n) => n.type === "value-number" && n.unit === "...");
    r !== -1 && (e.groups[r].unit = "", e.groups.splice(r + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
  }
  if (t.type === "value-comma_group" && t.groups.some((r) => r.type === "value-atword" && r.value.endsWith("[") || r.type === "value-word" && r.value.startsWith("]"))) return { type: "value-atword", value: t.groups.map((r) => r.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
}
mn2.ignoredProperties = Fl;
function $l(t) {
  return E(false, E(false, t, "'", '"'), /\\([^\da-f])/giu, "$1");
}
var yn2 = mn2;
async function Wl(t, e) {
  if (t.language === "yaml") {
    let s = t.value.trim(), r = s ? await e(s, { parser: "yaml" }) : "";
    return an2([t.startDelimiter, t.explicitLanguage, S2, r, r ? S2 : "", t.endDelimiter]);
  }
}
var gn2 = Wl;
function wn2(t) {
  let { node: e } = t;
  if (e.type === "front-matter") return async (s) => {
    let r = await gn2(e, s);
    return r ? [r, S2] : void 0;
  };
}
wn2.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
var vn2 = wn2;
var Je2 = null;
function Ze2(t) {
  if (Je2 !== null && typeof Je2.property) {
    let e = Je2;
    return Je2 = Ze2.prototype = null, e;
  }
  return Je2 = Ze2.prototype = t != null ? t : /* @__PURE__ */ Object.create(null), new Ze2();
}
var Gl = 10;
for (let t = 0; t <= Gl; t++) Ze2();
function Hr2(t) {
  return Ze2(t);
}
function Yl(t, e = "type") {
  Hr2(t);
  function s(r) {
    let n = r[e], i = t[n];
    if (!Array.isArray(i)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
    return i;
  }
  return s;
}
var xn2 = Yl;
var Vl = { "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] };
var bn2 = Vl;
var zl = xn2(bn2);
var _n2 = zl;
function Hl(t, e) {
  let s = 0;
  for (let r = 0; r < t.line - 1; ++r) s = e.indexOf(`
`, s) + 1;
  return s + t.column;
}
var jr2 = Hl;
function Nt2(t) {
  return (e, s, r) => {
    let n = !!(r != null && r.backwards);
    if (s === false) return false;
    let { length: i } = e, o = s;
    for (; o >= 0 && o < i; ) {
      let u = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(u)) return o;
      } else if (!t.includes(u)) return o;
      n ? o-- : o++;
    }
    return o === -1 || o === i ? o : false;
  };
}
var Qg = Nt2(/\s/u);
var Pt2 = Nt2(" 	");
var En2 = Nt2(",; 	");
var Rt2 = Nt2(/[^\n\r]/u);
function kn2(t, e) {
  let { value: s } = t;
  return s === "-" || s === "--" || s.charAt(0) !== "-" ? e : e - (s.charAt(1) === "-" ? 2 : 1);
}
function Sn2(t, e) {
  var s, r, n;
  if (typeof ((r = (s = t.source) == null ? void 0 : s.start) == null ? void 0 : r.offset) == "number") return t.source.start.offset;
  if (typeof t.sourceIndex == "number") return t.type === "value-word" ? kn2(t, t.sourceIndex) : t.sourceIndex;
  if ((n = t.source) != null && n.start) return jr2(t.source.start, e);
  throw Object.assign(new Error("Can not locate node."), { node: t });
}
function Kr2(t, e) {
  var s, r;
  if (t.type === "css-comment" && t.inline) return Rt2(e, t.source.startOffset);
  if (typeof ((r = (s = t.source) == null ? void 0 : s.end) == null ? void 0 : r.offset) == "number") return t.source.end.offset;
  if (t.source) {
    if (t.source.end) {
      let n = jr2(t.source.end, e);
      return t.type === "value-word" ? kn2(t, n) : n;
    }
    if (ue(t.nodes)) return Kr2($(false, t.nodes, -1), e);
  }
  return null;
}
function Qr2(t, e) {
  t.source && (t.source.startOffset = Sn2(t, e), t.source.endOffset = Kr2(t, e));
  for (let s in t) {
    let r = t[s];
    s === "source" || !r || typeof r != "object" || (r.type === "value-root" || r.type === "value-unknown" ? Tn2(r, jl(t), r.text || r.value) : Qr2(r, e));
  }
}
function Tn2(t, e, s) {
  t.source && (t.source.startOffset = Sn2(t, s) + e, t.source.endOffset = Kr2(t, s) + e);
  for (let r in t) {
    let n = t[r];
    r === "source" || !n || typeof n != "object" || Tn2(n, e, s);
  }
}
function jl(t) {
  var s;
  let e = t.source.startOffset;
  return typeof t.prop == "string" && (e += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (e += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/u)[0].length), t.type !== "css-atrule" && typeof ((s = t.raws) == null ? void 0 : s.between) == "string" && (e += t.raws.between.length), e;
}
function On(t) {
  let e = "initial", s = "initial", r, n = false, i = [];
  for (let o = 0; o < t.length; o++) {
    let u = t[o];
    switch (e) {
      case "initial":
        if (u === "'") {
          e = "single-quotes";
          continue;
        }
        if (u === '"') {
          e = "double-quotes";
          continue;
        }
        if ((u === "u" || u === "U") && t.slice(o, o + 4).toLowerCase() === "url(") {
          e = "url", o += 3;
          continue;
        }
        if (u === "*" && t[o - 1] === "/") {
          e = "comment-block";
          continue;
        }
        if (u === "/" && t[o - 1] === "/") {
          e = "comment-inline", r = o - 1;
          continue;
        }
        continue;
      case "single-quotes":
        if (u === "'" && t[o - 1] !== "\\" && (e = s, s = "initial"), u === `
` || u === "\r") return t;
        continue;
      case "double-quotes":
        if (u === '"' && t[o - 1] !== "\\" && (e = s, s = "initial"), u === `
` || u === "\r") return t;
        continue;
      case "url":
        if (u === ")" && (e = "initial"), u === `
` || u === "\r") return t;
        if (u === "'") {
          e = "single-quotes", s = "url";
          continue;
        }
        if (u === '"') {
          e = "double-quotes", s = "url";
          continue;
        }
        continue;
      case "comment-block":
        u === "/" && t[o - 1] === "*" && (e = "initial");
        continue;
      case "comment-inline":
        (u === '"' || u === "'" || u === "*") && (n = true), (u === `
` || u === "\r") && (n && i.push([r, o]), e = "initial", n = false);
        continue;
    }
  }
  for (let [o, u] of i) t = t.slice(0, o) + E(false, t.slice(o, u), /["'*]/gu, " ") + t.slice(u);
  return t;
}
function N2(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.startOffset;
}
function P2(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.endOffset;
}
var Kl = /\*\/$/;
var Ql = /^\/\*\*?/;
var Pn2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
var Xl = /(^|\s+)\/\/([^\n\r]*)/g;
var Cn2 = /^(\r?\n)+/;
var Jl = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g;
var An2 = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g;
var Zl = /(\r?\n|^) *\* ?/g;
var Rn2 = [];
function In2(t) {
  let e = t.match(Pn2);
  return e ? e[0].trimStart() : "";
}
function qn2(t) {
  let e = t.match(Pn2), s = e == null ? void 0 : e[0];
  return s == null ? t : t.slice(s.length);
}
function Ln2(t) {
  let e = `
`;
  t = E(false, t.replace(Ql, "").replace(Kl, ""), Zl, "$1");
  let s = "";
  for (; s !== t; ) s = t, t = E(false, t, Jl, `${e}$1 $2${e}`);
  t = t.replace(Cn2, "").trimEnd();
  let r = /* @__PURE__ */ Object.create(null), n = E(false, t, An2, "").replace(Cn2, "").trimEnd(), i;
  for (; i = An2.exec(t); ) {
    let o = E(false, i[2], Xl, "");
    if (typeof r[i[1]] == "string" || Array.isArray(r[i[1]])) {
      let u = r[i[1]];
      r[i[1]] = [...Rn2, ...Array.isArray(u) ? u : [u], o];
    } else r[i[1]] = o;
  }
  return { comments: n, pragmas: r };
}
function Dn2({ comments: t = "", pragmas: e = {} }) {
  let s = `
`, r = "/**", n = " *", i = " */", o = Object.keys(e), u = o.flatMap((c) => Nn2(c, e[c])).map((c) => `${n} ${c}${s}`).join("");
  if (!t) {
    if (o.length === 0) return "";
    if (o.length === 1 && !Array.isArray(e[o[0]])) {
      let c = e[o[0]];
      return `${r} ${Nn2(o[0], c)[0]}${i}`;
    }
  }
  let a = t.split(s).map((c) => `${n} ${c}`).join(s) + s;
  return r + s + (t ? a : "") + (t && o.length > 0 ? n + s : "") + u + i;
}
function Nn2(t, e) {
  return [...Rn2, ...Array.isArray(e) ? e : [e]].map((s) => `@${t} ${s}`.trim());
}
var Mn2 = ["noformat", "noprettier"];
var Bn2 = ["format", "prettier"];
var Un2 = "format";
function ec(t) {
  if (!t.startsWith("#!")) return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var Fn2 = ec;
function Xr2(t) {
  let e = Fn2(t);
  e && (t = t.slice(e.length + 1));
  let s = In2(t), { pragmas: r, comments: n } = Ln2(s);
  return { shebang: e, text: t, pragmas: r, comments: n };
}
function $n2(t) {
  let { pragmas: e } = Xr2(t);
  return Bn2.some((s) => Object.prototype.hasOwnProperty.call(e, s));
}
function Wn2(t) {
  let { pragmas: e } = Xr2(t);
  return Mn2.some((s) => Object.prototype.hasOwnProperty.call(e, s));
}
function Gn2(t) {
  let { shebang: e, text: s, pragmas: r, comments: n } = Xr2(t), i = qn2(s), o = Dn2({ pragmas: { [Un2]: "", ...r }, comments: n.trimStart() });
  return (e ? `${e}
` : "") + o + (i.startsWith(`
`) ? `
` : `

`) + i;
}
var et2 = 3;
function tc(t) {
  let e = t.slice(0, et2);
  if (e !== "---" && e !== "+++") return;
  let s = t.indexOf(`
`, et2);
  if (s === -1) return;
  let r = t.slice(et2, s).trim(), n = t.indexOf(`
${e}`, s), i = r;
  if (i || (i = e === "+++" ? "toml" : "yaml"), n === -1 && e === "---" && i === "yaml" && (n = t.indexOf(`
...`, s)), n === -1) return;
  let o = n + 1 + et2, u = t.charAt(o + 1);
  if (!/\s?/u.test(u)) return;
  let a = t.slice(0, o);
  return { type: "front-matter", language: i, explicitLanguage: r, value: t.slice(s + 1, n), startDelimiter: e, endDelimiter: a.slice(-et2), raw: a };
}
function rc(t) {
  let e = tc(t);
  if (!e) return { content: t };
  let { raw: s } = e;
  return { frontMatter: e, content: E(false, s, /[^\n]/gu, " ") + t.slice(s.length) };
}
var Ce2 = rc;
function Yn2(t) {
  return $n2(Ce2(t).content);
}
function Vn2(t) {
  return Wn2(Ce2(t).content);
}
function zn2(t) {
  let { frontMatter: e, content: s } = Ce2(t);
  return (e ? e.raw + `

` : "") + Gn2(s);
}
var sc = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
function Hn2(t) {
  var e, s;
  return (s = (e = t.findAncestor((r) => r.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : s.toLowerCase();
}
var nc = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
function jn2(t) {
  return nc.has(t.toLowerCase());
}
function Kn2(t, e) {
  var r;
  let s = t.findAncestor((n) => n.type === "css-atrule");
  return ((r = s == null ? void 0 : s.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
}
function Ae2(t) {
  return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
}
function Ne2(t, e) {
  var r;
  let s = t.findAncestor((n) => n.type === "value-func");
  return ((r = s == null ? void 0 : s.value) == null ? void 0 : r.toLowerCase()) === e;
}
function Qn2(t) {
  var r;
  let e = t.findAncestor((n) => n.type === "css-rule"), s = (r = e == null ? void 0 : e.raws) == null ? void 0 : r.selector;
  return s && (s.startsWith(":import") || s.startsWith(":export"));
}
function he2(t, e) {
  let s = Array.isArray(e) ? e : [e], r = t.findAncestor((n) => n.type === "css-atrule");
  return r && s.includes(r.name.toLowerCase());
}
function Xn2(t) {
  var s;
  let { node: e } = t;
  return e.groups[0].value === "url" && e.groups.length === 2 && ((s = t.findAncestor((r) => r.type === "css-atrule")) == null ? void 0 : s.name) === "import";
}
function Jn2(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "url";
}
function Zn2(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "var";
}
function ei2(t) {
  let { selector: e } = t;
  return e ? typeof e == "string" && /^@.+:.*$/u.test(e) || e.value && /^@.+:.*$/u.test(e.value) : false;
}
function ti2(t) {
  return t.type === "value-word" && ["from", "through", "end"].includes(t.value);
}
function ri2(t) {
  return t.type === "value-word" && ["and", "or", "not"].includes(t.value);
}
function si(t) {
  return t.type === "value-word" && t.value === "in";
}
function It2(t) {
  return t.type === "value-operator" && t.value === "*";
}
function tt2(t) {
  return t.type === "value-operator" && t.value === "/";
}
function X2(t) {
  return t.type === "value-operator" && t.value === "+";
}
function de2(t) {
  return t.type === "value-operator" && t.value === "-";
}
function ic(t) {
  return t.type === "value-operator" && t.value === "%";
}
function qt2(t) {
  return It2(t) || tt2(t) || X2(t) || de2(t) || ic(t);
}
function ni2(t) {
  return t.type === "value-word" && ["==", "!="].includes(t.value);
}
function ii(t) {
  return t.type === "value-word" && ["<", ">", "<=", ">="].includes(t.value);
}
function rt2(t, e) {
  return e.parser === "scss" && t.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(t.name);
}
function Zr2(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/u.test(t.raws.params);
}
function Lt2(t) {
  return t.name.startsWith("prettier-placeholder");
}
function oi(t) {
  return t.prop.startsWith("@prettier-placeholder");
}
function ai(t, e) {
  return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
}
function ui2(t) {
  var e, s;
  return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((s = t.value.group) == null ? void 0 : s.type) === "value-value" && t.prop.toLowerCase() === "composes";
}
function li(t) {
  var e, s, r;
  return ((r = (s = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : s.group) == null ? void 0 : r.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
}
function me2(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.before) === "";
}
function Dt2(t) {
  var e, s;
  return t.type === "value-comma_group" && ((s = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : s.type) === "value-colon";
}
function Jr2(t) {
  var e;
  return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && Dt2(t.groups[0]);
}
function es(t, e) {
  var i;
  if (e.parser !== "scss") return false;
  let { node: s } = t;
  if (s.groups.length === 0) return false;
  let r = t.grandparent;
  if (!Jr2(s) && !(r && Jr2(r))) return false;
  let n = t.findAncestor((o) => o.type === "css-decl");
  return !!((i = n == null ? void 0 : n.prop) != null && i.startsWith("$") || Jr2(r) || r.type === "value-func");
}
function Pe2(t) {
  return t.type === "value-comment" && t.inline;
}
function Mt(t) {
  return t.type === "value-word" && t.value === "#";
}
function ts(t) {
  return t.type === "value-word" && t.value === "{";
}
function Bt2(t) {
  return t.type === "value-word" && t.value === "}";
}
function st2(t) {
  return ["value-word", "value-atword"].includes(t.type);
}
function nt2(t) {
  return (t == null ? void 0 : t.type) === "value-colon";
}
function ci(t, e) {
  if (!Dt2(e)) return false;
  let { groups: s } = e, r = s.indexOf(t);
  return r === -1 ? false : nt2(s[r + 1]);
}
function fi(t) {
  return t.value && ["not", "and", "or"].includes(t.value.toLowerCase());
}
function pi(t) {
  return t.type !== "value-func" ? false : sc.has(t.value.toLowerCase());
}
function Re2(t) {
  return /\/\//u.test(t.split(/[\n\r]/u).pop());
}
function it2(t) {
  return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
}
function hi(t, e) {
  var s, r;
  if (((s = t.open) == null ? void 0 : s.value) !== "(" || ((r = t.close) == null ? void 0 : r.value) !== ")" || t.groups.some((n) => n.type !== "value-comma_group")) return false;
  if (e.type === "value-comma_group") {
    let n = e.groups.indexOf(t) - 1, i = e.groups[n];
    if ((i == null ? void 0 : i.type) === "value-word" && i.value === "with") return true;
  }
  return false;
}
function ot2(t) {
  var e, s;
  return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((s = t.close) == null ? void 0 : s.value) === ")";
}
function oc(t, e, s) {
  var m;
  let { node: r } = t, n = t.parent, i = t.grandparent, o = Hn2(t), u = o && n.type === "value-value" && (o === "grid" || o.startsWith("grid-template")), a = t.findAncestor((y2) => y2.type === "css-atrule"), c = a && rt2(a, e), f = r.groups.some((y2) => Pe2(y2)), p = t.map(s, "groups"), l = [""], d = Ne2(t, "url"), x = false, h = false;
  for (let y2 = 0; y2 < r.groups.length; ++y2) {
    let b2 = r.groups[y2 - 1], w2 = r.groups[y2], v2 = r.groups[y2 + 1], R2 = r.groups[y2 + 2];
    if (Pe2(w2) && !v2) {
      l.push([l.pop(), un2([" ", p[y2]])]);
      continue;
    }
    if (l.push([l.pop(), p[y2]]), d) {
      (v2 && X2(v2) || X2(w2)) && l.push([l.pop(), " "]);
      continue;
    }
    if (nt2(v2) && w2.type === "value-word" && l.length > 2 && r.groups.slice(0, y2).every((C) => C.type === "value-comment") && !Pe2(b2) && (l[l.length - 2] = ae2($(false, l, -2))), he2(t, "forward") && w2.type === "value-word" && w2.value && b2 !== void 0 && b2.type === "value-word" && b2.value === "as" && v2.type === "value-operator" && v2.value === "*" || he2(t, "utility") && w2.type === "value-word" && v2 && v2.type === "value-operator" && v2.value === "*" || !v2 || w2.type === "value-word" && it2(v2) && P2(w2) === N2(v2)) continue;
    if (w2.type === "value-string" && w2.quoted) {
      let C = w2.value.lastIndexOf("#{"), xe2 = w2.value.lastIndexOf("}");
      C !== -1 && xe2 !== -1 ? x = C > xe2 : C !== -1 ? x = true : xe2 !== -1 && (x = false);
    }
    if (x || nt2(w2) || nt2(v2) || w2.type === "value-atword" && (w2.value === "" || w2.value.endsWith("[")) || v2.type === "value-word" && v2.value.startsWith("]") || w2.value === "~" || w2.type !== "value-string" && w2.value && w2.value.includes("\\") && v2 && v2.type !== "value-comment" || b2 != null && b2.value && b2.value.indexOf("\\") === b2.value.length - 1 && w2.type === "value-operator" && w2.value === "/" || w2.value === "\\" || ai(w2, v2) || Mt(w2) || ts(w2) || Bt2(v2) || ts(v2) && me2(v2) || Bt2(w2) && me2(v2) || w2.value === "--" && Mt(v2)) continue;
    let F = qt2(w2), Q2 = qt2(v2);
    if ((F && Mt(v2) || Q2 && Bt2(w2)) && me2(v2) || !b2 && tt2(w2) || Ne2(t, "calc") && (X2(w2) || X2(v2) || de2(w2) || de2(v2)) && me2(v2)) continue;
    let W2 = (X2(w2) || de2(w2)) && y2 === 0 && (v2.type === "value-number" || v2.isHex) && i && pi(i) && !me2(v2), T2 = (R2 == null ? void 0 : R2.type) === "value-func" || R2 && st2(R2) || w2.type === "value-func" || st2(w2), O2 = v2.type === "value-func" || st2(v2) || (b2 == null ? void 0 : b2.type) === "value-func" || b2 && st2(b2);
    if (e.parser === "scss" && F && w2.value === "-" && v2.type === "value-func" && P2(w2) !== N2(v2)) {
      l.push([l.pop(), " "]);
      continue;
    }
    if (!(!(It2(v2) || It2(w2)) && !Ne2(t, "calc") && !W2 && (tt2(v2) && !T2 || tt2(w2) && !O2 || X2(v2) && !T2 || X2(w2) && !O2 || de2(v2) || de2(w2)) && (me2(v2) || F && (!b2 || b2 && qt2(b2)))) && !((e.parser === "scss" || e.parser === "less") && F && w2.value === "-" && ot2(v2) && P2(w2) === N2(v2.open) && v2.open.value === "(")) {
      if (Pe2(w2)) {
        if (n.type === "value-paren_group") {
          l.push(ae2(S2), "");
          continue;
        }
        l.push(S2, "");
        continue;
      }
      if (c && (ni2(v2) || ii(v2) || ri2(v2) || si(w2) || ti2(w2))) {
        l.push([l.pop(), " "]);
        continue;
      }
      if (a && a.name.toLowerCase() === "namespace") {
        l.push([l.pop(), " "]);
        continue;
      }
      if (u) {
        w2.source && v2.source && w2.source.start.line !== v2.source.start.line ? (l.push(S2, ""), h = true) : l.push([l.pop(), " "]);
        continue;
      }
      if (Q2) {
        l.push([l.pop(), " "]);
        continue;
      }
      if ((v2 == null ? void 0 : v2.value) !== "..." && !(it2(w2) && it2(v2) && P2(w2) === N2(v2))) {
        if (it2(w2) && ot2(v2) && P2(w2) === N2(v2.open)) {
          l.push(D, "");
          continue;
        }
        if (w2.value === "with" && ot2(v2)) {
          l = [[Te2(l), " "]];
          continue;
        }
        (m = w2.value) != null && m.endsWith("#") && v2.value === "{" && ot2(v2.group) || Pe2(v2) && !R2 || l.push(A, "");
      }
    }
  }
  return f && l.push([l.pop(), Xe2]), h && l.unshift("", S2), c ? L2(q2(l)) : Xn2(t) ? L2(Te2(l)) : L2(q2(Te2(l)));
}
var di = oc;
function ac(t) {
  return t.length === 1 ? t : t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/u, "$1").replace(/^([+-])?\./u, "$10.").replace(/(\.\d+?)0+(?=e|$)/u, "$1").replace(/\.(?=e|$)/u, "");
}
var mi = ac;
var Ut2 = /* @__PURE__ */ new Map([["em", "em"], ["rem", "rem"], ["ex", "ex"], ["rex", "rex"], ["cap", "cap"], ["rcap", "rcap"], ["ch", "ch"], ["rch", "rch"], ["ic", "ic"], ["ric", "ric"], ["lh", "lh"], ["rlh", "rlh"], ["vw", "vw"], ["svw", "svw"], ["lvw", "lvw"], ["dvw", "dvw"], ["vh", "vh"], ["svh", "svh"], ["lvh", "lvh"], ["dvh", "dvh"], ["vi", "vi"], ["svi", "svi"], ["lvi", "lvi"], ["dvi", "dvi"], ["vb", "vb"], ["svb", "svb"], ["lvb", "lvb"], ["dvb", "dvb"], ["vmin", "vmin"], ["svmin", "svmin"], ["lvmin", "lvmin"], ["dvmin", "dvmin"], ["vmax", "vmax"], ["svmax", "svmax"], ["lvmax", "lvmax"], ["dvmax", "dvmax"], ["cm", "cm"], ["mm", "mm"], ["q", "Q"], ["in", "in"], ["pt", "pt"], ["pc", "pc"], ["px", "px"], ["deg", "deg"], ["grad", "grad"], ["rad", "rad"], ["turn", "turn"], ["s", "s"], ["ms", "ms"], ["hz", "Hz"], ["khz", "kHz"], ["dpi", "dpi"], ["dpcm", "dpcm"], ["dppx", "dppx"], ["x", "x"], ["cqw", "cqw"], ["cqh", "cqh"], ["cqi", "cqi"], ["cqb", "cqb"], ["cqmin", "cqmin"], ["cqmax", "cqmax"], ["fr", "fr"]]);
function rs(t) {
  let e = t.toLowerCase();
  return Ut2.has(e) ? Ut2.get(e) : t;
}
var yi = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gsu;
var uc = /(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/giu;
var lc = /[a-z]+/giu;
var cc = /[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/giu;
var fc = new RegExp(yi.source + `|(${cc.source})?(${uc.source})(${lc.source})?`, "giu");
function Y2(t, e) {
  return E(false, t, yi, (s) => At2(s, e));
}
function gi(t, e) {
  let s = e.singleQuote ? "'" : '"';
  return t.includes('"') || t.includes("'") ? t : s + t + s;
}
function ye2(t) {
  return E(false, t, fc, (e, s, r, n, i) => !r && n && (i != null ? i : i = "", i = i.toLowerCase(), !i || i === "n" || Ut2.has(i)) ? ss(n) + (i ? rs(i) : "") : e);
}
function ss(t) {
  return mi(t).replace(/\.0(?=$|e)/u, "");
}
function wi(t) {
  return t.trailingComma === "es5" || t.trailingComma === "all";
}
function pc(t, e, s) {
  let r = !!(s != null && s.backwards);
  if (e === false) return false;
  let n = t.charAt(e);
  if (r) {
    if (t.charAt(e - 1) === "\r" && n === `
`) return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029") return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`) return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029") return e + 1;
  }
  return e;
}
var Ft = pc;
function hc(t, e, s = {}) {
  let r = Pt2(t, s.backwards ? e - 1 : e, s), n = Ft(t, r, s);
  return r !== n;
}
var $t2 = hc;
function dc(t, e) {
  if (e === false) return false;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let s = e + 2; s < t.length; ++s) if (t.charAt(s) === "*" && t.charAt(s + 1) === "/") return s + 2;
  }
  return e;
}
var vi = dc;
function mc(t, e) {
  return e === false ? false : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? Rt2(t, e) : e;
}
var xi = mc;
function yc(t, e) {
  let s = null, r = e;
  for (; r !== s; ) s = r, r = En2(t, r), r = vi(t, r), r = Pt2(t, r);
  return r = xi(t, r), r = Ft(t, r), r !== false && $t2(t, r);
}
var Wt2 = yc;
function gc({ node: t, parent: e }, s) {
  return !!(t.source && s.originalText.slice(N2(t), N2(e.close)).trimEnd().endsWith(","));
}
function wc(t, e) {
  return Zn2(t.grandparent) && gc(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((s) => s.type === "value-comment")) && wi(e) && t.callParent(() => es(t, e)) ? Ot2(",") : "";
}
function bi(t, e, s) {
  let { node: r, parent: n } = t, i = t.map(({ node: d }) => typeof d == "string" ? d : s(), "groups");
  if (n && Jn2(n) && (r.groups.length === 1 || r.groups.length > 0 && r.groups[0].type === "value-comma_group" && r.groups[0].groups.length > 0 && r.groups[0].groups[0].type === "value-word" && r.groups[0].groups[0].value.startsWith("data:"))) return [r.open ? s("open") : "", G2(",", i), r.close ? s("close") : ""];
  if (!r.open) {
    let d = ns(t);
    Qe2(i);
    let x = xc(G2(",", i), 2), h = G2(d ? S2 : A, x);
    return q2(d ? [S2, h] : L2([vc(t) ? D : "", Te2(h)]));
  }
  let o = t.map(({ node: d, isLast: x, index: h }) => {
    var b2;
    let m = i[h];
    Dt2(d) && d.type === "value-comma_group" && d.groups && d.groups[0].type !== "value-paren_group" && ((b2 = d.groups[2]) == null ? void 0 : b2.type) === "value-paren_group" && j2(m) === se2 && j2(m.contents) === re2 && j2(m.contents.contents) === ne2 && (m = L2(ae2(m)));
    let y2 = [m, x ? wc(t, e) : ","];
    if (!x && d.type === "value-comma_group" && ue(d.groups)) {
      let w2 = $(false, d.groups, -1);
      !w2.source && w2.close && (w2 = w2.close), w2.source && Wt2(e.originalText, P2(w2)) && y2.push(S2);
    }
    return y2;
  }, "groups"), u = ci(r, n), a = hi(r, n), c = es(t, e), f = a || c && !u, p = a || u, l = L2([r.open ? s("open") : "", q2([D, G2(A, o)]), D, r.close ? s("close") : ""], { shouldBreak: f });
  return p ? ae2(l) : l;
}
function ns(t) {
  return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((s) => s.type === "value-comma_group"), (e, s) => s === "group" && e.type === "value-value", (e, s) => s === "group" && e.type === "value-root", (e, s) => s === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
}
function vc(t) {
  return t.match((e) => e.type === "value-paren_group" && !e.open, (e, s) => s === "group" && e.type === "value-value", (e, s) => s === "group" && e.type === "value-root", (e, s) => s === "value" && e.type === "css-decl");
}
function xc(t, e) {
  let s = [];
  for (let r = 0; r < t.length; r += e) s.push(t.slice(r, r + e));
  return s;
}
function bc(t, e, s) {
  let r = [];
  return t.each(() => {
    let { node: n, previous: i } = t;
    if ((i == null ? void 0 : i.type) === "css-comment" && i.text.trim() === "prettier-ignore" ? r.push(e.originalText.slice(N2(n), P2(n))) : r.push(s()), t.isLast) return;
    let { next: o } = t;
    o.type === "css-comment" && !$t2(e.originalText, N2(o), { backwards: true }) && !Oe2(n) || o.type === "css-atrule" && o.name === "else" && n.type !== "css-comment" ? r.push(" ") : (r.push(e.__isHTMLStyleAttribute ? A : S2), Wt2(e.originalText, P2(n)) && !Oe2(n) && r.push(S2));
  }, "nodes"), r;
}
var Ie2 = bc;
function _c(t, e, s) {
  var _a2;
  var n, i, o, u, a, c;
  let { node: r } = t;
  switch (r.type) {
    case "front-matter":
      return [r.raw, S2];
    case "css-root": {
      let f = Ie2(t, e, s), p = r.raws.after.trim();
      return p.startsWith(";") && (p = p.slice(1).trim()), [r.frontMatter ? [s("frontMatter"), S2] : "", f, p ? ` ${p}` : "", r.nodes.length > 0 ? S2 : ""];
    }
    case "css-comment": {
      let f = r.inline || r.raws.inline, p = e.originalText.slice(N2(r), P2(r));
      return f ? p.trimEnd() : p;
    }
    case "css-rule":
      return [s("selector"), r.important ? " !important" : "", r.nodes ? [((n = r.selector) == null ? void 0 : n.type) === "selector-unknown" && Re2(r.selector.value) ? A : r.selector ? " " : "", "{", r.nodes.length > 0 ? q2([S2, Ie2(t, e, s)]) : "", S2, "}", ei2(r) ? ";" : ""] : ";"];
    case "css-decl": {
      let f = t.parent, { between: p } = r.raws, l = p.trim(), d = l === ":", x = typeof r.value == "string" && /^ *$/u.test(r.value), h = typeof r.value == "string" ? r.value : s("value");
      return h = ui2(r) ? sn2(h) : h, !d && Re2(l) && !((o = (i = r.value) == null ? void 0 : i.group) != null && o.group && t.call(() => ns(t), "value", "group", "group")) && (h = q2([S2, ae2(h)])), [E(false, r.raws.before, /[\s;]/gu, ""), f.type === "css-atrule" && f.variable || Qn2(t) ? r.prop : Ae2(r.prop), l.startsWith("//") ? " " : "", l, r.extend || x ? "" : " ", e.parser === "less" && r.extend && r.selector ? ["extend(", s("selector"), ")"] : "", h, r.raws.important ? r.raws.important.replace(/\s*!\s*important/iu, " !important") : r.important ? " !important" : "", r.raws.scssDefault ? r.raws.scssDefault.replace(/\s*!default/iu, " !default") : r.scssDefault ? " !default" : "", r.raws.scssGlobal ? r.raws.scssGlobal.replace(/\s*!global/iu, " !global") : r.scssGlobal ? " !global" : "", r.nodes ? [" {", q2([D, Ie2(t, e, s)]), D, "}"] : oi(r) && !f.raws.semicolon && e.originalText[P2(r) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && t.isLast ? Ot2(";") : ";"];
    }
    case "css-atrule": {
      let f = t.parent, p = Lt2(r) && !f.raws.semicolon && e.originalText[P2(r) - 1] !== ";";
      if (e.parser === "less") {
        if (r.mixin) return [s("selector"), r.important ? " !important" : "", p ? "" : ";"];
        if (r.function) return [r.name, typeof r.params == "string" ? r.params : s("params"), p ? "" : ";"];
        if (r.variable) return ["@", r.name, ": ", r.value ? s("value") : "", r.raws.between.trim() ? r.raws.between.trim() + " " : "", r.nodes ? ["{", q2([r.nodes.length > 0 ? D : "", Ie2(t, e, s)]), D, "}"] : "", p ? "" : ";"];
      }
      let l = r.name === "import" && ((u = r.params) == null ? void 0 : u.type) === "value-unknown" && r.params.value.endsWith(";");
      return ["@", Zr2(r) || r.name.endsWith(":") || Lt2(r) ? r.name : Ae2(r.name), r.params ? [Zr2(r) ? "" : Lt2(r) ? r.raws.afterName === "" ? "" : r.name.endsWith(":") ? " " : /^\s*\n\s*\n/u.test(r.raws.afterName) ? [S2, S2] : /^\s*\n/u.test(r.raws.afterName) ? S2 : " " : " ", typeof r.params == "string" ? r.params : s("params")] : "", r.selector ? q2([" ", s("selector")]) : "", r.value ? L2([" ", s("value"), rt2(r, e) ? li(r) ? " " : A : ""]) : r.name === "else" ? " " : "", r.nodes ? [rt2(r, e) ? "" : r.selector && !r.selector.nodes && typeof r.selector.value == "string" && Re2(r.selector.value) || !r.selector && typeof r.params == "string" && Re2(r.params) ? A : " ", "{", q2([r.nodes.length > 0 ? D : "", Ie2(t, e, s)]), D, "}"] : p || l ? "" : ";"];
    }
    case "media-query-list": {
      let f = [];
      return t.each(({ node: p }) => {
        p.type === "media-query" && p.value === "" || f.push(s());
      }, "nodes"), L2(q2(G2(A, f)));
    }
    case "media-query":
      return [G2(" ", t.map(s, "nodes")), t.isLast ? "" : ","];
    case "media-type":
      return ye2(Y2(r.value, e));
    case "media-feature-expression":
      return r.nodes ? ["(", ...t.map(s, "nodes"), ")"] : r.value;
    case "media-feature":
      return Ae2(Y2(E(false, r.value, / +/gu, " "), e));
    case "media-colon":
      return [r.value, " "];
    case "media-value":
      return ye2(Y2(r.value, e));
    case "media-keyword":
      return Y2(r.value, e);
    case "media-url":
      return Y2(E(false, E(false, r.value, /^url\(\s+/giu, "url("), /\s+\)$/gu, ")"), e);
    case "media-unknown":
      return r.value;
    case "selector-root":
      return L2([he2(t, "custom-selector") ? [t.findAncestor((f) => f.type === "css-atrule").customSelector, A] : "", G2([",", he2(t, ["extend", "custom-selector", "nest"]) ? A : S2], t.map(s, "nodes"))]);
    case "selector-selector": {
      let f = r.nodes.length > 2;
      return L2((f ? q2 : (p) => p)(t.map(s, "nodes")));
    }
    case "selector-comment":
      return r.value;
    case "selector-string":
      return Y2(r.value, e);
    case "selector-tag":
      return [r.namespace ? [r.namespace === true ? "" : r.namespace.trim(), "|"] : "", ((a = t.previous) == null ? void 0 : a.type) === "selector-nesting" ? r.value : ye2(Kn2(t, r.value) ? r.value.toLowerCase() : r.value)];
    case "selector-id":
      return ["#", r.value];
    case "selector-class":
      return [".", ye2(Y2(r.value, e))];
    case "selector-attribute":
      return ["[", r.namespace ? [r.namespace === true ? "" : r.namespace.trim(), "|"] : "", r.attribute.trim(), (_a2 = r.operator) != null ? _a2 : "", r.value ? gi(Y2(r.value.trim(), e), e) : "", r.insensitive ? " i" : "", "]"];
    case "selector-combinator": {
      if (r.value === "+" || r.value === ">" || r.value === "~" || r.value === ">>>") {
        let l = t.parent;
        return [l.type === "selector-selector" && l.nodes[0] === r ? "" : A, r.value, t.isLast ? "" : " "];
      }
      let f = r.value.trim().startsWith("(") ? A : "", p = ye2(Y2(r.value.trim(), e)) || A;
      return [f, p];
    }
    case "selector-universal":
      return [r.namespace ? [r.namespace === true ? "" : r.namespace.trim(), "|"] : "", r.value];
    case "selector-pseudo":
      return [Ae2(r.value), ue(r.nodes) ? L2(["(", q2([D, G2([",", A], t.map(s, "nodes"))]), D, ")"]) : ""];
    case "selector-nesting":
      return r.value;
    case "selector-unknown": {
      let f = t.findAncestor((d) => d.type === "css-rule");
      if (f != null && f.isSCSSNesterProperty) return ye2(Y2(Ae2(r.value), e));
      let p = t.parent;
      if ((c = p.raws) != null && c.selector) {
        let d = N2(p), x = d + p.raws.selector.length;
        return e.originalText.slice(d, x).trim();
      }
      let l = t.grandparent;
      if (p.type === "value-paren_group" && (l == null ? void 0 : l.type) === "value-func" && l.value === "selector") {
        let d = P2(p.open) + 1, x = N2(p.close), h = e.originalText.slice(d, x).trim();
        return Re2(h) ? [Xe2, h] : h;
      }
      return r.value;
    }
    case "value-value":
    case "value-root":
      return s("group");
    case "value-comment":
      return e.originalText.slice(N2(r), P2(r));
    case "value-comma_group":
      return di(t, e, s);
    case "value-paren_group":
      return bi(t, e, s);
    case "value-func":
      return [r.value, he2(t, "supports") && fi(r) ? " " : "", s("group")];
    case "value-paren":
      return r.value;
    case "value-number":
      return [ss(r.value), rs(r.unit)];
    case "value-operator":
      return r.value;
    case "value-word":
      return r.isColor && r.isHex || jn2(r.value) ? r.value.toLowerCase() : r.value;
    case "value-colon": {
      let { previous: f } = t;
      return L2([r.value, typeof (f == null ? void 0 : f.value) == "string" && f.value.endsWith("\\") || Ne2(t, "url") ? "" : A]);
    }
    case "value-string":
      return At2(r.raws.quote + r.value + r.raws.quote, e);
    case "value-atword":
      return ["@", r.value];
    case "value-unicode-range":
      return r.value;
    case "value-unknown":
      return r.value;
    case "value-comma":
    default:
      throw new dn2(r, "PostCSS");
  }
}
var Ec = { print: _c, embed: vn2, insertPragma: zn2, massageAstNode: yn2, getVisitorKeys: _n2 };
var _i = Ec;
var Ei = [{ name: "CSS", type: "markup", extensions: [".css", ".wxss"], tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["css"], vscodeLanguageIds: ["css"], linguistLanguageId: 50 }, { name: "PostCSS", type: "markup", extensions: [".pcss", ".postcss"], tmScope: "source.postcss", aceMode: "text", group: "CSS", parsers: ["css"], vscodeLanguageIds: ["postcss"], linguistLanguageId: 262764437 }, { name: "Less", type: "markup", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", aliases: ["less-css"], codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"], linguistLanguageId: 198 }, { name: "SCSS", type: "markup", extensions: [".scss"], tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", parsers: ["scss"], vscodeLanguageIds: ["scss"], linguistLanguageId: 329 }];
var ki = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
var kc = { singleQuote: ki.singleQuote };
var Si = kc;
var Zs = {};
rn2(Zs, { css: () => My, less: () => By, scss: () => Uy });
var hl = be2(gt2(), 1);
var dl = be2(Io2(), 1);
var ml = be2(ha(), 1);
function cp(t, e) {
  let s = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(s, e);
}
var da = cp;
var ba = be2(xa(), 1);
function Z2(t, e, s) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let r in t) Z2(t[r], e, s), r === "type" && typeof t[r] == "string" && !t[r].startsWith(e) && (!s || !s.test(t[r])) && (t[r] = e + t[r]);
  }
  return t;
}
function Ms(t) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let e in t) Ms(t[e]);
    !Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
  }
  return t;
}
var _p = ba.default.default;
function Ep(t) {
  let e;
  try {
    e = _p(t);
  } catch (e2) {
    return { type: "selector-unknown", value: t };
  }
  return Z2(Ms(e), "media-");
}
var _a = Ep;
var yu2 = be2(mu2(), 1);
function Mm(t) {
  if (/\/\/|\/\*/u.test(t)) return { type: "selector-unknown", value: t.trim() };
  let e;
  try {
    new yu2.default((s) => {
      e = s;
    }).process(t);
  } catch (e2) {
    return { type: "selector-unknown", value: t };
  }
  return Z2(e, "selector-");
}
var te2 = Mm;
var ll = be2(sl(), 1);
var Sy = (t) => {
  for (; t.parent; ) t = t.parent;
  return t;
};
var Fr2 = Sy;
function Ty(t) {
  return Fr2(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
}
var nl = Ty;
function Oy(t) {
  if (ue(t)) {
    for (let e = t.length - 1; e > 0; e--) if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#")) return true;
  }
  return false;
}
var il = Oy;
function Cy(t) {
  return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
}
var ol = Cy;
function Ay(t, e) {
  return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
}
var al = Ay;
var ul = (t) => t.type === "paren" && t.value === ")";
function Ny(t, e) {
  var _a2;
  var a;
  let { nodes: s } = t, r = { open: null, close: null, groups: [], type: "paren_group" }, n = [r], i = r, o = { groups: [], type: "comma_group" }, u = [o];
  for (let c = 0; c < s.length; ++c) {
    let f = s[c];
    if (e.parser === "scss" && f.type === "number" && f.unit === ".." && f.value.endsWith(".") && (f.value = f.value.slice(0, -1), f.unit = "..."), f.type === "func" && f.value === "selector" && (f.group.groups = [te2(Fr2(t).text.slice(f.group.open.sourceIndex + 1, f.group.close.sourceIndex))]), f.type === "func" && f.value === "url") {
      let p = (_a2 = (a = f.group) == null ? void 0 : a.groups) != null ? _a2 : [], l = [];
      for (let d = 0; d < p.length; d++) {
        let x = p[d];
        x.type === "comma_group" ? l = [...l, ...x.groups] : l.push(x);
      }
      (il(l) || !ol(l) && !al(l[0], e)) && (f.group.groups = [nl(f)]);
    }
    if (f.type === "paren" && f.value === "(") r = { open: f, close: null, groups: [], type: "paren_group" }, n.push(r), o = { groups: [], type: "comma_group" }, u.push(o);
    else if (ul(f)) {
      if (o.groups.length > 0 && r.groups.push(o), r.close = f, u.length === 1) throw new Error("Unbalanced parenthesis");
      u.pop(), o = $(false, u, -1), o.groups.push(r), n.pop(), r = $(false, n, -1);
    } else if (f.type === "comma") {
      if (c === s.length - 3 && s[c + 1].type === "comment" && ul(s[c + 2])) continue;
      r.groups.push(o), o = { groups: [], type: "comma_group" }, u[u.length - 1] = o;
    } else o.groups.push(f);
  }
  return o.groups.length > 0 && r.groups.push(o), i;
}
function $r3(t) {
  return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? $r3(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? { ...t, groups: t.groups.map($r3) } : t;
}
function cl(t, e) {
  if (t && typeof t == "object") for (let s in t) s !== "parent" && (cl(t[s], e), s === "nodes" && (t.group = $r3(Ny(t, e)), delete t[s]));
  return t;
}
function Py(t, e) {
  if (e.parser === "less" && t.startsWith("~`")) return { type: "value-unknown", value: t };
  let s = null;
  try {
    s = new ll.default(t, { loose: true }).parse();
  } catch (e2) {
    return { type: "value-unknown", value: t };
  }
  s.text = t;
  let r = cl(s, e);
  return Z2(r, "value-", /^selector-/u);
}
var pe2 = Py;
var Ry = /* @__PURE__ */ new Set(["import", "use", "forward"]);
function Iy(t) {
  return Ry.has(t);
}
var fl = Iy;
function qy(t, e) {
  return e.parser !== "scss" || !t.selector ? false : t.selector.replace(/\/\*.*?\*\//u, "").replace(/\/\/.*\n/u, "").trim().endsWith(":");
}
var pl = qy;
var Ly = /(\s*)(!default).*$/u;
var Dy = /(\s*)(!global).*$/u;
function yl(t, e) {
  var _a2, _b, _c2, _d;
  var s, r;
  if (t && typeof t == "object") {
    delete t.parent;
    for (let u in t) yl(t[u], e);
    if (!t.type) return t;
    if ((_a2 = t.raws) != null ? _a2 : t.raws = {}, t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
      let u;
      if (t.value.trimEnd().endsWith("}")) {
        let a = e.originalText.slice(0, t.source.start.offset), c = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), f = E(false, a, /[^\n]/gu, " ") + c, p;
        e.parser === "scss" ? p = vl : e.parser === "less" ? p = wl : p = gl;
        let l;
        try {
          l = p(f, { ...e });
        } catch (e2) {
        }
        ((s = l == null ? void 0 : l.nodes) == null ? void 0 : s.length) === 1 && l.nodes[0].type === "css-rule" && (u = l.nodes[0].nodes);
      }
      return u ? t.value = { type: "css-rule", nodes: u } : t.value = { type: "value-unknown", value: t.raws.value.raw }, t;
    }
    let n = "";
    typeof t.selector == "string" && (n = t.raws.selector ? (_b = t.raws.selector.scss) != null ? _b : t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (n += t.raws.between), t.raws.selector = n);
    let i = "";
    typeof t.value == "string" && (i = t.raws.value ? (_c2 = t.raws.value.scss) != null ? _c2 : t.raws.value.raw : t.value, t.raws.value = i.trim());
    let o = "";
    if (typeof t.params == "string" && (o = t.raws.params ? (_d = t.raws.params.scss) != null ? _d : t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (o = t.raws.afterName + o), t.raws.between && t.raws.between.trim().length > 0 && (o = o + t.raws.between), o = o.trim(), t.raws.params = o), n.trim().length > 0) return n.startsWith("@") && n.endsWith(":") ? t : t.mixin ? (t.selector = pe2(n, e), t) : (pl(t, e) && (t.isSCSSNesterProperty = true), t.selector = te2(n), t);
    if (i.trim().length > 0) {
      let u = i.match(Ly);
      u && (i = i.slice(0, u.index), t.scssDefault = true, u[0].trim() !== "!default" && (t.raws.scssDefault = u[0]));
      let a = i.match(Dy);
      if (a && (i = i.slice(0, a.index), t.scssGlobal = true, a[0].trim() !== "!global" && (t.raws.scssGlobal = a[0])), i.startsWith("progid:")) return { type: "value-unknown", value: i };
      t.value = pe2(i, e);
    }
    if (e.parser === "less" && t.type === "css-decl" && i.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = te2(i.slice(7, -1)))), t.type === "css-atrule") {
      if (e.parser === "less") {
        if (t.mixin) {
          let u = t.raws.identifier + t.name + t.raws.afterName + t.raws.params;
          return t.selector = te2(u), delete t.params, t;
        }
        if (t.function) return t;
      }
      if (e.parser === "css" && t.name === "custom-selector") {
        let u = t.params.match(/:--\S+\s+/u)[0].trim();
        return t.customSelector = u, t.selector = te2(t.params.slice(u.length).trim()), delete t.params, t;
      }
      if (e.parser === "less") {
        if (t.name.includes(":") && !t.params) {
          t.variable = true;
          let u = t.name.split(":");
          t.name = u[0], t.value = pe2(u.slice(1).join(":"), e);
        }
        if (!["page", "nest", "keyframes"].includes(t.name) && ((r = t.params) == null ? void 0 : r[0]) === ":") {
          t.variable = true;
          let u = t.params.slice(1);
          u && (t.value = pe2(u, e)), t.raws.afterName += ":";
        }
        if (t.variable) return delete t.params, t.value || delete t.value, t;
      }
    }
    if (t.type === "css-atrule" && o.length > 0) {
      let { name: u } = t, a = t.name.toLowerCase();
      return u === "warn" || u === "error" ? (t.params = { type: "media-unknown", value: o }, t) : u === "extend" || u === "nest" ? (t.selector = te2(o), delete t.params, t) : u === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/su.test(o) ? t.params = pe2(o, e) : (t.selector = te2(o), delete t.params), t) : fl(a) ? (t.import = true, delete t.filename, t.params = pe2(o, e), t) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(u) ? (o = o.replace(/(\$\S+?)(\s+)?\.{3}/u, "$1...$2"), o = o.replace(/^(?!if)(\S+)(\s+)\(/u, "$1($2"), t.value = pe2(o, e), delete t.params, t) : ["media", "custom-media"].includes(a) ? o.includes("#{") ? { type: "media-unknown", value: o } : (t.params = _a(o), t) : (t.params = o, t);
    }
  }
  return t;
}
function Xs(t, e, s) {
  let r = Ce2(e), { frontMatter: n } = r;
  e = r.content;
  let i;
  try {
    i = t(e, { map: false });
  } catch (o) {
    let { name: u, reason: a, line: c, column: f } = o;
    throw typeof c != "number" ? o : da(`${u}: ${a}`, { loc: { start: { line: c, column: f } }, cause: o });
  }
  return s.originalText = e, i = yl(Z2(i, "css-"), s), Qr2(i, e), n && (n.source = { startOffset: 0, endOffset: n.raw.length }, i.frontMatter = n), i;
}
function gl(t, e = {}) {
  return Xs(hl.default.default, t, e);
}
function wl(t, e = {}) {
  return Xs((s) => dl.default.parse(On(s)), t, e);
}
function vl(t, e = {}) {
  return Xs(ml.default, t, e);
}
var Js = { astFormat: "postcss", hasPragma: Yn2, hasIgnorePragma: Vn2, locStart: N2, locEnd: P2 };
var My = { ...Js, parse: gl };
var By = { ...Js, parse: wl };
var Uy = { ...Js, parse: vl };
var Fy = { postcss: _i };
var s_ = en2;

// src/managers/css/CSSValidationService.ts
var CSSValidationService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Validate CSS syntax using Prettier's CSS parser.
   * Only called during manual save operations via saveElement().
   *
   * DESIGN DECISION: CSS Variables are NOT validated here.
   * CSS Variables are simple key-value pairs stored separately and don't
   * require CSS syntax validation. This method only validates CSS rules.
   *
   * @param cssCode The CSS code to validate
   * @returns true if valid, false if invalid
   */
  async validateCSS(cssCode) {
    const dangerousPatterns = [
      { pattern: /@import\s+url\(/i, name: "@import url()" },
      { pattern: /javascript:/i, name: "javascript:" },
      { pattern: /expression\(/i, name: "expression()" },
      { pattern: /behavior:/i, name: "behavior:" },
      { pattern: /-moz-binding:/i, name: "-moz-binding:" }
    ];
    for (const { pattern, name } of dangerousPatterns) {
      if (pattern.test(cssCode)) {
        Logger.error("CSS contains potentially dangerous content:", name);
        showNotice(`CSS contains unsafe content (${name}) and cannot be saved`, NOTICE_DURATIONS.STANDARD, "error");
        return false;
      }
    }
    try {
      await fu(cssCode, {
        parser: "css",
        plugins: [postcss_exports]
      });
      return true;
    } catch (error) {
      Logger.error("CSS validation failed:", error);
      showNotice("Invalid CSS syntax. Please check your code.", NOTICE_DURATIONS.STANDARD, "error");
      return false;
    }
  }
  /**
   * Format CSS code using Prettier.
   * Returns formatted CSS or null if formatting fails.
   *
   * @param cssCode The CSS code to format
   * @returns Formatted CSS string or null if invalid
   */
  async formatCSS(cssCode) {
    try {
      const formatted = await fu(cssCode, {
        parser: "css",
        plugins: [postcss_exports],
        tabWidth: Number(this.plugin.settings.editorTabWidth) || 4,
        useTabs: false
      });
      return formatted;
    } catch (error) {
      Logger.error("CSS formatting failed:", error);
      showNotice("Unable to format CSS. Please check syntax.", NOTICE_DURATIONS.STANDARD, "error");
      return null;
    }
  }
  /**
   * Update the full customCSS from all enabled rules.
   * Used when rules are added, updated, or toggled.
   */
  async updateCustomCSS(uuid, rule, css) {
    let fullCSS = "";
    const existingIndex = this.plugin.settings.cssRules.findIndex((el) => el.uuid === uuid);
    if (existingIndex >= 0) {
      if (this.plugin.settings.cssRules[existingIndex].enabled) {
        if (css !== "") {
          fullCSS += `/* ${rule} */
${css}

`;
        }
      }
    } else {
      if (css !== "") {
        fullCSS += `/* ${rule} */
${css}

`;
      }
    }
    this.plugin.settings.cssRules.forEach((cssRule) => {
      if (cssRule.uuid === uuid) return;
      if (cssRule.enabled) {
        fullCSS += `/* ${cssRule.rule} */
${cssRule.css}

`;
      }
    });
    this.plugin.settings.customCSS = fullCSS;
    await this.plugin.saveSettings();
  }
  /**
   * Update customCSS from all rules (for enable/disable operations)
   */
  async rebuildCustomCSS() {
    let fullCSS = "";
    this.plugin.settings.cssRules.forEach((rule) => {
      if (rule.enabled) {
        fullCSS += `/* ${rule.rule} */
${rule.css}

`;
      }
    });
    this.plugin.settings.customCSS = fullCSS;
    await this.plugin.saveSettings();
  }
  /**
   * Apply theme changes to the DOM
   */
  applyTheme() {
    this.plugin.themeManager.applyIfEnabled();
  }
};

// src/managers/css/CSSEditorManager.ts
var CSSEditorManager = class {
  constructor(workspace, plugin, view, config) {
    this.config = config;
    this.currentRule = "";
    this.editorEl = null;
    this.ruleInputEl = null;
    this.enabledToggleEl = null;
    this.editorSection = null;
    this.currentEditingElement = null;
    this.isEditingExisting = false;
    this.ruleListManager = null;
    // Timer tracking for cleanup
    this.timers = [];
    // Auto-apply changes when typing (with debounce)
    this.changeListener = (delta) => {
      const timeout = window.setTimeout(() => {
        let css = this.aceService.getValue();
        if (this.plugin.settings.autoApplyChanges) {
          const timer = window.setTimeout(() => {
            const css2 = this.aceService.getValue();
            if (css2 !== "") {
              this.applyChanges(css2);
            }
          }, this.plugin.settings.cssEditorDebounceDelay);
          this.timers.push(timer);
        }
      }, 10);
      this.timers.push(timeout);
    };
    this.plugin = plugin;
    this.view = view;
    this.app = plugin.app;
    this.workspace = workspace;
    this.settings = plugin.settings;
    this.aceService = new AceService(this.plugin);
    this.cssVariableManager = new CSSVariableManager(this.plugin);
    this.validationService = new CSSValidationService(plugin);
    this.ruleItemRenderer = new CSSRuleItemRenderer({
      plugin: this.plugin,
      view: this.view,
      aceService: this.aceService,
      onEdit: (rule, item) => this.handleEditRule(rule, item),
      onToggle: (rule, button) => this.handleToggleRule(rule, button),
      onDelete: (rule, item) => this.handleDeleteRule(rule, item)
    });
  }
  /**
   * Initialize the rule list manager once the container is available
   */
  initializeRuleListManager(container) {
    this.ruleListManager = new CSSRuleListManager(
      this.plugin,
      this.view,
      this.ruleItemRenderer,
      container
    );
  }
  /**
   * Shows or hides the CSS editor section.
   * @param show Whether to show (true) or hide (false) the editor
   */
  showEditorSection(show) {
    var _a2, _b;
    (_a2 = this.editorSection) == null ? void 0 : _a2.toggleClass("show", show);
    (_b = this.editorSection) == null ? void 0 : _b.toggleClass("hide", !show);
  }
  /**
   * Creates the CSS editor section in the DOM.
   * Initializes the Ace editor, input fields, buttons, and event handlers.
   * @param containerEl Parent element to create the editor section in
   */
  createEditorSection(containerEl) {
    this.editorSection = containerEl.createDiv("css-editor-section");
    this.editorUUID = this.editorSection.createEl(
      "input",
      {
        cls: "css-editor-uuid",
        attr: {
          type: "hidden"
        }
      }
    );
    const ruleContainer = this.editorSection.createDiv("editor-rule-container");
    ruleContainer.createSpan(
      {
        text: "CSS rule:"
      }
    );
    this.ruleInputEl = ruleContainer.createEl(
      "input",
      {
        attr: {
          type: "text",
          placeholder: "Enter a descriptive name "
        }
      }
    );
    this.editorEl = this.editorSection.createEl(
      "textarea",
      {
        cls: "css-editor",
        attr: {
          placeholder: "Enter CSS rules here..."
        }
      }
    );
    this.editor = this.aceService.createEditor(this.editorEl);
    this.aceService.configureEditor(this.config, "css");
    if (this.plugin.settings.enableAceSnippets) {
      this.editor.setOption("enableSnippets", true);
      const snippetManager = ace3.require("ace/snippets").snippetManager;
      const snippetContent = this.cssVariableManager.snippetManagerVars();
      const snippets = snippetManager.parseSnippetFile(snippetContent);
      snippetManager.register(snippets, "css");
    }
    const editorOptions = this.editorSection.createDiv(
      "editor-options-container",
      (el) => {
        el.addClass("hide");
      }
    );
    const wordwrapOptionContainer = editorOptions.createDiv("wordwrap-toggle-container");
    wordwrapOptionContainer.createEl(
      "label",
      {
        text: "Wordwrap:",
        attr: {
          "for": "toggle-wordwrap-checkbox"
        }
      }
    );
    const wordWrapCheckboxContainer = wordwrapOptionContainer.createDiv("checkbox-container");
    const wordWrapCheckbox = wordWrapCheckboxContainer.createEl(
      "input",
      {
        cls: "toggle-wordwrap-checkbox",
        attr: {
          id: "toggle-wordwrap-checkbox",
          type: "checkbox"
        }
      }
    );
    if (this.plugin.settings.editorWordWrap) {
      wordWrapCheckbox.checked = true;
      wordWrapCheckboxContainer.addClass("is-enabled");
    }
    wordWrapCheckboxContainer.addEventListener("click", () => {
      var _a2;
      const isEnabled = wordWrapCheckboxContainer.classList.toggle("is-enabled");
      wordWrapCheckbox.checked = isEnabled;
      (_a2 = this.editor) == null ? void 0 : _a2.getSession().setUseWrapMode(isEnabled);
    });
    const fontsizeOptionContainer = editorOptions.createDiv("font-size-container");
    fontsizeOptionContainer.createEl(
      "label",
      {
        text: "Font size:",
        attr: {
          "for": "fontsize-slider"
        }
      }
    );
    const fontsizeSliderContainer = fontsizeOptionContainer.createDiv("slider-container");
    const fontsizeSlider = fontsizeSliderContainer.createEl(
      "input",
      {
        cls: "slider",
        attr: {
          id: "fontsize-slider",
          type: "range",
          min: 5,
          max: 30,
          step: 1,
          value: this.plugin.settings.editorFontSize
        }
      }
    );
    const fontsizeDisplayValue = fontsizeOptionContainer.createDiv(
      "slider-value",
      (el) => {
        el.innerText = " " + this.plugin.settings.editorFontSize.toString();
      }
    );
    fontsizeSlider.addEventListener("change", (e) => {
      var _a2;
      let sliderValue = Number(e.target.value);
      (_a2 = this.editor) == null ? void 0 : _a2.setFontSize(sliderValue);
      fontsizeDisplayValue.innerText = sliderValue.toString();
    });
    const buttonContainer = this.editorSection.createDiv("button-container");
    if (!this.plugin.settings.autoApplyChanges) {
      const applyButton = buttonContainer.createEl(
        "button",
        {
          text: "Apply changes"
        }
      );
      applyButton.addEventListener("click", () => {
        this.applyChanges(this.aceService.getValue());
      });
    }
    const saveButton = buttonContainer.createEl(
      "button",
      {
        text: "Save rule",
        cls: "mod-cta"
      }
    );
    const cancelButton = buttonContainer.createEl(
      "button",
      {
        text: "Cancel"
      }
    );
    const formatButton = buttonContainer.createEl(
      "button",
      {
        cls: "clickable-icon",
        attr: {
          "aria-label": "Format CSS with Prettier",
          "data-tooltip-position": "top"
        }
      }
    );
    (0, import_obsidian7.setIcon)(formatButton, "wand-sparkles");
    formatButton.addEventListener("click", async () => {
      const currentCSS = this.aceService.getValue();
      if (!currentCSS || currentCSS.trim() === "") {
        showNotice("No CSS to format", 2e3, "info");
        return;
      }
      const cursorPosition = this.editor.getCursorPosition();
      const formatted = await this.validationService.formatCSS(currentCSS);
      if (formatted) {
        const Range = ace3.require("ace/range").Range;
        const fullRange = new Range(
          0,
          0,
          this.editor.session.getLength(),
          this.editor.session.getLine(this.editor.session.getLength() - 1).length
        );
        this.editor.session.replace(fullRange, formatted);
        try {
          this.editor.moveCursorToPosition(cursorPosition);
        } catch (e) {
          this.editor.navigateFileStart();
        }
        showNotice("CSS formatted successfully", 2e3, "success");
      }
    });
    const settingsButton = buttonContainer.createEl(
      "button",
      {
        cls: "clickable-icon",
        attr: {
          "aria-label": "Show editor options",
          "data-tooltip-position": "top"
        }
      }
    );
    (0, import_obsidian7.setIcon)(settingsButton, "settings-2");
    settingsButton.addEventListener("click", () => {
      const shouldExpand = editorOptions.hasClass("hide");
      editorOptions.toggleClass("show", shouldExpand);
      editorOptions.toggleClass("hide", !shouldExpand);
      settingsButton.setAttr(
        "aria-label",
        shouldExpand ? "Hide editor options" : "Show editor options"
      );
    });
    this.ruleInputEl.addEventListener("input", () => {
      this.currentRule = this.ruleInputEl.value;
    });
    this.ruleInputEl.addEventListener("change", () => {
      this.currentRule = this.ruleInputEl.value;
      if (this.plugin.settings.autoApplyChanges) {
        const css = this.aceService.getValue();
        if (css !== "") {
          this.applyChanges(css);
        }
      }
    });
    saveButton.addEventListener("click", async () => {
      if (await this.saveElement()) {
        if (!this.isEditingExisting) {
          this.showEditorSection(false);
        } else {
          this.removeInlineEditor();
        }
      }
      if (this.view.ruleSearch) {
        await this.view.filterCSSRules(this.view.ruleSearch);
      }
    });
    cancelButton.addEventListener("click", () => {
      if (this.isEditingExisting) {
        this.removeInlineEditor();
      } else {
        this.showEditorSection(false);
      }
      this.resetEditor();
      this.clearAppliedChanges();
    });
    this.plugin.registerEvent(
      this.workspace.on("css-change", async () => {
        this.aceService.updateTheme();
      })
    );
  }
  setRule(uuid, rule, isEditingExisting) {
    if (!this.ruleInputEl || !this.editorUUID) return;
    const existingRule = this.plugin.settings.cssRules.find((el) => el.uuid === uuid);
    if (existingRule) {
      this.currentRule = existingRule.rule;
      this.ruleInputEl.value = existingRule.rule;
      this.editorUUID.value = existingRule.uuid;
      this.editorEl.value = existingRule.css;
      this.aceService.setValue(existingRule.css, 1);
    } else {
      this.currentRule = rule;
      this.ruleInputEl.value = rule;
      this.editorUUID.value = uuid;
      this.generateDefaultCSS(rule);
      showNotice(`Element selected: ${rule}`, NOTICE_DURATIONS.STANDARD, "success");
    }
    this.editor.session.on("change", this.changeListener);
  }
  generateDefaultCSS(selector) {
    if (!this.editorEl) return;
    const element = this.findElementBySelector(selector);
    let css = "";
    const computedStyle = getComputedStyle(element);
    if (element && this.plugin.settings.generateComputedCSS) {
      css += `${selector} {
`;
      css += `  /* Basic styling */
`;
      css += `  color: ${computedStyle.color};
`;
      css += `  background-color: ${computedStyle.backgroundColor};
`;
      if (computedStyle.borderWidth !== "0px") {
        css += `  border: ${computedStyle.borderWidth} ${computedStyle.borderStyle} ${computedStyle.borderColor};
`;
      }
      css += `  padding: ${computedStyle.padding};
`;
      css += `  margin: ${computedStyle.margin};
`;
      css += `  font-family: ${computedStyle.fontFamily};
`;
      css += `  font-size: ${computedStyle.fontSize};
`;
      css += `  font-weight: ${computedStyle.fontWeight};
`;
      css += `}
`;
      css += `
`;
      css += `${selector}:hover {
`;
      css += `  /* Hover state styling */
`;
      css += `  /* background-color: var(--interactive-hover); */
`;
      css += `}
`;
    } else {
      css += `${selector} {
`;
      css += `	
`;
      css += `}`;
    }
    this.aceService.setValue(css, 1);
  }
  /**
   * Validate and find element by CSS selector
   *
   * @param selector CSS selector to validate and query
   * @returns HTMLElement if found, null if invalid or not found
   */
  findElementBySelector(selector) {
    if (!selector || selector.trim().length === 0) {
      Logger.error("Empty selector provided");
      showNotice("Selector cannot be empty", NOTICE_DURATIONS.SHORT, "error");
      return null;
    }
    const dangerousPatterns = [
      /javascript:/i,
      /<script/i,
      /on\w+\s*=/i
      // onclick=, onerror=, etc.
    ];
    for (const pattern of dangerousPatterns) {
      if (pattern.test(selector)) {
        Logger.error("Potentially dangerous selector:", selector);
        showNotice("Selector contains unsafe content", NOTICE_DURATIONS.SHORT, "error");
        return null;
      }
    }
    try {
      return document.querySelector(selector);
    } catch (error) {
      Logger.error(`Invalid CSS selector: ${selector}`, error);
      showNotice("Invalid CSS selector syntax", NOTICE_DURATIONS.SHORT, "error");
      return null;
    }
  }
  /**
   * Apply CSS changes to the theme without validation.
   * Used for auto-apply/live-preview functionality.
   *
   * DESIGN DECISION: This method intentionally does NOT validate CSS syntax.
   * This preserves the live preview experience where users can see changes
   * as they type, even with incomplete CSS (e.g., unclosed brackets).
   * Validation only occurs on manual save via saveElement().
   */
  applyChanges(css) {
    if (!this.editorEl || !this.ruleInputEl) return;
    const rule = this.ruleInputEl.value.trim();
    const uuid = this.editorUUID.value;
    if (!uuid) {
      return;
    }
    this.validationService.updateCustomCSS(uuid, rule, css);
    this.validationService.applyTheme();
  }
  clearAppliedChanges() {
    this.validationService.updateCustomCSS(generateUniqueId(), "", "");
    this.validationService.applyTheme();
  }
  async saveElement() {
    if (!this.editorEl || !this.ruleInputEl) return false;
    const uuid = this.editorUUID.value;
    const rule = this.ruleInputEl.value.trim();
    const css = this.aceService.getValue();
    if (!rule || !css) {
      showNotice("Please enter both a rule (name) and CSS", NOTICE_DURATIONS.STANDARD, "error");
      return false;
    }
    if (!await this.validationService.validateCSS(css)) {
      return false;
    }
    const existingIndex = this.plugin.settings.cssRules.findIndex((el) => el.uuid === uuid);
    if (existingIndex >= 0) {
      this.plugin.settings.cssRules[existingIndex] = {
        uuid,
        rule,
        css,
        // name: name || undefined,
        enabled: this.plugin.settings.cssRules[existingIndex].enabled
      };
    } else {
      this.plugin.settings.cssRules.push({
        uuid,
        rule,
        css,
        // name: name || undefined,
        enabled: true
      });
    }
    this.plugin.saveSettings();
    await this.validationService.updateCustomCSS(uuid, rule, css);
    this.validationService.applyTheme();
    this.editorEl.value = "";
    if (this.ruleListManager) {
      let element;
      if (existingIndex >= 0) {
        element = this.ruleListManager.updateRuleItem(uuid, {
          uuid,
          rule,
          css,
          enabled: this.plugin.settings.cssRules[existingIndex].enabled
        });
      } else {
        element = this.ruleListManager.addRuleItem({
          uuid,
          rule,
          css,
          enabled: true
        });
      }
      if (element) {
        this.ruleListManager.scrollToAndHighlight(element);
      }
    }
    showNotice("Rule saved successfully", NOTICE_DURATIONS.STANDARD, "success");
    return true;
  }
  resetEditor() {
    if (!this.editorEl || !this.ruleInputEl) return;
    this.editorUUID.value = generateUniqueId();
    this.ruleInputEl.value = "";
    this.aceService.setValue("");
    this.currentRule = "";
    this.isEditingExisting = false;
    this.currentEditingElement = null;
    this.editor.session.on("change", this.changeListener);
  }
  /**
   * Focus the rule name input field
   */
  focusRuleInput() {
    if (this.ruleInputEl) {
      this.ruleInputEl.focus();
    }
  }
  /**
   * Focus the Ace editor and position cursor optimally
   * Positions cursor before the last closing brace for easy property addition
   */
  focusAceEditor() {
    if (!this.editor) return;
    this.editor.focus();
    const searchOptions = {
      backwards: true,
      wrap: false,
      caseSensitive: true,
      regExp: false
    };
    this.editor.navigateFileEnd();
    const range = this.editor.find("}", searchOptions);
    if (range) {
      const row = range.start.row;
      if (row > 0) {
        this.editor.gotoLine(row, Number.MAX_VALUE);
        const tabWidth = Number(this.plugin.settings.editorTabWidth) || 4;
        const indent = " ".repeat(tabWidth);
        this.editor.insert("\n" + indent);
      } else {
        this.editor.moveCursorTo(range.start.row, range.start.column);
      }
    }
  }
  removeInlineEditor() {
    this.editor.session.off("change", this.changeListener);
    const inlineEditors = document.querySelectorAll(".inline-rule-editor");
    inlineEditors.forEach((editor) => editor.remove());
    this.isEditingExisting = false;
    this.currentEditingElement = null;
    this.showEditorSection(false);
    if (this.editorSection) {
      const content = this.view.containerEl.querySelector(".rules-section .collapsible-content");
      if (content) {
        const rulesButtonContainer = content.querySelector(".css-rules-button-container");
        if (rulesButtonContainer && rulesButtonContainer.nextSibling) {
          content.insertBefore(this.editorSection, rulesButtonContainer.nextSibling);
        } else {
          content.appendChild(this.editorSection);
        }
      }
    }
  }
  // Handler methods for rule item actions
  async handleEditRule(rule, item) {
    this.removeInlineEditor();
    this.resetEditor();
    this.clearAppliedChanges();
    this.isEditingExisting = true;
    this.currentEditingElement = item;
    const inlineEditor = item.createDiv("inline-rule-editor");
    if (this.editorSection) {
      this.setRule(rule.uuid, rule.rule, true);
      inlineEditor.appendChild(this.editorSection);
      this.showEditorSection(true);
      if (this.plugin.settings.viewScrollToTop) {
        window.setTimeout(() => {
          this.scrollToDivByUUID(rule.uuid);
        }, TIMEOUT_DELAYS.SCROLL_DELAY);
      }
      const focusEditor = (0, import_obsidian7.debounce)(() => {
        this.focusAceEditor();
      }, 100, false);
      focusEditor();
    }
  }
  async handleToggleRule(rule, button) {
    const getCurrentlyEditedIndex = () => {
      const ruleList = this.view.containerEl.querySelector(".css-rule");
      const existingRules = ruleList.querySelectorAll(".rule-item");
      for (let index = 0; index < existingRules.length; index++) {
        const el = existingRules[index];
        const openEditor = el.querySelector(".inline-rule-editor");
        if (openEditor) {
          return index;
        }
      }
      return false;
    };
    const currentlyEditedIndex = getCurrentlyEditedIndex();
    const existingIndex = this.plugin.settings.cssRules.findIndex((el) => el.uuid === rule.uuid);
    if (existingIndex >= 0) {
      this.plugin.settings.cssRules[existingIndex].enabled = !this.plugin.settings.cssRules[existingIndex].enabled;
      if (this.ruleListManager) {
        this.ruleListManager.toggleRuleEnabled(
          rule.uuid,
          this.plugin.settings.cssRules[existingIndex].enabled
        );
      }
    }
    let fullCSS = "";
    this.plugin.settings.cssRules.forEach((cssRule, index) => {
      if (cssRule.enabled) {
        if (index === currentlyEditedIndex) {
          let css = this.aceService.getValue();
          fullCSS += `/* ${cssRule.rule} */
${css}

`;
        } else {
          fullCSS += `/* ${cssRule.rule} */
${cssRule.css}

`;
        }
      }
    });
    this.plugin.settings.customCSS = fullCSS;
    this.plugin.saveSettings();
    this.validationService.applyTheme();
  }
  async handleDeleteRule(rule, item) {
    var _a2;
    this.plugin.settings.cssRules = this.plugin.settings.cssRules.filter(
      (el) => el.uuid !== rule.uuid
    );
    await this.validationService.rebuildCustomCSS();
    this.validationService.applyTheme();
    const hasEditor = (_a2 = this.view.containerEl.querySelector(`[data-cts-uuid="${rule.uuid}"]`)) == null ? void 0 : _a2.querySelector(".css-editor-section.show");
    if (hasEditor) {
      this.removeInlineEditor();
    }
    if (this.ruleListManager) {
      this.ruleListManager.removeRuleItem(rule.uuid);
    } else {
      item.remove();
    }
    if (this.view.ruleSearch !== "") {
      await this.view.filterCSSRules(this.view.ruleSearch);
    }
  }
  scrollToDivByUUID(uuid) {
    const target = this.view.containerEl.querySelector(`[data-cts-uuid="${uuid}"]`);
    if (target) {
      smoothScrollToElement(this.view.containerEl, target);
    }
  }
  /**
   * Create a rule item using the renderer (for compatibility)
   * @deprecated Use ruleListManager.addRuleItem() for incremental updates
   */
  createRuleItem(containerEl, rule) {
    return this.ruleItemRenderer.createRuleItem(containerEl, rule);
  }
  /**
   * Clean up timers and resources
   */
  destroy() {
    this.timers.forEach((timer) => window.clearTimeout(timer));
    this.timers = [];
  }
};

// src/views/components/HeaderSection.ts
var import_obsidian8 = require("obsidian");

// src/utils/DOMReferences.ts
var DOMReferences = class _DOMReferences {
  constructor(container) {
    this.cache = /* @__PURE__ */ new Map();
    this.destroyed = false;
    this.container = container;
  }
  /**
   * Get a cached DOM element by selector, with lazy loading
   */
  get(selector) {
    if (this.destroyed) {
      throw new Error("DOMReferences has been destroyed");
    }
    if (!this.cache.has(selector)) {
      const element = this.container.querySelector(selector);
      this.cache.set(selector, element);
    }
    return this.cache.get(selector);
  }
  /**
   * Get multiple cached DOM elements by selector
   */
  getAll(selector) {
    if (this.destroyed) {
      throw new Error("DOMReferences has been destroyed");
    }
    return this.container.querySelectorAll(selector);
  }
  /**
   * Get cached element with type safety and null checking
   */
  getRequired(selector) {
    const element = this.get(selector);
    if (!element) {
      throw new Error(`Required element not found: ${selector}`);
    }
    return element;
  }
  /**
   * Invalidate cache for a specific selector
   */
  invalidate(selector) {
    this.cache.delete(selector);
  }
  /**
   * Clear all cached references
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Create a scoped DOMReferences instance for a child container
   */
  scope(childSelector) {
    const childContainer = this.get(childSelector);
    return childContainer ? new _DOMReferences(childContainer) : null;
  }
  /**
   * Check if an element exists without caching
   */
  exists(selector) {
    return this.container.querySelector(selector) !== null;
  }
  /**
   * Wait for an element to appear in the DOM
   */
  async waitFor(selector, timeout = 5e3) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      const element = this.container.querySelector(selector);
      if (element) {
        this.cache.set(selector, element);
        return element;
      }
      await new Promise((resolve) => window.setTimeout(resolve, 50));
    }
    return null;
  }
  /**
   * Clean up all references and mark as destroyed
   */
  destroy() {
    this.cache.clear();
    this.destroyed = true;
  }
};
var Selectors = {
  // Variables section
  variablesList: ".variable-list",
  variableItems: ".variable-item",
  customVariableItems: ".custom-variable-item",
  variableInputs: ".variable-value-input",
  tagFilters: ".tag-filter-active",
  // Rules section
  ruleItems: ".rule-item",
  rulesList: ".css-rule",
  editorSection: ".css-editor-section",
  // Common UI elements
  searchInputs: ".search-input",
  clearButtons: ".clear-search-input-button",
  collapseIcons: ".collapse-icon.clickable-icon",
  // Form elements
  formInputs: 'input[type="text"]',
  toggleSwitches: 'input[type="checkbox"]',
  buttons: "button"
};

// src/views/components/UIComponent.ts
var UIComponent = class {
  constructor(context) {
    this.element = null;
    this.app = context.app;
    this.plugin = context.plugin;
    this.settings = context.settings;
    this.settingsManager = context.plugin.settingsManager;
    this.container = context.containerEl;
    this.cssEditorManager = context.cssEditorManager;
    this.elementSelectorManager = context.elementSelectorManager;
    this.cssVariableManager = context.cssVariableManager;
    this.domRefs = new DOMReferences(context.containerEl);
  }
  destroy() {
    var _a2;
    this.domRefs.destroy();
    (_a2 = this.element) == null ? void 0 : _a2.remove();
  }
  createSection(className) {
    this.element = this.container.createDiv(className);
    this.domRefs = new DOMReferences(this.element);
    return this.element;
  }
  saveSettings() {
    return this.plugin.saveSettings();
  }
  isVisible() {
    return this.element ? !this.element.hasClass("hide") : false;
  }
  toggle(show) {
    if (!this.element) return;
    const shouldShow = show != null ? show : this.element.hasClass("hide");
    this.element.toggleClass("show", shouldShow);
    this.element.toggleClass("hide", !shouldShow);
  }
  /**
   * Get a DOM element with caching, scoped to this component
   *
   * BEST PRACTICES:
   * - Use for elements that are accessed multiple times
   * - Call invalidateCache() after DOM modifications
   * - Prefer this over direct querySelector() for repeated queries
   *
   * @example
   * const header = this.getElement<HTMLDivElement>('.header');
   */
  getElement(selector) {
    return this.domRefs.get(selector);
  }
  /**
   * Get multiple DOM elements, scoped to this component
   *
   * NOTE: This is NOT cached and always returns fresh results.
   * Use for dynamic collections that change frequently.
   *
   * @example
   * const items = this.getElements('.item'); // Always fresh
   */
  getElements(selector) {
    return this.domRefs.getAll(selector);
  }
  /**
   * Get a required DOM element with error handling
   *
   * Throws an error if element not found. Use for critical elements
   * that must exist for the component to function.
   */
  getRequiredElement(selector) {
    return this.domRefs.getRequired(selector);
  }
  /**
   * Invalidate DOM cache when structure changes
   *
   * Call this after:
   * - Adding/removing elements from the DOM
   * - Replacing element content
   * - Any operation that changes the DOM structure
   *
   * @param selector Specific selector to invalidate, or omit to clear all
   * @example
   * this.invalidateCache('.variable-list'); // Clear specific
   * this.invalidateCache(); // Clear all cache
   */
  invalidateCache(selector) {
    if (selector) {
      this.domRefs.invalidate(selector);
    } else {
      this.domRefs.clearCache();
    }
  }
};

// src/views/components/HeaderSection.ts
var HeaderSection = class extends UIComponent {
  constructor(context) {
    super(context);
  }
  render() {
    const section = this.createSection("theme-studio-header");
    this.renderControls(section);
    return section;
  }
  renderControls(container) {
    const toggleContainer = container.createDiv("theme-toggle-container");
    this.renderThemeEnabledToggle(toggleContainer);
    this.renderLightDarkToggle(toggleContainer);
  }
  renderThemeEnabledToggle(container) {
    const { toggle, label } = createToggleSwitch(
      container,
      "theme-toggle-switch",
      "Enable theme",
      this.plugin.settings.themeEnabled,
      async () => {
        this.plugin.themeManager.toggleCustomTheme();
      }
    );
  }
  renderLightDarkToggle(container) {
    const toggleThemeWrapper = container.createDiv("toggle-theme-wrapper");
    const toggleThemeButton = toggleThemeWrapper.createEl("button", {
      cls: "toggle-theme-mode clickable-icon"
    });
    toggleThemeButton.setAttr("aria-label", "Toggle light/dark mode");
    toggleThemeButton.setAttr("data-tooltip-position", "top");
    (0, import_obsidian8.setIcon)(toggleThemeButton, getCurrentTheme(this.app) === "obsidian" ? "sun" : "moon");
    toggleThemeButton.addEventListener("click", async () => {
      this.handleThemeToggle(toggleThemeButton);
    });
  }
  async handleThemeToggle(toggleButton) {
    this.app.changeTheme(getCurrentTheme(this.app) === "obsidian" ? "moonstone" : "obsidian");
    (0, import_obsidian8.setIcon)(toggleButton, getCurrentTheme(this.app) === "obsidian" ? "sun" : "moon");
  }
  destroy() {
    var _a2;
    (_a2 = this.element) == null ? void 0 : _a2.remove();
  }
};

// src/views/components/CSSVariablesSection.ts
var import_obsidian12 = require("obsidian");

// src/utils/Debouncer.ts
var import_obsidian9 = require("obsidian");
var SimpleDebouncer = class {
  constructor(fn3, delay, immediate = false) {
    this.isDestroyed = false;
    this.debouncedFn = (0, import_obsidian9.debounce)(fn3, delay, immediate);
  }
  /**
   * Execute the debounced function
   */
  execute(...args) {
    if (!this.isDestroyed && this.debouncedFn) {
      this.debouncedFn(...args);
    }
  }
  /**
   * Cancel pending execution and clean up
   */
  destroy() {
    this.isDestroyed = true;
    this.debouncedFn = void 0;
  }
};

// src/modals/addVariableModal.ts
var import_obsidian10 = require("obsidian");
var AddVariableModal = class extends import_obsidian10.Modal {
  constructor(app, plugin) {
    super(app);
    this.variableName = "";
    this.variableValue = "";
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    if (contentEl.parentElement) {
      contentEl.parentElement.addClass("cts-add-variable-modal");
    }
    new import_obsidian10.Setting(contentEl).setName("Add CSS variable").setHeading();
    const variableNameInput = new import_obsidian10.Setting(contentEl).setName("Name").setDesc("A variable is prefixed with two dashes --, followed by the variable name.").addText(
      (text) => text.setValue("").setPlaceholder("Enter name (e.g. --my-variable)").onChange(async (value) => {
        this.variableName = value;
      })
    );
    const variableValueInput = new import_obsidian10.Setting(contentEl).setName("Value").setDesc("A variable value can be any valid CSS value.").addText(
      (text) => text.setValue("").setPlaceholder("Enter value (e.g. purple)").onChange(async (value) => {
        this.variableValue = value;
      })
    );
    new import_obsidian10.Setting(contentEl).addButton((button) => {
      button.setButtonText("Add variable");
      button.onClick(async () => {
        var _a2, _b, _c2;
        let variable = this.variableName;
        let value = this.variableValue;
        let parent = "custom";
        if (!variable) {
          showNotice("Please enter a name", NOTICE_DURATIONS.STANDARD, "error");
          (_a2 = variableNameInput.settingEl.querySelector("input")) == null ? void 0 : _a2.focus();
          return;
        }
        if (!variable.match(/^--[a-zA-Z0-9-_\p{Emoji}]+/gui)) {
          showNotice("Please enter a valid variable name", NOTICE_DURATIONS.STANDARD, "error");
          (_b = variableNameInput.settingEl.querySelector("input")) == null ? void 0 : _b.focus();
          return;
        }
        if (!value) {
          showNotice("Please enter a value", NOTICE_DURATIONS.STANDARD, "error");
          (_c2 = variableValueInput.settingEl.querySelector("input")) == null ? void 0 : _c2.focus();
          return;
        }
        let uuid = generateUniqueId();
        this.plugin.settings.cssVariables.push({
          uuid,
          parent,
          variable,
          value
        });
        this.plugin.saveSettings();
        this.plugin.themeManager.applyIfEnabled();
        this.close();
        let leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CTS).first();
        if (leaf && leaf.view instanceof CustomThemeStudioView) {
          showNotice("The variable has been added", NOTICE_DURATIONS.STANDARD, "success");
          leaf.view.refreshCustomVariables();
        }
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/components/ui/FormInput.ts
var import_obsidian11 = require("obsidian");
var VariableClearableInput = class {
  constructor(container, config) {
    this.container = container;
    this.config = config;
    this.input = this.createVariableInput();
    this.createVariableStyleClearButton();
    this.setupEventListeners();
  }
  createVariableInput() {
    const inputWrapper = this.container.createDiv("variable-input-wrapper");
    this.clearContainer = inputWrapper.createDiv("clear-variable-input");
    const input = this.clearContainer.createEl("input", {
      cls: "variable-value-input",
      attr: {
        type: this.config.type || "text",
        placeholder: this.config.placeholder || "",
        value: this.config.value || ""
      }
    });
    if (this.config.required) {
      input.setAttribute("required", "");
    }
    if (this.config.disabled) {
      input.setAttribute("disabled", "");
    }
    return input;
  }
  createVariableStyleClearButton() {
    if (!this.clearContainer) return;
    this.clearButtonEl = this.clearContainer.createEl("button", {
      cls: "clear-variable-input-button",
      attr: {
        "aria-label": "Clear input",
        "data-tooltip-position": "top",
        tabindex: "0"
      }
    });
    this.clearButtonEl.addEventListener("click", () => {
      this.setValue("");
      this.focus();
      if (this.config.onClear) {
        this.config.onClear();
      }
    });
  }
  setupEventListeners() {
    if (this.config.onInput) {
      this.input.addEventListener("input", (e) => {
        const value = e.target.value;
        this.config.onInput(value);
        this.updateTouchedState();
      });
    }
    if (this.config.onChange) {
      this.input.addEventListener("change", (e) => {
        const value = e.target.value;
        this.config.onChange(value);
        this.updateTouchedState();
      });
    }
    if (this.config.onFocus) {
      this.input.addEventListener("focus", this.config.onFocus);
    }
    if (this.config.onBlur) {
      this.input.addEventListener("blur", this.config.onBlur);
    }
    this.input.addEventListener("input", () => {
      this.updateTouchedState();
    });
    this.updateTouchedState();
  }
  updateTouchedState() {
    const hasValue = this.getValue().length > 0;
    if (hasValue) {
      this.input.classList.add("clear-variable-input--touched");
    } else {
      this.input.classList.remove("clear-variable-input--touched");
    }
  }
  // Public API
  getValue() {
    return this.input.value;
  }
  setValue(value) {
    this.input.value = value;
    this.updateTouchedState();
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  getElement() {
    return this.input;
  }
  getContainer() {
    return this.clearContainer;
  }
  destroy() {
    var _a2;
    this.input.remove();
    (_a2 = this.clearButtonEl) == null ? void 0 : _a2.remove();
  }
};
var VariableColorInput = class extends VariableClearableInput {
  constructor(container, config) {
    super(container, config);
    this.dynamicColorPicker = void 0;
    this.dynamicColorPickerContainer = void 0;
    this.isUpdatingFromPicker = false;
    this.colorConfig = config;
    if (this.colorConfig.colorPicker) {
      const initialValue = this.colorConfig.value || this.colorConfig.defaultColor;
      if (this.isColorValue(initialValue)) {
        this.createVariableColorPicker();
      }
      this.getElement().addEventListener("input", () => {
        if (!this.isUpdatingFromPicker) {
          this.updateColorPicker();
        }
      });
    }
  }
  isColorValue(value) {
    return /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/.test(value || "");
  }
  expandShortHex(color) {
    if (/^#[0-9A-Fa-f]{3}$/.test(color)) {
      return "#" + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    }
    return color;
  }
  updateColorPicker() {
    const value = this.getValue();
    const isColor = this.isColorValue(value);
    const expandedColor = this.expandShortHex(value);
    if (isColor && !this.dynamicColorPicker) {
      this.createVariableColorPicker();
    }
    if (isColor && this.dynamicColorPicker) {
      this.dynamicColorPicker.setValue(expandedColor);
    }
    if (!isColor && this.dynamicColorPicker) {
      this.destroyColorPicker();
    }
  }
  createVariableColorPicker() {
    var _a2;
    const variableInputWrapper = (_a2 = this.getContainer()) == null ? void 0 : _a2.parentElement;
    if (!variableInputWrapper) return;
    this.dynamicColorPickerContainer = variableInputWrapper.createDiv("variable-color-picker");
    const currentValue = this.getValue();
    const defaultValue = currentValue || this.colorConfig.defaultColor || "#000000";
    let isInitializing = true;
    this.dynamicColorPicker = new import_obsidian11.ColorComponent(this.dynamicColorPickerContainer).setValue(defaultValue).onChange((color) => {
      if (isInitializing) {
        return;
      }
      this.isUpdatingFromPicker = true;
      const input = this.getElement();
      input.value = color;
      if (this.colorConfig.onInput) {
        this.colorConfig.onInput(color);
      }
      window.setTimeout(() => {
        this.isUpdatingFromPicker = false;
      }, 0);
    });
    window.setTimeout(() => {
      isInitializing = false;
    }, 0);
    this.dynamicColorPickerContainer.setAttr("aria-label", "Color picker");
    this.dynamicColorPickerContainer.setAttr("data-tooltip-position", "top");
  }
  destroyColorPicker() {
    if (this.dynamicColorPickerContainer) {
      this.dynamicColorPickerContainer.remove();
      this.dynamicColorPickerContainer = void 0;
    }
    this.dynamicColorPicker = void 0;
  }
  setValue(value) {
    super.setValue(value);
    if (this.colorConfig.colorPicker && !this.isUpdatingFromPicker) {
      this.updateColorPicker();
    }
  }
  destroy() {
    this.destroyColorPicker();
    super.destroy();
  }
};

// src/views/components/ui/VariableItem.ts
var VariableItem = class {
  constructor(container, config) {
    this.container = container;
    this.config = config;
    this.element = this.createElement();
    this.setupDebounceUpdate();
    this.render();
  }
  createElement() {
    const className = this.config.isCustom ? "custom-variable-item" : "variable-item";
    return this.container.createDiv({
      cls: className,
      attr: {
        "data-var-name": this.config.data.name,
        "data-var-value": this.config.data.value
      }
    });
  }
  setupDebounceUpdate() {
    this.debounceUpdate = new SimpleDebouncer(
      () => {
        if (this.config.settings.themeEnabled) {
          this.applyThemeChanges();
        }
        showNotice("Variable updated successfully", 1500, "success");
      },
      DEBOUNCE_DELAYS.VARIABLE_UPDATE,
      true
    );
  }
  applyThemeChanges() {
    Logger.debug("Applying theme changes for variable:", this.config.data.name);
  }
  render() {
    if (this.config.isCustom) {
      this.renderCustomVariable();
    } else {
      this.renderStandardVariable();
    }
  }
  renderStandardVariable() {
    this.createVariableName();
    this.createVariableInput();
    this.createCopyDefaultButton();
  }
  renderCustomVariable() {
    const inputWrapper = this.element.createDiv("custom-variable-input-wrapper");
    this.createCustomNameInput(inputWrapper);
    const buttonWrapper = this.createCustomValueInput(inputWrapper);
    this.createDeleteButton(buttonWrapper);
  }
  createVariableName() {
    const nameEl = this.element.createDiv("variable-name");
    const nameSpan = nameEl.createSpan({
      text: this.config.data.name + ": ",
      attr: {
        "aria-label": `Copy "var(${this.config.data.name})" to clipboard`,
        "data-tooltip-position": "top"
      }
    });
    nameSpan.addEventListener("click", () => {
      this.handleVariableNameCopy();
    });
  }
  createVariableInput() {
    const currentValue = this.getCurrentValue();
    this.valueInput = new VariableColorInput(this.element, {
      type: "text",
      placeholder: this.config.data.defaultValue || this.config.data.value,
      value: currentValue,
      colorPicker: this.config.settings.enableColorPicker && this.isColorValue(this.config.data.value),
      defaultColor: this.config.data.value,
      onInput: (value) => this.handleValueChange(value),
      onColorChange: (color) => this.handleValueChange(color),
      onClear: () => this.handleValueChange("")
    });
  }
  createCustomNameInput(container) {
    this.nameInput = new VariableClearableInput(container, {
      type: "text",
      placeholder: "Variable name",
      value: this.config.data.name,
      classes: ["variable-name-input"],
      onInput: (value) => this.handleNameChange(value),
      onClear: () => this.handleNameChange("")
    });
  }
  createCustomValueInput(container) {
    const buttonWrapper = container.createDiv("custom-variable-input-button-wrapper");
    this.valueInput = new VariableColorInput(buttonWrapper, {
      type: "text",
      placeholder: "Variable value",
      value: this.config.data.value,
      colorPicker: this.config.settings.enableColorPicker,
      defaultColor: this.config.data.value && this.config.data.value.startsWith("#") ? this.config.data.value : "#000000",
      onInput: (value) => this.handleValueChange(value)
    });
    return buttonWrapper;
  }
  createCopyDefaultButton() {
    if (!this.config.data.defaultValue) return;
    const inputWrapper = this.element.querySelector(".variable-input-wrapper");
    if (!inputWrapper) {
      Logger.error("Variable input wrapper not found for default value button");
      return;
    }
    createIconButton(inputWrapper, {
      icon: "copy",
      label: `Copy default value "${this.config.data.defaultValue}" to clipboard`,
      classes: ["copy-default-value"],
      onClick: () => {
        copyStringToClipboard(this.config.data.defaultValue, this.config.data.defaultValue);
      }
    });
  }
  createDeleteButton(container) {
    const deleteButton = createIconButton(container, {
      icon: "trash",
      label: "Delete this variable",
      classes: ["delete-variable-button", "mod-destructive"],
      onClick: async () => {
        await this.handleDelete(deleteButton);
      }
    });
  }
  getCurrentValue() {
    const existingVariable = this.config.settings.cssVariables.find(
      (v2) => v2.variable === this.config.data.name && v2.parent === this.config.category
    );
    return (existingVariable == null ? void 0 : existingVariable.value) || "";
  }
  isColorValue(value) {
    return value.startsWith("#");
  }
  validateVariableName(name) {
    if (!name) {
      return "Variable name is required";
    }
    if (!name.match(/^--[a-zA-Z0-9-_\p{Emoji}]+/gui)) {
      return "Please enter a valid variable name (must start with --)";
    }
    return null;
  }
  handleNameChange(newName) {
    var _a2;
    const validationError = this.validateVariableName(newName);
    if (validationError) {
      showNotice(validationError, NOTICE_DURATIONS.STANDARD, "error");
      return;
    }
    const valueInput = ((_a2 = this.valueInput) == null ? void 0 : _a2.getValue()) || "";
    if (!newName || !valueInput) {
      showNotice("Both fields are required", NOTICE_DURATIONS.STANDARD, "error");
      return;
    }
    this.updateCustomVariable(newName, valueInput);
  }
  handleValueChange(newValue) {
    var _a2, _b;
    if (this.config.isCustom) {
      const nameInput = ((_a2 = this.nameInput) == null ? void 0 : _a2.getValue()) || "";
      if (!nameInput || !newValue) {
        showNotice("Both fields are required", NOTICE_DURATIONS.STANDARD, "error");
        return;
      }
      const validationError = this.validateVariableName(nameInput);
      if (validationError) {
        showNotice(validationError, NOTICE_DURATIONS.STANDARD, "error");
        (_b = this.nameInput) == null ? void 0 : _b.focus();
        return;
      }
      this.updateCustomVariable(nameInput, newValue);
    } else {
      this.updateStandardVariable(newValue);
    }
  }
  updateStandardVariable(value) {
    const existingVariable = this.config.settings.cssVariables.find(
      (v2) => v2.variable === this.config.data.name && v2.parent === this.config.category
    );
    const existingUUID = existingVariable == null ? void 0 : existingVariable.uuid;
    this.config.cssVariableManager.updateVariable(
      value !== "" ? existingUUID : "",
      this.config.data.name,
      value,
      this.config.category
    );
    this.debounceUpdate.execute();
    if (this.config.onUpdate) {
      this.config.onUpdate({
        ...this.config.data,
        value
      });
    }
  }
  updateCustomVariable(name, value) {
    this.config.cssVariableManager.updateVariable(
      this.config.data.uuid,
      name,
      value,
      this.config.category
    );
    this.debounceUpdate.execute();
    if (this.config.onUpdate) {
      this.config.onUpdate({
        ...this.config.data,
        name,
        value
      });
    }
  }
  async handleDelete(button) {
    if (!this.config.data.uuid) return;
    const { confirm: confirm2 } = await Promise.resolve().then(() => (init_confirmModal(), confirmModal_exports));
    button.addClass("mod-loading");
    try {
      if (await confirm2("Are you sure you want to delete this variable?", this.config.app)) {
        if (this.config.onDelete) {
          this.config.onDelete(this.config.data.uuid);
        }
        this.destroy();
        showNotice("Variable deleted", NOTICE_DURATIONS.STANDARD, "success");
      }
    } finally {
      button.removeClass("mod-loading");
    }
  }
  // Public API
  getData() {
    var _a2, _b;
    return {
      ...this.config.data,
      name: ((_a2 = this.nameInput) == null ? void 0 : _a2.getValue()) || this.config.data.name,
      value: ((_b = this.valueInput) == null ? void 0 : _b.getValue()) || this.config.data.value
    };
  }
  updateData(data) {
    this.config.data = { ...this.config.data, ...data };
    if (data.name && this.nameInput) {
      this.nameInput.setValue(data.name);
    }
    if (data.value && this.valueInput) {
      this.valueInput.setValue(data.value);
    }
    this.element.setAttr("data-var-name", this.config.data.name);
    this.element.setAttr("data-var-value", this.config.data.value);
  }
  getElement() {
    return this.element;
  }
  isVisible() {
    return !this.element.hasClass("hide");
  }
  setVisible(visible) {
    this.element.toggleClass("show", visible);
    this.element.toggleClass("hide", !visible);
  }
  matchesSearch(searchTerm) {
    var _a2;
    const name = this.config.data.name.toLowerCase();
    const value = this.config.data.value.toLowerCase();
    const currentValue = ((_a2 = this.valueInput) == null ? void 0 : _a2.getValue().toLowerCase()) || "";
    const term = searchTerm.toLowerCase();
    return name.includes(term) || value.includes(term) || currentValue.includes(term);
  }
  // Event Handler Methods
  handleVariableNameCopy() {
    const varReference = `var(${this.config.data.name})`;
    copyStringToClipboard(varReference, varReference);
  }
  destroy() {
    var _a2, _b;
    this.debounceUpdate.destroy();
    (_a2 = this.nameInput) == null ? void 0 : _a2.destroy();
    (_b = this.valueInput) == null ? void 0 : _b.destroy();
    this.element.remove();
  }
};

// src/utils/EventManager.ts
var EventManager = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.onceListeners = /* @__PURE__ */ new Map();
  }
  /**
   * Subscribe to an event
   */
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, /* @__PURE__ */ new Set());
    }
    this.listeners.get(event).add(callback);
    return () => {
      this.off(event, callback);
    };
  }
  /**
   * Subscribe to an event that will only fire once
   */
  once(event, callback) {
    if (!this.onceListeners.has(event)) {
      this.onceListeners.set(event, /* @__PURE__ */ new Set());
    }
    this.onceListeners.get(event).add(callback);
    return () => {
      this.offOnce(event, callback);
    };
  }
  /**
   * Unsubscribe from an event
   */
  off(event, callback) {
    const listeners = this.listeners.get(event);
    if (listeners) {
      listeners.delete(callback);
      if (listeners.size === 0) {
        this.listeners.delete(event);
      }
    }
  }
  /**
   * Remove a once listener
   */
  offOnce(event, callback) {
    const listeners = this.onceListeners.get(event);
    if (listeners) {
      listeners.delete(callback);
      if (listeners.size === 0) {
        this.onceListeners.delete(event);
      }
    }
  }
  /**
   * Emit an event to all listeners
   */
  emit(event, data) {
    const listeners = this.listeners.get(event);
    if (listeners) {
      listeners.forEach((callback) => {
        try {
          callback(data);
        } catch (error) {
          Logger.error(`Error in event listener for ${event}:`, error);
        }
      });
    }
    const onceListeners = this.onceListeners.get(event);
    if (onceListeners) {
      const listenersArray = Array.from(onceListeners);
      onceListeners.clear();
      this.onceListeners.delete(event);
      listenersArray.forEach((callback) => {
        try {
          callback(data);
        } catch (error) {
          Logger.error(`Error in once event listener for ${event}:`, error);
        }
      });
    }
  }
  /**
   * Remove all listeners for a specific event
   */
  removeAllListeners(event) {
    if (event) {
      this.listeners.delete(event);
      this.onceListeners.delete(event);
    } else {
      this.listeners.clear();
      this.onceListeners.clear();
    }
  }
  /**
   * Get the number of listeners for an event
   */
  listenerCount(event) {
    var _a2, _b;
    const regular = ((_a2 = this.listeners.get(event)) == null ? void 0 : _a2.size) || 0;
    const once = ((_b = this.onceListeners.get(event)) == null ? void 0 : _b.size) || 0;
    return regular + once;
  }
  /**
   * Check if there are any listeners for an event
   */
  hasListeners(event) {
    return this.listenerCount(event) > 0;
  }
  /**
   * Create a typed event emitter for a specific component
   */
  createEmitter(event) {
    return (data) => this.emit(event, data);
  }
  /**
   * Create a promise that resolves when an event is emitted
   */
  waitFor(event, timeout) {
    return new Promise((resolve, reject) => {
      let timeoutId = null;
      const unsubscribe = this.once(event, (data) => {
        if (timeoutId) {
          window.clearTimeout(timeoutId);
        }
        resolve(data);
      });
      if (timeout) {
        timeoutId = window.setTimeout(() => {
          unsubscribe();
          reject(new Error(`Event ${event} timeout after ${timeout}ms`));
        }, timeout);
      }
    });
  }
  /**
   * Destroy the event manager and clean up all listeners
   */
  destroy() {
    this.listeners.clear();
    this.onceListeners.clear();
  }
};
var globalEventManager = new EventManager();
var DOMEventManager = class {
  constructor(container, eventManager) {
    this.domListeners = /* @__PURE__ */ new Map();
    this.container = container;
    this.eventManager = eventManager || new EventManager();
  }
  /**
   * Add delegated event listener
   */
  delegate(eventType, selector, handler) {
    const delegatedHandler = (event) => {
      const target = event.target;
      const matchingElement = target.closest(selector);
      if (matchingElement && this.container.contains(matchingElement)) {
        handler(event, matchingElement);
      }
    };
    const listenerKey = `${eventType}:${selector}`;
    this.domListeners.set(listenerKey, delegatedHandler);
    this.container.addEventListener(eventType, delegatedHandler);
    return () => {
      this.container.removeEventListener(eventType, delegatedHandler);
      this.domListeners.delete(listenerKey);
    };
  }
  /**
   * Remove all DOM event listeners
   */
  destroy() {
    this.domListeners.forEach((handler, key) => {
      const [eventType] = key.split(":");
      this.container.removeEventListener(eventType, handler);
    });
    this.domListeners.clear();
  }
  getEventManager() {
    return this.eventManager;
  }
};

// src/views/components/CSSVariablesSection.ts
var CSSVariablesSection = class extends UIComponent {
  constructor(context) {
    super(context);
    this.variableSearch = "";
    this.activeTag = "all";
    this.variableItems = /* @__PURE__ */ new Map();
    this.eventManager = new EventManager();
    this.activeTag = this.plugin.settings.activeVariableTagFilter || "all";
    this.setupDebounceUpdate();
    this.setupEventListeners();
  }
  setupDebounceUpdate() {
    this.debounceUpdate = new SimpleDebouncer(
      () => {
        this.plugin.themeManager.applyIfEnabled();
        this.eventManager.emit("variable:updated", {
          name: "bulk",
          value: "updated",
          category: "multiple"
        });
        showNotice("Variable updated successfully", 1500, "success");
      },
      500,
      true
    );
  }
  setupEventListeners() {
    this.eventManager.on("variable:updated", (data) => {
      Logger.debug("Variable updated:", data);
    });
    this.eventManager.on("variable:deleted", (data) => {
      this.handleVariableDeleted(data.uuid);
    });
  }
  render() {
    const section = this.createSection("variables-section");
    const { content } = createCollapsibleSection(section, {
      title: "CSS variables",
      expanded: this.plugin.settings.expandCSSVariables,
      onToggle: (expanded) => {
        this.plugin.settings.expandCSSVariables = expanded;
        this.eventManager.emit("section:toggled", {
          section: "variables",
          expanded
        });
        this.saveSettings();
      }
    });
    this.domEventManager = new DOMEventManager(section, this.eventManager);
    this.setupDOMEventDelegation();
    this.renderButtons(content);
    this.renderTagFilters(content);
    this.renderSearch(content);
    this.renderCategories(content);
    return section;
  }
  setupDOMEventDelegation() {
    this.domEventManager.delegate("click", ".tag[data-tag-filter]", (event, target) => {
      const filterTag = target.getAttribute("data-tag-filter");
      if (filterTag) {
        this.handleTagFilterClick(filterTag, target);
      }
    });
  }
  renderButtons(container) {
    const buttonContainer = container.createDiv("css-variables-button-container");
    createIconButton(buttonContainer, {
      icon: "square-pen",
      label: "Add CSS variable",
      classes: ["new-variable-button"],
      onClick: () => {
        new AddVariableModal(this.app, this.plugin).open();
      }
    });
  }
  renderTagFilters(container) {
    const filterTags = container.createDiv("filter-tags");
    const tags = [
      "all",
      "components",
      "editor",
      "foundations",
      "plugins",
      "window",
      "theme-dark",
      "theme-light",
      "CTS"
    ];
    tags.forEach((tag) => {
      const isActive = tag.toLowerCase() === this.activeTag;
      const tagEl = filterTags.createEl("a", {
        text: tag,
        cls: "tag tag-filter-" + tag + (isActive ? " tag-filter-active" : ""),
        attr: {
          "data-tag-filter": tag.toLowerCase(),
          tabindex: "0",
          role: "button",
          "aria-label": "Show " + tag + " variables",
          "data-tooltip-position": "top"
        }
      });
      tagEl.addEventListener("click", (ev) => {
        this.handleTagFilter(ev, tags, filterTags);
      });
    });
  }
  handleTagFilter(event, tags, filterContainer) {
    const filterTag = event.currentTarget.getAttr("data-tag-filter");
    this.activeTag = filterTag;
    this.plugin.settings.activeVariableTagFilter = filterTag;
    this.saveSettings();
    tags.forEach((tag) => {
      const tagButton = filterContainer.querySelector(`[data-tag-filter="${tag.toLowerCase()}"]`);
      tagButton == null ? void 0 : tagButton.removeClass("tag-filter-active");
    });
    event.currentTarget.addClass("tag-filter-active");
    const dataFilterTags = this.container.querySelectorAll("[data-filter-tag]");
    dataFilterTags.forEach((element) => {
      const filter = element.getAttr("data-filter-tag");
      const showCategory = this.activeTag === "all" && (filterTag === "all" || filter === filterTag) || this.activeTag !== "all" && filter === filterTag;
      element.toggleClass("show", showCategory);
      element.toggleClass("hide", !showCategory);
    });
    if (this.variableSearch !== "") {
      this.updateVariableListVisibility();
    }
  }
  renderSearch(container) {
    const searchContainer = container.querySelector(".search-container");
    const { searchInput } = createSearchInput(searchContainer || container, {
      placeholder: "Search CSS variables\u2026",
      onInput: (searchTerm) => {
        this.variableSearch = searchTerm;
        this.filterVariables(searchTerm);
        this.updateVariableListVisibility();
      },
      onClear: () => {
        this.variableSearch = "";
        this.resetVariableListVisibility();
      }
    });
    this.renderResultsCounter(searchContainer || container);
  }
  renderResultsCounter(container) {
    const counter = container.createDiv("search-results-counter");
    this.eventManager.on("search:variable", ({ term, results }) => {
      if (term) {
        counter.textContent = `${results} variable${results !== 1 ? "s" : ""} found`;
        counter.addClass("active");
        counter.toggleClass("no-results", results === 0);
      } else {
        counter.textContent = "";
        counter.removeClass("active");
        counter.removeClass("no-results");
      }
    });
  }
  renderCategories(container) {
    allCategories.forEach((category) => {
      this.renderCategory(container, category);
    });
  }
  renderCategory(container, category) {
    const categoryEl = container.createDiv({
      cls: "variable-category",
      attr: {
        id: "variable-category-" + category.category,
        "data-filter-tag": category.tag
      }
    });
    const showCategory = this.activeTag === "all" || category.tag === this.activeTag;
    categoryEl.toggleClass("show", showCategory);
    categoryEl.toggleClass("hide", !showCategory);
    const { header, content: variableListEl } = this.createCategoryHeader(categoryEl, category);
    if (category.help) {
      this.addCategoryHelp(variableListEl, category.help);
    }
    this.renderCategoryVariables(variableListEl, category);
  }
  createCategoryHeader(container, category) {
    const header = container.createDiv("var-cat");
    const catTitle = header.createDiv("collapsible-header");
    catTitle.createSpan({ text: category.title.replace("+", " ") });
    const itemCount = this.getCategoryItemCount(category.category);
    catTitle.createSpan({
      cls: "category-item-count",
      text: `${itemCount}`
    });
    const catToggleIcon = catTitle.createEl("button", {
      cls: "collapse-icon clickable-icon",
      attr: {
        tabindex: "0",
        "aria-label": "Expand category",
        "data-tooltip-position": "top"
      }
    });
    (0, import_obsidian12.setIcon)(catToggleIcon, "chevron-right");
    const variableListEl = container.createDiv({
      cls: "variable-list",
      attr: {
        "data-var-category": category.category,
        "data-var-tag": category.tag
      }
    });
    variableListEl.addClass("hide");
    const categoryId = "variable-category-" + category.category;
    const shouldBeExpanded = this.plugin.settings.expandedVariableCategories.includes(categoryId);
    if (shouldBeExpanded) {
      variableListEl.removeClass("hide");
      variableListEl.addClass("show");
      (0, import_obsidian12.setIcon)(catToggleIcon, "chevron-down");
      catToggleIcon.setAttr("aria-label", "Collapse category");
    }
    header.addEventListener("click", () => {
      this.handleCategoryToggle(variableListEl, catToggleIcon, container);
    });
    return { header, content: variableListEl };
  }
  addCategoryHelp(container, help) {
    const helpContainer = container.createDiv("variable-category-help-container");
    const helpIcon = helpContainer.createSpan("variable-category-help-icon");
    (0, import_obsidian12.setIcon)(helpIcon, "info");
    const helpSpan = helpContainer.createSpan({
      cls: "variable-category-help"
    });
    helpSpan.appendChild(help.cloneNode(true));
  }
  getCategoryItemCount(category) {
    if (category === "custom") {
      return this.plugin.settings.cssVariables.filter((v2) => v2.parent === "custom").length;
    } else {
      return cssVariableDefaults.filter((cat) => cat.cat === category).length;
    }
  }
  updateCategoryItemCount(category) {
    const categoryEl = this.container.querySelector(`#variable-category-${category}`);
    if (categoryEl) {
      const countBadge = categoryEl.querySelector(".category-item-count");
      if (countBadge) {
        const newCount = this.getCategoryItemCount(category);
        countBadge.textContent = `${newCount}`;
      }
    }
  }
  renderCategoryVariables(container, category) {
    if (category.category === "custom") {
      this.renderCustomVariables(container, category.category);
    } else {
      this.renderDefaultVariables(container, category.category);
    }
  }
  renderCustomVariables(container, category) {
    const items = this.plugin.settings.cssVariables.filter((v2) => v2.parent === "custom").sort((a, b2) => a.variable.localeCompare(b2.variable));
    items.forEach((item) => {
      this.createVariableItemComponent(container, {
        uuid: item.uuid,
        name: item.variable,
        value: item.value
      }, category, true);
    });
  }
  renderDefaultVariables(container, category) {
    const items = cssVariableDefaults.filter((cat) => cat.cat === category).sort((a, b2) => a.variable.localeCompare(b2.variable));
    items.forEach((item) => {
      this.createVariableItemComponent(container, {
        name: item.variable,
        value: item.default,
        defaultValue: item.default
      }, category, false);
    });
  }
  /**
   * Create a variable item using the new VariableItem component
   */
  createVariableItemComponent(container, data, category, isCustom) {
    const variableItem = new VariableItem(container, {
      data,
      category,
      settings: this.plugin.settings,
      cssVariableManager: this.cssVariableManager,
      app: this.app,
      isCustom,
      onUpdate: (updatedData) => {
        this.eventManager.emit("variable:updated", {
          name: updatedData.name,
          value: updatedData.value,
          category
        });
      },
      onDelete: (uuid) => {
        this.handleVariableDelete(uuid);
      }
    });
    const key = isCustom ? data.uuid : `${category}:${data.name}`;
    this.variableItems.set(key, variableItem);
  }
  handleVariableDelete(uuid) {
    this.plugin.settings.cssVariables = this.plugin.settings.cssVariables.filter(
      (el) => el.uuid !== uuid
    );
    let fullCSS = "";
    this.plugin.settings.cssRules.forEach((rule) => {
      if (rule.enabled) {
        fullCSS += `/* ${rule.rule} */
${rule.css}

`;
      }
    });
    this.plugin.settings.customCSS = fullCSS;
    this.saveSettings();
    this.plugin.themeManager.applyIfEnabled();
    this.variableItems.delete(uuid);
    this.eventManager.emit("variable:deleted", {
      uuid,
      name: "deleted"
    });
    this.updateCategoryItemCount("custom");
    if (this.variableSearch !== "") {
      this.filterVariables(this.variableSearch);
    }
  }
  handleVariableDeleted(uuid) {
    const variableItem = this.variableItems.get(uuid);
    if (variableItem) {
      variableItem.destroy();
      this.variableItems.delete(uuid);
    }
  }
  handleTagFilterClick(filterTag, target) {
    this.activeTag = filterTag;
    const filterContainer = target.closest(".filter-tags");
    const allTags = filterContainer.querySelectorAll(".tag[data-tag-filter]");
    allTags.forEach((tag) => tag.removeClass("tag-filter-active"));
    target.addClass("tag-filter-active");
    this.filterVariablesByTag(filterTag);
    this.eventManager.emit("filter:tag", {
      tag: filterTag,
      count: this.getVisibleVariableCount()
    });
  }
  filterVariablesByTag(filterTag) {
    const categoryElements = this.getElements("[data-filter-tag]");
    categoryElements.forEach((element) => {
      const filter = element.getAttr("data-filter-tag");
      const showCategory = this.activeTag === "all" && (filterTag === "all" || filter === filterTag) || this.activeTag !== "all" && filter === filterTag;
      element.toggleClass("show", showCategory);
      element.toggleClass("hide", !showCategory);
    });
    if (this.variableSearch !== "") {
      this.updateVariableListVisibilityOptimized();
    }
  }
  updateVariableListVisibilityOptimized() {
    const variableListEls = this.getElements(Selectors.variablesList);
    variableListEls.forEach((el) => {
      const hasVisibleChildren = this.hasVisibleVariableItems(el);
      const dataVarTag = el.getAttr("data-var-tag");
      const shouldExpand = (this.activeTag === "all" || dataVarTag === this.activeTag) && hasVisibleChildren;
      this.toggleCategoryVisibility(el, shouldExpand);
    });
  }
  hasVisibleVariableItems(container) {
    const containerItems = Array.from(this.variableItems.values()).filter(
      (item) => container.contains(item.getElement())
    );
    return containerItems.some((item) => item.isVisible());
  }
  toggleCategoryVisibility(el, shouldExpand) {
    var _a2, _b;
    el.toggleClass("show", shouldExpand);
    el.toggleClass("hide", !shouldExpand);
    (_a2 = el.parentElement) == null ? void 0 : _a2.toggleClass("show", shouldExpand);
    (_b = el.parentElement) == null ? void 0 : _b.toggleClass("hide", !shouldExpand);
    const previousElement = el.previousSibling;
    const variableListIcon = previousElement == null ? void 0 : previousElement.querySelector(".collapse-icon.clickable-icon");
    if (variableListIcon) {
      const iconName = shouldExpand ? "chevron-down" : "chevron-right";
      const ariaLabel = shouldExpand ? "Collapse category" : "Expand category";
      (0, import_obsidian12.setIcon)(variableListIcon, iconName);
      variableListIcon.setAttr("aria-label", ariaLabel);
      variableListIcon.setAttr("data-tooltip-position", "top");
    }
  }
  getVisibleVariableCount() {
    return Array.from(this.variableItems.values()).filter((item) => item.isVisible()).length;
  }
  createVariableValueInput(container, variable, category, currentValue) {
    const inputWrapper = container.createDiv("variable-input-wrapper");
    const clearInputContainer = inputWrapper.createDiv("clear-variable-input");
    const valueInput = clearInputContainer.createEl("input", {
      cls: "variable-value-input",
      attr: {
        type: "text",
        placeholder: variable.value,
        value: currentValue
      }
    });
    if (currentValue) {
      valueInput.classList.add("clear-variable-input--touched");
    }
    this.addColorPicker(inputWrapper, valueInput, variable);
    this.addClearButton(clearInputContainer, valueInput);
    this.addInputListener(valueInput, variable, category);
    this.addCopyDefaultButton(inputWrapper, variable.value);
  }
  addColorPicker(wrapper, input, variable) {
    var _a2;
    if (!this.plugin.settings.enableColorPicker || !variable.value.startsWith("#")) {
      return;
    }
    const colorPickerEl = wrapper.createDiv("variable-color-picker");
    const colorPicker = new import_obsidian12.ColorComponent(colorPickerEl).setValue((_a2 = variable.value) != null ? _a2 : "#000000").onChange((value) => {
      if (variable.value !== value) {
        input.value = value;
        input.classList.add("clear-variable-input--touched");
        input.focus();
        input.trigger(this.plugin.settings.variableInputListener);
      }
    }).then(() => {
      colorPickerEl.setAttr("aria-label", "Show color picker");
      colorPickerEl.setAttr("data-tooltip-position", "top");
    });
    input.addEventListener(this.plugin.settings.variableInputListener, (e) => {
      this.handleColorInputSync(e, colorPicker, variable.value);
    });
  }
  addClearButton(container, input) {
    const clearButton = container.createEl("button", {
      cls: "clear-variable-input-button",
      attr: {
        "aria-label": "Clear input",
        "data-tooltip-position": "top",
        tabindex: "0"
      }
    });
    clearButton.addEventListener("click", () => {
      this.handleClearInput(input);
    });
  }
  addInputListener(input, variable, category) {
    input.addEventListener(this.plugin.settings.variableInputListener, (e) => {
      this.handleVariableInput(e, variable, category, input);
    });
  }
  addCopyDefaultButton(container, defaultValue) {
    const copyButton = createIconButton(container, {
      icon: "copy",
      label: 'Copy default value "' + defaultValue + '" to clipboard',
      classes: ["copy-default-value"],
      onClick: () => {
        copyStringToClipboard(defaultValue, defaultValue);
      }
    });
  }
  createCustomVariableItemInput(container, variable, category) {
    this.createVariableItemComponent(container, {
      uuid: variable.uuid,
      name: variable.name,
      value: variable.value
    }, category, true);
  }
  /**
   * Refresh the custom variables category by clearing and re-rendering all custom variables.
   * This ensures all custom variables are properly tracked in this.variableItems.
   */
  refreshCustomVariables() {
    const customVarList = this.container.querySelector('[data-var-category="custom"]');
    if (!customVarList) {
      Logger.warn("Custom variables container not found");
      return;
    }
    const customKeys = Array.from(this.variableItems.keys()).filter(
      (key) => {
        var _a2;
        return ((_a2 = this.variableItems.get(key)) == null ? void 0 : _a2.getData().uuid) !== void 0;
      }
    );
    customKeys.forEach((key) => {
      const item = this.variableItems.get(key);
      item == null ? void 0 : item.destroy();
      this.variableItems.delete(key);
    });
    customVarList.empty();
    this.renderCustomVariables(customVarList, "custom");
    const customVarCategory = this.container.querySelector("#variable-category-custom");
    if (customVarCategory) {
      const variableList = customVarCategory.querySelector('[data-var-category="custom"]');
      const icon = customVarCategory.querySelector(".collapse-icon.clickable-icon");
      if (variableList) {
        variableList.removeClass("hide");
        variableList.addClass("show");
      }
      if (icon) {
        (0, import_obsidian12.setIcon)(icon, "chevron-down");
        icon.setAttr("aria-label", "Collapse category");
      }
      if (this.plugin.settings.viewScrollToTop) {
        const scrollDelayed = (0, import_obsidian12.debounce)(() => {
          const top = customVarCategory.offsetTop - UI_CONSTANTS.SCROLL_OFFSET;
          this.container.scrollTo({
            top,
            behavior: "smooth"
          });
        }, TIMEOUT_DELAYS.SCROLL_DELAY, false);
        scrollDelayed();
      }
    }
    this.updateCategoryItemCount("custom");
  }
  getCurrentVariableValue(variableName, category) {
    const customVars = this.plugin.settings.cssVariables;
    const existingVariable = customVars.find((v2) => v2.variable === variableName && v2.parent === category);
    return (existingVariable == null ? void 0 : existingVariable.value) || "";
  }
  getExistingVariable(variableName, category) {
    return this.plugin.settings.cssVariables.find((v2) => v2.variable === variableName && v2.parent === category);
  }
  updateInputTouchedState(input) {
    if (input.value && !input.classList.contains("clear-variable-input--touched")) {
      input.classList.add("clear-variable-input--touched");
    } else if (!input.value && input.classList.contains("clear-variable-input--touched")) {
      input.classList.remove("clear-variable-input--touched");
    }
  }
  /**
   * Optimized variable filtering using VariableItem components
   */
  async filterVariables(searchTerm) {
    let visibleCount = 0;
    this.variableItems.forEach((variableItem) => {
      const matches = searchTerm === "" || variableItem.matchesSearch(searchTerm);
      variableItem.setVisible(matches);
      if (matches) {
        visibleCount++;
      }
    });
    this.eventManager.emit("search:variable", {
      term: searchTerm,
      results: visibleCount
    });
  }
  updateVariableListVisibility() {
    var _a2;
    const activeTagFilter = (_a2 = this.container.querySelector(".tag-filter-active")) == null ? void 0 : _a2.getAttr("data-tag-filter");
    const variableListEls = this.container.querySelectorAll(".variable-list");
    variableListEls.forEach((el) => {
      var _a3, _b, _c2;
      const children = Array.from(el.children);
      const hasVisibleChildren = children.some((child) => child.hasClass("show"));
      const dataVarTag = el.getAttr("data-var-tag");
      const variableListIcon = (_a3 = el.previousSibling) == null ? void 0 : _a3.querySelector(".collapse-icon.clickable-icon");
      const shouldExpand = (activeTagFilter === "all" || dataVarTag === activeTagFilter) && hasVisibleChildren;
      el.toggleClass("show", shouldExpand);
      el.toggleClass("hide", !shouldExpand);
      (_b = el.parentElement) == null ? void 0 : _b.toggleClass("show", shouldExpand);
      (_c2 = el.parentElement) == null ? void 0 : _c2.toggleClass("hide", !shouldExpand);
      const iconName = shouldExpand ? "chevron-down" : "chevron-right";
      const ariaLabel = shouldExpand ? "Collapse category" : "Expand category";
      (0, import_obsidian12.setIcon)(variableListIcon, iconName);
      variableListIcon == null ? void 0 : variableListIcon.setAttr("aria-label", ariaLabel);
      variableListIcon == null ? void 0 : variableListIcon.setAttr("data-tooltip-position", "top");
    });
  }
  resetVariableListVisibility() {
    var _a2;
    const activeTagFilter = (_a2 = this.container.querySelector(".tag-filter-active")) == null ? void 0 : _a2.getAttr("data-tag-filter");
    const variableListEls = this.container.querySelectorAll(".variable-list");
    variableListEls.forEach((el) => {
      var _a3, _b, _c2;
      const dataVarTag = el.getAttr("data-var-tag");
      const variableListIcon = (_a3 = el.previousSibling) == null ? void 0 : _a3.querySelector(".collapse-icon.clickable-icon");
      const shouldShowCategory = activeTagFilter === "all" || dataVarTag === activeTagFilter;
      el.addClass("hide");
      el.removeClass("show");
      (_b = el.parentElement) == null ? void 0 : _b.toggleClass("show", shouldShowCategory);
      (_c2 = el.parentElement) == null ? void 0 : _c2.toggleClass("hide", !shouldShowCategory);
      (0, import_obsidian12.setIcon)(variableListIcon, "chevron-right");
      variableListIcon == null ? void 0 : variableListIcon.setAttr("aria-label", "Expand category");
      variableListIcon == null ? void 0 : variableListIcon.setAttr("data-tooltip-position", "top");
    });
  }
  scrollToElement(target) {
    if (target && this.container) {
      const top = target.offsetTop - UI_CONSTANTS.SCROLL_OFFSET;
      this.container.scrollTo({
        top,
        behavior: "smooth"
      });
    }
  }
  destroy() {
    var _a2;
    this.debounceUpdate.destroy();
    this.variableItems.forEach((item) => item.destroy());
    this.variableItems.clear();
    this.eventManager.destroy();
    (_a2 = this.domEventManager) == null ? void 0 : _a2.destroy();
    super.destroy();
  }
  // Event Handler Methods
  handleCategoryToggle(variableListEl, catToggleIcon, container) {
    const categoryId = container.getAttribute("id");
    const shouldExpand = variableListEl.hasClass("hide");
    if (shouldExpand) {
      if (!this.plugin.settings.expandedVariableCategories.includes(categoryId)) {
        this.plugin.settings.expandedVariableCategories.push(categoryId);
      }
    } else {
      this.plugin.settings.expandedVariableCategories = this.plugin.settings.expandedVariableCategories.filter((id) => id !== categoryId);
    }
    this.saveSettings();
    variableListEl.toggleClass("show", shouldExpand);
    variableListEl.toggleClass("hide", !shouldExpand);
    (0, import_obsidian12.setIcon)(catToggleIcon, shouldExpand ? "chevron-down" : "chevron-right");
    catToggleIcon.setAttr("aria-label", shouldExpand ? "Collapse category" : "Expand category");
    if (shouldExpand && this.plugin.settings.viewScrollToTop) {
      window.setTimeout(() => {
        this.scrollToElement(container);
      }, 100);
    }
  }
  handleClearInput(input) {
    input.value = "";
    input.focus();
    input.trigger(this.plugin.settings.variableInputListener);
    input.classList.remove("clear-variable-input--touched");
  }
  handleColorInputSync(event, colorPicker, defaultValue) {
    const newValue = event.target.value;
    colorPicker.setValue(newValue || defaultValue);
  }
  handleVariableInput(event, variable, category, input) {
    const newValue = event.target.value;
    const existingVariable = this.getExistingVariable(variable.name, category);
    const existingUUID = existingVariable == null ? void 0 : existingVariable.uuid;
    this.cssVariableManager.updateVariable(
      newValue !== "" ? existingUUID : "",
      variable.name,
      newValue,
      category
    );
    this.debounceUpdate.execute();
    this.updateInputTouchedState(input);
  }
};

// src/views/components/CSSRulesSection.ts
var import_obsidian14 = require("obsidian");

// src/modals/fontImportModal.ts
var import_obsidian13 = require("obsidian");
init_confirmModal();
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var FontImportModal = class extends import_obsidian13.Modal {
  constructor(app, plugin) {
    super(app);
    this.fontName = "";
    this.base64Content = "";
    this.plugin = plugin;
    this.fontExtensions = ["ttf", "otf", "woff", "woff2"];
    this.fontFilePath = "";
  }
  async onOpen() {
    const { contentEl } = this;
    if (contentEl.parentElement) {
      contentEl.parentElement.addClass("cts-font-import-modal");
    }
    new import_obsidian13.Setting(contentEl).setName("Import font").setHeading();
    contentEl.createDiv(
      {
        text: "Embedding assets increases the file size of your theme, which may lead to poor performance in the following situations:"
      }
    );
    const listItems = [
      "Downloading and updating your theme from the community theme directory.",
      "Loading and using your theme in the Obsidian app.",
      "Editing your theme in a code editor."
    ];
    const listFragment = contentEl.createEl("ul");
    listItems.forEach((text) => {
      listFragment.appendChild(contentEl.createEl("li", { text }));
    });
    contentEl.appendChild(listFragment);
    const linkContainer = contentEl.createDiv("cts-font-import-modal-desc");
    linkContainer.createSpan(
      {
        text: "See: "
      }
    );
    linkContainer.createEl(
      "a",
      {
        cls: "external-link",
        href: "https://docs.obsidian.md/Themes/App+themes/Embed+fonts+and+images+in+your+theme#Consider+file+size",
        text: "Embed fonts and images in your theme - Developer Documentation",
        attr: {
          "aria-label": "https://docs.obsidian.md/Themes/App+themes/Embed+fonts+and+images+in+your+theme#Consider+file+size",
          "data-tooltip-position": "top",
          tabindex: "0"
        }
      }
    );
    const fontNameInput = new import_obsidian13.Setting(contentEl).setName("Font name").setDesc("Enter a font name which is used to identify this font in your CSS rules/variables.").addText(
      (text) => text.setValue("").setPlaceholder("Enter font name").onChange(async (value) => {
        this.fontName = value;
      })
    );
    new import_obsidian13.Setting(contentEl).setDesc("Choose a font file to create a new @font-face rule").addButton((button) => {
      button.setButtonText("Choose");
      button.onClick(async () => {
        const nameInput = fontNameInput.settingEl.querySelector("input");
        if (!nameInput) {
          Logger.error("Font name input element not found");
          showNotice("Font import interface error - please try again", NOTICE_DURATIONS.STANDARD, "error");
          return;
        }
        this.fontName = nameInput.value;
        if (!this.fontName) {
          showNotice("Please enter a name for the font you want to import", NOTICE_DURATIONS.STANDARD, "error");
          nameInput.focus();
          return;
        }
        this.base64Content = await this.importFontFile();
        if (this.base64Content) {
          let css = this.generateFontFaceRule();
          let uuid = generateUniqueId();
          let rule = "@font-face: " + this.fontName;
          this.plugin.settings.cssRules.push({
            uuid,
            rule,
            css,
            enabled: false
          });
          this.plugin.saveSettings();
          this.close();
          let leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CTS).first();
          if (leaf) {
            if (!await confirm('The @font-face has been saved as a new CSS rule. Click "OK" to reload the "Custom Theme Studio" view or if you have unsaved changes, click "Cancel" to reload the view manually at a later time.', this.plugin.app)) {
              return;
            }
            await this.app.workspace.revealLeaf(leaf);
            if (leaf.view instanceof CustomThemeStudioView) {
              let view = leaf.view;
              const ruleList = view.containerEl.querySelector(".css-rule");
              if (ruleList) {
                ruleList.empty();
                this.plugin.settings.cssRules.sort((a, b2) => a.rule.localeCompare(b2.rule));
                this.plugin.settings.cssRules.forEach((rule2) => {
                  view.cssEditorManager.createRuleItem(ruleList, rule2);
                });
                if (this.plugin.settings.viewScrollToTop) {
                  window.setTimeout(() => {
                    const ruleDiv = view.containerEl.querySelector(`[data-cts-uuid="${uuid}"]`);
                    view.scrollToDiv(ruleDiv);
                  }, 100);
                }
              }
            }
          } else {
            showNotice("The @font-face has been saved as a new CSS rule", NOTICE_DURATIONS.STANDARD, "success");
          }
        }
      });
    });
    let debounceFocus = (0, import_obsidian13.debounce)(
      () => {
        const nameInput = fontNameInput.settingEl.querySelector("input");
        if (nameInput) {
          nameInput.focus();
        }
      },
      10,
      true
    );
    debounceFocus();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  generateFontFaceRule() {
    let mimeType;
    let ext = import_path.default.extname(this.fontFilePath);
    switch (ext) {
      case ".woff":
        mimeType = "font/woff";
        break;
      case ".woff2":
        mimeType = "font/woff2";
        break;
      case ".ttf":
        mimeType = "font/ttf";
        break;
      case ".otf":
        mimeType = "font/otf";
        break;
      default:
        mimeType = "application/octet-stream";
        break;
    }
    return `@font-face {
	font-family: "${this.fontName}";
	src: url(data:${mimeType};base64,${this.base64Content});
}`;
  }
  async importFontFile() {
    const windowWithRequire = window;
    const electron = windowWithRequire.require ? windowWithRequire.require("electron") : null;
    const remote = electron ? electron.remote : null;
    const { canceled, filePaths } = await remote.dialog.showOpenDialog({
      title: "Import CFG Settings",
      filters: [{ name: "Font files", extensions: this.fontExtensions }],
      properties: ["openFile"]
    });
    if (canceled || !filePaths || filePaths.length === 0) {
      return null;
    }
    this.fontFilePath = filePaths[0];
    const fileContent = import_fs.default.readFileSync(this.fontFilePath);
    return (0, import_obsidian13.arrayBufferToBase64)(fileContent);
  }
};

// src/views/components/CSSRulesSection.ts
var CSSRulesSection = class extends UIComponent {
  constructor(context) {
    super(context);
    this.ruleSearch = "";
  }
  render() {
    const section = this.createSection("rules-section");
    const { content } = createCollapsibleSection(section, {
      title: "CSS rules",
      expanded: this.plugin.settings.expandCSSRules,
      onToggle: (expanded) => {
        this.plugin.settings.expandCSSRules = expanded;
        this.saveSettings();
      }
    });
    this.renderButtons(content);
    this.renderEditorSection(content);
    this.renderSearch(content);
    this.renderRuleList(content);
    return section;
  }
  renderButtons(container) {
    const buttonContainer = container.createDiv("css-rules-button-container");
    createIconButton(buttonContainer, {
      icon: "square-pen",
      label: "Add CSS rule",
      classes: ["add-rule-button"],
      onClick: async () => {
        await this.handleAddRule();
      }
    });
    createIconButton(buttonContainer, {
      icon: "mouse-pointer-square-dashed",
      label: "Select an element",
      classes: ["select-element-button"],
      onClick: async () => {
        await this.handleSelectElement();
      }
    });
    if (this.plugin.settings.enableFontImport) {
      createIconButton(buttonContainer, {
        icon: "file-type",
        label: "Import font",
        classes: ["add-font-face-button"],
        onClick: () => {
          new FontImportModal(this.app, this.plugin).open();
        }
      });
    }
  }
  async handleAddRule() {
    const editorSection = this.container.querySelector(".css-editor-section");
    const isEditorVisible = editorSection && getComputedStyle(editorSection).display !== "none";
    if (isEditorVisible && this.plugin.settings.showConfirmation) {
      const { confirm: confirm2 } = await Promise.resolve().then(() => (init_confirmModal(), confirmModal_exports));
      if (!await confirm2("You have an unsaved CSS rule form open. Creating a new rule will discard your changes. Continue?", this.plugin.app)) {
        return;
      }
    }
    this.removeInlineEditors();
    this.cssEditorManager.resetEditor();
    this.cssEditorManager.clearAppliedChanges();
    this.cssEditorManager.showEditorSection(true);
    this.positionEditorSection(editorSection);
    if (this.plugin.settings.viewScrollToTop) {
      window.setTimeout(() => {
        this.scrollToElement(editorSection);
      }, 100);
    }
    const focusRuleInput = (0, import_obsidian14.debounce)(() => {
      this.cssEditorManager.focusRuleInput();
    }, 250, false);
    focusRuleInput();
  }
  async handleSelectElement() {
    const editorSection = this.container.querySelector(".css-editor-section");
    const isEditorVisible = editorSection && getComputedStyle(editorSection).display !== "none";
    if (isEditorVisible && this.plugin.settings.showConfirmation) {
      const { confirm: confirm2 } = await Promise.resolve().then(() => (init_confirmModal(), confirmModal_exports));
      if (!await confirm2("You have an unsaved CSS rule form open. Creating a new rule will discard your changes. Continue?", this.plugin.app)) {
        return;
      }
    }
    this.removeInlineEditors();
    this.cssEditorManager.resetEditor();
    this.cssEditorManager.clearAppliedChanges();
    this.cssEditorManager.showEditorSection(false);
    this.elementSelectorManager.startElementSelection();
  }
  removeInlineEditors() {
    const inlineEditors = document.querySelectorAll(".inline-rule-editor");
    inlineEditors.forEach((editor) => editor.remove());
  }
  positionEditorSection(editorSection) {
    const buttonContainer = this.container.querySelector(".css-rules-button-container");
    if (buttonContainer && editorSection) {
      buttonContainer.after(editorSection);
    }
  }
  renderEditorSection(container) {
    this.cssEditorManager.createEditorSection(container);
    this.cssEditorManager.showEditorSection(false);
  }
  renderSearch(container) {
    const searchContainer = container.createDiv("search-rules-container");
    const clearInputContainer = searchContainer.createDiv("clear-search-rules-input");
    const { searchInput, clearButton } = createSearchInput(clearInputContainer, {
      placeholder: "Search CSS rules\u2026",
      onInput: (searchTerm) => {
        this.ruleSearch = searchTerm;
        this.filterCSSRules(searchTerm);
        this.updateSearchInputState(searchInput, searchTerm);
      },
      onClear: () => {
        this.ruleSearch = "";
        this.resetRuleVisibility();
      }
    });
    if (!searchInput.classList.contains("search-rules-input")) {
      searchInput.classList.add("search-rules-input");
    }
    if (clearButton && !clearButton.classList.contains("clear-search-rules-input-button")) {
      clearButton.classList.add("clear-search-rules-input-button");
    }
    this.renderResultsCounter(searchContainer);
  }
  renderResultsCounter(container) {
    const counter = container.createDiv("search-results-counter");
    this.ruleSearchCounter = counter;
  }
  updateSearchInputState(input, searchTerm) {
    if (searchTerm && !input.classList.contains("clear-search-rules-input--touched")) {
      input.classList.add("clear-search-rules-input--touched");
    } else if (!searchTerm && input.classList.contains("clear-search-rules-input--touched")) {
      input.classList.remove("clear-search-rules-input--touched");
    }
  }
  renderRuleList(container) {
    const ruleListContainer = container.createDiv("css-rule-container");
    const ruleList = ruleListContainer.createDiv("css-rule");
    this.cssEditorManager.initializeRuleListManager(ruleList);
    this.plugin.settings.cssRules.sort((a, b2) => a.rule.localeCompare(b2.rule)).forEach((rule) => {
      this.cssEditorManager.createRuleItem(ruleList, rule);
    });
  }
  async filterCSSRules(query) {
    let matchCount = 0;
    this.plugin.settings.cssRules.forEach((rule) => {
      var _a2, _b;
      const matchesQuery = ((_a2 = rule.rule.toLowerCase()) == null ? void 0 : _a2.includes(query.toLowerCase())) || ((_b = rule.css.toLowerCase()) == null ? void 0 : _b.includes(query.toLowerCase()));
      const ruleEl = this.container.querySelector(`[data-cts-uuid="${rule.uuid}"]`);
      if (ruleEl) {
        ruleEl.toggleClass("show", matchesQuery);
        ruleEl.toggleClass("hide", !matchesQuery);
        if (matchesQuery) matchCount++;
      }
    });
    this.updateResultsCounter(query, matchCount);
  }
  updateResultsCounter(term, results) {
    const counter = this.ruleSearchCounter;
    if (counter) {
      if (term) {
        counter.textContent = `${results} rule${results !== 1 ? "s" : ""} found`;
        counter.addClass("active");
        counter.toggleClass("no-results", results === 0);
      } else {
        counter.textContent = "";
        counter.removeClass("active");
        counter.removeClass("no-results");
      }
    }
  }
  resetRuleVisibility() {
    const ruleListEls = this.container.querySelectorAll(".rule-item");
    ruleListEls.forEach((element) => {
      element.toggleClass("show", true);
      element.toggleClass("hide", false);
    });
    this.updateResultsCounter("", 0);
  }
  scrollToElement(target) {
    if (target && this.container) {
      smoothScrollToElement(this.container, target);
    }
  }
  destroy() {
    var _a2;
    (_a2 = this.element) == null ? void 0 : _a2.remove();
  }
};

// src/settings/index.ts
var import_obsidian16 = require("obsidian");

// src/ace/AceThemes.ts
var import_ace = __toESM(require_ace());
var import_theme_chrome = __toESM(require_theme_chrome());
var import_theme_cloud_editor = __toESM(require_theme_cloud_editor());
var import_theme_cloud9_day = __toESM(require_theme_cloud9_day());
var import_theme_clouds = __toESM(require_theme_clouds());
var import_theme_crimson_editor = __toESM(require_theme_crimson_editor());
var import_theme_dawn = __toESM(require_theme_dawn());
var import_theme_dreamweaver = __toESM(require_theme_dreamweaver());
var import_theme_eclipse = __toESM(require_theme_eclipse());
var import_theme_github = __toESM(require_theme_github());
var import_theme_github_light_default = __toESM(require_theme_github_light_default());
var import_theme_gruvbox_light_hard = __toESM(require_theme_gruvbox_light_hard());
var import_theme_iplastic = __toESM(require_theme_iplastic());
var import_theme_katzenmilch = __toESM(require_theme_katzenmilch());
var import_theme_kuroir = __toESM(require_theme_kuroir());
var import_theme_solarized_light = __toESM(require_theme_solarized_light());
var import_theme_sqlserver = __toESM(require_theme_sqlserver());
var import_theme_textmate = __toESM(require_theme_textmate());
var import_theme_tomorrow = __toESM(require_theme_tomorrow());
var import_theme_xcode = __toESM(require_theme_xcode());
var import_theme_ambiance = __toESM(require_theme_ambiance());
var import_theme_chaos = __toESM(require_theme_chaos());
var import_theme_cloud9_night = __toESM(require_theme_cloud9_night());
var import_theme_cloud9_night_low_color = __toESM(require_theme_cloud9_night_low_color());
var import_theme_clouds_midnight = __toESM(require_theme_clouds_midnight());
var import_theme_cobalt = __toESM(require_theme_cobalt());
var import_theme_dracula = __toESM(require_theme_dracula());
var import_theme_github_dark = __toESM(require_theme_github_dark());
var import_theme_gob = __toESM(require_theme_gob());
var import_theme_gruvbox = __toESM(require_theme_gruvbox());
var import_theme_gruvbox_dark_hard = __toESM(require_theme_gruvbox_dark_hard());
var import_theme_idle_fingers = __toESM(require_theme_idle_fingers());
var import_theme_kr_theme = __toESM(require_theme_kr_theme());
var import_theme_merbivore = __toESM(require_theme_merbivore());
var import_theme_merbivore_soft = __toESM(require_theme_merbivore_soft());
var import_theme_mono_industrial = __toESM(require_theme_mono_industrial());
var import_theme_monokai = __toESM(require_theme_monokai());
var import_theme_nord_dark = __toESM(require_theme_nord_dark());
var import_theme_one_dark = __toESM(require_theme_one_dark());
var import_theme_pastel_on_dark = __toESM(require_theme_pastel_on_dark());
var import_theme_solarized_dark = __toESM(require_theme_solarized_dark());
var import_theme_terminal = __toESM(require_theme_terminal());
var import_theme_tomorrow_night = __toESM(require_theme_tomorrow_night());
var import_theme_tomorrow_night_blue = __toESM(require_theme_tomorrow_night_blue());
var import_theme_tomorrow_night_bright = __toESM(require_theme_tomorrow_night_bright());
var import_theme_tomorrow_night_eighties = __toESM(require_theme_tomorrow_night_eighties());
var import_theme_twilight = __toESM(require_theme_twilight());
var import_theme_vibrant_ink = __toESM(require_theme_vibrant_ink());
var lightThemes = [
  ["Chrome", "chrome"],
  ["Cloud Editor", "cloud_editor"],
  ["Cloud9 Day", "cloud9_day"],
  ["Clouds", "clouds"],
  ["Crimson Editor", "crimson_editor"],
  ["Dawn", "dawn"],
  ["Dreamweaver", "dreamweaver"],
  ["Eclipse", "eclipse"],
  ["Github (Legacy)", "github"],
  ["Github Light Default", "github_light_default"],
  ["Gruvbox Light Hard", "gruvbox_light_hard"],
  ["iPlastic", "iplastic"],
  ["Katzenmilch", "katzenmilch"],
  ["Kuroir", "kuroir"],
  ["Solarized Light", "solarized_light"],
  ["Sqlserver", "sqlserver"],
  ["Textmate", "textmate"],
  ["Tomorrow", "tomorrow"],
  ["XCode", "xcode"]
];
var AceLightThemesList = lightThemes.map(
  ([name, value]) => ({ name, value })
);
var darkThemes = [
  ["Ambiance", "ambiance"],
  ["Chaos", "chaos"],
  ["Cloud Editor Dark", "cloud_editor_dark"],
  ["Cloud9 Night", "cloud9_night"],
  ["Cloud9 Night Low Color", "cloud9_night_low_color"],
  ["Clouds Midnight", "clouds_midnight"],
  ["Cobalt", "cobalt"],
  ["Dracula", "dracula"],
  ["Github Dark", "github_dark"],
  ["Gob", "gob"],
  ["Gruvbox", "gruvbox"],
  ["Gruvbox Dark Hard", "gruvbox_dark_hard"],
  ["idle Fingers", "idle_fingers"],
  ["krTheme", "kr_theme"],
  ["Merbivore", "merbivore"],
  ["Merbivore Soft", "merbivore_soft"],
  ["Mono Industrial", "mono_industrial"],
  ["Monokai", "monokai"],
  ["Nord Dark", "nord_dark"],
  ["One Dark", "one_dark"],
  ["Pastel on Dark", "pastel_on_dark"],
  ["Solarized Dark", "solarized_dark"],
  ["Terminal", "terminal"],
  ["Tomorrow Night", "tomorrow_night"],
  ["Tomorrow Night Blue", "tomorrow_night_blue"],
  ["Tomorrow Night Bright", "tomorrow_night_bright"],
  ["Tomorrow Night Eighties", "tomorrow_night_eighties"],
  ["Twilight", "twilight"],
  ["Vibrant Ink", "vibrant_ink"]
];
var AceDarkThemesList = darkThemes.map(
  ([name, value]) => ({ name, value })
);
var AceKeyboardList = ["default", "vscode", "sublime", "emacs", "vim"];

// src/settings/index.ts
init_confirmModal();

// src/settings/settingsIO.ts
var import_obsidian15 = require("obsidian");
var SettingsIO = class _SettingsIO {
  constructor() {
  }
  static getInstance() {
    if (!_SettingsIO.instance) {
      _SettingsIO.instance = new _SettingsIO();
    }
    return _SettingsIO.instance;
  }
  init(app) {
    this.app = app;
  }
  /**
   * Exports the plugin settings to a JSON file in the vault.
   * The file will be created as CTS_settings.json in the vault root.
   *
   * @param settings - The settings object to export.
   * @returns A promise that resolves to true if the export was successful, false otherwise.
   */
  async exportSettings(settings, app) {
    try {
      if (!app) {
        throw new Error("App reference not set");
      }
      const settingsData = JSON.stringify(settings, null, 2);
      return this.exportToVault(settingsData, app);
    } catch (error) {
      Logger.error("Failed to export settings:", error);
      new import_obsidian15.Notice("Failed to export settings");
      return false;
    }
  }
  /**
   * Exports the settings to the vault.
   * Exports the settings to a file named CTS_settings.json
   *
   * @param settingsData - The settings data to export.
   * @returns A promise that resolves to true if the export was successful, false otherwise.
   */
  async exportToVault(settingsData, app) {
    try {
      const filename = "CTS_settings.json";
      const existingFile = app.vault.getAbstractFileByPath(filename);
      if (existingFile instanceof import_obsidian15.TFile) {
        const backupName = `CTS_settings_backup_${Date.now()}.json`;
        await app.vault.copy(existingFile, backupName);
        await app.vault.modify(existingFile, settingsData);
      } else {
        await app.vault.create(filename, settingsData);
      }
      new import_obsidian15.Notice(`Settings exported to vault: ${filename}`);
      return true;
    } catch (error) {
      Logger.error("Failed to export to vault:", error);
      new import_obsidian15.Notice("Failed to export settings to vault");
      return false;
    }
  }
  /**
   * Imports settings from a JSON file in the vault.
   * Looks for CTS_settings.json in the vault root.
   *
   * @returns The imported settings or null if the import failed.
   */
  async importSettings(app) {
    try {
      if (!app) {
        throw new Error("App reference not set");
      }
      return this.importFromVault(app);
    } catch (error) {
      Logger.error("Failed to import settings:", error);
      new import_obsidian15.Notice("Failed to import settings");
      return null;
    }
  }
  /**
   * Fallback method to import settings from the vault.
   * from the file CTS_settings.json
   *
   * @returns The imported settings or null if the import failed.
   */
  async importFromVault(app) {
    try {
      const filename = "CTS_settings.json";
      const file = app.vault.getAbstractFileByPath(filename);
      if (!file || !(file instanceof import_obsidian15.TFile)) {
        new import_obsidian15.Notice(`Could not find ${filename} in vault`);
        return null;
      }
      const fileContent = await app.vault.read(file);
      const importedSettings = JSON.parse(fileContent);
      if (!this.validateSettings(importedSettings)) {
        new import_obsidian15.Notice("Invalid settings file format");
        return null;
      }
      new import_obsidian15.Notice("Settings imported from vault successfully");
      return importedSettings;
    } catch (error) {
      Logger.error("Failed to import from vault:", error);
      new import_obsidian15.Notice("Failed to import settings from vault");
      return null;
    }
  }
  /**
   * Validates the settings object to ensure it has the correct structure.
   *
   * @param settings - The settings object to validate.
   * @return True if the settings object is valid, false otherwise.
   */
  validateSettings(settings) {
    if (!settings || typeof settings !== "object") return false;
    if (typeof settings.themeEnabled !== "boolean") return false;
    if (typeof settings.autoApplyChanges !== "boolean") return false;
    if (typeof settings.exportThemeIncludeDisabled !== "boolean") return false;
    if (typeof settings.exportPrettierFormat !== "boolean") return false;
    if (typeof settings.showConfirmation !== "boolean") return false;
    if (typeof settings.enableFontImport !== "boolean") return false;
    if (typeof settings.enableColorPicker !== "boolean") return false;
    if (typeof settings.enableAceAutoCompletion !== "boolean") return false;
    if (typeof settings.enableAceSnippets !== "boolean") return false;
    if (typeof settings.enableAceColorPicker !== "boolean") return false;
    if (typeof settings.editorLineNumbers !== "boolean") return false;
    if (typeof settings.editorWordWrap !== "boolean") return false;
    if (typeof settings.viewScrollToTop !== "boolean") return false;
    if (typeof settings.generateComputedCSS !== "boolean") return false;
    if (typeof settings.selectorPreferClasses !== "boolean") return false;
    if (typeof settings.selectorAlwaysIncludeTag !== "boolean") return false;
    if (typeof settings.expandCSSVariables !== "boolean") return false;
    if (typeof settings.expandCSSRules !== "boolean") return false;
    if (typeof settings.expandExportTheme !== "boolean") return false;
    if (typeof settings.expandEditorSettings !== "boolean") return false;
    if (typeof settings.customCSS !== "string") return false;
    if (typeof settings.exportThemeName !== "string") return false;
    if (typeof settings.exportThemeAuthor !== "string") return false;
    if (typeof settings.exportThemeURL !== "string") return false;
    if (typeof settings.lastSelectedSelector !== "string") return false;
    if (typeof settings.activeVariableTagFilter !== "string") return false;
    if (typeof settings.variableInputListener !== "string") return false;
    if (typeof settings.editorFontFamily !== "string") return false;
    if (typeof settings.editorTheme !== "string") return false;
    if (typeof settings.editorLightTheme !== "string") return false;
    if (typeof settings.editorDarkTheme !== "string") return false;
    if (typeof settings.editorKeyboard !== "string") return false;
    if (typeof settings.debugLevel !== "string") return false;
    if (typeof settings.selectorStyle !== "string") return false;
    if (typeof settings.selectorExcludedAttributes !== "string") return false;
    if (typeof settings.editorFontSize !== "number") return false;
    if (typeof settings.cssEditorDebounceDelay !== "number") return false;
    if (typeof settings.editorTabWidth !== "number" && typeof settings.editorTabWidth !== "string") return false;
    if (!Array.isArray(settings.cssVariables)) return false;
    if (!Array.isArray(settings.cssRules)) return false;
    if (!Array.isArray(settings.expandedVariableCategories)) return false;
    if (settings.cssVariables.length > 0) {
      const variable = settings.cssVariables[0];
      if (typeof variable.parent !== "string" || typeof variable.variable !== "string" || typeof variable.value !== "string") {
        return false;
      }
    }
    if (settings.cssRules.length > 0) {
      const rule = settings.cssRules[0];
      if (typeof rule.uuid !== "string" || typeof rule.rule !== "string" || typeof rule.css !== "string" || typeof rule.enabled !== "boolean") {
        return false;
      }
    }
    return true;
  }
};
var settingsIO = SettingsIO.getInstance();
var settingsIO_default = settingsIO;

// src/settings/index.ts
var SETTINGS_VERSION = 1;
var DEFAULT_SETTINGS = {
  version: SETTINGS_VERSION,
  themeEnabled: false,
  customCSS: "",
  cssVariables: [],
  cssRules: [],
  exportThemeName: "My Custom Theme",
  exportThemeAuthor: "Anonymous",
  exportThemeURL: "https://github.com/obsidianmd",
  exportThemeIncludeDisabled: false,
  exportPrettierFormat: true,
  lastSelectedSelector: "",
  expandCSSVariables: false,
  expandCSSRules: false,
  expandExportTheme: false,
  expandEditorSettings: false,
  expandedVariableCategories: [],
  activeVariableTagFilter: "all",
  autoApplyChanges: false,
  variableInputListener: "change",
  generateComputedCSS: false,
  showConfirmation: true,
  enableFontImport: false,
  enableColorPicker: false,
  enableAceAutoCompletion: false,
  enableAceSnippets: false,
  enableAceColorPicker: false,
  editorLineNumbers: true,
  editorWordWrap: false,
  editorFontSize: 15,
  editorFontFamily: "",
  editorTabWidth: 4,
  editorTheme: "Auto",
  editorLightTheme: "github_light_default",
  editorDarkTheme: "github_dark",
  editorKeyboard: "default",
  viewScrollToTop: true,
  debugLevel: "none",
  selectorStyle: "minimal",
  selectorPreferClasses: false,
  selectorAlwaysIncludeTag: false,
  selectorExcludedAttributes: `data-tooltip-*
data-delay
aria-expanded
aria-current
aria-controls
aria-describedby`,
  cssEditorDebounceDelay: 500
};
var THEME_COLOR = {
  Auto: "Auto",
  Light: "Light",
  Dark: "Dark"
};
var CustomThemeStudioSettingTab = class extends import_obsidian16.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("cts-settings-tab");
    new import_obsidian16.Setting(containerEl).setName("Enable custom theme").setDesc("Toggle your custom theme on or off.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.themeEnabled).onChange(async (value) => {
        this.plugin.settings.themeEnabled = value;
        if (value) {
          this.plugin.themeManager.applyCustomTheme();
        } else {
          this.plugin.themeManager.removeCustomTheme();
        }
        await this.plugin.saveSettings();
        let themeToggle = window.document.querySelector('.cts-view [id="theme-toggle-switch"]');
        if (themeToggle) {
          if (value) {
            themeToggle.checked = true;
          } else {
            themeToggle.checked = false;
          }
        }
      })
    );
    new import_obsidian16.Setting(containerEl).setName("CSS variables").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Variable update trigger").setDesc('When to update CSS after changing variable values. Choose "Input" for live updates (every keystroke) or "Change" to update only when you finish editing (clicking away from the field).').addDropdown((dropdown) => {
      dropdown.addOptions({
        "input": "input",
        "change": "change"
      }).setValue(this.plugin.settings.variableInputListener).onChange(async (newValue) => {
        this.plugin.settings.variableInputListener = newValue;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian16.Setting(containerEl).setName("Variable color picker").setDesc("Enable a color picker for CSS variables that have a default HEX color value.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableColorPicker).onChange(async (value) => {
        this.plugin.settings.enableColorPicker = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("CSS rules").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Font import").setDesc("Enable font imports to create @font-face CSS rules.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableFontImport).onChange(async (value) => {
        this.plugin.settings.enableFontImport = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Warn before discarding changes").setDesc("Warn before discarding unsaved changes when closing or switching between CSS editors.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showConfirmation).onChange(async (value) => {
        this.plugin.settings.showConfirmation = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Element selector").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Selector style preset").setDesc('Choose the style of CSS selectors generated when picking elements. "Minimal" creates short selectors, "Balanced" includes the tag name, and "Specific" includes all attributes.').addDropdown(
      (dropdown) => dropdown.addOption("minimal", "Minimal (clean & short)").addOption("balanced", "Balanced (moderate specificity)").addOption("specific", "Specific (maximum detail)").setValue(this.plugin.settings.selectorStyle).onChange(async (value) => {
        this.plugin.settings.selectorStyle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Prefer classes over attributes").setDesc("When enabled, prioritize class selectors (e.g., .my-class) over data attributes.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.selectorPreferClasses).onChange(async (value) => {
        this.plugin.settings.selectorPreferClasses = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Always include tag names").setDesc("When enabled, always include the HTML tag (e.g., div[data-foo] instead of [data-foo]).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.selectorAlwaysIncludeTag).onChange(async (value) => {
        this.plugin.settings.selectorAlwaysIncludeTag = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Excluded attribute patterns").setDesc('Attributes matching these patterns will be excluded from Minimal and Balanced selectors (one per line). Supports wildcards like "data-tooltip-*". Specific mode includes all attributes.').addTextArea(
      (text) => text.setPlaceholder("data-tooltip-*\ndata-delay\naria-expanded").setValue(this.plugin.settings.selectorExcludedAttributes).onChange(async (value) => {
        this.plugin.settings.selectorExcludedAttributes = value;
        await this.plugin.saveSettings();
      })
    ).then((setting) => {
      var _a2;
      (_a2 = setting.controlEl.querySelector("textarea")) == null ? void 0 : _a2.setAttribute("rows", "5");
    });
    new import_obsidian16.Setting(containerEl).setName("Generate CSS").setDesc("Automatically populate the CSS editor with common properties (color, background, font, etc.) when selecting an element.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.generateComputedCSS).onChange(async (value) => {
        this.plugin.settings.generateComputedCSS = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("CSS editor").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Auto-apply changes").setDesc('Automatically preview changes "live" as you make them. Changes become permanent once the CSS is saved.').addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoApplyChanges).onChange(async (value) => {
        this.plugin.settings.autoApplyChanges = value;
        await this.plugin.saveSettings();
      })
    );
    let noticeDiv = this.containerEl.createDiv("cts-auto-apply-changes-notice");
    let noticeIcon = noticeDiv.createDiv("cts-auto-apply-changes-notice-icon");
    noticeIcon.setAttribute("aria-label", "Notice");
    noticeIcon.setAttribute("data-tooltip-position", "top");
    let noticeText = noticeDiv.createDiv("cts-auto-apply-changes-notice-text");
    noticeText.textContent = 'When enabled, every keystroke triggers a "live" refresh of your theme. This can lead to unwanted styling and possibly make Obsidian unusable.';
    (0, import_obsidian16.setIcon)(noticeIcon, "alert-triangle");
    this.containerEl.appendChild(noticeDiv);
    let debounceDelaySlider;
    new import_obsidian16.Setting(containerEl).setName("Auto-apply change delay").setDesc("Delay before live-previewing CSS changes while typing (requires auto-apply). Lower values = faster feedback but may cause performance issues.").addSlider((slider) => {
      debounceDelaySlider = slider;
      slider.setLimits(0, 2e3, 100).setValue(this.plugin.settings.cssEditorDebounceDelay).onChange(async (value) => {
        slider.sliderEl.setAttribute("aria-label", value.toString() + "ms");
        this.plugin.settings.cssEditorDebounceDelay = value;
        await this.plugin.saveSettings();
      });
      slider.sliderEl.setAttribute("aria-label", this.plugin.settings.cssEditorDebounceDelay.toString() + "ms");
      slider.sliderEl.setAttribute("data-tooltip-position", "top");
      slider.sliderEl.setAttribute("data-tooltip-delay", "100");
    }).addExtraButton(
      (button) => button.setIcon("rotate-ccw").setTooltip(`Restore default (${DEFAULT_SETTINGS.cssEditorDebounceDelay.toString()})`).onClick(async () => {
        debounceDelaySlider.setValue(DEFAULT_SETTINGS.cssEditorDebounceDelay);
        debounceDelaySlider.sliderEl.setAttribute("aria-label", DEFAULT_SETTINGS.cssEditorDebounceDelay.toString());
        this.plugin.settings.cssEditorDebounceDelay = 500;
        await this.plugin.saveSettings();
      })
    );
    const editorSettingsHeading = new import_obsidian16.Setting(containerEl).setName("CSS editor preferences").setHeading().setTooltip("Click to expand/collapse CSS editor preferences");
    editorSettingsHeading.settingEl.addClass("cts-collapsible-heading");
    const chevronIcon = editorSettingsHeading.nameEl.createDiv("cts-chevron-icon");
    (0, import_obsidian16.setIcon)(chevronIcon, this.plugin.settings.expandEditorSettings ? "chevron-down" : "chevron-right");
    const editorSettingsContainer = containerEl.createDiv("cts-editor-settings-container");
    if (!this.plugin.settings.expandEditorSettings) {
      editorSettingsContainer.style.display = "none";
    }
    editorSettingsHeading.settingEl.addEventListener("click", async () => {
      this.plugin.settings.expandEditorSettings = !this.plugin.settings.expandEditorSettings;
      editorSettingsContainer.style.display = this.plugin.settings.expandEditorSettings ? "block" : "none";
      chevronIcon.empty();
      (0, import_obsidian16.setIcon)(chevronIcon, this.plugin.settings.expandEditorSettings ? "chevron-down" : "chevron-right");
      await this.plugin.saveSettings();
    });
    new import_obsidian16.Setting(editorSettingsContainer).setName("Editor color picker").setDesc("Show inline color picker for hex/rgb values.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAceColorPicker).onChange(async (value) => {
        this.plugin.settings.enableAceColorPicker = value;
        await this.plugin.saveSettings();
      })
    );
    let liveAutoCompletiongsToggle = new import_obsidian16.Setting(editorSettingsContainer).setName("Live auto completion").setDesc("Show auto-completion suggestions while typing CSS properties and values.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAceAutoCompletion).onChange(async (value) => {
        var _a2;
        if (!value) {
          if ((_a2 = snippetsToggle.settingEl.querySelector(".checkbox-container")) == null ? void 0 : _a2.hasClass("is-enabled")) {
            new import_obsidian16.Notice('Snippets are enabled and require that "Live auto completion" be enabled. Please disable the below "Snippets" toggle before disabling this setting.', 1e4);
            toggle.setValue(true);
            return;
          }
        }
        this.plugin.settings.enableAceAutoCompletion = value;
        await this.plugin.saveSettings();
      })
    );
    let snippetsToggle = new import_obsidian16.Setting(editorSettingsContainer).setName("Snippets").setDesc("Show Obsidian CSS variables in auto-completion (requires live auto-completion).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAceSnippets).onChange(async (value) => {
        var _a2;
        this.plugin.settings.enableAceSnippets = value;
        if (value) {
          if (!((_a2 = liveAutoCompletiongsToggle.settingEl.querySelector(".checkbox-container")) == null ? void 0 : _a2.hasClass("is-enabled"))) {
            new import_obsidian16.Notice('Please enable the above "Live auto completion" toggle before enabling this setting.', 1e4);
            toggle.setValue(false);
            this.plugin.settings.enableAceSnippets = false;
          }
        } else {
          new import_obsidian16.Notice('Disabling this setting requires a reload of the Obsidian window. From the command palette, run the command "Reload app without saving." \u2026 Click this message to dismiss.', 0);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(editorSettingsContainer).setName("Editor theme").setDesc('CSS editor color theme. "Auto" matches your Obsidian theme.').addDropdown(async (dropdown) => {
      for (const key in THEME_COLOR) {
        dropdown.addOption(key, key);
      }
      dropdown.setValue(this.plugin.settings.editorTheme);
      dropdown.onChange(async (option) => {
        this.plugin.settings.editorTheme = option;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian16.Setting(editorSettingsContainer).setName("Light mode theme").setDesc("Syntax highlighting theme when Obsidian is in light mode.").addDropdown((dropdown) => {
      AceLightThemesList.forEach((theme) => {
        dropdown.addOption(theme.value, theme.name);
      });
      dropdown.setValue(this.plugin.settings.editorLightTheme).onChange(async (newValue) => {
        this.plugin.settings.editorLightTheme = newValue;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian16.Setting(editorSettingsContainer).setName("Dark mode theme").setDesc("Syntax highlighting theme when Obsidian is in dark mode.").addDropdown((dropdown) => {
      AceDarkThemesList.forEach((theme) => {
        dropdown.addOption(theme.value, theme.name);
      });
      dropdown.setValue(this.plugin.settings.editorDarkTheme).onChange(async (newValue) => {
        this.plugin.settings.editorDarkTheme = newValue;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian16.Setting(editorSettingsContainer).setName("Keyboard shortcuts").setDesc("Keyboard shortcut scheme for the CSS editor.").addDropdown((dropdown) => {
      AceKeyboardList.forEach((binding) => {
        dropdown.addOption(binding, binding);
      });
      dropdown.setValue(this.plugin.settings.editorKeyboard).onChange(async (newValue) => {
        this.plugin.settings.editorKeyboard = newValue;
        await this.plugin.saveSettings();
      });
    });
    let fontSizeSlider;
    new import_obsidian16.Setting(editorSettingsContainer).setName("Font size").setDesc("Set the font size of the CSS editor.").addSlider((slider) => {
      fontSizeSlider = slider;
      slider.setLimits(5, 30, 1).setValue(this.plugin.settings.editorFontSize).onChange(async (value) => {
        slider.sliderEl.setAttribute("aria-label", value.toString());
        this.plugin.settings.editorFontSize = value;
        this.plugin.saveSettings();
      });
      slider.sliderEl.setAttribute("aria-label", this.plugin.settings.editorFontSize.toString());
      slider.sliderEl.setAttribute("data-tooltip-position", "top");
      slider.sliderEl.setAttribute("data-tooltip-delay", "100");
    }).addExtraButton(
      (button) => button.setIcon("rotate-ccw").setTooltip("Restore default (15)").onClick(async () => {
        fontSizeSlider.setValue(15);
        fontSizeSlider.sliderEl.setAttribute("aria-label", "15");
        this.plugin.settings.editorFontSize = 15;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(editorSettingsContainer).setName("Font family").setDesc('Font family for the CSS editor (e.g., "Fira Code", "Monaco"). Leave empty for default.').addText(
      (text) => text.setValue(this.plugin.settings.editorFontFamily).onChange(async (value) => {
        this.plugin.settings.editorFontFamily = value;
        await this.plugin.saveSettings();
      })
    );
    let tabWidthDropdown;
    new import_obsidian16.Setting(editorSettingsContainer).setName("Tab width").setDesc("Indentation width (spaces per tab level). Standard is 2 or 4.").addDropdown((dropdown) => {
      tabWidthDropdown = dropdown;
      dropdown.addOptions({
        "2": "2",
        "4": "4"
      }).setValue(this.plugin.settings.editorTabWidth.toString()).onChange(async (newValue) => {
        this.plugin.settings.editorTabWidth = newValue;
        await this.plugin.saveSettings();
      });
    }).addExtraButton(
      (button) => button.setIcon("rotate-ccw").setTooltip(`Restore default (${DEFAULT_SETTINGS.editorTabWidth.toString()})`).onClick(async () => {
        tabWidthDropdown.setValue(DEFAULT_SETTINGS.editorTabWidth.toString());
        this.plugin.settings.editorTabWidth = DEFAULT_SETTINGS.editorTabWidth.toString();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(editorSettingsContainer).setName("Word wrap").setDesc("Wrap long lines instead of scrolling horizontally.").addToggle((toggle) => toggle.setValue(this.plugin.settings.editorWordWrap).onChange(async (value) => {
      this.plugin.settings.editorWordWrap = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian16.Setting(editorSettingsContainer).setName("Line numbers").setDesc("Show line numbers in the CSS editor.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.editorLineNumbers).onChange(async (value) => {
        this.plugin.settings.editorLineNumbers = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Theme export").setHeading();
    containerEl.createDiv(
      {
        cls: "cts-theme-export-description",
        text: "These settings can also be changed at time of export."
      }
    );
    new import_obsidian16.Setting(containerEl).setName("Theme name").setDesc("The name or title for your exported theme. ").addText((text) => text.setValue(this.plugin.settings.exportThemeName).onChange(async (value) => {
      this.plugin.settings.exportThemeName = value;
      await this.plugin.saveSettings();
      let varInput = window.document.querySelector(".cts-view .export-form-theme-name");
      if (varInput) {
        varInput.value = value;
      }
    }));
    new import_obsidian16.Setting(containerEl).setName("Author name").setDesc("Your name as the theme author. ").addText((text) => text.setValue(this.plugin.settings.exportThemeAuthor).onChange(async (value) => {
      this.plugin.settings.exportThemeAuthor = value;
      await this.plugin.saveSettings();
      let varInput = window.document.querySelector(".cts-view .export-form-theme-author");
      if (varInput) {
        varInput.value = value;
      }
    }));
    new import_obsidian16.Setting(containerEl).setName("Author URL").setDesc("URL to your Github profile page (e.g. https://github.com/username). ").addText((text) => text.setValue(this.plugin.settings.exportThemeURL).onChange(async (value) => {
      this.plugin.settings.exportThemeURL = value;
      await this.plugin.saveSettings();
      let varInput = window.document.querySelector(".cts-view .export-form-theme-url");
      if (varInput) {
        varInput.value = value;
      }
    }));
    new import_obsidian16.Setting(containerEl).setName("Include disabled CSS rules when exporting").setDesc('Include disabled rules in exported themes (useful for sharing themes with optional features)."').addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.exportThemeIncludeDisabled).onChange(async (value) => {
        this.plugin.settings.exportThemeIncludeDisabled = value;
        await this.plugin.saveSettings();
        let includeDisabledToggle = window.document.querySelector('.cts-view [id="include-disabled-switch"]');
        if (includeDisabledToggle) {
          if (value) {
            includeDisabledToggle.checked = true;
          } else {
            includeDisabledToggle.checked = false;
          }
        }
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Prettier formatting").setDesc("Automatically format CSS using Prettier formatter.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.exportPrettierFormat).onChange(async (value) => {
        this.plugin.settings.exportPrettierFormat = value;
        await this.plugin.saveSettings();
        let enabledPrettierToggle = window.document.querySelector('.cts-view [id="enable-prettier-switch"]');
        if (enabledPrettierToggle) {
          if (value) {
            enabledPrettierToggle.checked = true;
          } else {
            enabledPrettierToggle.checked = false;
          }
        }
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Scroll helper").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Scroll to top").setDesc("Auto-scroll to expanded sections or active editors for easier navigation.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.viewScrollToTop).onChange(async (value) => {
        this.plugin.settings.viewScrollToTop = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Settings backup").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Export & import settings").setDesc("Export or import all plugin settings. Import will overwrite current settings. File saved to vault root as CTS_settings.json.").addButton((button) => {
      button.setButtonText("Export");
      button.onClick(async () => {
        settingsIO_default.exportSettings(this.plugin.settings, this.app);
      });
    }).addButton((button) => {
      button.setButtonText("Import");
      button.onClick(async () => {
        const importedSettings = await settingsIO_default.importSettings(this.app);
        if (importedSettings) {
          if (await confirm("This will overwrite your current settings and cannot be undone. Continue?", this.plugin.app)) {
            this.plugin.settings = importedSettings;
            await this.plugin.saveData(this.plugin.settings);
            new import_obsidian16.Notice("Settings imported successfully. The plugin will now be reloaded.");
            this.reload();
          }
        }
      });
    });
    new import_obsidian16.Setting(containerEl).setName("Troubleshooting").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Reload view").setDesc("Most settings under CSS variables & CSS rules require the plugin's view to be reloaded to take effect.").addButton(
      (button) => button.setButtonText("Reload").setClass("mod-destructive").onClick(async () => {
        if (await confirm("You may have unsaved changes. Reloading the view will reload all forms. Continue?", this.plugin.app)) {
          try {
            await this.plugin.reloadView();
            new import_obsidian16.Notice("The Custom Theme Studio view has been reloaded");
          } catch (error) {
            Logger.error(error);
            new import_obsidian16.Notice("Failed to reload view. Check developer console for details.", 1e4);
          }
        }
      })
    );
    new import_obsidian16.Setting(containerEl).setName("Debug level").setDesc("Control console logging verbosity for debugging").addDropdown((dropdown) => dropdown.addOption("none", "None (No logs)").addOption("error", "Errors only").addOption("warn", "Warnings and errors").addOption("info", "Info, warnings, and errors").addOption("debug", "Debug (All logs)").setValue(this.plugin.settings.debugLevel).onChange(async (value) => {
      this.plugin.settings.debugLevel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian16.Setting(containerEl).setName("Reset").setClass("reset-options-heading").setHeading();
    new import_obsidian16.Setting(containerEl).setName("Reset theme").setDesc("Reset all theme customizations.").addButton((button) => button.setButtonText("Reset").setClass("mod-destructive").onClick(async () => {
      if (await confirm("Are you sure you want to reset all theme customizations? This cannot be undone.", this.plugin.app)) {
        this.plugin.settings.customCSS = "";
        this.plugin.settings.cssVariables = [];
        this.plugin.settings.cssRules = [];
        this.plugin.settings.themeEnabled = false;
        this.plugin.themeManager.removeCustomTheme();
        this.plugin.themeManager.applyIfEnabled();
        await this.plugin.saveSettings();
        const leaves = this.app.workspace.getLeavesOfType("cts-view");
        if (leaves.length > 0) {
          this.plugin.reloadView();
        }
        this.display();
        new import_obsidian16.Notice("Theme has been reset");
      }
    }));
  }
  /** Reloads the plugin */
  async reload() {
    await this.app.plugins.disablePlugin("custom-theme-studio");
    await this.app.plugins.enablePlugin("custom-theme-studio");
    this.app.setting.openTabById("custom-theme-studio").display();
  }
};

// src/views/components/ExportSection.ts
var ExportSection = class extends UIComponent {
  constructor(context) {
    super(context);
    this.settingsUnsubscribers = [];
    this.setupReactiveListeners();
  }
  render() {
    const section = this.createSection("export-section");
    const { content } = createCollapsibleSection(section, {
      title: "Export theme",
      expanded: this.plugin.settings.expandExportTheme,
      onToggle: (expanded) => {
        this.plugin.settings.expandExportTheme = expanded;
        this.saveSettings();
      }
    });
    this.renderDescription(content);
    this.renderForm(content);
    this.renderButtons(content);
    return section;
  }
  renderDescription(container) {
    const description = container.createDiv("export-description");
    description.createSpan({
      text: "Export your custom variables and rules as CSS and manifest files to create a shareable theme."
    });
  }
  renderForm(container) {
    const formContainer = container.createDiv("export-form");
    this.renderThemeNameInput(formContainer);
    this.renderAuthorInput(formContainer);
    this.renderURLInput(formContainer);
    this.renderIncludeDisabledToggle(formContainer);
    this.renderPrettierToggle(formContainer);
  }
  renderThemeNameInput(container) {
    const nameContainer = container.createDiv("export-form-item");
    nameContainer.createSpan({ text: "Theme name:" });
    this.nameInput = nameContainer.createEl("input", {
      cls: "export-form-theme-name",
      attr: {
        type: "text",
        value: this.plugin.settings.exportThemeName || DEFAULT_SETTINGS.exportThemeName
      }
    });
    this.nameInput.addEventListener("change", () => {
      this.handleNameInputChange(this.nameInput.value);
    });
  }
  renderAuthorInput(container) {
    const authorContainer = container.createDiv("export-form-item");
    authorContainer.createSpan({ text: "Author:" });
    this.authorInput = authorContainer.createEl("input", {
      cls: "export-form-theme-author",
      attr: {
        type: "text",
        value: this.plugin.settings.exportThemeAuthor || DEFAULT_SETTINGS.exportThemeAuthor
      }
    });
    this.authorInput.addEventListener("change", () => {
      this.handleAuthorInputChange(this.authorInput.value);
    });
  }
  renderURLInput(container) {
    const urlContainer = container.createDiv("export-form-item");
    urlContainer.createSpan({ text: "URL:" });
    this.urlInput = urlContainer.createEl("input", {
      cls: "export-form-theme-url",
      attr: {
        type: "text",
        value: this.plugin.settings.exportThemeURL || DEFAULT_SETTINGS.exportThemeURL
      }
    });
    this.urlInput.addEventListener("change", () => {
      this.handleURLInputChange(this.urlInput.value);
    });
  }
  renderIncludeDisabledToggle(container) {
    const includeDisabledContainer = container.createDiv("export-form-item include-disabled-toggle");
    const { toggle } = createToggleSwitch(
      includeDisabledContainer,
      "include-disabled-switch",
      "Include disabled CSS rules when exporting",
      this.plugin.settings.exportThemeIncludeDisabled,
      async (checked) => {
        this.plugin.settings.exportThemeIncludeDisabled = checked;
        await this.saveSettings();
      }
    );
  }
  renderPrettierToggle(container) {
    const enablePrettierContainer = container.createDiv("export-form-item enable-prettier-toggle");
    const { toggle } = createToggleSwitch(
      enablePrettierContainer,
      "enable-prettier-switch",
      "Format CSS with Prettier formatter",
      this.plugin.settings.exportPrettierFormat,
      async (checked) => {
        this.plugin.settings.exportPrettierFormat = checked;
        await this.saveSettings();
      }
    );
  }
  renderButtons(container) {
    const buttonContainer = container.createDiv("button-container");
    this.renderCSSButtons(buttonContainer);
    this.renderManifestButtons(buttonContainer);
  }
  renderCSSButtons(container) {
    const exportCSSButtons = container.createDiv("export-css-buttons");
    exportCSSButtons.createSpan({ text: "CSS: " });
    createIconButton(exportCSSButtons, {
      icon: "download",
      label: "Export CSS",
      onClick: async () => {
        this.plugin.themeManager.exportThemeCSS();
      }
    });
    createIconButton(exportCSSButtons, {
      icon: "copy",
      label: "Copy CSS to clipboard",
      classes: ["copy-css-button"],
      onClick: () => {
        this.plugin.themeManager.copyThemeToClipboard();
      }
    });
  }
  renderManifestButtons(container) {
    const exportManifestButtons = container.createDiv("export-manifest-buttons");
    exportManifestButtons.createSpan({ text: "Manifest: " });
    createIconButton(exportManifestButtons, {
      icon: "download",
      label: "Export manifest JSON",
      onClick: async () => {
        this.plugin.themeManager.exportThemeManifest();
      }
    });
    createIconButton(exportManifestButtons, {
      icon: "copy",
      label: "Copy manifest JSON to clipboard",
      classes: ["copy-manifest-button"],
      onClick: () => {
        this.plugin.themeManager.copyManifestToClipboard();
      }
    });
  }
  // Event Handler Methods
  handleNameInputChange(value) {
    this.settingsManager.update("exportThemeName", value);
  }
  handleAuthorInputChange(value) {
    this.settingsManager.update("exportThemeAuthor", value);
  }
  handleURLInputChange(value) {
    this.settingsManager.update("exportThemeURL", value);
  }
  setupReactiveListeners() {
    this.settingsUnsubscribers.push(
      this.settingsManager.onChange("exportThemeName", (value) => {
        if (this.nameInput && this.nameInput.value !== value) {
          this.nameInput.value = value;
        }
      }),
      this.settingsManager.onChange("exportThemeAuthor", (value) => {
        if (this.authorInput && this.authorInput.value !== value) {
          this.authorInput.value = value;
        }
      }),
      this.settingsManager.onChange("exportThemeURL", (value) => {
        if (this.urlInput && this.urlInput.value !== value) {
          this.urlInput.value = value;
        }
      })
    );
  }
  destroy() {
    var _a2;
    this.settingsUnsubscribers.forEach((unsub) => unsub());
    this.settingsUnsubscribers = [];
    (_a2 = this.element) == null ? void 0 : _a2.remove();
  }
};

// src/views/customThemeStudioView.ts
var VIEW_TYPE_CTS = "cts-view";
var CustomThemeStudioView = class extends import_obsidian17.ItemView {
  constructor(settings, leaf, plugin, config) {
    super(leaf);
    this.config = config;
    this.components = [];
    this.plugin = plugin;
    this.cssVariableManager = new CSSVariableManager(this.plugin);
    this.elementSelectorManager = new ElementSelectorManager(this.plugin, this);
    this.cssEditorManager = new CSSEditorManager(this.app.workspace, this.plugin, this, this.config);
    this.workspace = this.app.workspace;
    this.settings = settings;
    this.editorScope = new import_obsidian17.Scope();
    this.context = {
      app: this.app,
      plugin: this.plugin,
      settings: this.settings,
      containerEl: this.containerEl,
      cssEditorManager: this.cssEditorManager,
      elementSelectorManager: this.elementSelectorManager,
      cssVariableManager: this.cssVariableManager
    };
  }
  getViewType() {
    return VIEW_TYPE_CTS;
  }
  getDisplayText() {
    return "Custom Theme Studio";
  }
  getIcon() {
    return "paintbrush";
  }
  async onOpen() {
    this.prepareContainer();
    this.renderComponents();
    this.setupAccessibility();
    this.setupEditorFocusKeymap();
  }
  prepareContainer() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("cts-view");
  }
  renderComponents() {
    this.components = [
      new HeaderSection(this.context),
      new CSSVariablesSection(this.context),
      new CSSRulesSection(this.context),
      new ExportSection(this.context)
    ];
    this.components.forEach((component) => {
      component.render();
    });
  }
  setupAccessibility() {
    this.containerEl.addEventListener("keydown", (e) => {
      const target = e.target;
      if ((target == null ? void 0 : target.getAttribute("role")) === "button" && target.tagName === "A") {
        const key = e.key;
        const isEnter = key === "Enter" || e.keyCode === 13;
        const isSpace = key === " " || key === "Spacebar" || e.keyCode === 32;
        if (isEnter || isSpace) {
          e.preventDefault();
          target.click();
        }
      }
    });
  }
  setupEditorFocusKeymap() {
    const editorEl = this.cssEditorManager.editor;
    this.registerDomEvent(editorEl, "focus", () => {
      this.app.keymap.pushScope(this.editorScope);
    }, true);
    this.registerDomEvent(editorEl, "blur", () => {
      this.app.keymap.popScope(this.editorScope);
    }, true);
  }
  async onClose() {
    this.elementSelectorManager.stopElementSelection();
    this.cssEditorManager.clearAppliedChanges();
    this.destroyComponents();
  }
  destroyComponents() {
    this.components.forEach((component) => {
      component.destroy();
    });
    this.components = [];
  }
  scrollToDiv(target) {
    if (target && this.containerEl) {
      smoothScrollToElement(this.containerEl, target);
    }
  }
  createCustomVariableItemInput(container, variable, category) {
    const cssVariablesComponent = this.components.find((component) => component instanceof CSSVariablesSection);
    if (cssVariablesComponent) {
      cssVariablesComponent.createCustomVariableItemInput(container, variable, category);
    }
  }
  refreshCustomVariables() {
    const cssVariablesComponent = this.components.find((component) => component instanceof CSSVariablesSection);
    if (cssVariablesComponent) {
      cssVariablesComponent.refreshCustomVariables();
    }
  }
  get variableSearch() {
    const cssVariablesComponent = this.components.find((component) => component instanceof CSSVariablesSection);
    return (cssVariablesComponent == null ? void 0 : cssVariablesComponent.variableSearch) || "";
  }
  get ruleSearch() {
    const cssRulesComponent = this.components.find((component) => component instanceof CSSRulesSection);
    return (cssRulesComponent == null ? void 0 : cssRulesComponent.ruleSearch) || "";
  }
  async filterCSSRules(query) {
    const cssRulesComponent = this.components.find((component) => component instanceof CSSRulesSection);
    if (cssRulesComponent) {
      await cssRulesComponent.filterCSSRules(query);
    }
  }
};

// src/managers/themeManager.ts
var import_obsidian18 = require("obsidian");
var import_file_saver = __toESM(require_FileSaver_min());
var ThemeManager = class {
  constructor(plugin) {
    this.styleEl = null;
    this.plugin = plugin;
    this.cssVariableManager = new CSSVariableManager(plugin);
  }
  /**
   * Applies the custom theme by injecting CSS into the document.
   * Generates CSS from variables and custom rules, then adds it to the document head.
   */
  applyCustomTheme() {
    this.removeCustomTheme();
    this.styleEl = document.createElement("style");
    this.styleEl.id = "custom-theme-studio-css";
    const variablesCSS = this.generateVariablesCSS();
    const rulesCSS = this.plugin.settings.customCSS || "";
    this.styleEl.textContent = (variablesCSS !== "" ? variablesCSS + "\n\n" : "") + rulesCSS;
    document.head.appendChild(this.styleEl);
  }
  /**
   * Apply custom theme only if enabled in settings
   */
  applyIfEnabled() {
    if (this.plugin.settings.themeEnabled) {
      this.applyCustomTheme();
    }
  }
  /**
   * Removes the custom theme CSS from the document.
   * Cleans up the injected style element.
   */
  removeCustomTheme() {
    if (this.styleEl) {
      this.styleEl.remove();
      this.styleEl = null;
    } else {
      const existingStyle = document.getElementById("custom-theme-studio-css");
      if (existingStyle) {
        existingStyle.remove();
      }
    }
  }
  /**
   * Toggles the custom theme on/off.
   * Updates settings, applies or removes theme, shows notification, and syncs UI toggle.
   */
  async toggleCustomTheme() {
    this.plugin.settings.themeEnabled = !this.plugin.settings.themeEnabled;
    if (this.plugin.settings.themeEnabled) {
      this.applyCustomTheme();
      showNotice("Custom theme enabled", NOTICE_DURATIONS.STANDARD, "success");
    } else {
      this.removeCustomTheme();
      showNotice("Custom theme disabled", NOTICE_DURATIONS.STANDARD, "error");
    }
    this.plugin.saveSettings();
    let themeToggle = window.document.querySelector('.cts-view [id="theme-toggle-switch"]');
    if (themeToggle) {
      if (this.plugin.settings.themeEnabled) {
        themeToggle.checked = true;
      } else {
        themeToggle.checked = false;
      }
    }
  }
  /**
   * Generates CSS custom properties (variables) from plugin settings.
   * @returns CSS string with :root selector containing all custom variables
   */
  generateVariablesCSS() {
    const variables = this.plugin.settings.cssVariables;
    if (!variables.length) {
      return "";
    }
    let css = "";
    const sections = {
      body: { selector: "body", vars: "", found: false },
      themelight: { selector: ".theme-light", vars: "", found: false },
      themedark: { selector: ".theme-dark", vars: "", found: false }
    };
    variables.forEach((v2) => {
      const parentKey = ["body", "themelight", "themedark"].includes(v2.parent) ? v2.parent : "body";
      if (v2.value !== "") {
        sections[parentKey].vars += `  ${v2.variable}: ${v2.value};
`;
        sections[parentKey].found = true;
      }
    });
    for (const section of Object.values(sections)) {
      if (section.found) {
        css += `${section.selector} {
${section.vars}}

`;
      }
    }
    return css;
  }
  async startElementSelection() {
    const leaves = this.plugin.app.workspace.getLeavesOfType("cts-view");
    if (leaves.length > 0) {
      const view = leaves[0].view;
      if (view == null ? void 0 : view.elementSelectorManager) {
        view.elementSelectorManager.startElementSelection();
        const section = window.activeDocument.querySelector(".rules-section");
        const icon = section == null ? void 0 : section.querySelector(".collapse-icon");
        const content = section == null ? void 0 : section.querySelector(".collapsible-content");
        if (content && icon) {
          content.classList.replace("hide", "show");
          (0, import_obsidian18.setIcon)(icon, "chevron-down");
          icon.setAttr("aria-label", "Collapse section");
          icon.setAttr("data-tooltip-position", "top");
        }
      }
    } else {
      await this.plugin.activateView();
      window.setTimeout(() => {
        const newLeaves = this.plugin.app.workspace.getLeavesOfType("cts-view");
        if (newLeaves.length > 0) {
          const view = newLeaves[0].view;
          if (view == null ? void 0 : view.elementSelectorManager) {
            view.elementSelectorManager.startElementSelection();
            const section = window.activeDocument.querySelector(".rules-section");
            const icon = section == null ? void 0 : section.querySelector(".collapse-icon");
            const content = section == null ? void 0 : section.querySelector(".collapsible-content");
            if (content && icon) {
              content.classList.replace("hide", "show");
              (0, import_obsidian18.setIcon)(icon, "chevron-down");
              icon.setAttr("aria-label", "Collapse section");
              icon.setAttr("data-tooltip-position", "top");
            }
          }
        }
      }, TIMEOUT_DELAYS.ELEMENT_SELECTION);
    }
  }
  async exportThemeCSS() {
    try {
      const variablesCSS = this.generateVariablesCSS();
      let fullCSS = "";
      if (this.plugin.settings.exportThemeIncludeDisabled) {
        this.plugin.settings.cssRules.forEach((rule) => {
          fullCSS += `/* ${rule.rule} */
${rule.css}

`;
        });
      }
      const rulesCSS = fullCSS !== "" ? fullCSS : this.plugin.settings.customCSS;
      const themeCSS = `/* ${this.plugin.settings.exportThemeName || DEFAULT_SETTINGS.exportThemeName} for Obsidian */
/* by ${this.plugin.settings.exportThemeAuthor || DEFAULT_SETTINGS.exportThemeAuthor} */
/* ${this.plugin.settings.exportThemeURL || DEFAULT_SETTINGS.exportThemeURL} */

${variablesCSS}

${rulesCSS}`;
      new import_obsidian18.Notice("Exporting theme CSS file\u2026", 5e3);
      let prettierCSS = this.plugin.settings.exportPrettierFormat ? await this.formatCSS(themeCSS) : themeCSS;
      (0, import_file_saver.saveAs)(new Blob([prettierCSS], { type: "text/css" }), "theme.css");
    } catch (error) {
      Logger.error("Failed to export theme", error);
      showNotice("Failed to export theme. Check the developer console for details", 1e4, "error");
    }
  }
  exportThemeManifest() {
    try {
      const themeId = (this.plugin.settings.exportThemeName || DEFAULT_SETTINGS.exportThemeName).toLowerCase().replace(/[^a-z0-9]+/g, "-");
      const manifest = {
        name: themeId,
        version: "1.0.0",
        minAppVersion: "0.15.0",
        author: this.plugin.settings.exportThemeAuthor || DEFAULT_SETTINGS.exportThemeAuthor,
        authorUrl: this.plugin.settings.exportThemeURL || DEFAULT_SETTINGS.exportThemeURL
      };
      const manifestJSON = JSON.stringify(manifest, null, 2);
      new import_obsidian18.Notice("Exporting theme manifest file\u2026", 5e3);
      (0, import_file_saver.saveAs)(new Blob([manifestJSON], { type: "application/json" }), "manifest.json");
    } catch (error) {
      Logger.error("Failed to export manifest:", error);
      showNotice("Failed to export manifest. Check the developer console for details", 1e4, "error");
    }
  }
  async copyThemeToClipboard() {
    try {
      const variablesCSS = this.generateVariablesCSS();
      let fullCSS = "";
      if (this.plugin.settings.exportThemeIncludeDisabled) {
        this.plugin.settings.cssRules.forEach((rule) => {
          fullCSS += `/* ${rule.rule} */
${rule.css}

`;
        });
      }
      const rulesCSS = fullCSS !== "" ? fullCSS : this.plugin.settings.customCSS;
      const themeCSS = `/* ${this.plugin.settings.exportThemeName || DEFAULT_SETTINGS.exportThemeName} for Obsidian */
/* by ${this.plugin.settings.exportThemeAuthor || DEFAULT_SETTINGS.exportThemeAuthor} */
/* ${this.plugin.settings.exportThemeURL || DEFAULT_SETTINGS.exportThemeURL} */

${variablesCSS}

${rulesCSS}`;
      let prettierCSS = this.plugin.settings.exportPrettierFormat ? await this.formatCSS(themeCSS) : themeCSS;
      await navigator.clipboard.writeText(prettierCSS);
      showNotice("Theme CSS copied to clipboard", NOTICE_DURATIONS.STANDARD, "success");
    } catch (error) {
      Logger.error("Failed to copy theme to clipboard:\n", error);
      showNotice("Failed to copy theme to clipboard. Check the developer console for details", 1e4, "error");
    }
  }
  async copyManifestToClipboard() {
    try {
      const themeId = (this.plugin.settings.exportThemeName || DEFAULT_SETTINGS.exportThemeName).toLowerCase().replace(/[^a-z0-9]+/g, "-");
      const manifest = {
        name: themeId,
        version: "1.0.0",
        minAppVersion: "0.15.0",
        author: this.plugin.settings.exportThemeAuthor || DEFAULT_SETTINGS.exportThemeAuthor,
        authorUrl: this.plugin.settings.exportThemeURL || DEFAULT_SETTINGS.exportThemeURL
      };
      await navigator.clipboard.writeText(JSON.stringify(manifest, null, 2));
      showNotice("Manifest JSON copied to clipboard", NOTICE_DURATIONS.STANDARD, "success");
    } catch (error) {
      Logger.error("Failed to copy manifest JSON to clipboard:", error);
      showNotice("Failed to copy manifest JSON to clipboard. Check the developer console for details", 1e4, "error");
    }
  }
  formatCSS(code) {
    return fu(code, {
      parser: "css",
      plugins: [postcss_exports],
      tabWidth: Number(this.plugin.settings.editorTabWidth)
    });
  }
};

// src/managers/SettingsManager.ts
var SettingsManager = class {
  constructor(plugin) {
    this.listeners = /* @__PURE__ */ new Map();
    this.validators = /* @__PURE__ */ new Map();
    this.isUpdating = false;
    this.plugin = plugin;
    this.setupDefaultValidators();
  }
  /**
   * Get a setting value with type safety
   */
  get(key) {
    return this.plugin.settings[key];
  }
  /**
   * Update a setting with validation, persistence, and reactive notifications
   */
  async update(key, value, options = {}) {
    const { validate = true, persist = true, notify = true } = options;
    if (this.isUpdating) {
      return false;
    }
    const oldValue = this.plugin.settings[key];
    if (oldValue === value) {
      return true;
    }
    if (validate) {
      const validation = this.validateSetting(key, value);
      if (!validation.valid) {
        Logger.error(`Settings validation failed for ${key}:`, validation.error);
        return false;
      }
      if (validation.sanitizedValue !== void 0) {
        value = validation.sanitizedValue;
      }
    }
    this.plugin.settings[key] = value;
    if (persist) {
      try {
        await this.plugin.saveSettings();
      } catch (error) {
        Logger.error(`Failed to save settings:`, error);
        this.plugin.settings[key] = oldValue;
        return false;
      }
    }
    if (notify) {
      this.notifyListeners(key, value, oldValue);
    }
    return true;
  }
  /**
   * Update multiple settings atomically
   */
  async updateBatch(updates, options = {}) {
    const { validate = true, persist = true, notify = true } = options;
    this.isUpdating = true;
    const oldValues = /* @__PURE__ */ new Map();
    try {
      if (validate) {
        for (const [key, value] of Object.entries(updates)) {
          const validation = this.validateSetting(key, value);
          if (!validation.valid) {
            Logger.error(`Batch validation failed for ${key}:`, validation.error);
            return false;
          }
          if (validation.sanitizedValue !== void 0) {
            updates[key] = validation.sanitizedValue;
          }
        }
      }
      for (const [key, value] of Object.entries(updates)) {
        const settingKey = key;
        oldValues.set(settingKey, this.plugin.settings[settingKey]);
        this.plugin.settings[settingKey] = value;
      }
      if (persist) {
        await this.plugin.saveSettings();
      }
      if (notify) {
        for (const [key, value] of Object.entries(updates)) {
          const settingKey = key;
          const oldValue = oldValues.get(settingKey);
          this.notifyListeners(settingKey, value, oldValue);
        }
      }
      return true;
    } catch (error) {
      Logger.error("Batch settings update failed:", error);
      for (const [key, oldValue] of oldValues) {
        this.plugin.settings[key] = oldValue;
      }
      return false;
    } finally {
      this.isUpdating = false;
    }
  }
  /**
   * Subscribe to setting changes
   */
  onChange(key, callback) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, /* @__PURE__ */ new Set());
    }
    this.listeners.get(key).add(callback);
    return () => {
      const listeners = this.listeners.get(key);
      if (listeners) {
        listeners.delete(callback);
        if (listeners.size === 0) {
          this.listeners.delete(key);
        }
      }
    };
  }
  /**
   * Subscribe to changes on multiple settings
   */
  onAnyChange(keys, callback) {
    const unsubscribers = keys.map(
      (key) => this.onChange(key, (value, oldValue) => callback(key, value, oldValue))
    );
    return () => {
      unsubscribers.forEach((unsub) => unsub());
    };
  }
  /**
   * Add custom validator for a setting
   */
  addValidator(key, validator) {
    this.validators.set(key, validator);
  }
  /**
   * Validate a setting value
   */
  validateSetting(key, value) {
    const validator = this.validators.get(key);
    if (validator) {
      return validator(value, key);
    }
    if (value === void 0 || value === null) {
      return {
        valid: false,
        error: `Setting ${key} cannot be null or undefined`
      };
    }
    return { valid: true };
  }
  /**
   * Notify all listeners for a setting change
   */
  notifyListeners(key, value, oldValue) {
    const listeners = this.listeners.get(key);
    if (listeners) {
      listeners.forEach((callback) => {
        try {
          callback(value, oldValue, key);
        } catch (error) {
          Logger.error(`Error in settings listener for ${key}:`, error);
        }
      });
    }
  }
  /**
   * Setup default validators for common settings
   */
  setupDefaultValidators() {
    this.addValidator("exportThemeName", (value) => ({
      valid: true,
      sanitizedValue: value.trim()
    }));
    this.addValidator("exportThemeAuthor", (value) => ({
      valid: true,
      sanitizedValue: value.trim()
    }));
    this.addValidator("editorFontSize", (value) => {
      if (value < 8 || value > 72) {
        return {
          valid: false,
          error: "Font size must be between 8 and 72"
        };
      }
      return { valid: true };
    });
    this.addValidator("editorTabWidth", (value) => {
      if (value < 1 || value > 16) {
        return {
          valid: false,
          error: "Tab width must be between 1 and 16"
        };
      }
      return { valid: true };
    });
    this.addValidator("cssVariables", (value) => ({
      valid: Array.isArray(value),
      error: Array.isArray(value) ? void 0 : "cssVariables must be an array"
    }));
    this.addValidator("cssRules", (value) => ({
      valid: Array.isArray(value),
      error: Array.isArray(value) ? void 0 : "cssRules must be an array"
    }));
  }
  /**
   * Get all current listeners (for debugging)
   */
  getListeners() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, listeners] of this.listeners) {
      result.set(key, listeners.size);
    }
    return result;
  }
  /**
   * Clean up all listeners
   */
  destroy() {
    this.listeners.clear();
    this.validators.clear();
  }
};

// src/modals/CssSnippetFuzzySuggestModal.ts
var import_obsidian19 = require("obsidian");
init_confirmModal();
var CssSnippetFuzzySuggestModal = class extends import_obsidian19.FuzzySuggestModal {
  constructor(app, plugin, config) {
    super(app);
    this.config = config;
    this.plugin = plugin;
    this.setPlaceholder("Search and choose a snippet to import");
    this.setInstructions([
      {
        command: "\u2191\u2193",
        purpose: "to navigate"
      },
      {
        command: "\u21B5",
        purpose: "to choose a snippet"
      },
      {
        command: "esc",
        purpose: "to cancel"
      }
    ]);
  }
  getItems() {
    var _a2;
    if ((_a2 = this.app.customCss) == null ? void 0 : _a2.snippets) {
      return this.app.customCss.snippets.map((x) => new CssFile(x));
    }
    return [];
  }
  getItemText(item) {
    return item.basename;
  }
  async onChooseItem(item, _evt) {
    let css = await this.readSnippetFile(this.app, item);
    let uuid = generateUniqueId();
    let rule = "Snippet: " + item.name;
    this.plugin.settings.cssRules.push({
      uuid,
      rule,
      css,
      enabled: false
    });
    this.plugin.saveSettings();
    let leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_CTS).first();
    if (leaf) {
      if (!await confirm('The snippet has been saved as a new CSS rule. Click "OK" to reload the "Custom Theme Studio" view or if you have unsaved changes, click "Cancel" to reload the view manually at a later time.', this.plugin.app)) {
        return;
      }
      await this.app.workspace.revealLeaf(leaf);
      if (leaf.view instanceof CustomThemeStudioView) {
        let view = leaf.view;
        const ruleList = view.containerEl.querySelector(".css-rule");
        if (ruleList) {
          ruleList.empty();
          this.plugin.settings.cssRules.sort((a, b2) => a.rule.localeCompare(b2.rule));
          this.plugin.settings.cssRules.forEach((rule2) => {
            view.cssEditorManager.createRuleItem(ruleList, rule2);
          });
          const rulesSection = view.containerEl.querySelector(".rules-section");
          const ruleSection = rulesSection.querySelector(".collapsible-content");
          const toggleIcon = rulesSection.querySelector(".collapse-icon");
          if (ruleSection && toggleIcon) {
            ruleSection.classList.replace("hide", "show");
            (0, import_obsidian19.setIcon)(toggleIcon, "chevron-down");
            toggleIcon.setAttr("aria-label", "Collapse section");
            toggleIcon.setAttr("data-tooltip-position", "top");
          }
          if (this.plugin.settings.viewScrollToTop) {
            window.setTimeout(() => {
              const ruleDiv = view.containerEl.querySelector(`[data-cts-uuid="${uuid}"]`);
              view.scrollToDiv(ruleDiv);
            }, 100);
          }
        }
      }
    } else {
      showNotice("The snippet has been saved as a new CSS rule", NOTICE_DURATIONS.STANDARD, "success");
    }
  }
  getSnippetDirectory(app) {
    return `${app.vault.configDir}/snippets/`;
  }
  async readSnippetFile(app, file) {
    const data = await app.vault.adapter.read(
      (0, import_obsidian19.normalizePath)(`${this.getSnippetDirectory(app)}${file.name}`)
    );
    return data;
  }
};
var CssFile = class {
  constructor(name) {
    /** File extension. */
    this.extension = "css";
    if (typeof name !== "string" || name.length === 0) {
      throw new Error("Invalid file name.");
    }
    const extensionWithDot = `.${this.extension}`;
    const basename = name.endsWith(extensionWithDot) ? name.slice(0, name.length - extensionWithDot.length) : name;
    this.name = `${basename}.${this.extension}`;
    this.basename = basename;
  }
};

// src/main.ts
var CustomThemeStudioPlugin = class extends import_obsidian20.Plugin {
  constructor() {
    super(...arguments);
    this.freezeDelaySecs = 5;
  }
  async onload() {
    await this.loadSettings();
    Logger.init(this);
    this.settingsManager = new SettingsManager(this);
    this.themeManager = new ThemeManager(this);
    this.registerView(
      VIEW_TYPE_CTS,
      (leaf) => new CustomThemeStudioView(this.settings, leaf, this, this.config)
    );
    this.addRibbonIcon("paintbrush", "Custom Theme Studio", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-theme-studio",
      name: "Open view",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "toggle-custom-theme",
      name: "Toggle custom theme",
      callback: () => {
        this.themeManager.toggleCustomTheme();
      }
    });
    this.addCommand({
      id: "select-element-for-css-rule",
      name: "Select an element for new CSS rule",
      callback: () => {
        this.themeManager.startElementSelection();
      }
    });
    this.addCommand({
      id: "freeze-obsidian",
      name: "Freeze Obsidian (with " + this.freezeDelaySecs.toString() + "s delay)",
      callback: () => {
        freezeTimer(this.freezeDelaySecs);
      }
    });
    this.addCommand({
      id: "import-css-snippet",
      name: "Import CSS snippet",
      callback: () => {
        new CssSnippetFuzzySuggestModal(this.app, this, this.config).open();
      }
    });
    this.addSettingTab(new CustomThemeStudioSettingTab(this.app, this));
    let fullCSS = "";
    this.settings.cssRules.forEach((rule) => {
      if (rule.enabled) {
        fullCSS += `/* ${rule.rule} */
${rule.css}

`;
      }
    });
    this.settings.customCSS = fullCSS;
    await this.saveSettings();
    if (this.settings.customCSS) {
      this.themeManager.applyIfEnabled();
    }
  }
  /**
   * Activates the Custom Theme Studio view.
   * If a view already exists, reveals it. Otherwise, creates a new view in the right sidebar.
   */
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CTS);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        Logger.error("custom-theme-studio: failed to get or create leaf");
        return;
      }
      await leaf.setViewState({ type: VIEW_TYPE_CTS, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  onunload() {
    var _a2;
    (_a2 = this.settingsManager) == null ? void 0 : _a2.destroy();
    this.themeManager.removeCustomTheme();
  }
  /**
   * Loads plugin settings from disk and applies migrations if needed.
   * Merges loaded settings with default values and ensures version is set.
   */
  async loadSettings() {
    const loadedData = await this.loadData();
    const migratedData = this.migrateSettings(loadedData || {});
    this.settings = Object.assign({}, DEFAULT_SETTINGS, migratedData);
    if (!this.settings.version) {
      this.settings.version = SETTINGS_VERSION;
      await this.saveSettings();
    }
  }
  /**
   * Migrate settings from older versions to current schema
   * Add migration logic here as schema evolves
   */
  migrateSettings(oldSettings) {
    const version = oldSettings.version || 0;
    if (version < 1) {
      Logger.info(`Migrating settings from version ${version} to version 1`);
    }
    oldSettings.version = SETTINGS_VERSION;
    return oldSettings;
  }
  /**
   * Persists current plugin settings to disk.
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Refreshes the Custom Theme Studio view by calling onOpen() on all open instances.
   * Used to update the UI after settings changes.
   */
  async reloadView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CTS);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof CustomThemeStudioView) {
        leaf.view.onOpen();
      }
    });
  }
};
/*! Bundled license information:

ace-builds/src-noconflict/ace.js:
  (*
  * based on code from:
  *
  * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
  * Available via the MIT or new BSD license.
  * see: http://github.com/jrburke/requirejs for details
  *)
*/

/* nosourcemap */