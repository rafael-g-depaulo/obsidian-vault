var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all7) => {
  for (var name in all7)
    __defProp(target, name, { get: all7[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION3 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root3 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply3(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values2) {
        var index2 = -1, length = values2.length, offset4 = array.length;
        while (++index2 < length) {
          array[offset4 + index2] = values2[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string3) {
        return string3.split("");
      }
      function asciiWords(string3) {
        return string3.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder2) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder2) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string3) {
        return reHasUnicode.test(string3);
      }
      function hasUnicodeWord(string3) {
        return reHasUnicodeWord.test(string3);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder2) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder2 || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string3) {
        return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
      }
      function stringToArray(string3) {
        return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
      }
      function trimmedEndIndex(string3) {
        var index2 = string3.length;
        while (index2-- && reWhitespace.test(string3.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string3) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string3)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string3) {
        return string3.match(reUnicode) || [];
      }
      function unicodeWords(string3) {
        return string3.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root3 : _2.defaults(root3.Object(), context, _2.pick(root3, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty4 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root3._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty4).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root3.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root3.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root3.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty4.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto2) {
            if (!isObject2(proto2)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto2);
            }
            object.prototype = proto2;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir2 = this.__dir__, isArr = isArray2(array), isRight = dir2 < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start3 = view.start, end4 = view.end, length = end4 - start3, index2 = isRight ? end4 : start3 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir2;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty4.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty4.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice2.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined2 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values3) {
          var index2 = -1, length = values3 == null ? 0 : values3.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values3[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer3(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty4.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty4.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys2(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index2 < length) {
            result2[index2] = skip ? undefined2 : get4(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined2) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined2) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer3(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values3, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values3.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values3 = arrayMap(values3, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values3.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values3 = new SetCache(values3);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values3[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values3, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start3, end4) {
          var length = array.length;
          start3 = toInteger(start3);
          if (start3 < 0) {
            start3 = -start3 > length ? 0 : length + start3;
          }
          end4 = end4 === undefined2 || end4 > length ? length : toInteger(end4);
          if (end4 < 0) {
            end4 += length;
          }
          end4 = start3 > end4 ? 0 : toLength(end4);
          while (start3 < end4) {
            array[start3++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys2);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys2);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path4) {
          path4 = castPath(path4, object);
          var index2 = 0, length = path4.length;
          while (object != null && index2 < length) {
            object = object[toKey(path4[index2++])];
          }
          return index2 && index2 == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty4.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number2, start3, end4) {
          return number2 >= nativeMin(start3, end4) && number2 < nativeMax(start3, end4);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path4, args) {
          path4 = castPath(path4, object);
          object = parent(object, path4);
          var func = object == null ? object : object[toKey(last(path4))];
          return func == null ? undefined2 : apply3(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer3(object)) {
            if (!isBuffer3(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty4.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty4.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty4.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty4.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path4, srcValue) {
          if (isKey(path4) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path4), srcValue);
          }
          return function(object) {
            var objValue = get4(object, path4);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path4) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer3(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject5(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path4) {
            return hasIn(object, path4);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path4 = paths[index2], value = baseGet(object, path4);
            if (predicate(value, path4)) {
              baseSet(result2, castPath(path4, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path4) {
          return function(object) {
            return baseGet(object, path4);
          };
        }
        function basePullAll(array, values3, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values3.length, seen = array;
          if (array === values3) {
            values3 = copyArray(values3);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values3[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice2.call(seen, fromIndex, 1);
              }
              splice2.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous2) {
              var previous2 = index2;
              if (isIndex(index2)) {
                splice2.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start3, end4, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end4 - start3) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start3;
            start3 += step;
          }
          return result2;
        }
        function baseRepeat(string3, n2) {
          var result2 = "";
          if (!string3 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string3;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string3 += string3;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start3) {
          return setToString(overRest(func, start3, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values2(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path4, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path4 = castPath(path4, object);
          var index2 = -1, length = path4.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey(path4[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path4[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string3) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string3),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice(array, start3, end4) {
          var index2 = -1, length = array.length;
          if (start3 < 0) {
            start3 = -start3 > length ? 0 : length + start3;
          }
          end4 = end4 > length ? length : end4;
          if (end4 < 0) {
            end4 += length;
          }
          length = start3 > end4 ? 0 : end4 - start3 >>> 0;
          start3 >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start3];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path4) {
          path4 = castPath(path4, object);
          object = parent(object, path4);
          return object == null || delete object[toKey(last(path4))];
        }
        function baseUpdate(object, path4, updater, customizer) {
          return baseSet(object, path4, updater(baseGet(object, path4)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values3, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values3.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values3[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString5(value));
        }
        var castRest = baseRest;
        function castSlice(array, start3, end4) {
          var length = array.length;
          end4 = end4 === undefined2 ? length : end4;
          return !start3 && end4 >= length ? array : baseSlice(array, start3, end4);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root3.clearTimeout(id);
        };
        function cloneBuffer(buffer2, isDeep) {
          if (isDeep) {
            return buffer2.slice();
          }
          var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
          buffer2.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order2 = orders[index2];
              return result2 * (order2 == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset4 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset4 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset4 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string3) {
            string3 = toString5(string3);
            var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string3) {
            return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder2 = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder2 && args[length - 1] !== placeholder2 ? [] : replaceHolders(args, placeholder2);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
            return apply3(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder2 = getHolder(wrapper), holdersCount = countHolders(args, placeholder2);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder2);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root3 && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply3(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars2) {
          chars2 = chars2 === undefined2 ? " " : baseToString(chars2);
          var charsLength = chars2.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars2, length) : chars2;
          }
          var result2 = baseRepeat(chars2, nativeCeil(length / stringSize(chars2)));
          return hasUnicode(chars2) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root3 && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply3(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start3, end4, step) {
            if (step && typeof step != "number" && isIterateeCall(start3, end4, step)) {
              end4 = step = undefined2;
            }
            start3 = toFinite(start3);
            if (end4 === undefined2) {
              end4 = start3;
              start3 = 0;
            } else {
              end4 = toFinite(end4);
            }
            step = step === undefined2 ? start3 < end4 ? 1 : -1 : toFinite(step);
            return baseRange(start3, end4, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder2, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder2;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair = (toString5(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString5(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop8 : function(values3) {
          return new Set2(values3);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty4.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject5(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert3 = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert3 || (convert3 = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert3(object), convert3(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty4.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys2, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop8 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty4.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty4.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys2(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue2(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty4.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start3, end4, transforms2) {
          var index2 = -1, length = transforms2.length;
          while (++index2 < length) {
            var data = transforms2[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start3 += size2;
                break;
              case "dropRight":
                end4 -= size2;
                break;
              case "take":
                end4 = nativeMin(end4, start3 + size2);
                break;
              case "takeRight":
                start3 = nativeMax(start3, end4 - size2);
                break;
            }
          }
          return { "start": start3, "end": end4 };
        }
        function getWrapDetails(source) {
          var match3 = source.match(reWrapDetails);
          return match3 ? match3[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path4, hasFunc) {
          path4 = castPath(path4, object);
          var index2 = -1, length = path4.length, result2 = false;
          while (++index2 < length) {
            var key = toKey(path4[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty4.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type2 = typeof index2;
          if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto2;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start3, transform2) {
          start3 = nativeMax(start3 === undefined2 ? func.length - 1 : start3, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax(args.length - start3, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start3 + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start3 + 1);
            while (++index2 < start3) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start3] = transform2(array);
            return apply3(func, this, otherArgs);
          };
        }
        function parent(object, path4) {
          return path4.length < 2 ? object : baseGet(object, baseSlice(path4, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root3.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count2 = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count2 >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count2 = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string3) {
          var result2 = [];
          if (string3.charCodeAt(0) === 46) {
            result2.push("");
          }
          string3.replace(rePropName, function(match3, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match3);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index2 < length) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values3) {
          var iteratee2 = last(values3);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values3) {
          var comparator = last(values3);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values3, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop5(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start3, end4) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start3 && typeof start3 != "number" && isIterateeCall(array, value, start3)) {
            start3 = 0;
            end4 = length;
          }
          return baseFill(array, value, start3, end4);
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values3) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3) : array;
        }
        function pullAllBy(array, values3, iteratee2) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values3, comparator) {
          return array && array.length && values3 && values3.length ? basePullAll(array, values3, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice2(array, start3, end4) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end4 && typeof end4 != "number" && isIterateeCall(array, start3, end4)) {
            start3 = 0;
            end4 = length;
          } else {
            start3 = start3 == null ? 0 : toInteger(start3);
            end4 = end4 === undefined2 ? length : toInteger(end4);
          }
          return baseSlice(array, start3, end4);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply3(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values3) {
          return isArrayLikeObject(array) ? baseDifference(array, values3) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values3) {
          return baseZipObject(props || [], values3 || [], assignValue);
        }
        function zipObjectDeep(props, values3) {
          return baseZipObject(props || [], values3 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start3 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start3)) {
            return this.thru(interceptor);
          }
          value = value.slice(start3, +start3 + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray4(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone4 = wrapperClone(parent2);
            clone4.__index__ = 0;
            clone4.__values__ = undefined2;
            if (result2) {
              previous2.__wrapped__ = clone4;
            } else {
              result2 = clone4;
            }
            var previous2 = clone4;
            parent2 = parent2.__wrapped__;
          }
          previous2.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty4.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find3 = createFind(findIndex2);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty4.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString3(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path4, args) {
          var index2 = -1, isFunc = typeof path4 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply3(path4, value, args) : baseInvoke(value, path4, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce2(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate3(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString3(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root3.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush3() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush3;
          return debounced;
        }
        var defer2 = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver2) {
          if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate3(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms2) {
          transforms2 = transforms2.length == 1 && isArray2(transforms2[0]) ? arrayMap(transforms2[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms2, 1), baseUnary(getIteratee()));
          var funcsLength = transforms2.length;
          return baseRest(function(args) {
            var index2 = -1, length = nativeMin(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms2[index2].call(this, args[index2]);
            }
            return apply3(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start3) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start3 = start3 === undefined2 ? start3 : toInteger(start3);
          return baseRest(func, start3);
        }
        function spread3(func, start3) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start3 = start3 == null ? 0 : nativeMax(toInteger(start3), 0);
          return baseRest(function(args) {
            var array = args[start3], otherArgs = castSlice(args, 0, start3);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply3(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap3(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone3(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys2(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean3(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer3 = nativeIsBuffer || stubFalse;
        var isDate4 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement2(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject5(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer3(value) || isTypedArray2(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty4.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual5(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError2(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject5(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger3(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber3(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber3(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject5(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto2 = getPrototype(value);
          if (proto2 === null) {
            return true;
          }
          var Ctor = hasOwnProperty4.call(proto2, "constructor") && proto2.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger3(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString3(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined3(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray4(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString3(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString5(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys2(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty4.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create4(prototype3, properties) {
          var result2 = baseCreate(prototype3);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults4 = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty4.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply3(mergeWith, undefined2, args);
        });
        function findKey2(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions2(object) {
          return object == null ? [] : baseFunctions(object, keys2(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get4(object, path4, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path4);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path4) {
          return object != null && hasPath(object, path4, baseHas);
        }
        function hasIn(object, path4) {
          return object != null && hasPath(object, path4, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty4.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge3 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path4) {
            path4 = castPath(path4, object);
            isDeep || (isDeep = path4.length > 1);
            return path4;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate3(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path4) {
            return predicate(value, path4[0]);
          });
        }
        function result(object, path4, defaultValue) {
          path4 = castPath(path4, object);
          var index2 = -1, length = path4.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index2 < length) {
            var value = object == null ? undefined2 : object[toKey(path4[index2])];
            if (value === undefined2) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path4, value) {
          return object == null ? object : baseSet(object, path4, value);
        }
        function setWith(object, path4, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path4, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer3(object) || isTypedArray2(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path4) {
          return object == null ? true : baseUnset(object, path4);
        }
        function update2(object, path4, updater) {
          return object == null ? object : baseUpdate(object, path4, castFunction(updater));
        }
        function updateWith(object, path4, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path4, castFunction(updater), customizer);
        }
        function values2(object) {
          return object == null ? [] : baseValues(object, keys2(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number2, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start3, end4) {
          start3 = toFinite(start3);
          if (end4 === undefined2) {
            end4 = start3;
            start3 = 0;
          } else {
            end4 = toFinite(end4);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start3, end4);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize3(word) : word);
        });
        function capitalize3(string3) {
          return upperFirst(toString5(string3).toLowerCase());
        }
        function deburr(string3) {
          string3 = toString5(string3);
          return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith2(string3, target, position6) {
          string3 = toString5(string3);
          target = baseToString(target);
          var length = string3.length;
          position6 = position6 === undefined2 ? length : baseClamp(toInteger(position6), 0, length);
          var end4 = position6;
          position6 -= target.length;
          return position6 >= 0 && string3.slice(position6, end4) == target;
        }
        function escape3(string3) {
          string3 = toString5(string3);
          return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
        }
        function escapeRegExp(string3) {
          string3 = toString5(string3);
          return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string3, length, chars2) {
          string3 = toString5(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          if (!length || strLength >= length) {
            return string3;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars2) + string3 + createPadding(nativeCeil(mid), chars2);
        }
        function padEnd(string3, length, chars2) {
          string3 = toString5(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          return length && strLength < length ? string3 + createPadding(length - strLength, chars2) : string3;
        }
        function padStart2(string3, length, chars2) {
          string3 = toString5(string3);
          length = toInteger(length);
          var strLength = length ? stringSize(string3) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars2) + string3 : string3;
        }
        function parseInt2(string3, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString5(string3).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string3, n2, guard) {
          if (guard ? isIterateeCall(string3, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString5(string3), n2);
        }
        function replace3() {
          var args = arguments, string3 = toString5(args[0]);
          return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string3, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string3 = toString5(string3);
          if (string3 && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string3)) {
              return castSlice(stringToArray(string3), 0, limit);
            }
          }
          return string3.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string3, target, position6) {
          string3 = toString5(string3);
          position6 = position6 == null ? 0 : baseClamp(toInteger(position6), 0, string3.length);
          target = baseToString(target);
          return string3.slice(position6, position6 + target.length) == target;
        }
        function template(string3, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string3, options, guard)) {
            options = undefined2;
          }
          string3 = toString5(string3);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty4.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string3.replace(reDelimiters, function(match3, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset4) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string3.slice(index2, offset4).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset4 + match3.length;
            return match3;
          });
          source += "';\n";
          var variable = hasOwnProperty4.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError2(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString5(value).toLowerCase();
        }
        function toUpper(value) {
          return toString5(value).toUpperCase();
        }
        function trim2(string3, chars2, guard) {
          string3 = toString5(string3);
          if (string3 && (guard || chars2 === undefined2)) {
            return baseTrim(string3);
          }
          if (!string3 || !(chars2 = baseToString(chars2))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars2), start3 = charsStartIndex(strSymbols, chrSymbols), end4 = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start3, end4).join("");
        }
        function trimEnd(string3, chars2, guard) {
          string3 = toString5(string3);
          if (string3 && (guard || chars2 === undefined2)) {
            return string3.slice(0, trimmedEndIndex(string3) + 1);
          }
          if (!string3 || !(chars2 = baseToString(chars2))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), end4 = charsEndIndex(strSymbols, stringToArray(chars2)) + 1;
          return castSlice(strSymbols, 0, end4).join("");
        }
        function trimStart(string3, chars2, guard) {
          string3 = toString5(string3);
          if (string3 && (guard || chars2 === undefined2)) {
            return string3.replace(reTrimStart, "");
          }
          if (!string3 || !(chars2 = baseToString(chars2))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), start3 = charsStartIndex(strSymbols, stringToArray(chars2));
          return castSlice(strSymbols, start3).join("");
        }
        function truncate(string3, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string3 = toString5(string3);
          var strLength = string3.length;
          if (hasUnicode(string3)) {
            var strSymbols = stringToArray(string3);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string3;
          }
          var end4 = length - stringSize(omission);
          if (end4 < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end4).join("") : string3.slice(0, end4);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end4 += result2.length - end4;
          }
          if (isRegExp2(separator)) {
            if (string3.slice(end4).search(separator)) {
              var match3, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString5(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match3 = separator.exec(substring)) {
                var newEnd = match3.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end4 : newEnd);
            }
          } else if (string3.indexOf(baseToString(separator), end4) != end4) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape3(string3) {
          string3 = toString5(string3);
          return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string3, pattern, guard) {
          string3 = toString5(string3);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
          }
          return string3.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply3(func, undefined2, args);
          } catch (e2) {
            return isError2(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply3(pair[0], this, args)) {
                return apply3(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow3 = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path4, srcValue) {
          return baseMatchesProperty(path4, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path4, args) {
          return function(object) {
            return baseInvoke(object, path4, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path4) {
            return baseInvoke(object, path4, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root3._ === this) {
            root3._ = oldDash;
          }
          return this;
        }
        function noop8() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path4) {
          return isKey(path4) ? baseProperty(toKey(path4)) : basePropertyDeep(path4);
        }
        function propertyOf(object) {
          return function(path4) {
            return object == null ? undefined2 : baseGet(object, path4);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index2 < n2) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString5(value)));
        }
        function uniqueId(prefix3) {
          var id = ++idCounter;
          return toString5(prefix3) + id;
        }
        var add3 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract3 = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind2;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create4;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults4;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer2;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop5;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter2;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow3;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions2;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial2;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys2;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge3;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate3;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick2;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set2;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice2;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread3;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray4;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values2;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap3;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add3;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize3;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone3;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith2;
        lodash.eq = eq;
        lodash.escape = escape3;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find3;
        lodash.findIndex = findIndex2;
        lodash.findKey = findKey2;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach2;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get4;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray2;
        lodash.isArrayBuffer = isArrayBuffer2;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean3;
        lodash.isBuffer = isBuffer3;
        lodash.isDate = isDate4;
        lodash.isElement = isElement2;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual5;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError2;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction2;
        lodash.isInteger = isInteger3;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber3;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject5;
        lodash.isRegExp = isRegExp2;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString3;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray2;
        lodash.isUndefined = isUndefined3;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop8;
        lodash.now = now2;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart2;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce2;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace3;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract3;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString5;
        lodash.toUpper = toUpper;
        lodash.trim = trim2;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape3;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach2;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty4.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION3;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type2 = index2 + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type2
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path4, args) {
          if (typeof path4 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path4, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate3(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start3, end4) {
          start3 = toInteger(start3);
          var result2 = this;
          if (result2.__filtered__ && (start3 > 0 || end4 < 0)) {
            return new LazyWrapper(result2);
          }
          if (start3 < 0) {
            result2 = result2.takeRight(-start3);
          } else if (start3) {
            result2 = result2.drop(start3);
          }
          if (end4 !== undefined2) {
            end4 = toInteger(end4);
            result2 = end4 < 0 ? result2.dropRight(-end4) : result2.take(end4 - start3);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty4.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root3._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root3._ = _2;
      }
    }).call(exports);
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn2(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error2(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error2("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn2("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray2(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty4 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config3) {
          {
            if (hasOwnProperty4.call(config3, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.ref !== void 0;
        }
        function hasValidKey(config3) {
          {
            if (hasOwnProperty4.call(config3, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config3) {
          {
            if (typeof config3.ref === "string" && ReactCurrentOwner.current && config3.__self && ReactCurrentOwner.current.stateNode !== config3.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config3.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type2, key, ref2, self2, source, owner, props) {
          var element4 = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type2,
            key,
            ref: ref2,
            props,
            _owner: owner
          };
          {
            element4._store = {};
            Object.defineProperty(element4._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element4, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element4, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element4.props);
              Object.freeze(element4);
            }
          }
          return element4;
        };
        function createElement133(type2, config3, children) {
          var propName;
          var props = {};
          var key = null;
          var ref2 = null;
          var self2 = null;
          var source = null;
          if (config3 != null) {
            if (hasValidRef(config3)) {
              ref2 = config3.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config3);
              }
            }
            if (hasValidKey(config3)) {
              {
                checkKeyStringCoercion(config3.key);
              }
              key = "" + config3.key;
            }
            self2 = config3.__self === void 0 ? null : config3.__self;
            source = config3.__source === void 0 ? null : config3.__source;
            for (propName in config3) {
              if (hasOwnProperty4.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config3[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type2 && type2.defaultProps) {
            var defaultProps2 = type2.defaultProps;
            for (propName in defaultProps2) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps2[propName];
              }
            }
          }
          {
            if (key || ref2) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref2) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type2, key, ref2, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement2(element4, config3, children) {
          if (element4 === null || element4 === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element4 + ".");
          }
          var propName;
          var props = assign({}, element4.props);
          var key = element4.key;
          var ref2 = element4.ref;
          var self2 = element4._self;
          var source = element4._source;
          var owner = element4._owner;
          if (config3 != null) {
            if (hasValidRef(config3)) {
              ref2 = config3.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config3)) {
              {
                checkKeyStringCoercion(config3.key);
              }
              key = "" + config3.key;
            }
            var defaultProps2;
            if (element4.type && element4.type.defaultProps) {
              defaultProps2 = element4.type.defaultProps;
            }
            for (propName in config3) {
              if (hasOwnProperty4.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config3[propName] === void 0 && defaultProps2 !== void 0) {
                  props[propName] = defaultProps2[propName];
                } else {
                  props[propName] = config3[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element4.type, key, ref2, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape3(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match3) {
            return escaperLookup[match3];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text6) {
          return text6.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element4, index2) {
          if (typeof element4 === "object" && element4 !== null && element4.key != null) {
            {
              checkKeyStringCoercion(element4.key);
            }
            return escape3("" + element4.key);
          }
          return index2.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type2 = typeof children;
          if (type2 === "undefined" || type2 === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type2) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray2(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray2(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type2 === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count2 = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count2++);
          });
          return result;
        }
        function countChildren(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray4(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext5(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error2("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error2("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn2("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error3) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error3;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error2("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps2;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps2;
                },
                set: function(newDefaultProps) {
                  error2("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps2 = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error2("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render3) {
          {
            if (render3 != null && render3.$$typeof === REACT_MEMO_TYPE) {
              error2("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render3 !== "function") {
              error2("forwardRef requires a render function but was given %s.", render3 === null ? "null" : typeof render3);
            } else {
              if (render3.length !== 0 && render3.length !== 2) {
                error2("forwardRef render functions accept exactly two parameters: props and ref. %s", render3.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render3 != null) {
              if (render3.defaultProps != null || render3.propTypes != null) {
                error2("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render3.name && !render3.displayName) {
                  render3.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType2(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo2(type2, compare) {
          {
            if (!isValidElementType2(type2)) {
              error2("memo: The first argument must be a component. Instead received: %s", type2 === null ? "null" : typeof type2);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type: type2,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type2.name && !type2.displayName) {
                  type2.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error2("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext9(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error2("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error2("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState66(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer3(reducer2, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer2, initialArg, init2);
        }
        function useRef19(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect20(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create4, deps);
        }
        function useInsertionEffect(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create4, deps);
        }
        function useLayoutEffect3(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create4, deps);
        }
        function useCallback2(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo6(create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create4, deps);
        }
        function useImperativeHandle(ref2, create4, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref2, create4, deps);
        }
        function useDebugValue2(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix3;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix3 === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match3 = x.stack.trim().match(/\n( *(at )?)/);
                prefix3 = match3 && match3[1] || "";
              }
            }
            return "\n" + prefix3 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s3 = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s3 >= 1 && c >= 0 && sampleLines[s3] !== controlLines[c]) {
                c--;
              }
              for (; s3 >= 1 && c >= 0; s3--, c--) {
                if (sampleLines[s3] !== controlLines[c]) {
                  if (s3 !== 1 || c !== 1) {
                    do {
                      s3--;
                      c--;
                      if (c < 0 || sampleLines[s3] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s3].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s3 >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype3 = Component2.prototype;
          return !!(prototype3 && prototype3.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element4) {
          {
            if (element4) {
              var owner = element4._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element4.type, element4._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values2, location3, componentName, element4) {
          {
            var has = Function.call.bind(hasOwnProperty4);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location3 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location3, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element4);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location3, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element4);
                  error2("Failed %s type: %s", location3, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element4) {
          {
            if (element4) {
              var owner = element4._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element4.type, element4._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element4, parentType) {
          if (!element4._store || element4._store.validated || element4.key != null) {
            return;
          }
          element4._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element4 && element4._owner && element4._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element4._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element4);
            error2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node2, parentType) {
          if (typeof node2 !== "object") {
            return;
          }
          if (isArray2(node2)) {
            for (var i = 0; i < node2.length; i++) {
              var child = node2[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node2)) {
            if (node2._store) {
              node2._store.validated = true;
            }
          } else if (node2) {
            var iteratorFn = getIteratorFn(node2);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node2.entries) {
                var iterator = iteratorFn.call(node2);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element4) {
          {
            var type2 = element4.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes;
            if (typeof type2 === "function") {
              propTypes = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type2.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type2);
              checkPropTypes(propTypes, element4.props, "prop", name, element4);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type2);
              error2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment2) {
          {
            var keys2 = Object.keys(fragment2.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment2);
                error2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment2.ref !== null) {
              setCurrentlyValidatingElement$1(fragment2);
              error2("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type2, props, children) {
          var validType = isValidElementType2(type2);
          if (!validType) {
            var info = "";
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type2 === null) {
              typeString = "null";
            } else if (isArray2(type2)) {
              typeString = "array";
            } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type2.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type2;
            }
            {
              error2("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element4 = createElement133.apply(this, arguments);
          if (element4 == null) {
            return element4;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type2);
            }
          }
          if (type2 === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element4);
          } else {
            validatePropTypes(element4);
          }
          return element4;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type2) {
          var validatedFactory = createElementWithValidation.bind(null, type2);
          validatedFactory.type = type2;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn2("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn2("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type2
                });
                return type2;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element4, props, children) {
          var newElement = cloneElement2.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error2("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error3) {
              popActScope(prevActScopeDepth);
              throw error3;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error3) {
                    popActScope(prevActScopeDepth);
                    reject(error3);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error2("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error2("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error3) {
                reject(error3);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i = 0;
              try {
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error3) {
                queue = queue.slice(i + 1);
                throw error3;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray4,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext5;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo2;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback2;
        exports.useContext = useContext9;
        exports.useDebugValue = useDebugValue2;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect20;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect3;
        exports.useMemo = useMemo6;
        exports.useReducer = useReducer3;
        exports.useRef = useRef19;
        exports.useState = useState66;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/void-elements/index.js
var require_void_elements = __commonJS({
  "node_modules/void-elements/index.js"(exports, module2) {
    module2.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push2(heap, node2) {
          var index2 = heap.length;
          heap.push(node2);
          siftUp(heap, node2, index2);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node2, i) {
          var index2 = i;
          while (index2 > 0) {
            var parentIndex = index2 - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare(parent, node2) > 0) {
              heap[parentIndex] = node2;
              heap[index2] = parent;
              index2 = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node2, i) {
          var index2 = i;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index2 < halfLength) {
            var leftIndex = (index2 + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare(left, node2) < 0) {
              if (rightIndex < length && compare(right, left) < 0) {
                heap[index2] = right;
                heap[rightIndex] = node2;
                index2 = rightIndex;
              } else {
                heap[index2] = left;
                heap[leftIndex] = node2;
                index2 = leftIndex;
              }
            } else if (rightIndex < length && compare(right, node2) < 0) {
              heap[index2] = right;
              heap[rightIndex] = node2;
              index2 = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push2(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error2) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error2;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push2(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push2(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React134 = require_react();
        var Scheduler = require_scheduler();
        var ReactSharedInternals = React134.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
          {
            suppressWarning = newSuppressWarning;
          }
        }
        function warn2(format) {
          {
            if (!suppressWarning) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error2(format) {
          {
            if (!suppressWarning) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment65 = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = false;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = /* @__PURE__ */ new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error2("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i = 0; i < dependencies.length; i++) {
            allNativeEvents.add(dependencies[i]);
          }
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var hasOwnProperty4 = Object.prototype.hasOwnProperty;
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type2 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type2;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkPropStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkFormFieldValueStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error2("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty4.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty4.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix4 = name.toLowerCase().slice(0, 5);
                return prefix4 !== "data-" && prefix4 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type2;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref2) {
          var name = _ref2[0], attributeName = _ref2[1];
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize3 = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize3);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize3);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize3);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        function getValueForProperty(node2, name, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node2[propertyName];
            } else {
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node2.hasAttribute(attributeName)) {
                  var value = node2.getAttribute(attributeName);
                  if (value === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return value;
                  }
                  if (value === "" + expected) {
                    return expected;
                  }
                  return value;
                }
              } else if (node2.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return node2.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node2.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node2, name, expected, isCustomComponentTag) {
          {
            if (!isAttributeNameSafe(name)) {
              return;
            }
            if (!node2.hasAttribute(name)) {
              return expected === void 0 ? void 0 : null;
            }
            var value = node2.getAttribute(name);
            {
              checkAttributeStringCoercion(expected, name);
            }
            if (value === "" + expected) {
              return expected;
            }
            return value;
          }
        }
        function setValueForProperty(node2, name, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name);
          if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
            value = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name)) {
              var _attributeName = name;
              if (value === null) {
                node2.removeAttribute(_attributeName);
              } else {
                {
                  checkAttributeStringCoercion(value, name);
                }
                node2.setAttribute(_attributeName, "" + value);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type2 = propertyInfo.type;
              node2[propertyName] = type2 === BOOLEAN ? false : "";
            } else {
              node2[propertyName] = value;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null) {
            node2.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
              attributeValue = "";
            } else {
              {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                attributeValue = "" + value;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node2.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node2.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix3;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix3 === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match3 = x.stack.trim().match(/\n( *(at )?)/);
                prefix3 = match3 && match3[1] || "";
              }
            }
            return "\n" + prefix3 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s3 = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s3 >= 1 && c >= 0 && sampleLines[s3] !== controlLines[c]) {
                c--;
              }
              for (; s3 >= 1 && c >= 0; s3--, c--) {
                if (sampleLines[s3] !== controlLines[c]) {
                  if (s3 !== 1 || c !== 1) {
                    do {
                      s3--;
                      c--;
                      if (c < 0 || sampleLines[s3] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s3].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s3 >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype3 = Component.prototype;
          return !!(prototype3 && prototype3.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
              return describeFunctionComponentFrame(fiber.type.render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node2 = workInProgress2;
            do {
              info += describeFiber(node2);
              node2 = node2.return;
            } while (node2);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromType(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type2.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type2.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type2) {
          return type2.displayName || "Context";
        }
        function getComponentNameFromFiber(fiber) {
          var tag = fiber.tag, type2 = fiber.type;
          switch (tag) {
            case CacheComponent:
              return "Cache";
            case ContextConsumer:
              var context = type2;
              return getContextName$1(context) + ".Consumer";
            case ContextProvider:
              var provider = type2;
              return getContextName$1(provider._context) + ".Provider";
            case DehydratedFragment:
              return "DehydratedFragment";
            case ForwardRef:
              return getWrappedName$1(type2, type2.render, "ForwardRef");
            case Fragment65:
              return "Fragment";
            case HostComponent:
              return type2;
            case HostPortal:
              return "Portal";
            case HostRoot:
              return "Root";
            case HostText:
              return "Text";
            case LazyComponent:
              return getComponentNameFromType(type2);
            case Mode:
              if (type2 === REACT_STRICT_MODE_TYPE) {
                return "StrictMode";
              }
              return "Mode";
            case OffscreenComponent:
              return "Offscreen";
            case Profiler:
              return "Profiler";
            case ScopeComponent:
              return "Scope";
            case SuspenseComponent:
              return "Suspense";
            case SuspenseListComponent:
              return "SuspenseList";
            case TracingMarkerComponent:
              return "TracingMarker";
            case ClassComponent:
            case FunctionComponent:
            case IncompleteClassComponent:
            case IndeterminateComponent:
            case MemoComponent:
            case SimpleMemoComponent:
              if (typeof type2 === "function") {
                return type2.displayName || type2.name || null;
              }
              if (typeof type2 === "string") {
                return type2;
              }
              break;
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current === null) {
              return null;
            }
            var owner = current._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentNameFromFiber(owner);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
            current = fiber;
            isRendering = false;
          }
        }
        function getCurrentFiber() {
          {
            return current;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function toString5(value) {
          return "" + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              {
                checkFormFieldValueStringCoercion(value);
              }
              return value;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type2 = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type2 === "checkbox" || type2 === "radio");
        }
        function getTracker(node2) {
          return node2._valueTracker;
        }
        function detachTracker(node2) {
          node2._valueTracker = null;
        }
        function getValueFromNode(node2) {
          var value = "";
          if (!node2) {
            return value;
          }
          if (isCheckable(node2)) {
            value = node2.checked ? "true" : "false";
          } else {
            value = node2.value;
          }
          return value;
        }
        function trackValueOnNode(node2) {
          var valueField = isCheckable(node2) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node2.constructor.prototype, valueField);
          {
            checkFormFieldValueStringCoercion(node2[valueField]);
          }
          var currentValue = "" + node2[valueField];
          if (node2.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get5 = descriptor.get, set3 = descriptor.set;
          Object.defineProperty(node2, valueField, {
            configurable: true,
            get: function() {
              return get5.call(this);
            },
            set: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
              set3.call(this, value);
            }
          });
          Object.defineProperty(node2, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node2);
              delete node2[valueField];
            }
          };
          return tracker;
        }
        function track(node2) {
          if (getTracker(node2)) {
            return;
          }
          node2._valueTracker = trackValueOnNode(node2);
        }
        function updateValueIfChanged(node2) {
          if (!node2) {
            return false;
          }
          var tracker = getTracker(node2);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node2);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement(doc) {
          doc = doc || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc === "undefined") {
            return null;
          }
          try {
            return doc.activeElement || doc.body;
          } catch (e2) {
            return doc.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props) {
          var usesChecked = props.type === "checkbox" || props.type === "radio";
          return usesChecked ? props.checked != null : props.value != null;
        }
        function getHostProps(element4, props) {
          var node2 = element4;
          var checked = props.checked;
          var hostProps = assign({}, props, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked != null ? checked : node2._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element4, props) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node2 = element4;
          var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
          node2._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
            controlled: isControlled(props)
          };
        }
        function updateChecked(element4, props) {
          var node2 = element4;
          var checked = props.checked;
          if (checked != null) {
            setValueForProperty(node2, "checked", checked, false);
          }
        }
        function updateWrapper(element4, props) {
          var node2 = element4;
          {
            var controlled = isControlled(props);
            if (!node2._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error2("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node2._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error2("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element4, props);
          var value = getToStringValue(props.value);
          var type2 = props.type;
          if (value != null) {
            if (type2 === "number") {
              if (value === 0 && node2.value === "" || node2.value != value) {
                node2.value = toString5(value);
              }
            } else if (node2.value !== toString5(value)) {
              node2.value = toString5(value);
            }
          } else if (type2 === "submit" || type2 === "reset") {
            node2.removeAttribute("value");
            return;
          }
          {
            if (props.hasOwnProperty("value")) {
              setDefaultValue(node2, props.type, value);
            } else if (props.hasOwnProperty("defaultValue")) {
              setDefaultValue(node2, props.type, getToStringValue(props.defaultValue));
            }
          }
          {
            if (props.checked == null && props.defaultChecked != null) {
              node2.defaultChecked = !!props.defaultChecked;
            }
          }
        }
        function postMountWrapper(element4, props, isHydrating2) {
          var node2 = element4;
          if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
            var type2 = props.type;
            var isButton = type2 === "submit" || type2 === "reset";
            if (isButton && (props.value === void 0 || props.value === null)) {
              return;
            }
            var initialValue = toString5(node2._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node2.value) {
                  node2.value = initialValue;
                }
              }
            }
            {
              node2.defaultValue = initialValue;
            }
          }
          var name = node2.name;
          if (name !== "") {
            node2.name = "";
          }
          {
            node2.defaultChecked = !node2.defaultChecked;
            node2.defaultChecked = !!node2._wrapperState.initialChecked;
          }
          if (name !== "") {
            node2.name = name;
          }
        }
        function restoreControlledState(element4, props) {
          var node2 = element4;
          updateWrapper(node2, props);
          updateNamedCousins(node2, props);
        }
        function updateNamedCousins(rootNode, props) {
          var name = props.name;
          if (props.type === "radio" && name != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            {
              checkAttributeStringCoercion(name, "name");
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
            for (var i = 0; i < group.length; i++) {
              var otherNode = group[i];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node2, type2, value) {
          if (type2 !== "number" || getActiveElement(node2.ownerDocument) !== node2) {
            if (value == null) {
              node2.defaultValue = toString5(node2._wrapperState.initialValue);
            } else if (node2.defaultValue !== toString5(value)) {
              node2.defaultValue = toString5(value);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element4, props) {
          {
            if (props.value == null) {
              if (typeof props.children === "object" && props.children !== null) {
                React134.Children.forEach(props.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error2("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                  }
                });
              } else if (props.dangerouslySetInnerHTML != null) {
                if (!didWarnInvalidInnerHTML) {
                  didWarnInvalidInnerHTML = true;
                  error2("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            if (props.selected != null && !didWarnSelectedSetOnOption) {
              error2("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element4, props) {
          if (props.value != null) {
            element4.setAttribute("value", toString5(getToStringValue(props.value)));
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray2(a) {
          return isArrayImpl(a);
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props) {
          {
            checkControlledValueProps("select", props);
            for (var i = 0; i < valuePropNames.length; i++) {
              var propName = valuePropNames[i];
              if (props[propName] == null) {
                continue;
              }
              var propNameIsArray = isArray2(props[propName]);
              if (props.multiple && !propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props.multiple && propNameIsArray) {
                error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node2, multiple, propValue, setDefaultSelected) {
          var options2 = node2.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i = 0; i < selectedValues.length; i++) {
              selectedValue["$" + selectedValues[i]] = true;
            }
            for (var _i = 0; _i < options2.length; _i++) {
              var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
              if (options2[_i].selected !== selected) {
                options2[_i].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options2[_i].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString5(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i2 = 0; _i2 < options2.length; _i2++) {
              if (options2[_i2].value === _selectedValue) {
                options2[_i2].selected = true;
                if (setDefaultSelected) {
                  options2[_i2].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options2[_i2].disabled) {
                defaultSelected = options2[_i2];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$1(element4, props) {
          return assign({}, props, {
            value: void 0
          });
        }
        function initWrapperState$1(element4, props) {
          var node2 = element4;
          {
            checkSelectPropTypes(props);
          }
          node2._wrapperState = {
            wasMultiple: !!props.multiple
          };
          {
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element4, props) {
          var node2 = element4;
          node2.multiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node2, !!props.multiple, value, false);
          } else if (props.defaultValue != null) {
            updateOptions(node2, !!props.multiple, props.defaultValue, true);
          }
        }
        function postUpdateWrapper(element4, props) {
          var node2 = element4;
          var wasMultiple = node2._wrapperState.wasMultiple;
          node2._wrapperState.wasMultiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node2, !!props.multiple, value, false);
          } else if (wasMultiple !== !!props.multiple) {
            if (props.defaultValue != null) {
              updateOptions(node2, !!props.multiple, props.defaultValue, true);
            } else {
              updateOptions(node2, !!props.multiple, props.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element4, props) {
          var node2 = element4;
          var value = props.value;
          if (value != null) {
            updateOptions(node2, !!props.multiple, value, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element4, props) {
          var node2 = element4;
          if (props.dangerouslySetInnerHTML != null) {
            throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          }
          var hostProps = assign({}, props, {
            value: void 0,
            defaultValue: void 0,
            children: toString5(node2._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element4, props) {
          var node2 = element4;
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error2("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props.value;
          if (initialValue == null) {
            var children = props.children, defaultValue = props.defaultValue;
            if (children != null) {
              {
                error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (defaultValue != null) {
                  throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                }
                if (isArray2(children)) {
                  if (children.length > 1) {
                    throw new Error("<textarea> can only have at most one child.");
                  }
                  children = children[0];
                }
                defaultValue = children;
              }
            }
            if (defaultValue == null) {
              defaultValue = "";
            }
            initialValue = defaultValue;
          }
          node2._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element4, props) {
          var node2 = element4;
          var value = getToStringValue(props.value);
          var defaultValue = getToStringValue(props.defaultValue);
          if (value != null) {
            var newValue = toString5(value);
            if (newValue !== node2.value) {
              node2.value = newValue;
            }
            if (props.defaultValue == null && node2.defaultValue !== newValue) {
              node2.defaultValue = newValue;
            }
          }
          if (defaultValue != null) {
            node2.defaultValue = toString5(defaultValue);
          }
        }
        function postMountWrapper$3(element4, props) {
          var node2 = element4;
          var textContent = node2.textContent;
          if (textContent === node2._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node2.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element4, props) {
          updateWrapper$1(element4, props);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        function getIntrinsicNamespace(type2) {
          switch (type2) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type2) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type2);
          }
          if (parentNamespace === SVG_NAMESPACE && type2 === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node2, html4) {
          if (node2.namespaceURI === SVG_NAMESPACE) {
            if (!("innerHTML" in node2)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html4.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node2.firstChild) {
                node2.removeChild(node2.firstChild);
              }
              while (svgNode.firstChild) {
                node2.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node2.innerHTML = html4;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node2, text6) {
          if (text6) {
            var firstChild = node2.firstChild;
            if (firstChild && firstChild === node2.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text6;
              return;
            }
          }
          node2.textContent = text6;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix4, key) {
          return prefix4 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes2 = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes2.forEach(function(prefix4) {
            isUnitlessNumber[prefixKey(prefix4, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          {
            checkCSSPropertyStringCoercion(value, name);
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize2 = function(string3) {
            return string3.replace(hyphenPattern, function(_2, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2("Unsupported style property %s. Did you mean %s?", name, camelize2(name.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles2) {
          {
            var serialized = "";
            var delimiter = "";
            for (var styleName in styles2) {
              if (!styles2.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles2[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node2, styles2) {
          var style4 = node2.style;
          for (var styleName in styles2) {
            if (!styles2.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles2[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles2[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style4.setProperty(styleName, styleValue);
            } else {
              style4[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value) {
          return value == null || typeof value === "boolean" || value === "";
        }
        function expandShorthandMap(styles2) {
          var expanded = {};
          for (var key in styles2) {
            var longhands = shorthandToLonghand[key] || [key];
            for (var i = 0; i < longhands.length; i++) {
              expanded[longhands[i]] = key;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key in expandedUpdates) {
              var originalKey = expandedUpdates[key];
              var correctOriginalKey = expandedStyles[key];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error2("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (props.children != null || props.dangerouslySetInnerHTML != null) {
              throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (props.children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (props.style != null && typeof props.style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty4.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type2, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type2, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            }
          }
        }
        function validateProperties(type2, props) {
          if (isCustomComponent(type2, props)) {
            return;
          }
          warnInvalidARIAProps(type2, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type2, props) {
          {
            if (type2 !== "input" && type2 !== "textarea" && type2 !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type2 === "select" && props.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (hasOwnProperty4.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved2 = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved2 && name !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved2) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type2, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type2, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            }
          }
        };
        function validateProperties$2(type2, props, eventRegistry) {
          if (isCustomComponent(type2, props)) {
            return;
          }
          warnUnknownProperties(type2, props, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
          {
            if (currentReplayingEvent !== null) {
              error2("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
          {
            if (currentReplayingEvent === null) {
              error2("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
          return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (typeof restoreImpl !== "function") {
            throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i = 0; i < queuedTargets.length; i++) {
              restoreStateOfTarget(queuedTargets[i]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn, bookkeeping) {
          return fn(bookkeeping);
        };
        var flushSyncImpl = function() {
        };
        var isInsideEventHandler = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushSyncImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn, a, b) {
          if (isInsideEventHandler) {
            return fn(a, b);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn, a, b);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name, type2, props) {
          switch (name) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props.disabled && isInteractive(type2));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props = getFiberCurrentPropsFromNode(stateNode);
          if (props === null) {
            return null;
          }
          var listener3 = props[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
            return null;
          }
          if (listener3 && typeof listener3 !== "function") {
            throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener3 + "` type.");
          }
          return listener3;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM) {
          try {
            var options = {};
            Object.defineProperty(options, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
          } catch (e2) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name, func, context, a, b, c, d2, e2, f) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context, funcArgs);
          } catch (error3) {
            this.onError(error3);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d2, e2, f) {
              if (typeof document === "undefined" || document === null) {
                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context, funcArgs);
                didError = false;
              }
              var error3;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error3 = event.error;
                didSetError = true;
                if (error3 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error3 != null && typeof error3 === "object") {
                    try {
                      error3._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name ? name : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error3 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error3 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error3);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error3) {
            hasError = true;
            caughtError = error3;
          }
        };
        function invokeGuardedCallback(name, func, context, a, b, c, d2, e2, f) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d2, e2, f) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error3 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error3;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error3 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error3;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error3 = caughtError;
            hasError = false;
            caughtError = null;
            return error3;
          } else {
            throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function get4(key) {
          return key._reactInternals;
        }
        function has(key) {
          return key._reactInternals !== void 0;
        }
        function set2(key, value) {
          key._reactInternals = value;
        }
        var NoFlags = 0;
        var PerformedWork = 1;
        var Placement = 2;
        var Update = 4;
        var ChildDeletion = 16;
        var ContentReset = 32;
        var Callback = 64;
        var DidCapture = 128;
        var ForceClientRender = 256;
        var Ref = 512;
        var Snapshot = 1024;
        var Passive = 2048;
        var Hydrating = 4096;
        var Visibility = 8192;
        var StoreConsistency = 16384;
        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
        var HostEffectMask = 32767;
        var Incomplete = 32768;
        var ShouldCapture = 65536;
        var ForceUpdateForLegacySuspense = 131072;
        var Forked = 1048576;
        var RefStatic = 2097152;
        var LayoutStatic = 4194304;
        var PassiveStatic = 8388608;
        var MountLayoutDev = 16777216;
        var MountPassiveDev = 33554432;
        var BeforeMutationMask = Update | Snapshot | 0;
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
        var LayoutMask = Update | Callback | Ref | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node2 = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node2;
            do {
              node2 = nextNode;
              if ((node2.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node2.return;
              }
              nextNode = node2.return;
            } while (nextNode);
          } else {
            while (node2.return) {
              node2 = node2.return;
            }
          }
          if (node2.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current2 = fiber.alternate;
              if (current2 !== null) {
                suspenseState = current2.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance2 = ownerFiber.stateNode;
              if (!instance2._warnedAboutRefsInRender) {
                error2("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
              }
              instance2._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get4(component);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) {
            throw new Error("Unable to find node on an unmounted component.");
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (nearestMounted === null) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a = fiber;
          var b = alternate;
          while (true) {
            var parentA = a.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a = b = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) {
              a = parentA;
              b = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
              }
            }
            if (a.alternate !== b) {
              throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (a.tag !== HostRoot) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a.stateNode.current === a) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node2) {
          if (node2.tag === HostComponent || node2.tag === HostText) {
            return node2;
          }
          var child = node2.child;
          while (child !== null) {
            var match3 = findCurrentHostFiberImpl(child);
            if (match3 !== null) {
              return match3;
            }
            child = child.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node2) {
          if (node2.tag === HostComponent || node2.tag === HostText) {
            return node2;
          }
          var child = node2.child;
          while (child !== null) {
            if (child.tag !== HostPortal) {
              var match3 = findCurrentHostFiberWithNoPortalsImpl(child);
              if (match3 !== null) {
                return match3;
              }
            }
            child = child.sibling;
          }
          return null;
        }
        var scheduleCallback = Scheduler.unstable_scheduleCallback;
        var cancelCallback = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now2 = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error2("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            if (enableSchedulingProfiler) {
              internals = assign({}, internals, {
                getLaneLabelMap,
                injectProfilingHooks
              });
            }
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err) {
            {
              error2("React instrumentation encountered an error: %s.", err);
            }
          }
          if (hook.checkDCE) {
            return true;
          } else {
            return false;
          }
        }
        function onScheduleRoot(root4, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root4, children);
              } catch (err) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitRoot(root4, eventPriority) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root4.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                var schedulerPriority;
                switch (eventPriority) {
                  case DiscreteEventPriority:
                    schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority;
                    break;
                }
                injectedHook.onCommitFiberRoot(rendererID, root4, schedulerPriority, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root4, void 0, didError);
              }
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onPostCommitRoot(root4) {
          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root4);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error2("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          {
            if (typeof unstable_yieldValue === "function") {
              unstable_setDisableYieldValue(newIsStrictMode);
              setSuppressWarning(newIsStrictMode);
            }
            if (injectedHook && typeof injectedHook.setStrictMode === "function") {
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error2("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
          {
            var map = /* @__PURE__ */ new Map();
            var lane = 1;
            for (var index3 = 0; index3 < TotalLanes; index3++) {
              var label = getLabelForLane(lane);
              map.set(lane, label);
              lane *= 2;
            }
            return map;
          }
        }
        function markCommitStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
              injectedProfilingHooks.markCommitStarted(lanes);
            }
          }
        }
        function markCommitStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
              injectedProfilingHooks.markCommitStopped();
            }
          }
        }
        function markComponentRenderStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
              injectedProfilingHooks.markComponentRenderStarted(fiber);
            }
          }
        }
        function markComponentRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
              injectedProfilingHooks.markComponentRenderStopped();
            }
          }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStopped();
            }
          }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
            }
          }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
            }
          }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
            }
          }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
            }
          }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
            }
          }
        }
        function markLayoutEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
              injectedProfilingHooks.markLayoutEffectsStarted(lanes);
            }
          }
        }
        function markLayoutEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
              injectedProfilingHooks.markLayoutEffectsStopped();
            }
          }
        }
        function markPassiveEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            }
          }
        }
        function markPassiveEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
              injectedProfilingHooks.markPassiveEffectsStopped();
            }
          }
        }
        function markRenderStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
              injectedProfilingHooks.markRenderStarted(lanes);
            }
          }
        }
        function markRenderYielded() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
              injectedProfilingHooks.markRenderYielded();
            }
          }
        }
        function markRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
              injectedProfilingHooks.markRenderStopped();
            }
          }
        }
        function markRenderScheduled(lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
              injectedProfilingHooks.markRenderScheduled(lane);
            }
          }
        }
        function markForceUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
            }
          }
        }
        function markStateUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
            }
          }
        }
        var NoMode = 0;
        var ConcurrentMode = 1;
        var ProfileMode = 2;
        var StrictLegacyMode = 8;
        var StrictEffectsMode = 16;
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log3 = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x) {
          var asUint = x >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log3(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = 0;
        var NoLane = 0;
        var SyncLane = 1;
        var InputContinuousHydrationLane = 2;
        var InputContinuousLane = 4;
        var DefaultHydrationLane = 8;
        var DefaultLane = 16;
        var TransitionHydrationLane = 32;
        var TransitionLanes = 4194240;
        var TransitionLane1 = 64;
        var TransitionLane2 = 128;
        var TransitionLane3 = 256;
        var TransitionLane4 = 512;
        var TransitionLane5 = 1024;
        var TransitionLane6 = 2048;
        var TransitionLane7 = 4096;
        var TransitionLane8 = 8192;
        var TransitionLane9 = 16384;
        var TransitionLane10 = 32768;
        var TransitionLane11 = 65536;
        var TransitionLane12 = 131072;
        var TransitionLane13 = 262144;
        var TransitionLane14 = 524288;
        var TransitionLane15 = 1048576;
        var TransitionLane16 = 2097152;
        var RetryLanes = 130023424;
        var RetryLane1 = 4194304;
        var RetryLane2 = 8388608;
        var RetryLane3 = 16777216;
        var RetryLane4 = 33554432;
        var RetryLane5 = 67108864;
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = 134217728;
        var NonIdleLanes = 268435455;
        var IdleHydrationLane = 268435456;
        var IdleLane = 536870912;
        var OffscreenLane = 1073741824;
        function getLabelForLane(lane) {
          {
            if (lane & SyncLane) {
              return "Sync";
            }
            if (lane & InputContinuousHydrationLane) {
              return "InputContinuousHydration";
            }
            if (lane & InputContinuousLane) {
              return "InputContinuous";
            }
            if (lane & DefaultHydrationLane) {
              return "DefaultHydration";
            }
            if (lane & DefaultLane) {
              return "Default";
            }
            if (lane & TransitionHydrationLane) {
              return "TransitionHydration";
            }
            if (lane & TransitionLanes) {
              return "Transition";
            }
            if (lane & RetryLanes) {
              return "Retry";
            }
            if (lane & SelectiveHydrationLane) {
              return "SelectiveHydration";
            }
            if (lane & IdleHydrationLane) {
              return "IdleHydration";
            }
            if (lane & IdleLane) {
              return "Idle";
            }
            if (lane & OffscreenLane) {
              return "Offscreen";
            }
          }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
          switch (getHighestPriorityLane(lanes)) {
            case SyncLane:
              return SyncLane;
            case InputContinuousHydrationLane:
              return InputContinuousHydrationLane;
            case InputContinuousLane:
              return InputContinuousLane;
            case DefaultHydrationLane:
              return DefaultHydrationLane;
            case DefaultLane:
              return DefaultLane;
            case TransitionHydrationLane:
              return TransitionHydrationLane;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return lanes & TransitionLanes;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return lanes & RetryLanes;
            case SelectiveHydrationLane:
              return SelectiveHydrationLane;
            case IdleHydrationLane:
              return IdleHydrationLane;
            case IdleLane:
              return IdleLane;
            case OffscreenLane:
              return OffscreenLane;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return lanes;
          }
        }
        function getNextLanes(root4, wipLanes) {
          var pendingLanes = root4.pendingLanes;
          if (pendingLanes === NoLanes) {
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var suspendedLanes = root4.suspendedLanes;
          var pingedLanes = root4.pingedLanes;
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
            } else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              if (nonIdlePingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
              }
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            if (unblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(unblockedLanes);
            } else {
              if (pingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(pingedLanes);
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
            var nextLane = getHighestPriorityLane(nextLanes);
            var wipLane = getHighestPriorityLane(wipLanes);
            if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
              return wipLanes;
            }
          }
          if ((nextLanes & InputContinuousLane) !== NoLanes) {
            nextLanes |= pendingLanes & DefaultLane;
          }
          var entangledLanes = root4.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root4.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              nextLanes |= entanglements[index3];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root4, lanes) {
          var eventTimes = root4.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            var eventTime = eventTimes[index3];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case SyncLane:
            case InputContinuousHydrationLane:
            case InputContinuousLane:
              return currentTime + 250;
            case DefaultHydrationLane:
            case DefaultLane:
            case TransitionHydrationLane:
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return currentTime + 5e3;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return NoTimestamp;
            case SelectiveHydrationLane:
            case IdleHydrationLane:
            case IdleLane:
            case OffscreenLane:
              return NoTimestamp;
            default:
              {
                error2("Should have found matching lanes. This is a bug in React.");
              }
              return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root4, currentTime) {
          var pendingLanes = root4.pendingLanes;
          var suspendedLanes = root4.suspendedLanes;
          var pingedLanes = root4.pingedLanes;
          var expirationTimes = root4.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            var expirationTime = expirationTimes[index3];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index3] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root4.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getHighestPriorityPendingLanes(root4) {
          return getHighestPriorityLanes(root4.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root4) {
          var everythingButOffscreen = root4.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function includesSyncLane(lanes) {
          return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
          return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root4, lanes) {
          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
          return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root4, lanes) {
          return (lanes & root4.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
          return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          if ((nextTransitionLane & TransitionLanes) === NoLanes) {
            nextTransitionLane = TransitionLane1;
          }
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          if ((nextRetryLane & RetryLanes) === NoLanes) {
            nextRetryLane = RetryLane1;
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a, b) {
          return (a & b) !== NoLanes;
        }
        function isSubsetOfLanes(set3, subset) {
          return (set3 & subset) === subset;
        }
        function mergeLanes(a, b) {
          return a | b;
        }
        function removeLanes(set3, subset) {
          return set3 & ~subset;
        }
        function intersectLanes(a, b) {
          return a & b;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a, b) {
          return a !== NoLane && a < b ? a : b;
        }
        function createLaneMap(initial2) {
          var laneMap = [];
          for (var i = 0; i < TotalLanes; i++) {
            laneMap.push(initial2);
          }
          return laneMap;
        }
        function markRootUpdated(root4, updateLane, eventTime) {
          root4.pendingLanes |= updateLane;
          if (updateLane !== IdleLane) {
            root4.suspendedLanes = NoLanes;
            root4.pingedLanes = NoLanes;
          }
          var eventTimes = root4.eventTimes;
          var index3 = laneToIndex(updateLane);
          eventTimes[index3] = eventTime;
        }
        function markRootSuspended(root4, suspendedLanes) {
          root4.suspendedLanes |= suspendedLanes;
          root4.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root4.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            expirationTimes[index3] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root4, pingedLanes, eventTime) {
          root4.pingedLanes |= root4.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root4, remainingLanes) {
          var noLongerPendingLanes = root4.pendingLanes & ~remainingLanes;
          root4.pendingLanes = remainingLanes;
          root4.suspendedLanes = NoLanes;
          root4.pingedLanes = NoLanes;
          root4.expiredLanes &= remainingLanes;
          root4.mutableReadLanes &= remainingLanes;
          root4.entangledLanes &= remainingLanes;
          var entanglements = root4.entanglements;
          var eventTimes = root4.eventTimes;
          var expirationTimes = root4.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            entanglements[index3] = NoLanes;
            eventTimes[index3] = NoTimestamp;
            expirationTimes[index3] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root4, entangledLanes) {
          var rootEntangledLanes = root4.entangledLanes |= entangledLanes;
          var entanglements = root4.entanglements;
          var lanes = rootEntangledLanes;
          while (lanes) {
            var index3 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index3;
            if (lane & entangledLanes | entanglements[index3] & entangledLanes) {
              entanglements[index3] |= entangledLanes;
            }
            lanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root4, renderLanes2) {
          var renderLane = getHighestPriorityLane(renderLanes2);
          var lane;
          switch (renderLane) {
            case InputContinuousLane:
              lane = InputContinuousHydrationLane;
              break;
            case DefaultLane:
              lane = DefaultHydrationLane;
              break;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              lane = TransitionHydrationLane;
              break;
            case IdleLane:
              lane = IdleHydrationLane;
              break;
            default:
              lane = NoLane;
              break;
          }
          if ((lane & (root4.suspendedLanes | renderLanes2)) !== NoLane) {
            return NoLane;
          }
          return lane;
        }
        function addFiberToLanesMap(root4, fiber, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root4.pendingUpdatersLaneMap;
          while (lanes > 0) {
            var index3 = laneToIndex(lanes);
            var lane = 1 << index3;
            var updaters = pendingUpdatersLaneMap[index3];
            updaters.add(fiber);
            lanes &= ~lane;
          }
        }
        function movePendingFibersToMemoized(root4, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root4.pendingUpdatersLaneMap;
          var memoizedUpdaters = root4.memoizedUpdaters;
          while (lanes > 0) {
            var index3 = laneToIndex(lanes);
            var lane = 1 << index3;
            var updaters = pendingUpdatersLaneMap[index3];
            if (updaters.size > 0) {
              updaters.forEach(function(fiber) {
                var alternate = fiber.alternate;
                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                  memoizedUpdaters.add(fiber);
                }
              });
              updaters.clear();
            }
            lanes &= ~lane;
          }
        }
        function getTransitionsForLanes(root4, lanes) {
          {
            return null;
          }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
          return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
          currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn) {
          var previousPriority = currentUpdatePriority;
          try {
            currentUpdatePriority = priority;
            return fn();
          } finally {
            currentUpdatePriority = previousPriority;
          }
        }
        function higherEventPriority(a, b) {
          return a !== 0 && a < b ? a : b;
        }
        function lowerEventPriority(a, b) {
          return a === 0 || a > b ? a : b;
        }
        function isHigherEventPriority(a, b) {
          return a !== 0 && a < b;
        }
        function lanesToEventPriority(lanes) {
          var lane = getHighestPriorityLane(lanes);
          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
            return DiscreteEventPriority;
          }
          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
            return ContinuousEventPriority;
          }
          if (includesNonIdleWork(lane)) {
            return DefaultEventPriority;
          }
          return IdleEventPriority;
        }
        function isRootDehydrated(root4) {
          var currentState = root4.current.memoizedState;
          return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn) {
          _attemptSynchronousHydration = fn;
        }
        function attemptSynchronousHydration(fiber) {
          _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn) {
          attemptContinuousHydration = fn;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn) {
          attemptHydrationAtCurrentPriority = fn;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn) {
          getCurrentUpdatePriority$1 = fn;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn) {
          attemptHydrationAtPriority = fn;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = /* @__PURE__ */ new Map();
        var queuedPointerCaptures = /* @__PURE__ */ new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isDiscreteEventThatRequiresHydration(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance2 = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance2 !== null) {
                  queuedTarget.blockedOn = instance2;
                  attemptHydrationAtPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root4 = nearestMounted.stateNode;
                if (isRootDehydrated(root4)) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
          var updatePriority = getCurrentUpdatePriority$1();
          var queuedTarget = {
            blockedOn: null,
            target,
            priority: updatePriority
          };
          var i = 0;
          for (; i < queuedExplicitHydrationTargets.length; i++) {
            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
              break;
            }
          }
          queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
          if (i === 0) {
            attemptExplicitHydrationTarget(queuedTarget);
          }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn === null) {
              {
                var nativeEvent = queuedEvent.nativeEvent;
                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                setReplayingEvent(nativeEventClone);
                nativeEvent.target.dispatchEvent(nativeEventClone);
                resetReplayingEvent();
              }
            } else {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map.delete(key);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i = 1; i < queuedDiscreteEvents.length; i++) {
              var queuedEvent = queuedDiscreteEvents[i];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriority(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEventPriority:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            case DefaultEventPriority:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(DiscreteEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(ContinuousEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          {
            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
            nativeEvent.stopPropagation();
            return;
          }
          clearIfContinuousEvent(domEventName, nativeEvent);
          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
            while (blockedOn !== null) {
              var fiber = getInstanceFromNode(blockedOn);
              if (fiber !== null) {
                attemptSynchronousHydration(fiber);
              }
              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (nextBlockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              }
              if (nextBlockedOn === blockedOn) {
                break;
              }
              blockedOn = nextBlockedOn;
            }
            if (blockedOn !== null) {
              nativeEvent.stopPropagation();
            }
            return;
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return_targetInst = null;
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance2 = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance2 !== null) {
                  return instance2;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root4 = nearestMounted.stateNode;
                if (isRootDehydrated(root4)) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          return_targetInst = targetInst;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message": {
              var schedulerPriority = getCurrentPriorityLevel();
              switch (schedulerPriority) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            }
            default:
              return DefaultEventPriority;
          }
        }
        function addEventBubbleListener(target, eventType, listener3) {
          target.addEventListener(eventType, listener3, false);
          return listener3;
        }
        function addEventCaptureListener(target, eventType, listener3) {
          target.addEventListener(eventType, listener3, true);
          return listener3;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener3, passive) {
          target.addEventListener(eventType, listener3, {
            capture: true,
            passive
          });
          return listener3;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener3, passive) {
          target.addEventListener(eventType, listener3, {
            passive
          });
          return listener3;
        }
        var root3 = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root3 = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset() {
          root3 = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start3;
          var startValue = startText;
          var startLength = startValue.length;
          var end4;
          var endValue = getText();
          var endLength = endValue.length;
          for (start3 = 0; start3 < startLength; start3++) {
            if (startValue[start3] !== endValue[start3]) {
              break;
            }
          }
          var minEnd = startLength - start3;
          for (end4 = 1; end4 <= minEnd; end4++) {
            if (startValue[startLength - end4] !== endValue[endLength - end4]) {
              break;
            }
          }
          var sliceTail = end4 > 1 ? 1 - end4 : void 0;
          fallbackText = endValue.slice(start3, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root3) {
            return root3.value;
          }
          return root3.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize3 = Interface[_propName];
              if (normalize3) {
                this[_propName] = normalize3(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0)
              return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== "Unidentified") {
              return key;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
        var documentMode2 = null;
        if (canUseDOM && "documentMode" in document) {
          documentMode2 = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode2;
        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode2 && documentMode2 > 8 && documentMode2 <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars2 = nativeEvent.data;
              if (chars2 === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars2;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars2 = getData();
              reset();
              isComposing = false;
              return chars2;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars2;
          if (canUseTextInputEvent) {
            chars2 = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars2 = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars2) {
            return null;
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.data = chars2;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element4 = document.createElement("div");
            element4.setAttribute(eventName, "return;");
            isSupported = typeof element4[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node2) {
          var state = node2._wrapperState;
          if (!state || !state.controlled || node2.type !== "number") {
            return;
          }
          {
            setDefaultValue(node2, "number", node2.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && !isReplayingEvent(nativeEvent)) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc = nativeEventTarget.ownerDocument;
            if (doc) {
              win = doc.defaultView || doc.parentWindow;
            } else {
              win = window;
            }
          }
          var from;
          var to;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from = targetInst;
            to = _related ? getClosestInstanceFromNode(_related) : null;
            if (to !== null) {
              var nearestMounted = getNearestMountedFiber(to);
              if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                to = null;
              }
            }
          } else {
            from = null;
            to = targetInst;
          }
          if (from === to) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from == null ? win : getNodeFromInstance(from);
          var toNode = to == null ? win : getNodeFromInstance(to);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter2 = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter2 = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter2, from, to);
        }
        function is3(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is3;
        function shallowEqual2(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i = 0; i < keysA.length; i++) {
            var currentKey = keysA[i];
            if (!hasOwnProperty4.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node2) {
          while (node2 && node2.firstChild) {
            node2 = node2.firstChild;
          }
          return node2;
        }
        function getSiblingNode(node2) {
          while (node2) {
            if (node2.nextSibling) {
              return node2.nextSibling;
            }
            node2 = node2.parentNode;
          }
        }
        function getNodeForCharacterOffset(root4, offset4) {
          var node2 = getLeafNode(root4);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node2) {
            if (node2.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node2.textContent.length;
              if (nodeStart <= offset4 && nodeEnd >= offset4) {
                return {
                  node: node2,
                  offset: offset4 - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node2 = getLeafNode(getSiblingNode(node2));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e2) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length = 0;
          var start3 = -1;
          var end4 = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node2 = outerNode;
          var parentNode = null;
          outer:
            while (true) {
              var next = null;
              while (true) {
                if (node2 === anchorNode && (anchorOffset === 0 || node2.nodeType === TEXT_NODE)) {
                  start3 = length + anchorOffset;
                }
                if (node2 === focusNode && (focusOffset === 0 || node2.nodeType === TEXT_NODE)) {
                  end4 = length + focusOffset;
                }
                if (node2.nodeType === TEXT_NODE) {
                  length += node2.nodeValue.length;
                }
                if ((next = node2.firstChild) === null) {
                  break;
                }
                parentNode = node2;
                node2 = next;
              }
              while (true) {
                if (node2 === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start3 = length;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end4 = length;
                }
                if ((next = node2.nextSibling) !== null) {
                  break;
                }
                node2 = parentNode;
                parentNode = node2.parentNode;
              }
              node2 = next;
            }
          if (start3 === -1 || end4 === -1) {
            return null;
          }
          return {
            start: start3,
            end: end4
          };
        }
        function setOffsets(node2, offsets) {
          var doc = node2.ownerDocument || document;
          var win = doc && doc.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length = node2.textContent.length;
          var start3 = Math.min(offsets.start, length);
          var end4 = offsets.end === void 0 ? start3 : Math.min(offsets.end, length);
          if (!selection.extend && start3 > end4) {
            var temp = end4;
            end4 = start3;
            start3 = temp;
          }
          var startMarker = getNodeForCharacterOffset(node2, start3);
          var endMarker = getNodeForCharacterOffset(node2, end4);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range = doc.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start3 > end4) {
              selection.addRange(range);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range);
            }
          }
        }
        function isTextNode(node2) {
          return node2 && node2.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node2) {
          return node2 && node2.ownerDocument && containsNode(node2.ownerDocument.documentElement, node2);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element4 = getActiveElement();
          while (element4 instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element4)) {
              win = element4.contentWindow;
            } else {
              return element4;
            }
            element4 = getActiveElement(win.document);
          }
          return element4;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i = 0; i < ancestors.length; i++) {
              var info = ancestors[i];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection(input, offsets) {
          var start3 = offsets.start;
          var end4 = offsets.end;
          if (end4 === void 0) {
            end4 = start3;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start3;
            input.selectionEnd = Math.min(end4, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node2) {
          if ("selectionStart" in node2 && hasSelectionCapabilities(node2)) {
            return {
              start: node2.selectionStart,
              end: node2.selectionEnd
            };
          } else {
            var win = node2.ownerDocument && node2.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual2(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes3 = {};
          prefixes3[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes3["Webkit" + styleProp] = "webkit" + eventName;
          prefixes3["Moz" + styleProp] = "moz" + eventName;
          return prefixes3;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style3 = {};
        if (canUseDOM) {
          style3 = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style3) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
        var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i];
            var domEventName = eventName.toLowerCase();
            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + capitalizedEvent);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener3, currentTarget) {
          var type2 = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type2, listener3, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i = dispatchListeners.length - 1; i >= 0; i--) {
              var _dispatchListeners$i = dispatchListeners[i], instance2 = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener3 = _dispatchListeners$i.listener;
              if (instance2 !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener3, currentTarget);
              previousInstance = instance2;
            }
          } else {
            for (var _i = 0; _i < dispatchListeners.length; _i++) {
              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          {
            if (!nonDelegatedEvents.has(domEventName)) {
              error2('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          {
            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
              error2('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var eventSystemFlags = 0;
          if (isCapturePhaseListener) {
            eventSystemFlags |= IS_CAPTURE_PHASE;
          }
          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (domEventName !== "selectionchange") {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement);
              }
            });
            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
            if (ownerDocument !== null) {
              if (!ownerDocument[listeningMarker]) {
                ownerDocument[listeningMarker] = true;
                listenToNativeEvent("selectionchange", false, ownerDocument);
              }
            }
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener3 = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener3, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener3);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener3, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener3);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node2 = targetInst;
              mainLoop:
                while (true) {
                  if (node2 === null) {
                    return;
                  }
                  var nodeTag = node2.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container = node2.stateNode.containerInfo;
                    if (isMatchingRootContainer(container, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node2.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container !== null) {
                      var parentNode = getClosestInstanceFromNode(container);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node2 = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container = container.parentNode;
                    }
                  }
                  node2 = node2.return;
                }
            }
          }
          batchedUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance2, listener3, currentTarget) {
          return {
            instance: instance2,
            listener: listener3,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners = [];
          var instance2 = targetFiber;
          var lastHostComponent = null;
          while (instance2 !== null) {
            var _instance2 = instance2, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener3 = getListener(instance2, reactEventName);
                if (listener3 != null) {
                  listeners.push(createDispatchListener(instance2, listener3, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance2 = instance2.return;
          }
          return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners = [];
          var instance2 = targetFiber;
          while (instance2 !== null) {
            var _instance3 = instance2, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance2, captureName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance2, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance2, reactName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance2, bubbleListener, currentTarget));
              }
            }
            instance2 = instance2.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners = [];
          var instance2 = target;
          while (instance2 !== null) {
            if (instance2 === common) {
              break;
            }
            var _instance4 = instance2, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance2, registrationName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance2, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance2, registrationName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance2, bubbleListener, currentTarget));
                }
              }
            }
            instance2 = instance2.return;
          }
          if (listeners.length !== 0) {
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
          var common = from && to ? getLowestCommonAncestor(from, to) : null;
          if (from !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
          }
          if (to !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            dialog: true,
            webview: true
          };
          validatePropertiesInDevelopment = function(type2, props) {
            validateProperties(type2, props);
            validateProperties$1(type2, props);
            validateProperties$2(type2, props, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name) {
              names.push(name);
            });
            error2("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener3) {
            if (listener3 === false) {
              error2("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error2("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener3);
            }
          };
          normalizeHTML = function(parent, html4) {
            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            testElement.innerHTML = html4;
            return testElement.innerHTML;
          };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          {
            checkHtmlStringCoercion(markup);
          }
          var markupString = typeof markup === "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
          if (normalizedServerText === normalizedClientText) {
            return;
          }
          if (shouldWarnDev) {
            {
              if (!didWarnInvalidHydration) {
                didWarnInvalidHydration = true;
                error2('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
              }
            }
          }
          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
            throw new Error("Text content does not match server-rendered HTML.");
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop8() {
        }
        function trapClickOnNonInteractiveElement(node2) {
          node2.onclick = noop8;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i = 0; i < updatePayload.length; i += 2) {
            var propKey = updatePayload[i];
            var propValue = updatePayload[i + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement133(type2, props, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE) {
            namespaceURI = getIntrinsicNamespace(type2);
          }
          if (namespaceURI === HTML_NAMESPACE) {
            {
              isCustomComponentTag = isCustomComponent(type2, props);
              if (!isCustomComponentTag && type2 !== type2.toLowerCase()) {
                error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type2);
              }
            }
            if (type2 === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props.is === "string") {
              domElement = ownerDocument.createElement(type2, {
                is: props.is
              });
            } else {
              domElement = ownerDocument.createElement(type2);
              if (type2 === "select") {
                var node2 = domElement;
                if (props.multiple) {
                  node2.multiple = true;
                } else if (props.size) {
                  node2.size = props.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type2);
          }
          {
            if (namespaceURI === HTML_NAMESPACE) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty4.call(warnedUnknownTags, type2)) {
                warnedUnknownTags[type2] = true;
                error2("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type2);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text6, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text6);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "video":
            case "audio":
              for (var i = 0; i < mediaEventTypes.length; i++) {
                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
              }
              props = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props = rawProps;
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props = getHostProps$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props = rawProps;
          }
          assertValidProps(tag, props);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
              ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i = 0; i < mediaEventTypes.length; i++) {
                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = /* @__PURE__ */ new Set();
            var attributes3 = domElement.attributes;
            for (var _i = 0; _i < attributes3.length; _i++) {
              var name = attributes3[_i].name.toLowerCase();
              switch (name) {
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes3[_i].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (shouldWarnDev && true && typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                var dontWarnCustomElement = enableCustomElementPropertySupport;
                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (shouldWarnDev) {
              if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text6, isConcurrentMode) {
          var isDifferent = textNode.nodeValue !== text6;
          return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text6) {
          {
            if (text6 === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error2('Expected server HTML to contain a matching text node for "%s" in <%s>.', text6, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props);
              return;
            case "select":
              restoreControlledState$1(domElement, props);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              case "option":
                return tag === "#text";
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              case "colgroup":
                return tag === "col" || tag === "template";
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error2("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error2("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error2("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
          var type2;
          var namespace2;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type2 = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root4 = rootContainerInstance.documentElement;
              namespace2 = root4 ? root4.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container.namespaceURI || null;
              type2 = container.tagName;
              namespace2 = getChildNamespace(ownNamespace, type2);
              break;
            }
          }
          {
            var validatedTag = type2.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace: namespace2,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type2, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace2 = getChildNamespace(parentHostContextDev.namespace, type2);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type2);
            return {
              namespace: namespace2,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance2) {
          return instance2;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance3(type2, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type2, null, hostContextDev.ancestorInfo);
            if (typeof props.children === "string" || typeof props.children === "number") {
              var string3 = "" + props.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type2);
              validateDOMNesting(null, string3, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement133(type2, props, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type2, props, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type2, props, rootContainerInstance);
          switch (type2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props.autoFocus;
            case "img":
              return true;
            default:
              return false;
          }
        }
        function prepareUpdate(domElement, type2, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string3 = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type2);
              validateDOMNesting(null, string3, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type2, oldProps, newProps);
        }
        function shouldSetTextContent(type2, props) {
          return type2 === "textarea" || type2 === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text6, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text6, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text6, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        function getCurrentEventPriority() {
          var currentEvent = window.event;
          if (currentEvent === void 0) {
            return DefaultEventPriority;
          }
          return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        var localPromise = typeof Promise === "function" ? Promise : void 0;
        var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error3) {
          setTimeout(function() {
            throw error3;
          });
        }
        function commitMount(domElement, type2, newProps, internalInstanceHandle) {
          switch (type2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              if (newProps.autoFocus) {
                domElement.focus();
              }
              return;
            case "img": {
              if (newProps.src) {
                domElement.src = newProps.src;
              }
              return;
            }
          }
        }
        function commitUpdate(domElement, updatePayload, type2, oldProps, newProps, internalInstanceHandle) {
          updateProperties(domElement, updatePayload, type2, oldProps, newProps);
          updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container, child) {
          var parentNode;
          if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
          } else {
            parentNode = container;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container, child, beforeChild) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.insertBefore(child, beforeChild);
          } else {
            container.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.removeChild(child);
          } else {
            container.removeChild(child);
          }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node2 = suspenseInstance;
          var depth = 0;
          do {
            var nextNode = node2.nextSibling;
            parentInstance.removeChild(node2);
            if (nextNode && nextNode.nodeType === COMMENT_NODE) {
              var data = nextNode.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                depth++;
              }
            }
            node2 = nextNode;
          } while (node2);
          retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
          if (container.nodeType === COMMENT_NODE) {
            clearSuspenseBoundary(container.parentNode, suspenseInstance);
          } else if (container.nodeType === ELEMENT_NODE) {
            clearSuspenseBoundary(container, suspenseInstance);
          }
          retryIfBlockedOn(container);
        }
        function hideInstance(instance2) {
          instance2 = instance2;
          var style4 = instance2.style;
          if (typeof style4.setProperty === "function") {
            style4.setProperty("display", "none", "important");
          } else {
            style4.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance2, props) {
          instance2 = instance2;
          var styleProp = props[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance2.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text6) {
          textInstance.nodeValue = text6;
        }
        function clearContainer(container) {
          if (container.nodeType === ELEMENT_NODE) {
            container.textContent = "";
          } else if (container.nodeType === DOCUMENT_NODE) {
            if (container.documentElement) {
              container.removeChild(container.documentElement);
            }
          }
        }
        function canHydrateInstance(instance2, type2, props) {
          if (instance2.nodeType !== ELEMENT_NODE || type2.toLowerCase() !== instance2.nodeName.toLowerCase()) {
            return null;
          }
          return instance2;
        }
        function canHydrateTextInstance(instance2, text6) {
          if (text6 === "" || instance2.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance2;
        }
        function canHydrateSuspenseInstance(instance2) {
          if (instance2.nodeType !== COMMENT_NODE) {
            return null;
          }
          return instance2;
        }
        function isSuspenseInstancePending(instance2) {
          return instance2.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance2) {
          return instance2.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance2) {
          var dataset = instance2.nextSibling && instance2.nextSibling.dataset;
          var digest, message, stack;
          if (dataset) {
            digest = dataset.dgst;
            {
              message = dataset.msg;
              stack = dataset.stck;
            }
          }
          {
            return {
              message,
              digest,
              stack
            };
          }
        }
        function registerSuspenseInstanceRetry(instance2, callback) {
          instance2._reactRetry = callback;
        }
        function getNextHydratable(node2) {
          for (; node2 != null; node2 = node2.nextSibling) {
            var nodeType = node2.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
            if (nodeType === COMMENT_NODE) {
              var nodeData = node2.data;
              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                break;
              }
              if (nodeData === SUSPENSE_END_DATA) {
                return null;
              }
            }
          }
          return node2;
        }
        function getNextHydratableSibling(instance2) {
          return getNextHydratable(instance2.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
          return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
          return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance2, type2, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, instance2);
          updateFiberProps(instance2, props);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedProperties(instance2, type2, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text6, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedText(textInstance, text6);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node2 = suspenseInstance.nextSibling;
          var depth = 0;
          while (node2) {
            if (node2.nodeType === COMMENT_NODE) {
              var data = node2.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node2);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node2 = node2.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node2 = targetInstance.previousSibling;
          var depth = 0;
          while (node2) {
            if (node2.nodeType === COMMENT_NODE) {
              var data = node2.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node2;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node2 = node2.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
          return parentType !== "head" && parentType !== "body";
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text6, isConcurrentMode) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text6, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text6, isConcurrentMode) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text6, isConcurrentMode, shouldWarnDev);
          }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance2) {
          {
            if (instance2.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance2);
            } else if (instance2.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentContainer, instance2);
            }
          }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance2) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) {
              if (instance2.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentNode, instance2);
              } else if (instance2.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentNode, instance2);
              }
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance2, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance2.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance2);
              } else if (instance2.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentInstance, instance2);
              }
            }
          }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type2, props) {
          {
            warnForInsertedHydratedElement(parentContainer, type2);
          }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text6) {
          {
            warnForInsertedHydratedText(parentContainer, text6);
          }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type2, props) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedElement(parentNode, type2);
          }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text6) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null)
              warnForInsertedHydratedText(parentNode, text6);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type2, props, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type2);
            }
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text6, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text6);
            }
          }
        }
        function errorHydratingContainer(parentContainer) {
          {
            error2("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
          }
        }
        function preparePortalMount(portalInstance) {
          listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
        var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
        function detachDeletedInstance(node2) {
          delete node2[internalInstanceKey];
          delete node2[internalPropsKey];
          delete node2[internalEventHandlersKey];
          delete node2[internalEventHandlerListenersKey];
          delete node2[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node2) {
          node2[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node2) {
          node2[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node2) {
          node2[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node2) {
          return !!node2[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node2) {
          var inst = node2[internalInstanceKey] || node2[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          throw new Error("getNodeFromInstance: Invalid argument.");
        }
        function getFiberCurrentPropsFromNode(node2) {
          return node2[internalPropsKey] || null;
        }
        function updateFiberProps(node2, props) {
          node2[internalPropsKey] = props;
        }
        function getEventListenerSet(node2) {
          var elementListenerSet = node2[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node2[internalEventHandlersKey] = /* @__PURE__ */ new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element4) {
          {
            if (element4) {
              var owner = element4._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element4.type, element4._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values2, location3, componentName, element4) {
          {
            var has2 = Function.call.bind(hasOwnProperty4);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location3 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location3, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element4);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location3, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element4);
                  error2("Failed %s type: %s", location3, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index2 = -1;
        function createCursor(defaultValue) {
          return {
            current: defaultValue
          };
        }
        function pop(cursor, fiber) {
          if (index2 < 0) {
            {
              error2("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index2]) {
              error2("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index2];
          valueStack[index2] = null;
          {
            fiberStack[index2] = null;
          }
          index2--;
        }
        function push2(cursor, value, fiber) {
          index2++;
          valueStack[index2] = cursor.current;
          {
            fiberStack[index2] = fiber;
          }
          cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance2 = workInProgress2.stateNode;
            instance2.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance2.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type2 = workInProgress2.type;
            var contextTypes = type2.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance2 = workInProgress2.stateNode;
            if (instance2 && instance2.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance2.__reactInternalMemoizedMaskedChildContext;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name);
            }
            if (instance2) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return context;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type2) {
          {
            var childContextTypes = type2.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
          {
            if (contextStackCursor.current !== emptyContextObject) {
              throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
            }
            push2(contextStackCursor, context, fiber);
            push2(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type2, parentContext) {
          {
            var instance2 = fiber.stateNode;
            var childContextTypes = type2.childContextTypes;
            if (typeof instance2.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error2("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance2.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name = getComponentNameFromFiber(fiber) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name);
            }
            return assign({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance2 = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance2 && instance2.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push2(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push2(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type2, didChange) {
          {
            var instance2 = workInProgress2.stateNode;
            if (!instance2) {
              throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type2, previousContext);
              instance2.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop(didPerformWorkStackCursor, workInProgress2);
              pop(contextStackCursor, workInProgress2);
              push2(contextStackCursor, mergedContext, workInProgress2);
              push2(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop(didPerformWorkStackCursor, workInProgress2);
              push2(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
              throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
            }
            var node2 = fiber;
            do {
              switch (node2.tag) {
                case HostRoot:
                  return node2.stateNode.context;
                case ClassComponent: {
                  var Component = node2.type;
                  if (isContextProvider(Component)) {
                    return node2.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node2 = node2.return;
            } while (node2 !== null);
            throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
          } else {
            syncQueue.push(callback);
          }
        }
        function scheduleLegacySyncCallback(callback) {
          includesLegacySyncCallbacks = true;
          scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
          if (includesLegacySyncCallbacks) {
            flushSyncCallbacks();
          }
        }
        function flushSyncCallbacks() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i = 0;
            var previousUpdatePriority = getCurrentUpdatePriority();
            try {
              var isSync = true;
              var queue = syncQueue;
              setCurrentUpdatePriority(DiscreteEventPriority);
              for (; i < queue.length; i++) {
                var callback = queue[i];
                do {
                  callback = callback(isSync);
                } while (callback !== null);
              }
              syncQueue = null;
              includesLegacySyncCallbacks = false;
            } catch (error3) {
              if (syncQueue !== null) {
                syncQueue = syncQueue.slice(i + 1);
              }
              scheduleCallback(ImmediatePriority, flushSyncCallbacks);
              throw error3;
            } finally {
              setCurrentUpdatePriority(previousUpdatePriority);
              isFlushingSyncQueue = false;
            }
          }
          return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = "";
        function isForkedChild(workInProgress2) {
          warnIfNotHydrating();
          return (workInProgress2.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress2) {
          warnIfNotHydrating();
          return treeForkCount;
        }
        function getTreeId() {
          var overflow = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index3) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          var baseOverflow = treeContextOverflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index3 + 1;
          var length = getBitLength(totalChildren) + baseLength;
          if (length > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            treeContextId = 1 << restOfLength | id;
            treeContextOverflow = overflow;
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            treeContextId = 1 << length | _id;
            treeContextOverflow = _overflow;
          }
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          var returnFiber = workInProgress2.return;
          if (returnFiber !== null) {
            var numberOfForks = 1;
            var slotIndex = 0;
            pushTreeFork(workInProgress2, numberOfForks);
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        function getBitLength(number2) {
          return 32 - clz32(number2);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        function popTreeContext(workInProgress2) {
          while (workInProgress2 === treeForkProvider) {
            treeForkProvider = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
            treeForkCount = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
          }
          while (workInProgress2 === treeContextProvider) {
            treeContextProvider = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextOverflow = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextId = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
          }
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          if (treeContextProvider !== null) {
            return {
              id: treeContextId,
              overflow: treeContextOverflow
            };
          } else {
            return null;
          }
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          {
            if (!getIsHydrating()) {
              error2("Expected to be hydrating. This is a bug in React. Please file an issue.");
            }
          }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
          {
            if (isHydrating) {
              error2("We should not be hydrating here. This is a bug in React. Please file a bug.");
            }
          }
        }
        function markDidThrowWhileHydratingDEV() {
          {
            didSuspendOrErrorDEV = true;
          }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
          {
            return didSuspendOrErrorDEV;
          }
        }
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          if (treeContext !== null) {
            restoreSuspendedTreeContext(fiber, treeContext);
          }
          return true;
        }
        function warnUnhydratedInstance(returnFiber, instance2) {
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance2);
                break;
              }
              case HostComponent: {
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance2, isConcurrentMode);
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                if (suspenseState.dehydrated !== null)
                  didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance2);
                break;
              }
            }
          }
        }
        function deleteHydratableInstance(returnFiber, instance2) {
          warnUnhydratedInstance(returnFiber, instance2);
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance2;
          childToDelete.return = returnFiber;
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
          {
            if (didSuspendOrErrorDEV) {
              return;
            }
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type2 = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinContainer(parentContainer, type2);
                    break;
                  case HostText:
                    var text6 = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text6);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent: {
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, isConcurrentMode);
                    break;
                  }
                  case HostText: {
                    var _text = fiber.pendingProps;
                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, _isConcurrentMode);
                    break;
                  }
                }
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                var _parentInstance = suspenseState.dehydrated;
                if (_parentInstance !== null)
                  switch (fiber.tag) {
                    case HostComponent:
                      var _type2 = fiber.type;
                      var _props2 = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                      break;
                    case HostText:
                      var _text2 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                      break;
                  }
                break;
              }
              default:
                return;
            }
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type2 = fiber.type;
              var props = fiber.pendingProps;
              var instance2 = canHydrateInstance(nextInstance, type2);
              if (instance2 !== null) {
                fiber.stateNode = instance2;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance2);
                return true;
              }
              return false;
            }
            case HostText: {
              var text6 = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text6);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
              if (suspenseInstance !== null) {
                var suspenseState = {
                  dehydrated: suspenseInstance,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState;
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        }
        function shouldClientRenderOnMismatch(fiber) {
          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
          throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance2 = fiber.stateNode;
          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
          var updatePayload = hydrateInstance(instance2, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, _isConcurrentMode2);
                  break;
                }
              }
            }
          }
          return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent = fiber.return;
          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
            parent = parent.return;
          }
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
            var nextInstance = nextHydratableInstance;
            if (nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnIfUnhydratedTailNodes(fiber);
                throwOnHydrationMismatch();
              } else {
                while (nextInstance) {
                  deleteHydratableInstance(fiber, nextInstance);
                  nextInstance = getNextHydratableSibling(nextInstance);
                }
              }
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function hasUnhydratedTailNodes() {
          return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
          var nextInstance = nextHydratableInstance;
          while (nextInstance) {
            warnUnhydratedInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
          didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          if (hydrationErrors !== null) {
            queueRecoverableErrors(hydrationErrors);
            hydrationErrors = null;
          }
        }
        function getIsHydrating() {
          return isHydrating;
        }
        function queueHydrationError(error3) {
          if (hydrationErrors === null) {
            hydrationErrors = [error3];
          } else {
            hydrationErrors.push(error3);
          }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance2) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance2) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node2 = fiber;
            while (node2 !== null) {
              if (node2.mode & StrictLegacyMode) {
                maybeStrictRoot = node2;
              }
              node2 = node2.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set3) {
            var array = [];
            set3.forEach(function(value) {
              array.push(value);
            });
            return array.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance2) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance2.componentWillMount === "function" && instance2.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance2.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error2("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error2("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error2("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn2("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn2("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn2("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance2) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error2("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance2 !== null && typeof instance2.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error2("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = assign({}, baseProps);
            var defaultProps2 = Component.defaultProps;
            for (var propName in defaultProps2) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps2[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, context, nextValue) {
          {
            push2(valueCursor, context._currentValue, providerFiber);
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error2("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(context, providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber);
          {
            {
              context._currentValue = currentValue;
            }
          }
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          var node2 = parent;
          while (node2 !== null) {
            var alternate = node2.alternate;
            if (!isSubsetOfLanes(node2.childLanes, renderLanes2)) {
              node2.childLanes = mergeLanes(node2.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
            if (node2 === propagationRoot) {
              break;
            }
            node2 = node2.return;
          }
          {
            if (node2 !== propagationRoot) {
              error2("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function propagateContextChange(workInProgress2, context, renderLanes2) {
          {
            propagateContextChange_eager(workInProgress2, context, renderLanes2);
          }
        }
        function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list3 = fiber.dependencies;
            if (list3 !== null) {
              nextFiber = fiber.child;
              var dependency = list3.firstContext;
              while (dependency !== null) {
                if (dependency.context === context) {
                  if (fiber.tag === ClassComponent) {
                    var lane = pickArbitraryLane(renderLanes2);
                    var update2 = createUpdate(NoTimestamp, lane);
                    update2.tag = ForceUpdate;
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null)
                      ;
                    else {
                      var sharedQueue = updateQueue.shared;
                      var pending = sharedQueue.pending;
                      if (pending === null) {
                        update2.next = update2;
                      } else {
                        update2.next = pending.next;
                        pending.next = update2;
                      }
                      sharedQueue.pending = update2;
                    }
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                  list3.lanes = mergeLanes(list3.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else if (fiber.tag === DehydratedFragment) {
              var parentSuspense = fiber.return;
              if (parentSuspense === null) {
                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
              }
              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
              var _alternate = parentSuspense.alternate;
              if (_alternate !== null) {
                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
              }
              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
              nextFiber = fiber.sibling;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
        }
        function readContext(context) {
          {
            if (isDisallowedContextReadInDEV) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          var value = context._currentValue;
          if (lastFullyObservedContext === context)
            ;
          else {
            var contextItem = {
              context,
              memoizedValue: value,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null) {
                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return value;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue) {
          if (concurrentQueues === null) {
            concurrentQueues = [queue];
          } else {
            concurrentQueues.push(queue);
          }
        }
        function finishQueueingConcurrentUpdates() {
          if (concurrentQueues !== null) {
            for (var i = 0; i < concurrentQueues.length; i++) {
              var queue = concurrentQueues[i];
              var lastInterleavedUpdate = queue.interleaved;
              if (lastInterleavedUpdate !== null) {
                queue.interleaved = null;
                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                var lastPendingUpdate = queue.pending;
                if (lastPendingUpdate !== null) {
                  var firstPendingUpdate = lastPendingUpdate.next;
                  lastPendingUpdate.next = firstInterleavedUpdate;
                  lastInterleavedUpdate.next = firstPendingUpdate;
                }
                queue.pending = lastInterleavedUpdate;
              }
            }
            concurrentQueues = null;
          }
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update2, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update2.next = update2;
            pushConcurrentUpdateQueue(queue);
          } else {
            update2.next = interleaved.next;
            interleaved.next = update2;
          }
          queue.interleaved = update2;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update2, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update2.next = update2;
            pushConcurrentUpdateQueue(queue);
          } else {
            update2.next = interleaved.next;
            interleaved.next = update2;
          }
          queue.interleaved = update2;
        }
        function enqueueConcurrentClassUpdate(fiber, queue, update2, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update2.next = update2;
            pushConcurrentUpdateQueue(queue);
          } else {
            update2.next = interleaved.next;
            interleaved.next = update2;
          }
          queue.interleaved = update2;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node2 = sourceFiber;
          var parent = sourceFiber.return;
          while (parent !== null) {
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node2 = parent;
            parent = parent.return;
          }
          if (node2.tag === HostRoot) {
            var root4 = node2.stateNode;
            return root4;
          } else {
            return null;
          }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: NoLanes
            },
            effects: null
          };
          fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          var queue = workInProgress2.updateQueue;
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var clone3 = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: currentQueue.firstBaseUpdate,
              lastBaseUpdate: currentQueue.lastBaseUpdate,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = clone3;
          }
        }
        function createUpdate(eventTime, lane) {
          var update2 = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update2;
        }
        function enqueueUpdate(fiber, update2, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return null;
          }
          var sharedQueue = updateQueue.shared;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error2("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
          if (isUnsafeClassRenderPhaseUpdate()) {
            var pending = sharedQueue.pending;
            if (pending === null) {
              update2.next = update2;
            } else {
              update2.next = pending.next;
              pending.next = update2;
            }
            sharedQueue.pending = update2;
            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
          } else {
            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update2, lane);
          }
        }
        function entangleTransitions(root4, fiber, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root4.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes;
            markRootEntangled(root4, newQueueLanes);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update2 = firstBaseUpdate;
                do {
                  var clone3 = {
                    eventTime: update2.eventTime,
                    lane: update2.lane,
                    tag: update2.tag,
                    payload: update2.payload,
                    callback: update2.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone3;
                  } else {
                    newLast.next = clone3;
                    newLast = clone3;
                  }
                  update2 = update2.next;
                } while (update2 !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = queue;
              return;
            }
          }
          var lastBaseUpdate = queue.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue, update2, prevState, nextProps, instance2) {
          switch (update2.tag) {
            case ReplaceState: {
              var payload = update2.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance2, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      payload.call(instance2, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            case UpdateState: {
              var _payload = update2.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance2, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      _payload.call(instance2, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return assign({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props, instance2, renderLanes2) {
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue.shared;
          }
          var firstBaseUpdate = queue.firstBaseUpdate;
          var lastBaseUpdate = queue.lastBaseUpdate;
          var pendingQueue = queue.shared.pending;
          if (pendingQueue !== null) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update2 = firstBaseUpdate;
            do {
              var updateLane = update2.lane;
              var updateEventTime = update2.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone3 = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update2.tag,
                  payload: update2.payload,
                  callback: update2.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone3;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone3;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone = {
                    eventTime: updateEventTime,
                    lane: NoLane,
                    tag: update2.tag,
                    payload: update2.payload,
                    callback: update2.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                }
                newState = getStateFromUpdate(workInProgress2, queue, update2, newState, props, instance2);
                var callback = update2.callback;
                if (callback !== null && update2.lane !== NoLane) {
                  workInProgress2.flags |= Callback;
                  var effects = queue.effects;
                  if (effects === null) {
                    queue.effects = [update2];
                  } else {
                    effects.push(update2);
                  }
                }
              }
              update2 = update2.next;
              if (update2 === null) {
                pendingQueue = queue.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update2 = _firstPendingUpdate;
                  queue.lastBaseUpdate = _lastPendingUpdate;
                  queue.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate;
            var lastInterleaved = queue.shared.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                newLanes = mergeLanes(newLanes, interleaved.lane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (firstBaseUpdate === null) {
              queue.shared.lanes = NoLanes;
            }
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context) {
          if (typeof callback !== "function") {
            throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
          }
          callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance2) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i = 0; i < effects.length; i++) {
              var effect = effects[i];
              var callback = effect.callback;
              if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance2);
              }
            }
          }
        }
        var fakeInternalInstance = {};
        var emptyRefsObject = new React134.Component().refs;
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type2, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type2) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get4(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update2 = createUpdate(eventTime, lane);
            update2.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update2.callback = callback;
            }
            var root4 = enqueueUpdate(fiber, update2, lane);
            if (root4 !== null) {
              scheduleUpdateOnFiber(root4, fiber, lane, eventTime);
              entangleTransitions(root4, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get4(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update2 = createUpdate(eventTime, lane);
            update2.tag = ReplaceState;
            update2.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update2.callback = callback;
            }
            var root4 = enqueueUpdate(fiber, update2, lane);
            if (root4 !== null) {
              scheduleUpdateOnFiber(root4, fiber, lane, eventTime);
              entangleTransitions(root4, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get4(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update2 = createUpdate(eventTime, lane);
            update2.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update2.callback = callback;
            }
            var root4 = enqueueUpdate(fiber, update2, lane);
            if (root4 !== null) {
              scheduleUpdateOnFiber(root4, fiber, lane, eventTime);
              entangleTransitions(root4, fiber, lane);
            }
            {
              markForceUpdateScheduled(fiber, lane);
            }
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance2 = workInProgress2.stateNode;
          if (typeof instance2.shouldComponentUpdate === "function") {
            var shouldUpdate = instance2.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  shouldUpdate = instance2.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              if (shouldUpdate === void 0) {
                error2("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual2(oldProps, newProps) || !shallowEqual2(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance2 = workInProgress2.stateNode;
          {
            var name = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance2.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error2("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
              } else {
                error2("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
              }
            }
            if (instance2.getInitialState && !instance2.getInitialState.isReactClassApproved && !instance2.state) {
              error2("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
            }
            if (instance2.getDefaultProps && !instance2.getDefaultProps.isReactClassApproved) {
              error2("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
            }
            if (instance2.propTypes) {
              error2("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
            }
            if (instance2.contextType) {
              error2("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
            }
            {
              if (instance2.contextTypes) {
                error2("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error2("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
              }
            }
            if (typeof instance2.componentShouldUpdate === "function") {
              error2("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance2.shouldComponentUpdate !== "undefined") {
              error2("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance2.componentDidUnmount === "function") {
              error2("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
            }
            if (typeof instance2.componentDidReceiveProps === "function") {
              error2("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
            }
            if (typeof instance2.componentWillRecieveProps === "function") {
              error2("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
            }
            if (typeof instance2.UNSAFE_componentWillRecieveProps === "function") {
              error2("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
            }
            var hasMutatedProps = instance2.props !== newProps;
            if (instance2.props !== void 0 && hasMutatedProps) {
              error2("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
            }
            if (instance2.defaultProps) {
              error2("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function" && typeof instance2.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error2("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance2.getDerivedStateFromProps === "function") {
              error2("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof instance2.getDerivedStateFromError === "function") {
              error2("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error2("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
            }
            var _state = instance2.state;
            if (_state && (typeof _state !== "object" || isArray2(_state))) {
              error2("%s.state: must be set to an object or null", name);
            }
            if (typeof instance2.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance2) {
          instance2.updater = classComponentUpdater;
          workInProgress2.stateNode = instance2;
          set2(instance2, workInProgress2);
          {
            instance2._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          var instance2 = new ctor(props, context);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance2 = new ctor(props, context);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          var state = workInProgress2.memoizedState = instance2.state !== null && instance2.state !== void 0 ? instance2.state : null;
          adoptClassInstance(workInProgress2, instance2);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance2.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance2.componentWillMount === "function" && instance2.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance2.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance2.componentWillReceiveProps === "function" && instance2.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance2.componentWillUpdate === "function" && instance2.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error2("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return instance2;
        }
        function callComponentWillMount(workInProgress2, instance2) {
          var oldState = instance2.state;
          if (typeof instance2.componentWillMount === "function") {
            instance2.componentWillMount();
          }
          if (typeof instance2.UNSAFE_componentWillMount === "function") {
            instance2.UNSAFE_componentWillMount();
          }
          if (oldState !== instance2.state) {
            {
              error2("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext) {
          var oldState = instance2.state;
          if (typeof instance2.componentWillReceiveProps === "function") {
            instance2.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance2.UNSAFE_componentWillReceiveProps === "function") {
            instance2.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance2.state !== oldState) {
            {
              var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error2("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance2 = workInProgress2.stateNode;
          instance2.props = newProps;
          instance2.state = workInProgress2.memoizedState;
          instance2.refs = emptyRefsObject;
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance2.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance2.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance2.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error2("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance2);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance2);
            }
          }
          instance2.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance2.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance2.getSnapshotBeforeUpdate !== "function" && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance2);
            processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
            instance2.state = workInProgress2.memoizedState;
          }
          if (typeof instance2.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance2 = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance2.props = oldProps;
          var oldContext = instance2.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance2.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance2.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillMount === "function" || typeof instance2.componentWillMount === "function")) {
              if (typeof instance2.componentWillMount === "function") {
                instance2.componentWillMount();
              }
              if (typeof instance2.UNSAFE_componentWillMount === "function") {
                instance2.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance2.componentDidMount === "function") {
              var _fiberFlags = Update;
              {
                _fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags;
            }
          } else {
            if (typeof instance2.componentDidMount === "function") {
              var _fiberFlags2 = Update;
              {
                _fiberFlags2 |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags2 |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags2;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance2.props = newProps;
          instance2.state = newState;
          instance2.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
          var instance2 = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance2.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance2.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance2.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillReceiveProps === "function" || typeof instance2.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance2.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance2, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
            if (typeof instance2.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || enableLazyContextPropagation;
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance2.UNSAFE_componentWillUpdate === "function" || typeof instance2.componentWillUpdate === "function")) {
              if (typeof instance2.componentWillUpdate === "function") {
                instance2.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance2.UNSAFE_componentWillUpdate === "function") {
                instance2.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance2.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance2.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance2.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance2.props = newProps;
          instance2.state = newState;
          instance2.context = nextContext;
          return shouldUpdate;
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (typeof child._store !== "object") {
              throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            }
            child._store.validated = true;
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error2('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        function coerceRef(returnFiber, current2, element4) {
          var mixedRef = element4.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && !(element4._owner && element4._self && element4._owner.stateNode !== element4._self)) {
                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error2('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element4._owner) {
              var owner = element4._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (ownerFiber.tag !== ClassComponent) {
                  throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
              }
              var resolvedInst = inst;
              {
                checkPropStringCoercion(mixedRef, "ref");
              }
              var stringRef = "" + mixedRef;
              if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                return current2.ref;
              }
              var ref2 = function(value) {
                var refs = resolvedInst.refs;
                if (refs === emptyRefsObject) {
                  refs = resolvedInst.refs = {};
                }
                if (value === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value;
                }
              };
              ref2._stringRef = stringRef;
              return ref2;
            } else {
              if (typeof mixedRef !== "string") {
                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
              }
              if (!element4._owner) {
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var childString = Object.prototype.toString.call(newChild);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error2("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function resolveLazy(lazyType) {
          var payload = lazyType._payload;
          var init2 = lazyType._init;
          return init2(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = /* @__PURE__ */ new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone3 = createWorkInProgress(fiber, pendingProps);
            clone3.index = 0;
            clone3.sibling = null;
            return clone3;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              newFiber.flags |= Forked;
              return lastPlacedIndex;
            }
            var current2 = newFiber.alternate;
            if (current2 !== null) {
              var oldIndex = current2.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags |= Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (current2 === null || current2.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current2, element4, lanes) {
            var elementType = element4.type;
            if (elementType === REACT_FRAGMENT_TYPE) {
              return updateFragment2(returnFiber, current2, element4.props.children, lanes, element4.key);
            }
            if (current2 !== null) {
              if (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element4) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                var existing = useFiber(current2, element4.props);
                existing.ref = coerceRef(returnFiber, current2, element4);
                existing.return = returnFiber;
                {
                  existing._debugSource = element4._source;
                  existing._debugOwner = element4._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element4, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current2, element4);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current2, fragment2, lanes, key) {
            if (current2 === null || current2.tag !== Fragment65) {
              var created = createFiberFromFragment(fragment2, returnFiber.mode, lanes, key);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, fragment2);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return createChild(returnFiber, init2(payload), lanes);
                }
              }
              if (isArray2(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              if (key !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  if (newChild.key === key) {
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE: {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_LAZY_TYPE: {
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return updateSlot(returnFiber, oldFiber, init2(payload), lanes);
                }
              }
              if (isArray2(newChild) || getIteratorFn(newChild)) {
                if (key !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return updateFromMap(existingChildren, returnFiber, newIdx, init2(payload), lanes);
              }
              if (isArray2(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(child, returnFiber);
                  var key = child.key;
                  if (typeof key !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key);
                    break;
                  }
                  if (!knownKeys.has(key)) {
                    knownKeys.add(key);
                    break;
                  }
                  error2("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                  break;
                case REACT_LAZY_TYPE:
                  var payload = child._payload;
                  var init2 = child._init;
                  warnOnInvalidKey(init2(payload), knownKeys, returnFiber);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i = 0; i < newChildren.length; i++) {
                var child = newChildren[i];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              if (getIsHydrating()) {
                var _numberOfForks = newIdx;
                pushTreeFork(returnFiber, _numberOfForks);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks2 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks2);
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (typeof iteratorFn !== "function") {
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error2("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error2("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (newChildren == null) {
              throw new Error("An iterable object provided no iterator.");
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              if (getIsHydrating()) {
                var _numberOfForks3 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks3);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks4 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks4);
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element4, lanes) {
            var key = element4.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                var elementType = element4.type;
                if (elementType === REACT_FRAGMENT_TYPE) {
                  if (child.tag === Fragment65) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element4.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element4._source;
                      existing._debugOwner = element4._owner;
                    }
                    return existing;
                  }
                } else {
                  if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element4) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing = useFiber(child, element4.props);
                    _existing.ref = coerceRef(returnFiber, child, element4);
                    _existing.return = returnFiber;
                    {
                      _existing._debugSource = element4._source;
                      _existing._debugOwner = element4._owner;
                    }
                    return _existing;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element4.type === REACT_FRAGMENT_TYPE) {
              var created = createFiberFromFragment(element4.props.children, returnFiber.mode, lanes, element4.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element4, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element4);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_LAZY_TYPE:
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return reconcileChildFibers2(returnFiber, currentFirstChild, init2(payload), lanes);
              }
              if (isArray2(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current2, workInProgress2) {
          if (current2 !== null && workInProgress2.child !== current2.child) {
            throw new Error("Resuming work not yet implemented.");
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c) {
          if (c === NO_CONTEXT) {
            throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
          }
          return c;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push2(rootInstanceStackCursor, nextRootInstance, fiber);
          push2(contextFiberStackCursor, fiber, fiber);
          push2(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop(contextStackCursor$1, fiber);
          push2(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context = requiredContext(contextStackCursor$1.current);
          return context;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context, fiber.type);
          if (context === nextContext) {
            return;
          }
          push2(contextFiberStackCursor, fiber, fiber);
          push2(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push2(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props = workInProgress2.memoizedProps;
          {
            return true;
          }
        }
        function findFirstSuspended(row) {
          var node2 = row;
          while (node2 !== null) {
            if (node2.tag === SuspenseComponent) {
              var state = node2.memoizedState;
              if (state !== null) {
                var dehydrated = state.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node2;
                }
              }
            } else if (node2.tag === SuspenseListComponent && node2.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node2.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node2;
              }
            } else if (node2.child !== null) {
              node2.child.return = node2;
              node2 = node2.child;
              continue;
            }
            if (node2 === row) {
              return null;
            }
            while (node2.sibling === null) {
              if (node2.return === null || node2.return === row) {
                return null;
              }
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
          return null;
        }
        var NoFlags$1 = 0;
        var HasEffect = 1;
        var Insertion = 2;
        var Layout = 4;
        var Passive$1 = 8;
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
          for (var i = 0; i < workInProgressSources.length; i++) {
            var mutableSource = workInProgressSources[i];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root4, mutableSource) {
          var getVersion3 = mutableSource._getVersion;
          var version = getVersion3(mutableSource._source);
          if (root4.mutableSourceEagerHydrationData == null) {
            root4.mutableSourceEagerHydrationData = [mutableSource, version];
          } else {
            root4.mutableSourceEagerHydrationData.push(mutableSource, version);
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !isArray2(deps)) {
              error2("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table2 = "";
                var secondColumnStart = 30;
                for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                  var oldHookName = hookTypesDev[i];
                  var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table2 += row;
                }
                error2("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table2);
              }
            }
          }
        }
        function throwInvalidHookError() {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (objectIs(nextDeps[i], prevDeps[i])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current2 !== null && current2.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component(props, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              localIdCounter = 0;
              if (numberOfReRenders >= RE_RENDER_LIMIT) {
                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component(props, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && (current2.mode & ConcurrentMode) !== NoMode) {
              error2("Internal React error: Expected static flag was missing. Please notify the React team.");
            }
          }
          didScheduleRenderPhaseUpdate = false;
          if (didRenderTooFewHooks) {
            throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
          }
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
          } else {
            workInProgress2.flags &= ~(Passive | Update);
          }
          current2.lanes = removeLanes(current2.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue = hook.queue;
              if (queue !== null) {
                queue.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current2 = currentlyRenderingFiber$1.alternate;
            if (current2 !== null) {
              nextCurrentHook = current2.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (nextCurrentHook === null) {
              throw new Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            stores: null
          };
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function mountReducer(reducer2, initialArg, init2) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init2 !== void 0) {
            initialState = init2(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: reducer2,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer2, initialArg, init2) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer2;
          var current2 = currentHook;
          var baseQueue = current2.baseQueue;
          var pendingQueue = queue.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current2.baseQueue !== baseQueue) {
                error2("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          if (baseQueue !== null) {
            var first = baseQueue.next;
            var newState = current2.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update2 = first;
            do {
              var updateLane = update2.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone3 = {
                  lane: updateLane,
                  action: update2.action,
                  hasEagerState: update2.hasEagerState,
                  eagerState: update2.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone3;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone3;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone = {
                    lane: NoLane,
                    action: update2.action,
                    hasEagerState: update2.hasEagerState,
                    eagerState: update2.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (update2.hasEagerState) {
                  newState = update2.eagerState;
                } else {
                  var action = update2.action;
                  newState = reducer2(newState, action);
                }
              }
              update2 = update2.next;
            } while (update2 !== null && update2 !== first);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
          }
          var lastInterleaved = queue.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              var interleavedLane = interleaved.lane;
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
              markSkippedUpdateLanes(interleavedLane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (baseQueue === null) {
            queue.lanes = NoLanes;
          }
          var dispatch = queue.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer2, initialArg, init2) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer2;
          var dispatch = queue.dispatch;
          var lastRenderPhaseUpdate = queue.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update2 = firstRenderPhaseUpdate;
            do {
              var action = update2.action;
              newState = reducer2(newState, action);
              update2 = update2.next;
            } while (update2 !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function updateMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = mountWorkInProgressHook();
          var nextSnapshot;
          var isHydrating2 = getIsHydrating();
          if (isHydrating2) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            nextSnapshot = getServerSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                if (nextSnapshot !== getServerSnapshot()) {
                  error2("The result of getServerSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
          } else {
            nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error2("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var root4 = getWorkInProgressRoot();
            if (root4 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root4, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          hook.memoizedState = nextSnapshot;
          var inst = {
            value: nextSnapshot,
            getSnapshot
          };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = updateWorkInProgressHook();
          var nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error2("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var prevSnapshot = hook.memoizedState;
          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
          if (snapshotChanged) {
            hook.memoizedState = nextSnapshot;
            markWorkInProgressReceivedUpdate();
          }
          var inst = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            var root4 = getWorkInProgressRoot();
            if (root4 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root4, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= StoreConsistency;
          var check = {
            getSnapshot,
            value: renderedSnapshot
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.stores = [check];
          } else {
            var stores = componentUpdateQueue.stores;
            if (stores === null) {
              componentUpdateQueue.stores = [check];
            } else {
              stores.push(check);
            }
          }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        }
        function subscribeToStore(fiber, inst, subscribe) {
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          };
          return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error3) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root4 !== null) {
            scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
          }
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create4, destroy, deps) {
          var effect = {
            tag,
            create: create4,
            destroy,
            deps,
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              componentUpdateQueue.lastEffect = effect;
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          {
            var _ref2 = {
              current: initialValue
            };
            hook.memoizedState = _ref2;
            return _ref2;
          }
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create4, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create4, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create4, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create4, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create4, destroy, nextDeps);
        }
        function mountEffect(create4, deps) {
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create4, deps);
          } else {
            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create4, deps);
          }
        }
        function updateEffect(create4, deps) {
          return updateEffectImpl(Passive, Passive$1, create4, deps);
        }
        function mountInsertionEffect(create4, deps) {
          return mountEffectImpl(Update, Insertion, create4, deps);
        }
        function updateInsertionEffect(create4, deps) {
          return updateEffectImpl(Update, Insertion, create4, deps);
        }
        function mountLayoutEffect(create4, deps) {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, create4, deps);
        }
        function updateLayoutEffect(create4, deps) {
          return updateEffectImpl(Update, Layout, create4, deps);
        }
        function imperativeHandleEffect(create4, ref2) {
          if (typeof ref2 === "function") {
            var refCallback = ref2;
            var _inst = create4();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref2 !== null && ref2 !== void 0) {
            var refObject = ref2;
            {
              if (!refObject.hasOwnProperty("current")) {
                error2("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create4();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref2, create4, deps) {
          {
            if (typeof create4 !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create4 !== null ? typeof create4 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create4, ref2), effectDeps);
        }
        function updateImperativeHandle(ref2, create4, deps) {
          {
            if (typeof create4 !== "function") {
              error2("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create4 !== null ? typeof create4 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref2]) : null;
          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create4, ref2), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = value;
          return value;
        }
        function updateDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          var resolvedCurrentHook = currentHook;
          var prevValue = resolvedCurrentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          if (currentHook === null) {
            hook.memoizedState = value;
            return value;
          } else {
            var prevValue = currentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
        }
        function updateDeferredValueImpl(hook, prevValue, value) {
          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
          if (shouldDeferValue) {
            if (!objectIs(value, prevValue)) {
              var deferredLane = claimNextTransitionLane();
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
              markSkippedUpdateLanes(deferredLane);
              hook.baseState = true;
            }
            return prevValue;
          } else {
            if (hook.baseState) {
              hook.baseState = false;
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = value;
            return value;
          }
        }
        function startTransition(setPending, callback, options2) {
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
          setPending(true);
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = {};
          var currentTransition = ReactCurrentBatchConfig$2.transition;
          {
            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            setPending(false);
            callback();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$2.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn2("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        function mountTransition() {
          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
          var start3 = startTransition.bind(null, setPending);
          var hook = mountWorkInProgressHook();
          hook.memoizedState = start3;
          return [isPending, start3];
        }
        function updateTransition() {
          var _updateState = updateState(), isPending = _updateState[0];
          var hook = updateWorkInProgressHook();
          var start3 = hook.memoizedState;
          return [isPending, start3];
        }
        function rerenderTransition() {
          var _rerenderState = rerenderState(), isPending = _rerenderState[0];
          var hook = updateWorkInProgressHook();
          var start3 = hook.memoizedState;
          return [isPending, start3];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function mountId() {
          var hook = mountWorkInProgressHook();
          var root4 = getWorkInProgressRoot();
          var identifierPrefix = root4.identifierPrefix;
          var id;
          if (getIsHydrating()) {
            var treeId = getTreeId();
            id = ":" + identifierPrefix + "R" + treeId;
            var localId = localIdCounter++;
            if (localId > 0) {
              id += "H" + localId.toString(32);
            }
            id += ":";
          } else {
            var globalClientId = globalClientIdCounter++;
            id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
          }
          hook.memoizedState = id;
          return id;
        }
        function updateId() {
          var hook = updateWorkInProgressHook();
          var id = hook.memoizedState;
          return id;
        }
        function dispatchReducerAction(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update2 = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update2);
          } else {
            var root4 = enqueueConcurrentHookUpdate(fiber, queue, update2, lane);
            if (root4 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root4, fiber, lane, eventTime);
              entangleTransitionUpdate(root4, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error2("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update2 = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update2);
          } else {
            var alternate = fiber.alternate;
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update2.hasEagerState = true;
                  update2.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update2, lane);
                    return;
                  }
                } catch (error3) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            var root4 = enqueueConcurrentHookUpdate(fiber, queue, update2, lane);
            if (root4 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root4, fiber, lane, eventTime);
              entangleTransitionUpdate(root4, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update2) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          if (pending === null) {
            update2.next = update2;
          } else {
            update2.next = pending.next;
            pending.next = update2;
          }
          queue.pending = update2;
        }
        function entangleTransitionUpdate(root4, queue, lane) {
          if (isTransitionLane(lane)) {
            var queueLanes = queue.lanes;
            queueLanes = intersectLanes(queueLanes, root4.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            queue.lanes = newQueueLanes;
            markRootEntangled(root4, newQueueLanes);
          }
        }
        function markUpdateInDevTools(fiber, lane, action) {
          {
            markStateUpdateScheduled(fiber, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create4, deps);
            },
            useImperativeHandle: function(ref2, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref2, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer2, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create4, deps);
            },
            useImperativeHandle: function(ref2, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref2, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return mountInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer2, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref2, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref2, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer2, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref2, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref2, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer2, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create4, deps);
            },
            useImperativeHandle: function(ref2, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref2, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer2, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref2, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref2, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer2, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context) {
              warnInvalidContextAccess();
              return readContext(context);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context);
            },
            useEffect: function(create4, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create4, deps);
            },
            useImperativeHandle: function(ref2, create4, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref2, create4, deps);
            },
            useInsertionEffect: function(create4, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create4, deps);
            },
            useLayoutEffect: function(create4, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create4, deps);
            },
            useMemo: function(create4, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create4, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer2, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer2, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
          return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
          {
            nestedUpdateScheduled = true;
          }
        }
        function resetNestedUpdateFlag() {
          {
            currentUpdateIsNested = false;
            nestedUpdateScheduled = false;
          }
        }
        function syncNestedUpdateFlag() {
          {
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
          }
        }
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function recordLayoutEffectDuration(fiber) {
          if (layoutEffectStartTime >= 0) {
            var elapsedTime = now$1() - layoutEffectStartTime;
            layoutEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root4 = parentFiber.stateNode;
                  root4.effectDuration += elapsedTime;
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.effectDuration += elapsedTime;
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function recordPassiveEffectDuration(fiber) {
          if (passiveEffectStartTime >= 0) {
            var elapsedTime = now$1() - passiveEffectStartTime;
            passiveEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root4 = parentFiber.stateNode;
                  if (root4 !== null) {
                    root4.passiveEffectDuration += elapsedTime;
                  }
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  if (parentStateNode !== null) {
                    parentStateNode.passiveEffectDuration += elapsedTime;
                  }
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function startLayoutEffectTimer() {
          layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
          passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        function createCapturedValueAtFiber(value, source) {
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source),
            digest: null
          };
        }
        function createCapturedValue(value, digest, stack) {
          return {
            value,
            source: null,
            stack: stack != null ? stack : null,
            digest: digest != null ? digest : null
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error3 = errorInfo.value;
            if (true) {
              var source = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error3 != null && error3._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error3);
              }
              var componentName = source ? getComponentNameFromFiber(source) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (boundary.tag === HostRoot) {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              } else {
                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error3);
            }
          } catch (e2) {
            setTimeout(function() {
              throw e2;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update2 = createUpdate(NoTimestamp, lane);
          update2.tag = CaptureUpdate;
          update2.payload = {
            element: null
          };
          var error3 = errorInfo.value;
          update2.callback = function() {
            onUncaughtError(error3);
            logCapturedError(fiber, errorInfo);
          };
          return update2;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update2 = createUpdate(NoTimestamp, lane);
          update2.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update2.payload = function() {
              return getDerivedStateFromError(error$1);
            };
            update2.callback = function() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update2.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error2("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                  }
                }
              }
            };
          }
          return update2;
        }
        function attachPingListener(root4, wakeable, lanes) {
          var pingCache = root4.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root4.pingCache = new PossiblyWeakMap$1();
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root4, wakeable, lanes);
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root4, lanes);
              }
            }
            wakeable.then(ping, ping);
          }
        }
        function attachRetryListener(suspenseBoundary, root4, wakeable, lanes) {
          var wakeables = suspenseBoundary.updateQueue;
          if (wakeables === null) {
            var updateQueue = /* @__PURE__ */ new Set();
            updateQueue.add(wakeable);
            suspenseBoundary.updateQueue = updateQueue;
          } else {
            wakeables.add(wakeable);
          }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
          var tag = sourceFiber.tag;
          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
            var currentSource = sourceFiber.alternate;
            if (currentSource) {
              sourceFiber.updateQueue = currentSource.updateQueue;
              sourceFiber.memoizedState = currentSource.memoizedState;
              sourceFiber.lanes = currentSource.lanes;
            } else {
              sourceFiber.updateQueue = null;
              sourceFiber.memoizedState = null;
            }
          }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
          var node2 = returnFiber;
          do {
            if (node2.tag === SuspenseComponent && shouldCaptureSuspense(node2)) {
              return node2;
            }
            node2 = node2.return;
          } while (node2 !== null);
          return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root4, rootRenderLanes) {
          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
            if (suspenseBoundary === returnFiber) {
              suspenseBoundary.flags |= ShouldCapture;
            } else {
              suspenseBoundary.flags |= DidCapture;
              sourceFiber.flags |= ForceUpdateForLegacySuspense;
              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
              if (sourceFiber.tag === ClassComponent) {
                var currentSourceFiber = sourceFiber.alternate;
                if (currentSourceFiber === null) {
                  sourceFiber.tag = IncompleteClassComponent;
                } else {
                  var update2 = createUpdate(NoTimestamp, SyncLane);
                  update2.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update2, SyncLane);
                }
              }
              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
            }
            return suspenseBoundary;
          }
          suspenseBoundary.flags |= ShouldCapture;
          suspenseBoundary.lanes = rootRenderLanes;
          return suspenseBoundary;
        }
        function throwException(root4, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root4, rootRenderLanes);
            }
          }
          if (value !== null && typeof value === "object" && typeof value.then === "function") {
            var wakeable = value;
            resetSuspendedComponent(sourceFiber);
            {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
              }
            }
            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (suspenseBoundary !== null) {
              suspenseBoundary.flags &= ~ForceClientRender;
              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root4, rootRenderLanes);
              if (suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root4, wakeable, rootRenderLanes);
              }
              attachRetryListener(suspenseBoundary, root4, wakeable);
              return;
            } else {
              if (!includesSyncLane(rootRenderLanes)) {
                attachPingListener(root4, wakeable, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return;
              }
              var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
              value = uncaughtSuspenseError;
            }
          } else {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (_suspenseBoundary !== null) {
                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                  _suspenseBoundary.flags |= ForceClientRender;
                }
                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root4, rootRenderLanes);
                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                return;
              }
            }
          }
          value = createCapturedValueAtFiber(value, sourceFiber);
          renderDidError(value);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update2 = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, update2);
                return;
              }
              case ClassComponent:
                var errorInfo = value;
                var ctor = workInProgress2.type;
                var instance2 = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance2 !== null && typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        function getSuspendedCache() {
          {
            return null;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          if (current2 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(Component));
              }
            }
          }
          var render4 = Component.render;
          var ref2 = workInProgress2.ref;
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, render4, nextProps, ref2, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, render4, nextProps, ref2, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          if (current2 === null) {
            var type2 = Component.type;
            if (isSimpleFunctionComponent(type2) && Component.compare === null && Component.defaultProps === void 0) {
              var resolvedType = type2;
              {
                resolvedType = resolveFunctionForHotReloading(type2);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type2);
              }
              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
            }
            {
              var innerPropTypes = type2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(type2));
              }
            }
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(_innerPropTypes, nextProps, "prop", getComponentNameFromType(_type));
            }
          }
          var currentChild = current2.child;
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
          if (!hasScheduledUpdateOrContext) {
            var prevProps = currentChild.memoizedProps;
            var compare = Component.compare;
            compare = compare !== null ? compare : shallowEqual2;
            if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  outerMemoType = init2(payload);
                } catch (x) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(outerPropTypes, nextProps, "prop", getComponentNameFromType(outerMemoType));
                }
              }
            }
          }
          if (current2 !== null) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual2(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
              didReceiveUpdate = false;
              workInProgress2.pendingProps = nextProps = prevProps;
              if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                workInProgress2.lanes = current2.lanes;
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current2 !== null ? current2.memoizedState : null;
          if (nextProps.mode === "hidden" || enableLegacyHidden) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var spawnedCachePool = null;
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes,
                cachePool: spawnedCachePool,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState;
              workInProgress2.updateQueue = null;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateFragment(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current2, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current2, workInProgress2) {
          var ref2 = workInProgress2.ref;
          if (current2 === null && ref2 !== null || current2 !== null && current2.ref !== ref2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(Component));
              }
            }
          }
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            switch (shouldError(workInProgress2)) {
              case false: {
                var _instance = workInProgress2.stateNode;
                var ctor = workInProgress2.type;
                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                var state = tempInstance.state;
                _instance.updater.enqueueSetState(_instance, state, null);
                break;
              }
              case true: {
                workInProgress2.flags |= DidCapture;
                workInProgress2.flags |= ShouldCapture;
                var error$1 = new Error("Simulated error coming from DevTools");
                var lane = pickArbitraryLane(renderLanes2);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update2 = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                enqueueCapturedUpdate(workInProgress2, update2);
                break;
              }
            }
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(Component));
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance2 = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance2 === null) {
            resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current2 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error2("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
          markRef(current2, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, false);
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          var instance2 = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              setIsRendering(true);
              nextChildren = instance2.render();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance2.render();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current2 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance2.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root4 = workInProgress2.stateNode;
          if (root4.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root4.pendingContext, root4.pendingContext !== root4.context);
          } else if (root4.context) {
            pushTopLevelContextObject(workInProgress2, root4.context, false);
          }
          pushHostContainer(workInProgress2, root4.containerInfo);
        }
        function updateHostRoot(current2, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          if (current2 === null) {
            throw new Error("Should have a current fiber. This is a bug in React.");
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState.element;
          cloneUpdateQueue(current2, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var root4 = workInProgress2.stateNode;
          var nextChildren = nextState.element;
          if (prevState.isDehydrated) {
            var overrideState = {
              element: nextChildren,
              isDehydrated: false,
              cache: nextState.cache,
              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
              transitions: nextState.transitions
            };
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = overrideState;
            workInProgress2.memoizedState = overrideState;
            if (workInProgress2.flags & ForceClientRender) {
              var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
            } else if (nextChildren !== prevChildren) {
              var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
            } else {
              enterHydrationState(workInProgress2);
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node2 = child;
              while (node2) {
                node2.flags = node2.flags & ~Placement | Hydrating;
                node2 = node2.sibling;
              }
            }
          } else {
            resetHydrationState();
            if (nextChildren === prevChildren) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
          resetHydrationState();
          queueHydrationError(recoverableError);
          workInProgress2.flags |= ForceClientRender;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostComponent(current2, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type2 = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current2 !== null ? current2.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type2, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type2, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current2, workInProgress2);
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current2, workInProgress2) {
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init2 = lazyComponent._init;
          var Component = init2(payload);
          workInProgress2.type = Component;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
          var resolvedProps = resolveDefaultProps(Component, props);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component);
                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
              }
              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component = resolveClassForHotReloading(Component);
              }
              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef: {
              {
                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
              }
              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, resolvedProps, "prop", getComponentNameFromType(Component));
                  }
                }
              }
              child = updateMemoComponent(null, workInProgress2, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes2);
              return child;
            }
          }
          var hint = "";
          {
            if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props = workInProgress2.pendingProps;
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value;
          var hasId;
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
            hasId = checkDidRenderIdHook();
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            {
              var _componentName2 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
            initializeUpdateQueue(workInProgress2);
            adoptClassInstance(workInProgress2, value);
            mountClassInstance(workInProgress2, Component, props, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            reconcileChildren(null, workInProgress2, value, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error2("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error2("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error2("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error2("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2,
            cachePool: getSuspendedCache(),
            transitions: null
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          var cachePool = null;
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
            cachePool,
            transitions: prevOffscreenState.transitions
          };
        }
        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            var suspenseState = current2.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
          return removeLanes(current2.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current2 === null || current2.memoizedState !== null) {
              {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null) {
              var dehydrated = suspenseState.dehydrated;
              if (dehydrated !== null) {
                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
              }
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
            }
          } else {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var _dehydrated = prevState.dehydrated;
              if (_dehydrated !== null) {
                return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
              }
            }
            if (showFallback) {
              var _nextFallbackChildren = nextProps.fallback;
              var _nextPrimaryChildren = nextProps.children;
              var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
              var _primaryChildFragment2 = workInProgress2.child;
              var prevOffscreenState = current2.child.memoizedState;
              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
              workInProgress2.memoizedState = null;
              return _primaryChildFragment3;
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
          return createWorkInProgress(current2, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            var deletions = workInProgress2.deletions;
            if (deletions === null) {
              workInProgress2.deletions = [currentFallbackChildFragment];
              workInProgress2.flags |= ChildDeletion;
            } else {
              deletions.push(currentFallbackChildFragment);
            }
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if ((mode & ConcurrentMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            workInProgress2.deletions = null;
          } else {
            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
          if (recoverableError !== null) {
            queueHydrationError(recoverableError);
          }
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          var nextProps = workInProgress2.pendingProps;
          var primaryChildren = nextProps.children;
          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          primaryChildFragment.flags |= Placement;
          workInProgress2.memoizedState = null;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var fiberMode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          }
          return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            {
              error2("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
            }
            workInProgress2.lanes = laneToLanes(SyncLane);
          } else if (isSuspenseInstanceFallback(suspenseInstance)) {
            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
          } else {
            workInProgress2.lanes = laneToLanes(OffscreenLane);
          }
          return null;
        }
        function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
          if (!didSuspend) {
            warnIfHydrating();
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, null);
            }
            if (isSuspenseInstanceFallback(suspenseInstance)) {
              var digest, message, stack;
              {
                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                digest = _getSuspenseInstanceF.digest;
                message = _getSuspenseInstanceF.message;
                stack = _getSuspenseInstanceF.stack;
              }
              var error3;
              if (message) {
                error3 = new Error(message);
              } else {
                error3 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
              }
              var capturedValue = createCapturedValue(error3, digest, stack);
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
            }
            var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
            if (didReceiveUpdate || hasContextChanged2) {
              var root4 = getWorkInProgressRoot();
              if (root4 !== null) {
                var attemptHydrationAtLane = getBumpedLaneForHydration(root4, renderLanes2);
                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                  suspenseState.retryLane = attemptHydrationAtLane;
                  var eventTime = NoTimestamp;
                  enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                  scheduleUpdateOnFiber(root4, current2, attemptHydrationAtLane, eventTime);
                }
              }
              renderDidSuspendDelayIfPossible();
              var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
            } else if (isSuspenseInstancePending(suspenseInstance)) {
              workInProgress2.flags |= DidCapture;
              workInProgress2.child = current2.child;
              var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
              registerSuspenseInstanceRetry(suspenseInstance, retry);
              return null;
            } else {
              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
              var primaryChildren = nextProps.children;
              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
              primaryChildFragment.flags |= Hydrating;
              return primaryChildFragment;
            }
          } else {
            if (workInProgress2.flags & ForceClientRender) {
              workInProgress2.flags &= ~ForceClientRender;
              var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
            } else if (workInProgress2.memoizedState !== null) {
              workInProgress2.child = current2.child;
              workInProgress2.flags |= DidCapture;
              return null;
            } else {
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment4 = workInProgress2.child;
              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            }
          }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node2 = firstChild;
          while (node2 !== null) {
            if (node2.tag === SuspenseComponent) {
              var state = node2.memoizedState;
              if (state !== null) {
                scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
              }
            } else if (node2.tag === SuspenseListComponent) {
              scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
            } else if (node2.child !== null) {
              node2.child.return = node2;
              node2 = node2.child;
              continue;
            }
            if (node2 === workInProgress2) {
              return;
            }
            while (node2.sibling === null) {
              if (node2.return === null || node2.return === workInProgress2) {
                return;
              }
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error2('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error2('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error2('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error2('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index3) {
          {
            var isAnArray = isArray2(childSlot);
            var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
            if (isAnArray || isIterable) {
              var type2 = isAnArray ? "array" : "iterable";
              error2("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type2, index3, type2);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (isArray2(children)) {
                for (var i = 0; i < children.length; i++) {
                  if (!validateSuspenseListNestedChild(children[i], i)) {
                    return;
                  }
                }
              } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === "function") {
                  var childrenIterator = iteratorFn.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i)) {
                        return;
                      }
                      _i++;
                    }
                  }
                } else {
                  error2('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
          }
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail;
                if (lastContentRow === null) {
                  tail = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(workInProgress2, false, tail, lastContentRow, tailMode);
                break;
              }
              case "backwards": {
                var _tail = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail;
                  _tail = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(workInProgress2, true, _tail, null, tailMode);
                break;
              }
              case "together": {
                initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current2, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current2 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current2, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error2("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, context, newValue);
          {
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              if (objectIs(oldValue, newValue)) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context, renderLanes2);
              }
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current2, workInProgress2, renderLanes2) {
          var context = workInProgress2.type;
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render4 = newProps.children;
          {
            if (typeof render4 !== "function") {
              error2("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context);
          {
            markComponentRenderStarted(workInProgress2);
          }
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render4(newValue);
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            if (current2 !== null) {
              current2.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
          }
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            workInProgress2.dependencies = current2.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            {
              return null;
            }
          }
          cloneChildFibers(current2, workInProgress2);
          return workInProgress2.child;
        }
        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current2.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [current2];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(current2);
            }
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function checkScheduledUpdateOrContext(current2, renderLanes2) {
          var updateLanes = current2.lanes;
          if (includesSomeLane(updateLanes, renderLanes2)) {
            return true;
          }
          return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress2);
              var root4 = workInProgress2.stateNode;
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress2);
              break;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                pushContextProvider(workInProgress2);
              }
              break;
            }
            case HostPortal:
              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
              break;
            case ContextProvider: {
              var newValue = workInProgress2.memoizedProps.value;
              var context = workInProgress2.type._context;
              pushProvider(workInProgress2, context, newValue);
              break;
            }
            case Profiler:
              {
                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (hasChildWork) {
                  workInProgress2.flags |= Update;
                }
                {
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0;
                  stateNode.passiveEffectDuration = 0;
                }
              }
              break;
            case SuspenseComponent: {
              var state = workInProgress2.memoizedState;
              if (state !== null) {
                if (state.dehydrated !== null) {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  workInProgress2.flags |= DidCapture;
                  return null;
                }
                var primaryChildFragment = workInProgress2.child;
                var primaryChildLanes = primaryChildFragment.childLanes;
                if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                  return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  if (child !== null) {
                    return child.sibling;
                  } else {
                    return null;
                  }
                }
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              }
              break;
            }
            case SuspenseListComponent: {
              var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (didSuspendBefore) {
                if (_hasChildWork) {
                  return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                }
                workInProgress2.flags |= DidCapture;
              }
              var renderState = workInProgress2.memoizedState;
              if (renderState !== null) {
                renderState.rendering = null;
                renderState.tail = null;
                renderState.lastEffect = null;
              }
              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
              if (_hasChildWork) {
                break;
              } else {
                return null;
              }
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              workInProgress2.lanes = NoLanes;
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          {
            if (workInProgress2._debugNeedsRemount && current2 !== null) {
              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current2 !== null) {
            var oldProps = current2.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
              didReceiveUpdate = true;
            } else {
              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
              if (!hasScheduledUpdateOrContext && (workInProgress2.flags & DidCapture) === NoFlags) {
                didReceiveUpdate = false;
                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
              }
              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
            if (getIsHydrating() && isForkedChild(workInProgress2)) {
              var slotIndex = workInProgress2.index;
              var numberOfForks = getForksAtLevel();
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
            }
            case FunctionComponent: {
              var Component = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
              return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
              return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current2, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current2, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current2, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current2, workInProgress2, renderLanes2);
            case ForwardRef: {
              var type2 = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type2 ? _unresolvedProps2 : resolveDefaultProps(type2, _unresolvedProps2);
              return updateForwardRef(current2, workInProgress2, type2, _resolvedProps2, renderLanes2);
            }
            case Fragment65:
              return updateFragment(current2, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current2, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current2, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current2, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current2, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, _resolvedProps3, "prop", getComponentNameFromType(_type2));
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
              return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
            var node2 = workInProgress2.child;
            while (node2 !== null) {
              if (node2.tag === HostComponent || node2.tag === HostText) {
                appendInitialChild(parent, node2.stateNode);
              } else if (node2.tag === HostPortal)
                ;
              else if (node2.child !== null) {
                node2.child.return = node2;
                node2 = node2.child;
                continue;
              }
              if (node2 === workInProgress2) {
                return;
              }
              while (node2.sibling === null) {
                if (node2.return === null || node2.return === workInProgress2) {
                  return;
                }
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
          };
          updateHostContainer = function(current2, workInProgress2) {
          };
          updateHostComponent$1 = function(current2, workInProgress2, type2, newProps, rootContainerInstance) {
            var oldProps = current2.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance2 = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance2, type2, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function bubbleProperties(completedWork) {
          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
          var newChildLanes = NoLanes;
          var subtreeFlags = NoFlags;
          if (!didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                subtreeFlags |= child.subtreeFlags;
                subtreeFlags |= child.flags;
                actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                subtreeFlags |= _child.subtreeFlags;
                subtreeFlags |= _child.flags;
                _child.return = completedWork;
                _child = _child.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          } else {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var _treeBaseDuration = completedWork.selfBaseDuration;
              var _child2 = completedWork.child;
              while (_child2 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                subtreeFlags |= _child2.flags & StaticMask;
                _treeBaseDuration += _child2.treeBaseDuration;
                _child2 = _child2.sibling;
              }
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else {
              var _child3 = completedWork.child;
              while (_child3 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                subtreeFlags |= _child3.flags & StaticMask;
                _child3.return = completedWork;
                _child3 = _child3.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          }
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
            warnIfUnhydratedTailNodes(workInProgress2);
            resetHydrationState();
            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
            return false;
          }
          var wasHydrated = popHydrationState(workInProgress2);
          if (nextState !== null && nextState.dehydrated !== null) {
            if (current2 === null) {
              if (!wasHydrated) {
                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              }
              prepareToHydrateHostSuspenseInstance(workInProgress2);
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var isTimedOutSuspense = nextState !== null;
                  if (isTimedOutSuspense) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            } else {
              resetHydrationState();
              if ((workInProgress2.flags & DidCapture) === NoFlags) {
                workInProgress2.memoizedState = null;
              }
              workInProgress2.flags |= Update;
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var _isTimedOutSuspense = nextState !== null;
                  if (_isTimedOutSuspense) {
                    var _primaryChildFragment = workInProgress2.child;
                    if (_primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            }
          } else {
            upgradeHydrationErrorsToRecoverable();
            return true;
          }
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment65:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              bubbleProperties(workInProgress2);
              return null;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostRoot: {
              var fiberRoot = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current2 === null || current2.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else {
                  if (current2 !== null) {
                    var prevState = current2.memoizedState;
                    if (!prevState.isDehydrated || (workInProgress2.flags & ForceClientRender) !== NoFlags) {
                      workInProgress2.flags |= Snapshot;
                      upgradeHydrationErrorsToRecoverable();
                    }
                  }
                }
              }
              updateHostContainer(current2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type2 = workInProgress2.type;
              if (current2 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current2, workInProgress2, type2, newProps, rootContainerInstance);
                if (current2.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance2 = createInstance3(type2, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance2, workInProgress2, false, false);
                  workInProgress2.stateNode = instance2;
                  if (finalizeInitialChildren(instance2, type2, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current2 && workInProgress2.stateNode != null) {
                var oldText = current2.memoizedProps;
                updateHostText$1(current2, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                if (!fallthroughToNormalSuspensePath) {
                  if (workInProgress2.flags & ShouldCapture) {
                    return workInProgress2;
                  } else {
                    return null;
                  }
                }
              }
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
              if (nextDidTimeout !== prevDidTimeout) {
                if (nextDidTimeout) {
                  var _offscreenFiber2 = workInProgress2.child;
                  _offscreenFiber2.flags |= Visibility;
                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                    var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
              }
              var wakeables = workInProgress2.updateQueue;
              if (wakeables !== null) {
                workInProgress2.flags |= Update;
              }
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  if (nextDidTimeout) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(current2, workInProgress2);
              if (current2 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              bubbleProperties(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                bubbleProperties(workInProgress2);
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThenables = suspended.updateQueue;
                        if (newThenables !== null) {
                          workInProgress2.updateQueue = newThenables;
                          workInProgress2.flags |= Update;
                        }
                        workInProgress2.subtreeFlags = NoFlags;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now2() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThenables = _suspended.updateQueue;
                    if (_newThenables !== null) {
                      workInProgress2.updateQueue = _newThenables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                  } else if (now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next = renderState.tail;
                renderState.rendering = next;
                renderState.tail = next.sibling;
                renderState.renderingStartTime = now2();
                next.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next;
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              var _nextState = workInProgress2.memoizedState;
              var nextIsHidden = _nextState !== null;
              if (current2 !== null) {
                var _prevState = current2.memoizedState;
                var prevIsHidden = _prevState !== null;
                if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {
                  workInProgress2.flags |= Visibility;
                }
              }
              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                bubbleProperties(workInProgress2);
              } else {
                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                  bubbleProperties(workInProgress2);
                  {
                    if (workInProgress2.subtreeFlags & (Placement | Update)) {
                      workInProgress2.flags |= Visibility;
                    }
                  }
                }
              }
              return null;
            }
            case CacheComponent: {
              return null;
            }
            case TracingMarkerComponent: {
              return null;
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function unwindWork(current2, workInProgress2, renderLanes2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              var root4 = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null && suspenseState.dehydrated !== null) {
                if (workInProgress2.alternate === null) {
                  throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                }
                resetHydrationState();
              }
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              var context = workInProgress2.type._context;
              popProvider(context, workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            case CacheComponent:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              var root4 = interruptedWork.stateNode;
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              var context = interruptedWork.type._context;
              popProvider(context, interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error3) {
          {
            invokeGuardedCallback(null, function() {
              throw error3;
            });
            clearCaughtError();
          }
        }
        var callComponentWillUnmountWithTimer = function(current2, instance2) {
          instance2.props = current2.memoizedProps;
          instance2.state = current2.memoizedState;
          if (current2.mode & ProfileMode) {
            try {
              startLayoutEffectTimer();
              instance2.componentWillUnmount();
            } finally {
              recordLayoutEffectDuration(current2);
            }
          } else {
            instance2.componentWillUnmount();
          }
        };
        function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
          try {
            commitHookEffectListMount(Layout, current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance2) {
          try {
            callComponentWillUnmountWithTimer(current2, instance2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance2) {
          try {
            instance2.componentDidMount();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyAttachRef(current2, nearestMountedAncestor) {
          try {
            commitAttachRef(current2);
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        function safelyDetachRef(current2, nearestMountedAncestor) {
          var ref2 = current2.ref;
          if (ref2 !== null) {
            if (typeof ref2 === "function") {
              var retVal;
              try {
                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref2(null);
                  } finally {
                    recordLayoutEffectDuration(current2);
                  }
                } else {
                  retVal = ref2(null);
                }
              } catch (error3) {
                captureCommitPhaseError(current2, nearestMountedAncestor, error3);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                }
              }
            } else {
              ref2.current = null;
            }
          }
        }
        function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error3) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error3);
          }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root4, firstChild) {
          focusedInstanceHandle = prepareForCommit(root4.containerInfo);
          nextEffect = firstChild;
          commitBeforeMutationEffects_begin();
          var shouldFire = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          focusedInstanceHandle = null;
          return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitBeforeMutationEffects_complete();
            }
          }
        }
        function commitBeforeMutationEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              commitBeforeMutationEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          if ((flags & Snapshot) !== NoFlags) {
            setCurrentFiber(finishedWork);
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                break;
              }
              case ClassComponent: {
                if (current2 !== null) {
                  var prevProps = current2.memoizedProps;
                  var prevState = current2.memoizedState;
                  var instance2 = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance2.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance2.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  var snapshot = instance2.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error2("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                    }
                  }
                  instance2.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              }
              case HostRoot: {
                {
                  var root4 = finishedWork.stateNode;
                  clearContainer(root4.containerInfo);
                }
                break;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                break;
              default: {
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            resetCurrentFiber();
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                var destroy = effect.destroy;
                effect.destroy = void 0;
                if (destroy !== void 0) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStarted(finishedWork);
                    }
                  }
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStopped();
                    }
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStarted(finishedWork);
                  }
                }
                var create4 = effect.create;
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                effect.destroy = create4();
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStopped();
                  }
                }
                {
                  var destroy = effect.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var hookName = void 0;
                    if ((effect.tag & Layout) !== NoFlags) {
                      hookName = "useLayoutEffect";
                    } else if ((effect.tag & Insertion) !== NoFlags) {
                      hookName = "useInsertionEffect";
                    } else {
                      hookName = "useEffect";
                    }
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error2("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
          {
            if ((finishedWork.flags & Update) !== NoFlags) {
              switch (finishedWork.tag) {
                case Profiler: {
                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                  var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                  var commitTime2 = getCommitTime();
                  var phase = finishedWork.alternate === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onPostCommit === "function") {
                    onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                  }
                  var parentFiber = finishedWork.return;
                  outer:
                    while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root4 = parentFiber.stateNode;
                          root4.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                  break;
                }
              }
            }
          }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
          if ((finishedWork.flags & LayoutMask) !== NoFlags) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  } else {
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  }
                }
                break;
              }
              case ClassComponent: {
                var instance2 = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (!offscreenSubtreeWasHidden) {
                    if (current2 === null) {
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance2.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance2.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance2.componentDidMount();
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance2.componentDidMount();
                      }
                    } else {
                      var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                      var prevState = current2.memoizedState;
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance2.props !== finishedWork.memoizedProps) {
                            error2("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance2.state !== finishedWork.memoizedState) {
                            error2("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance2.componentDidUpdate(prevProps, prevState, instance2.__reactInternalSnapshotBeforeUpdate);
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance2.componentDidUpdate(prevProps, prevState, instance2.__reactInternalSnapshotBeforeUpdate);
                      }
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance2.props !== finishedWork.memoizedProps) {
                        error2("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance2.state !== finishedWork.memoizedState) {
                        error2("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance2);
                }
                break;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                break;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current2 === null && finishedWork.flags & Update) {
                  var type2 = finishedWork.type;
                  var props = finishedWork.memoizedProps;
                  commitMount(_instance2, type2, props);
                }
                break;
              }
              case HostText: {
                break;
              }
              case HostPortal: {
                break;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  var phase = current2 === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onRender === "function") {
                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                  }
                  {
                    if (typeof onCommit === "function") {
                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                    }
                    enqueuePendingPassiveProfilerEffect(finishedWork);
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root4 = parentFiber.stateNode;
                            root4.effectDuration += effectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += effectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                  }
                }
                break;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
              case TracingMarkerComponent: {
                break;
              }
              default:
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (!offscreenSubtreeWasHidden) {
            {
              if (finishedWork.flags & Ref) {
                commitAttachRef(finishedWork);
              }
            }
          }
        }
        function reappearLayoutEffectsOnFiber(node2) {
          switch (node2.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (node2.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
                } finally {
                  recordLayoutEffectDuration(node2);
                }
              } else {
                safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
              }
              break;
            }
            case ClassComponent: {
              var instance2 = node2.stateNode;
              if (typeof instance2.componentDidMount === "function") {
                safelyCallComponentDidMount(node2, node2.return, instance2);
              }
              safelyAttachRef(node2, node2.return);
              break;
            }
            case HostComponent: {
              safelyAttachRef(node2, node2.return);
              break;
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden) {
          var hostSubtreeRoot = null;
          {
            var node2 = finishedWork;
            while (true) {
              if (node2.tag === HostComponent) {
                if (hostSubtreeRoot === null) {
                  hostSubtreeRoot = node2;
                  try {
                    var instance2 = node2.stateNode;
                    if (isHidden) {
                      hideInstance(instance2);
                    } else {
                      unhideInstance(node2.stateNode, node2.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if (node2.tag === HostText) {
                if (hostSubtreeRoot === null) {
                  try {
                    var _instance3 = node2.stateNode;
                    if (isHidden) {
                      hideTextInstance(_instance3);
                    } else {
                      unhideTextInstance(_instance3, node2.memoizedProps);
                    }
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              } else if ((node2.tag === OffscreenComponent || node2.tag === LegacyHiddenComponent) && node2.memoizedState !== null && node2 !== finishedWork)
                ;
              else if (node2.child !== null) {
                node2.child.return = node2;
                node2 = node2.child;
                continue;
              }
              if (node2 === finishedWork) {
                return;
              }
              while (node2.sibling === null) {
                if (node2.return === null || node2.return === finishedWork) {
                  return;
                }
                if (hostSubtreeRoot === node2) {
                  hostSubtreeRoot = null;
                }
                node2 = node2.return;
              }
              if (hostSubtreeRoot === node2) {
                hostSubtreeRoot = null;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref2 = finishedWork.ref;
          if (ref2 !== null) {
            var instance2 = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance2);
                break;
              default:
                instanceToUse = instance2;
            }
            if (typeof ref2 === "function") {
              var retVal;
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref2(instanceToUse);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              } else {
                retVal = ref2(instanceToUse);
              }
              {
                if (typeof retVal === "function") {
                  error2("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                }
              }
            } else {
              {
                if (!ref2.hasOwnProperty("current")) {
                  error2("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                }
              }
              ref2.current = instanceToUse;
            }
          }
        }
        function detachFiberMutation(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.return = null;
          }
          fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            fiber.alternate = null;
            detachFiberAfterEffects(alternate);
          }
          {
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            if (fiber.tag === HostComponent) {
              var hostInstance = fiber.stateNode;
              if (hostInstance !== null) {
                detachDeletedInstance(hostInstance);
              }
            }
            fiber.stateNode = null;
            {
              fiber._debugOwner = null;
            }
            {
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
          }
        }
        function getHostParentFiber(fiber) {
          var parent = fiber.return;
          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }
            parent = parent.return;
          }
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node2 = fiber;
          siblings:
            while (true) {
              while (node2.sibling === null) {
                if (node2.return === null || isHostParent(node2.return)) {
                  return null;
                }
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
              while (node2.tag !== HostComponent && node2.tag !== HostText && node2.tag !== DehydratedFragment) {
                if (node2.flags & Placement) {
                  continue siblings;
                }
                if (node2.child === null || node2.tag === HostPortal) {
                  continue siblings;
                } else {
                  node2.child.return = node2;
                  node2 = node2.child;
                }
              }
              if (!(node2.flags & Placement)) {
                return node2.stateNode;
              }
            }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent = parentFiber.stateNode;
              if (parentFiber.flags & ContentReset) {
                resetTextContent(parent);
                parentFiber.flags &= ~ContentReset;
              }
              var before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo;
              var _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
          var tag = node2.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node2.stateNode;
            if (before) {
              insertInContainerBefore(parent, stateNode, before);
            } else {
              appendChildToContainer(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node2.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node2, before, parent) {
          var tag = node2.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node2.stateNode;
            if (before) {
              insertBefore(parent, stateNode, before);
            } else {
              appendChild(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node2.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root4, returnFiber, deletedFiber) {
          {
            var parent = returnFiber;
            findParent:
              while (parent !== null) {
                switch (parent.tag) {
                  case HostComponent: {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break findParent;
                  }
                  case HostRoot: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                  case HostPortal: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                }
                parent = parent.return;
              }
            if (hostParent === null) {
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            commitDeletionEffectsOnFiber(root4, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          }
          detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          var child = parent.child;
          while (child !== null) {
            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
            child = child.sibling;
          }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          onCommitUnmount(deletedFiber);
          switch (deletedFiber.tag) {
            case HostComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              }
            }
            case HostText: {
              {
                var prevHostParent = hostParent;
                var prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    removeChild(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case DehydratedFragment: {
              {
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case HostPortal: {
              {
                var _prevHostParent = hostParent;
                var _prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = _prevHostParent;
                hostParentIsContainer = _prevHostParentIsContainer;
              }
              return;
            }
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                var updateQueue = deletedFiber.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                      if (destroy !== void 0) {
                        if ((tag & Insertion) !== NoFlags$1) {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        } else if ((tag & Layout) !== NoFlags$1) {
                          {
                            markComponentLayoutEffectUnmountStarted(deletedFiber);
                          }
                          if (deletedFiber.mode & ProfileMode) {
                            startLayoutEffectTimer();
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            recordLayoutEffectDuration(deletedFiber);
                          } else {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          }
                          {
                            markComponentLayoutEffectUnmountStopped();
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ClassComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var instance2 = deletedFiber.stateNode;
                if (typeof instance2.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance2);
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ScopeComponent: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case OffscreenComponent: {
              if (deletedFiber.mode & ConcurrentMode) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              }
              break;
            }
            default: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
          }
        }
        function commitSuspenseCallback(finishedWork) {
          var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current2 = finishedWork.alternate;
            if (current2 !== null) {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                {
                  if (isDevToolsPresent) {
                    if (inProgressLanes !== null && inProgressRoot !== null) {
                      restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    } else {
                      throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                    }
                  }
                }
                wakeable.then(retry, retry);
              }
            });
          }
        }
        function commitMutationEffects(root4, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root4;
          setCurrentFiber(finishedWork);
          commitMutationEffectsOnFiber(finishedWork, root4);
          setCurrentFiber(finishedWork);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root4, parentFiber, lanes) {
          var deletions = parentFiber.deletions;
          if (deletions !== null) {
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              try {
                commitDeletionEffects(root4, parentFiber, childToDelete);
              } catch (error3) {
                captureCommitPhaseError(childToDelete, parentFiber, error3);
              }
            }
          }
          var prevDebugFiber = getCurrentFiber();
          if (parentFiber.subtreeFlags & MutationMask) {
            var child = parentFiber.child;
            while (child !== null) {
              setCurrentFiber(child);
              commitMutationEffectsOnFiber(child, root4);
              child = child.sibling;
            }
          }
          setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root4, lanes) {
          var current2 = finishedWork.alternate;
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                try {
                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                  recordLayoutEffectDuration(finishedWork);
                } else {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case ClassComponent: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              return;
            }
            case HostComponent: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref) {
                if (current2 !== null) {
                  safelyDetachRef(current2, current2.return);
                }
              }
              {
                if (finishedWork.flags & ContentReset) {
                  var instance2 = finishedWork.stateNode;
                  try {
                    resetTextContent(instance2);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
                if (flags & Update) {
                  var _instance4 = finishedWork.stateNode;
                  if (_instance4 != null) {
                    var newProps = finishedWork.memoizedProps;
                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                    var type2 = finishedWork.type;
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) {
                      try {
                        commitUpdate(_instance4, updatePayload, type2, oldProps, newProps, finishedWork);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostText: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (finishedWork.stateNode === null) {
                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  var textInstance = finishedWork.stateNode;
                  var newText = finishedWork.memoizedProps;
                  var oldText = current2 !== null ? current2.memoizedProps : newText;
                  try {
                    commitTextUpdate(textInstance, oldText, newText);
                  } catch (error3) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                  }
                }
              }
              return;
            }
            case HostRoot: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (current2 !== null) {
                    var prevRootState = current2.memoizedState;
                    if (prevRootState.isDehydrated) {
                      try {
                        commitHydratedContainer(root4.containerInfo);
                      } catch (error3) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostPortal: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
            case SuspenseComponent: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              var offscreenFiber = finishedWork.child;
              if (offscreenFiber.flags & Visibility) {
                var offscreenInstance = offscreenFiber.stateNode;
                var newState = offscreenFiber.memoizedState;
                var isHidden = newState !== null;
                offscreenInstance.isHidden = isHidden;
                if (isHidden) {
                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                  if (!wasHidden) {
                    markCommitTimeOfFallback();
                  }
                }
              }
              if (flags & Update) {
                try {
                  commitSuspenseCallback(finishedWork);
                } catch (error3) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error3);
                }
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case OffscreenComponent: {
              var _wasHidden = current2 !== null && current2.memoizedState !== null;
              if (finishedWork.mode & ConcurrentMode) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                recursivelyTraverseMutationEffects(root4, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseMutationEffects(root4, finishedWork);
              }
              commitReconciliationEffects(finishedWork);
              if (flags & Visibility) {
                var _offscreenInstance = finishedWork.stateNode;
                var _newState = finishedWork.memoizedState;
                var _isHidden = _newState !== null;
                var offscreenBoundary = finishedWork;
                _offscreenInstance.isHidden = _isHidden;
                {
                  if (_isHidden) {
                    if (!_wasHidden) {
                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                        nextEffect = offscreenBoundary;
                        var offscreenChild = offscreenBoundary.child;
                        while (offscreenChild !== null) {
                          nextEffect = offscreenChild;
                          disappearLayoutEffects_begin(offscreenChild);
                          offscreenChild = offscreenChild.sibling;
                        }
                      }
                    }
                  }
                }
                {
                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                }
              }
              return;
            }
            case SuspenseListComponent: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case ScopeComponent: {
              return;
            }
            default: {
              recursivelyTraverseMutationEffects(root4, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & Placement) {
            try {
              commitPlacement(finishedWork);
            } catch (error3) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error3);
            }
            finishedWork.flags &= ~Placement;
          }
          if (flags & Hydrating) {
            finishedWork.flags &= ~Hydrating;
          }
        }
        function commitLayoutEffects(finishedWork, root4, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root4;
          nextEffect = finishedWork;
          commitLayoutEffects_begin(finishedWork, root4, committedLanes);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root4, committedLanes) {
          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent && isModernRoot) {
              var isHidden = fiber.memoizedState !== null;
              var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
              if (newOffscreenSubtreeIsHidden) {
                commitLayoutMountEffects_complete(subtreeRoot, root4, committedLanes);
                continue;
              } else {
                var current2 = fiber.alternate;
                var wasHidden = current2 !== null && current2.memoizedState !== null;
                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                  nextEffect = fiber;
                  reappearLayoutEffects_begin(fiber);
                }
                var child = firstChild;
                while (child !== null) {
                  nextEffect = child;
                  commitLayoutEffects_begin(child, root4, committedLanes);
                  child = child.sibling;
                }
                nextEffect = fiber;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                commitLayoutMountEffects_complete(subtreeRoot, root4, committedLanes);
                continue;
              }
            }
            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitLayoutMountEffects_complete(subtreeRoot, root4, committedLanes);
            }
          }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root4, committedLanes) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & LayoutMask) !== NoFlags) {
              var current2 = fiber.alternate;
              setCurrentFiber(fiber);
              try {
                commitLayoutEffectOnFiber(root4, current2, fiber, committedLanes);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (fiber.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  } finally {
                    recordLayoutEffectDuration(fiber);
                  }
                } else {
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                }
                break;
              }
              case ClassComponent: {
                safelyDetachRef(fiber, fiber.return);
                var instance2 = fiber.stateNode;
                if (typeof instance2.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance2);
                }
                break;
              }
              case HostComponent: {
                safelyDetachRef(fiber, fiber.return);
                break;
              }
              case OffscreenComponent: {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  disappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
                break;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              disappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent) {
              var isHidden = fiber.memoizedState !== null;
              if (isHidden) {
                reappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              reappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              reappearLayoutEffectsOnFiber(fiber);
            } catch (error3) {
              captureCommitPhaseError(fiber, fiber.return, error3);
            }
            resetCurrentFiber();
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountEffects(root4, finishedWork, committedLanes, committedTransitions) {
          nextEffect = finishedWork;
          commitPassiveMountEffects_begin(finishedWork, root4, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root4, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitPassiveMountEffects_complete(subtreeRoot, root4, committedLanes, committedTransitions);
            }
          }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root4, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              try {
                commitPassiveMountOnFiber(root4, fiber, committedLanes, committedTransitions);
              } catch (error3) {
                captureCommitPhaseError(fiber, fiber.return, error3);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                } finally {
                  recordPassiveEffectDuration(finishedWork);
                }
              } else {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffects(firstChild) {
          nextEffect = firstChild;
          commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
              var deletions = fiber.deletions;
              if (deletions !== null) {
                for (var i = 0; i < deletions.length; i++) {
                  var fiberToDelete = deletions[i];
                  nextEffect = fiberToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                }
                {
                  var previousFiber = fiber.alternate;
                  if (previousFiber !== null) {
                    var detachedChild = previousFiber.child;
                    if (detachedChild !== null) {
                      previousFiber.child = null;
                      do {
                        var detachedSibling = detachedChild.sibling;
                        detachedChild.sibling = null;
                        detachedChild = detachedSibling;
                      } while (detachedChild !== null);
                    }
                  }
                }
                nextEffect = fiber;
              }
            }
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffects_complete();
            }
          }
        }
        function commitPassiveUnmountEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              commitPassiveUnmountOnFiber(fiber);
              resetCurrentFiber();
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                recordPassiveEffectDuration(finishedWork);
              } else {
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
            resetCurrentFiber();
            var child = fiber.child;
            if (child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var sibling = fiber.sibling;
            var returnFiber = fiber.return;
            {
              detachFiberAfterEffects(fiber);
              if (fiber === deletedSubtreeRoot) {
                nextEffect = null;
                return;
              }
            }
            if (sibling !== null) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              return;
            }
            nextEffect = returnFiber;
          }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
          switch (current2.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (current2.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                recordPassiveEffectDuration(current2);
              } else {
                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              }
              break;
            }
          }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Layout | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance2 = fiber.stateNode;
                try {
                  instance2.componentDidMount();
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
            }
          }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
                break;
              }
              case ClassComponent: {
                var instance2 = fiber.stateNode;
                if (typeof instance2.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance2);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                } catch (error3) {
                  captureCommitPhaseError(fiber, fiber.return, error3);
                }
              }
            }
          }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          COMPONENT_TYPE = symbolFor("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor("selector.role");
          TEST_NAME_TYPE = symbolFor("selector.test_id");
          TEXT_TYPE = symbolFor("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
          {
            var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
            var jestIsDefined = typeof jest !== "undefined";
            return jestIsDefined && isReactActEnvironmentGlobal !== false;
          }
        }
        function isConcurrentActEnvironment() {
          {
            var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
              error2("The current testing environment is not configured to support act(...)");
            }
            return isReactActEnvironmentGlobal;
          }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = 0;
        var BatchedContext = 1;
        var RenderContext = 2;
        var CommitContext = 4;
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now2();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now2();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
            return pickArbitraryLane(workInProgressRootRenderLanes);
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (ReactCurrentBatchConfig$3.transition !== null) {
              var transition = ReactCurrentBatchConfig$3.transition;
              if (!transition._updatedFibers) {
                transition._updatedFibers = /* @__PURE__ */ new Set();
              }
              transition._updatedFibers.add(fiber);
            }
            if (currentEventTransitionLane === NoLane) {
              currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
          }
          var updateLane = getCurrentUpdatePriority();
          if (updateLane !== NoLane) {
            return updateLane;
          }
          var eventLane = getCurrentEventPriority();
          return eventLane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          }
          return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root4, fiber, lane, eventTime) {
          checkForNestedUpdates();
          {
            if (isRunningInsertionEffect) {
              error2("useInsertionEffect must not schedule updates.");
            }
          }
          {
            if (isFlushingPassiveEffects) {
              didScheduleUpdateDuringPassiveEffects = true;
            }
          }
          markRootUpdated(root4, lane, eventTime);
          if ((executionContext & RenderContext) !== NoLanes && root4 === workInProgressRoot) {
            warnAboutRenderPhaseUpdatesInDEV(fiber);
          } else {
            {
              if (isDevToolsPresent) {
                addFiberToLanesMap(root4, fiber, lane);
              }
            }
            warnIfUpdatesNotWrappedWithActDEV(fiber);
            if (root4 === workInProgressRoot) {
              if ((executionContext & RenderContext) === NoContext) {
                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root4, workInProgressRootRenderLanes);
              }
            }
            ensureRootIsScheduled(root4, eventTime);
            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function scheduleInitialHydrationOnRoot(root4, lane, eventTime) {
          var current2 = root4.current;
          current2.lanes = lane;
          markRootUpdated(root4, lane, eventTime);
          ensureRootIsScheduled(root4, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
          return (executionContext & RenderContext) !== NoContext;
        }
        function ensureRootIsScheduled(root4, currentTime) {
          var existingCallbackNode = root4.callbackNode;
          markStarvedLanesAsExpired(root4, currentTime);
          var nextLanes = getNextLanes(root4, root4 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback$1(existingCallbackNode);
            }
            root4.callbackNode = null;
            root4.callbackPriority = NoLane;
            return;
          }
          var newCallbackPriority = getHighestPriorityLane(nextLanes);
          var existingCallbackPriority = root4.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority && !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
            {
              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                error2("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return;
          }
          if (existingCallbackNode != null) {
            cancelCallback$1(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLane) {
            if (root4.tag === LegacyRoot) {
              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
              }
              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root4));
            } else {
              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root4));
            }
            {
              if (ReactCurrentActQueue$1.current !== null) {
                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
              } else {
                scheduleMicrotask(function() {
                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                  }
                });
              }
            }
            newCallbackNode = null;
          } else {
            var schedulerPriorityLevel;
            switch (lanesToEventPriority(nextLanes)) {
              case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriorityLevel = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriorityLevel = IdlePriority;
                break;
              default:
                schedulerPriorityLevel = NormalPriority;
                break;
            }
            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root4));
          }
          root4.callbackPriority = newCallbackPriority;
          root4.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root4, didTimeout) {
          {
            resetNestedUpdateFlag();
          }
          currentEventTime = NoTimestamp;
          currentEventTransitionLane = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var originalCallbackNode = root4.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root4.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root4, root4 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var shouldTimeSlice = !includesBlockingLane(root4, lanes) && !includesExpiredLane(root4, lanes) && !didTimeout;
          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root4, lanes) : renderRootSync(root4, lanes);
          if (exitStatus !== RootInProgress) {
            if (exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root4);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root4, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root4, NoLanes);
              markRootSuspended$1(root4, lanes);
              ensureRootIsScheduled(root4, now2());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              markRootSuspended$1(root4, lanes);
            } else {
              var renderWasConcurrent = !includesBlockingLane(root4, lanes);
              var finishedWork = root4.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                exitStatus = renderRootSync(root4, lanes);
                if (exitStatus === RootErrored) {
                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root4);
                  if (_errorRetryLanes !== NoLanes) {
                    lanes = _errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root4, _errorRetryLanes);
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  var _fatalError = workInProgressRootFatalError;
                  prepareFreshStack(root4, NoLanes);
                  markRootSuspended$1(root4, lanes);
                  ensureRootIsScheduled(root4, now2());
                  throw _fatalError;
                }
              }
              root4.finishedWork = finishedWork;
              root4.finishedLanes = lanes;
              finishConcurrentRender(root4, exitStatus, lanes);
            }
          }
          ensureRootIsScheduled(root4, now2());
          if (root4.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root4);
          }
          return null;
        }
        function recoverFromConcurrentError(root4, errorRetryLanes) {
          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
          if (isRootDehydrated(root4)) {
            var rootWorkInProgress = prepareFreshStack(root4, errorRetryLanes);
            rootWorkInProgress.flags |= ForceClientRender;
            {
              errorHydratingContainer(root4.containerInfo);
            }
          }
          var exitStatus = renderRootSync(root4, errorRetryLanes);
          if (exitStatus !== RootErrored) {
            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
            if (errorsFromSecondAttempt !== null) {
              queueRecoverableErrors(errorsFromSecondAttempt);
            }
          }
          return exitStatus;
        }
        function queueRecoverableErrors(errors) {
          if (workInProgressRootRecoverableErrors === null) {
            workInProgressRootRecoverableErrors = errors;
          } else {
            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
          }
        }
        function finishConcurrentRender(root4, exitStatus, lanes) {
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored: {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            case RootErrored: {
              commitRoot(root4, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root4, lanes);
              if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root4, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root4.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root4, suspendedLanes);
                    break;
                  }
                  root4.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root4, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root4, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root4, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root4, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now2() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root4.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root4, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root4, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootCompleted: {
              commitRoot(root4, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            default: {
              throw new Error("Unknown root exit status.");
            }
          }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          var node2 = finishedWork;
          while (true) {
            if (node2.flags & StoreConsistency) {
              var updateQueue = node2.updateQueue;
              if (updateQueue !== null) {
                var checks2 = updateQueue.stores;
                if (checks2 !== null) {
                  for (var i = 0; i < checks2.length; i++) {
                    var check = checks2[i];
                    var getSnapshot = check.getSnapshot;
                    var renderedValue = check.value;
                    try {
                      if (!objectIs(getSnapshot(), renderedValue)) {
                        return false;
                      }
                    } catch (error3) {
                      return false;
                    }
                  }
                }
              }
            }
            var child = node2.child;
            if (node2.subtreeFlags & StoreConsistency && child !== null) {
              child.return = node2;
              node2 = child;
              continue;
            }
            if (node2 === finishedWork) {
              return true;
            }
            while (node2.sibling === null) {
              if (node2.return === null || node2.return === finishedWork) {
                return true;
              }
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
          return true;
        }
        function markRootSuspended$1(root4, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
          markRootSuspended(root4, suspendedLanes);
        }
        function performSyncWorkOnRoot(root4) {
          {
            syncNestedUpdateFlag();
          }
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          flushPassiveEffects();
          var lanes = getNextLanes(root4, NoLanes);
          if (!includesSomeLane(lanes, SyncLane)) {
            ensureRootIsScheduled(root4, now2());
            return null;
          }
          var exitStatus = renderRootSync(root4, lanes);
          if (root4.tag !== LegacyRoot && exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root4);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root4, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root4, NoLanes);
            markRootSuspended$1(root4, lanes);
            ensureRootIsScheduled(root4, now2());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          var finishedWork = root4.current.alternate;
          root4.finishedWork = finishedWork;
          root4.finishedLanes = lanes;
          commitRoot(root4, workInProgressRootRecoverableErrors, workInProgressTransitions);
          ensureRootIsScheduled(root4, now2());
          return null;
        }
        function flushRoot(root4, lanes) {
          if (lanes !== NoLanes) {
            markRootEntangled(root4, mergeLanes(lanes, SyncLane));
            ensureRootIsScheduled(root4, now2());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbacks();
            }
          }
        }
        function batchedUpdates$1(fn, a) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn(a);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext && !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function discreteUpdates(fn, a, b, c, d2) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            return fn(a, b, c, d2);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            if (executionContext === NoContext) {
              resetRenderTimer();
            }
          }
        }
        function flushSync(fn) {
          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushPassiveEffects();
          }
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            if (fn) {
              return fn();
            } else {
              return void 0;
            }
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            executionContext = prevExecutionContext;
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushSyncCallbacks();
            }
          }
        }
        function isAlreadyRendering() {
          return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
          push2(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root4, lanes) {
          root4.finishedWork = null;
          root4.finishedLanes = NoLanes;
          var timeoutHandle = root4.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root4.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              var current2 = interruptedWork.alternate;
              unwindInterruptedWork(current2, interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root4;
          var rootWorkInProgress = createWorkInProgress(root4.current, null);
          workInProgress = rootWorkInProgress;
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootInterleavedUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          workInProgressRootConcurrentErrors = null;
          workInProgressRootRecoverableErrors = null;
          finishQueueingConcurrentUpdates();
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
          return rootWorkInProgress;
        }
        function handleError(root4, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              if (enableSchedulingProfiler) {
                markComponentRenderStopped();
                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                  var wakeable = thrownValue;
                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                } else {
                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                }
              }
              throwException(root4, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now2();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError(error3) {
          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
            workInProgressRootExitStatus = RootErrored;
          }
          if (workInProgressRootConcurrentErrors === null) {
            workInProgressRootConcurrentErrors = [error3];
          } else {
            workInProgressRootConcurrentErrors.push(error3);
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root4, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root4 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root4.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root4, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root4, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            prepareFreshStack(root4, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root4, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root4, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root4 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root4.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root4, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root4, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            resetRenderTimer();
            prepareFreshStack(root4, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root4, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            {
              markRenderYielded();
            }
            return RootInProgress;
          } else {
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current2 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next = completeWork(current2, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next = completeWork(current2, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next !== null) {
                workInProgress = next;
                return;
              }
            } else {
              var _next = unwindWork(current2, completedWork);
              if (_next !== null) {
                _next.flags &= HostEffectMask;
                workInProgress = _next;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.flags |= Incomplete;
                returnFiber.subtreeFlags = NoFlags;
                returnFiber.deletions = null;
              } else {
                workInProgressRootExitStatus = RootDidNotComplete;
                workInProgress = null;
                return;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function commitRoot(root4, recoverableErrors, transitions2) {
          var previousUpdateLanePriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            commitRootImpl(root4, recoverableErrors, transitions2, previousUpdateLanePriority);
          } finally {
            ReactCurrentBatchConfig$3.transition = prevTransition;
            setCurrentUpdatePriority(previousUpdateLanePriority);
          }
          return null;
        }
        function commitRootImpl(root4, recoverableErrors, transitions2, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var finishedWork = root4.finishedWork;
          var lanes = root4.finishedLanes;
          {
            markCommitStarted(lanes);
          }
          if (finishedWork === null) {
            {
              markCommitStopped();
            }
            return null;
          } else {
            {
              if (lanes === NoLanes) {
                error2("root.finishedLanes should not be empty during a commit. This is a bug in React.");
              }
            }
          }
          root4.finishedWork = null;
          root4.finishedLanes = NoLanes;
          if (finishedWork === root4.current) {
            throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          }
          root4.callbackNode = null;
          root4.callbackPriority = NoLane;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root4, remainingLanes);
          if (root4 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              pendingPassiveTransitions = transitions2;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          if (subtreeHasEffects || rootHasEffect) {
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            ReactCurrentBatchConfig$3.transition = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(DiscreteEventPriority);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            ReactCurrentOwner$2.current = null;
            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root4, finishedWork);
            {
              recordCommitTime();
            }
            commitMutationEffects(root4, finishedWork, lanes);
            resetAfterCommit(root4.containerInfo);
            root4.current = finishedWork;
            {
              markLayoutEffectsStarted(lanes);
            }
            commitLayoutEffects(finishedWork, root4, lanes);
            {
              markLayoutEffectsStopped();
            }
            requestPaint();
            executionContext = prevExecutionContext;
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          } else {
            root4.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root4;
            pendingPassiveEffectsLanes = lanes;
          } else {
            {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
            }
          }
          remainingLanes = root4.pendingLanes;
          if (remainingLanes === NoLanes) {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              commitDoubleInvokeEffectsInDEV(root4.current, false);
            }
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            if (isDevToolsPresent) {
              root4.memoizedUpdaters.clear();
            }
          }
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root4, now2());
          if (recoverableErrors !== null) {
            var onRecoverableError = root4.onRecoverableError;
            for (var i = 0; i < recoverableErrors.length; i++) {
              var recoverableError = recoverableErrors[i];
              var componentStack = recoverableError.stack;
              var digest = recoverableError.digest;
              onRecoverableError(recoverableError.value, {
                componentStack,
                digest
              });
            }
          }
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var error$1 = firstUncaughtError;
            firstUncaughtError = null;
            throw error$1;
          }
          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root4.tag !== LegacyRoot) {
            flushPassiveEffects();
          }
          remainingLanes = root4.pendingLanes;
          if (includesSomeLane(remainingLanes, SyncLane)) {
            {
              markNestedUpdateScheduled();
            }
            if (root4 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root4;
            }
          } else {
            nestedUpdateCount = 0;
          }
          flushSyncCallbacks();
          {
            markCommitStopped();
          }
          return null;
        }
        function flushPassiveEffects() {
          if (rootWithPendingPassiveEffects !== null) {
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(priority);
              return flushPassiveEffectsImpl();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            }
          }
          return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
          {
            pendingPassiveProfilerEffects.push(fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var transitions2 = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root4 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Cannot flush passive effects while already rendering.");
          }
          {
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          {
            markPassiveEffectsStarted(lanes);
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountEffects(root4.current);
          commitPassiveMountEffects(root4, root4.current, lanes, transitions2);
          {
            var profilerEffects = pendingPassiveProfilerEffects;
            pendingPassiveProfilerEffects = [];
            for (var i = 0; i < profilerEffects.length; i++) {
              var _fiber = profilerEffects[i];
              commitPassiveEffectDurations(root4, _fiber);
            }
          }
          {
            markPassiveEffectsStopped();
          }
          {
            commitDoubleInvokeEffectsInDEV(root4.current, true);
          }
          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          {
            if (didScheduleUpdateDuringPassiveEffects) {
              if (root4 === rootWithPassiveNestedUpdates) {
                nestedPassiveUpdateCount++;
              } else {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = root4;
              }
            } else {
              nestedPassiveUpdateCount = 0;
            }
            isFlushingPassiveEffects = false;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          onPostCommitRoot(root4);
          {
            var stateNode = root4.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance2) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance2);
        }
        function markLegacyErrorBoundaryAsFailed(instance2) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance2]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance2);
          }
        }
        function prepareToThrowUncaughtError(error3) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error3;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error3) {
          var errorInfo = createCapturedValueAtFiber(error3, sourceFiber);
          var update2 = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          var root4 = enqueueUpdate(rootFiber, update2, SyncLane);
          var eventTime = requestEventTime();
          if (root4 !== null) {
            markRootUpdated(root4, SyncLane, eventTime);
            ensureRootIsScheduled(root4, eventTime);
          }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
          {
            reportUncaughtErrorInDEV(error$1);
            setIsRunningInsertionEffect(false);
          }
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
            return;
          }
          var fiber = null;
          {
            fiber = nearestMountedAncestor;
          }
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance2 = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance2.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance2)) {
                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                var update2 = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                var root4 = enqueueUpdate(fiber, update2, SyncLane);
                var eventTime = requestEventTime();
                if (root4 !== null) {
                  markRootUpdated(root4, SyncLane, eventTime);
                  ensureRootIsScheduled(root4, eventTime);
                }
                return;
              }
            }
            fiber = fiber.return;
          }
          {
            error2("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
          }
        }
        function pingSuspendedRoot(root4, wakeable, pingedLanes) {
          var pingCache = root4.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root4, pingedLanes);
          warnIfSuspenseResolutionNotWrappedWithActDEV(root4);
          if (workInProgressRoot === root4 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root4, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root4, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root4 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          if (root4 !== null) {
            markRootUpdated(root4, retryLane, eventTime);
            ensureRootIsScheduled(root4, eventTime);
          }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState;
          var retryLane = NoLane;
          if (suspenseState !== null) {
            retryLane = suspenseState.retryLane;
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
              }
              break;
            case SuspenseListComponent:
              retryCache = boundaryFiber.stateNode;
              break;
            default:
              throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
              error2("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
          {
            setCurrentFiber(fiber);
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
            }
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
            }
            resetCurrentFiber();
          }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
          {
            var current2 = firstChild;
            var subtreeRoot = null;
            while (current2 !== null) {
              var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
              if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                current2 = current2.child;
              } else {
                if ((current2.flags & fiberFlags) !== NoFlags) {
                  invokeEffectFn(current2);
                }
                if (current2.sibling !== null) {
                  current2 = current2.sibling;
                } else {
                  current2 = subtreeRoot = current2.return;
                }
              }
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & ConcurrentMode)) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
              return;
            }
            var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
            }
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error2("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current2, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current2, unitOfWork, lanes);
            } catch (originalError) {
              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(current2, unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                  originalError._suppressLogging = true;
                }
              }
              throw originalError;
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                    error2("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error2("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        function restorePendingUpdaters(root4, lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root4.memoizedUpdaters;
              memoizedUpdaters.forEach(function(schedulingFiber) {
                addFiberToLanesMap(root4, schedulingFiber, lanes);
              });
            }
          }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
          {
            var actQueue = ReactCurrentActQueue$1.current;
            if (actQueue !== null) {
              actQueue.push(callback);
              return fakeActCallbackNode;
            } else {
              return scheduleCallback(priorityLevel, callback);
            }
          }
        }
        function cancelCallback$1(callbackNode) {
          if (callbackNode === fakeActCallbackNode) {
            return;
          }
          return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
          return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          {
            if (fiber.mode & ConcurrentMode) {
              if (!isConcurrentActEnvironment()) {
                return;
              }
            } else {
              if (!isLegacyActEnvironment()) {
                return;
              }
              if (executionContext !== NoContext) {
                return;
              }
              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                return;
              }
            }
            if (ReactCurrentActQueue$1.current === null) {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error2("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root4) {
          {
            if (root4.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
              error2("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
            }
          }
        }
        function setIsRunningInsertionEffect(isRunning) {
          {
            isRunningInsertionEffect = isRunning;
          }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type2) {
          {
            if (resolveFamily === null) {
              return type2;
            }
            var family = resolveFamily(type2);
            if (family === void 0) {
              return type2;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type2) {
          return resolveFunctionForHotReloading(type2);
        }
        function resolveForwardRefForHotReloading(type2) {
          {
            if (resolveFamily === null) {
              return type2;
            }
            var family = resolveFamily(type2);
            if (family === void 0) {
              if (type2 !== null && type2 !== void 0 && typeof type2.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type2.render);
                if (type2.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: currentRender
                  };
                  if (type2.displayName !== void 0) {
                    syntheticType.displayName = type2.displayName;
                  }
                  return syntheticType;
                }
              }
              return type2;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element4) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element4.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = /* @__PURE__ */ new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root4, update2) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update2.staleFamilies, updatedFamilies = update2.updatedFamilies;
            flushPassiveEffects();
            flushSync(function() {
              scheduleFibersWithFamiliesRecursively(root4.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root4, element4) {
          {
            if (root4.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync(function() {
              updateContainer(element4, root4, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type2 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type2;
                break;
              case ForwardRef:
                candidateType = type2.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (_root !== null) {
                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
              }
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root4, families) {
          {
            var hostInstances = /* @__PURE__ */ new Set();
            var types = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root4.current, types, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type2 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type2;
                break;
              case ForwardRef:
                candidateType = type2.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node2 = fiber;
            while (true) {
              switch (node2.tag) {
                case HostComponent:
                  hostInstances.add(node2.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node2.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node2.stateNode.containerInfo);
                  return;
              }
              if (node2.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node2 = node2.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node2 = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node2.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node2.stateNode);
              } else if (node2.child !== null) {
                node2.child.return = node2;
                node2 = node2.child;
                continue;
              }
              if (node2 === fiber) {
                return foundHostInstances;
              }
              while (node2.sibling === null) {
                if (node2.return === null || node2.return === fiber) {
                  return foundHostInstances;
                }
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e2) {
            hasBadMapPolyfill = true;
          }
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        };
        function shouldConstruct$1(Component) {
          var prototype3 = Component.prototype;
          return !!(prototype3 && prototype3.isReactComponent);
        }
        function isSimpleFunctionComponent(type2) {
          return typeof type2 === "function" && !shouldConstruct$1(type2) && type2.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component) {
          if (typeof Component === "function") {
            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
          } else if (Component !== void 0 && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              return ForwardRef;
            }
            if ($$typeof === REACT_MEMO_TYPE) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
            workInProgress2.elementType = current2.elementType;
            workInProgress2.type = current2.type;
            workInProgress2.stateNode = current2.stateNode;
            {
              workInProgress2._debugSource = current2._debugSource;
              workInProgress2._debugOwner = current2._debugOwner;
              workInProgress2._debugHookTypes = current2._debugHookTypes;
            }
            workInProgress2.alternate = current2;
            current2.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current2.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.flags = current2.flags & StaticMask;
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current2.type);
                break;
              case ForwardRef:
                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= StaticMask | Placement;
          var current2 = workInProgress2.alternate;
          if (current2 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.type = current2.type;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode;
            if (isStrictMode === true) {
              mode |= StrictLegacyMode;
              {
                mode |= StrictEffectsMode;
              }
            }
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type2, key, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type2;
          if (typeof type2 === "function") {
            if (shouldConstruct$1(type2)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type2 === "string") {
            fiberTag = HostComponent;
          } else {
            getTag:
              switch (type2) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictLegacyMode;
                  if ((mode & ConcurrentMode) !== NoMode) {
                    mode |= StrictEffectsMode;
                  }
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_SCOPE_TYPE:
                case REACT_CACHE_TYPE:
                case REACT_TRACING_MARKER_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                default: {
                  if (typeof type2 === "object" && type2 !== null) {
                    switch (type2.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type2 == null ? type2 : typeof type2) + "." + info));
                }
              }
          }
          var fiber = createFiber(fiberTag, pendingProps, key, mode);
          fiber.elementType = type2;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element4, mode, lanes) {
          var owner = null;
          {
            owner = element4._owner;
          }
          var type2 = element4.type;
          var key = element4.key;
          var pendingProps = element4.props;
          var fiber = createFiberFromTypeAndProps(type2, key, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element4._source;
            fiber._debugOwner = element4._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          var fiber = createFiber(Fragment65, elements, key, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key) {
          {
            if (typeof pendingProps.id !== "string") {
              error2('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
          fiber.elementType = REACT_SUSPENSE_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
          fiber.elementType = REACT_OFFSCREEN_TYPE;
          fiber.lanes = lanes;
          var primaryChildInstance = {
            isHidden: false
          };
          fiber.stateNode = primaryChildInstance;
          return fiber;
        }
        function createFiberFromText(content3, mode, lanes) {
          var fiber = createFiber(HostText, content3, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(DehydratedFragment, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source.tag;
          target.key = source.key;
          target.elementType = source.elementType;
          target.type = source.type;
          target.stateNode = source.stateNode;
          target.return = source.return;
          target.child = source.child;
          target.sibling = source.sibling;
          target.index = source.index;
          target.ref = source.ref;
          target.pendingProps = source.pendingProps;
          target.memoizedProps = source.memoizedProps;
          target.updateQueue = source.updateQueue;
          target.memoizedState = source.memoizedState;
          target.dependencies = source.dependencies;
          target.mode = source.mode;
          target.flags = source.flags;
          target.subtreeFlags = source.subtreeFlags;
          target.deletions = source.deletions;
          target.lanes = source.lanes;
          target.childLanes = source.childLanes;
          target.alternate = source.alternate;
          {
            target.actualDuration = source.actualDuration;
            target.actualStartTime = source.actualStartTime;
            target.selfBaseDuration = source.selfBaseDuration;
            target.treeBaseDuration = source.treeBaseDuration;
          }
          target._debugSource = source._debugSource;
          target._debugOwner = source._debugOwner;
          target._debugNeedsRemount = source._debugNeedsRemount;
          target._debugHookTypes = source._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.callbackNode = null;
          this.callbackPriority = NoLane;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          this.identifierPrefix = identifierPrefix;
          this.onRecoverableError = onRecoverableError;
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.effectDuration = 0;
            this.passiveEffectDuration = 0;
          }
          {
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
            for (var _i = 0; _i < TotalLanes; _i++) {
              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
            }
          }
          {
            switch (tag) {
              case ConcurrentRoot:
                this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var root4 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
          root4.current = uninitializedFiber;
          uninitializedFiber.stateNode = root4;
          {
            var _initialState = {
              element: initialChildren,
              isDehydrated: hydrate2,
              cache: null,
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            uninitializedFiber.memoizedState = _initialState;
          }
          initializeUpdateQueue(uninitializedFiber);
          return root4;
        }
        var ReactVersion = "18.2.0";
        function createPortal(children, containerInfo, implementation) {
          var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          {
            checkKeyStringCoercion(key);
          }
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: key == null ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get4(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) {
              return processChildContext(fiber, Component, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
          {
            var fiber = get4(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                throw new Error("Unable to find node on an unmounted component.");
              } else {
                var keys2 = Object.keys(component).join(",");
                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys2);
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictLegacyMode) {
              var componentName = getComponentNameFromFiber(fiber) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictLegacyMode) {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error2("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = false;
          var initialChildren = null;
          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = true;
          var root4 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          root4.context = getContextForSubtree(null);
          var current2 = root4.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current2);
          var update2 = createUpdate(eventTime, lane);
          update2.callback = callback !== void 0 && callback !== null ? callback : null;
          enqueueUpdate(current2, update2, lane);
          scheduleInitialHydrationOnRoot(root4, lane, eventTime);
          return root4;
        }
        function updateContainer(element4, container, parentComponent, callback) {
          {
            onScheduleRoot(container, element4);
          }
          var current$1 = container.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current$1);
          {
            markRenderScheduled(lane);
          }
          var context = getContextForSubtree(parentComponent);
          if (container.context === null) {
            container.context = context;
          } else {
            container.pendingContext = context;
          }
          {
            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error2("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
            }
          }
          var update2 = createUpdate(eventTime, lane);
          update2.payload = {
            element: element4
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error2("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update2.callback = callback;
          }
          var root4 = enqueueUpdate(current$1, update2, lane);
          if (root4 !== null) {
            scheduleUpdateOnFiber(root4, current$1, lane, eventTime);
            entangleTransitions(root4, current$1, lane);
          }
          return lane;
        }
        function getPublicRootInstance(container) {
          var containerFiber = container.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function attemptSynchronousHydration$1(fiber) {
          switch (fiber.tag) {
            case HostRoot: {
              var root4 = fiber.stateNode;
              if (isRootDehydrated(root4)) {
                var lanes = getHighestPriorityPendingLanes(root4);
                flushRoot(root4, lanes);
              }
              break;
            }
            case SuspenseComponent: {
              flushSync(function() {
                var root5 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root5 !== null) {
                  var eventTime = requestEventTime();
                  scheduleUpdateOnFiber(root5, fiber, SyncLane, eventTime);
                }
              });
              var retryLane = SyncLane;
              markRetryLaneIfNotHydrated(fiber, retryLane);
              break;
            }
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = SelectiveHydrationLane;
          var root4 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root4 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root4, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = requestUpdateLane(fiber);
          var root4 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root4 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root4, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        var shouldErrorImpl = function(fiber) {
          return null;
        };
        function shouldError(fiber) {
          return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path4, index3) {
            var key = path4[index3];
            var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
            if (index3 + 1 === path4.length) {
              if (isArray2(updated)) {
                updated.splice(key, 1);
              } else {
                delete updated[key];
              }
              return updated;
            }
            updated[key] = copyWithDeleteImpl(obj[key], path4, index3 + 1);
            return updated;
          };
          var copyWithDelete = function(obj, path4) {
            return copyWithDeleteImpl(obj, path4, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index3) {
            var oldKey = oldPath[index3];
            var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
            if (index3 + 1 === oldPath.length) {
              var newKey = newPath[index3];
              updated[newKey] = updated[oldKey];
              if (isArray2(updated)) {
                updated.splice(oldKey, 1);
              } else {
                delete updated[oldKey];
              }
            } else {
              updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index3 + 1);
            }
            return updated;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn2("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i = 0; i < newPath.length - 1; i++) {
                if (oldPath[i] !== newPath[i]) {
                  warn2("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path4, index3, value) {
            if (index3 >= path4.length) {
              return value;
            }
            var key = path4[index3];
            var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
            updated[key] = copyWithSetImpl(obj[key], path4, index3 + 1, value);
            return updated;
          };
          var copyWithSet = function(obj, path4, value) {
            return copyWithSetImpl(obj, path4, 0, value);
          };
          var findHook = function(fiber, id) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id > 0) {
              currentHook2 = currentHook2.next;
              id--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id, path4, value) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path4, value);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root4 !== null) {
                scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateDeletePath = function(fiber, id, path4) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path4);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root4 !== null) {
                scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign({}, fiber.memoizedProps);
              var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root4 !== null) {
                scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideProps = function(fiber, path4, value) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path4, value);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root4 !== null) {
              scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsDeletePath = function(fiber, path4) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path4);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root4 !== null) {
              scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root4 !== null) {
              scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
            }
          };
          scheduleUpdate = function(fiber) {
            var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root4 !== null) {
              scheduleUpdateOnFiber(root4, fiber, SyncLane, NoTimestamp);
            }
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance2) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setErrorHandler,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            getCurrentFiber: getCurrentFiberForDevTools,
            reconcilerVersion: ReactVersion
          });
        }
        var defaultOnRecoverableError = typeof reportError === "function" ? reportError : function(error3) {
          console["error"](error3);
        };
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root4 = this._internalRoot;
          if (root4 === null) {
            throw new Error("Cannot update an unmounted root.");
          }
          {
            if (typeof arguments[1] === "function") {
              error2("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            } else if (isValidContainer(arguments[1])) {
              error2("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
            } else if (typeof arguments[1] !== "undefined") {
              error2("You passed a second argument to root.render(...) but it only accepts one argument.");
            }
            var container = root4.containerInfo;
            if (container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root4.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error2("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root4, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error2("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root4 = this._internalRoot;
          if (root4 !== null) {
            this._internalRoot = null;
            var container = root4.containerInfo;
            {
              if (isAlreadyRendering()) {
                error2("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
              }
            }
            flushSync(function() {
              updateContainer(null, root4, null, null);
            });
            unmarkContainerAsRoot(container);
          }
        };
        function createRoot10(container, options2) {
          if (!isValidContainer(container)) {
            throw new Error("createRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          var transitionCallbacks = null;
          if (options2 !== null && options2 !== void 0) {
            {
              if (options2.hydrate) {
                warn2("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
              } else {
                if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                  error2("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                }
              }
            }
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
            if (options2.transitionCallbacks !== void 0) {
              transitionCallbacks = options2.transitionCallbacks;
            }
          }
          var root4 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root4.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          return new ReactDOMRoot(root4);
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
          if (target) {
            queueExplicitHydrationTarget(target);
          }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container, initialChildren, options2) {
          if (!isValidContainer(container)) {
            throw new Error("hydrateRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          {
            if (initialChildren === void 0) {
              error2("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            }
          }
          var hydrationCallbacks = options2 != null ? options2 : null;
          var mutableSources = options2 != null && options2.hydratedSources || null;
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          if (options2 !== null && options2 !== void 0) {
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
          }
          var root4 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root4.current, container);
          listenToAllSupportedEvents(container);
          if (mutableSources) {
            for (var i = 0; i < mutableSources.length; i++) {
              var mutableSource = mutableSources[i];
              registerMutableSourceForHydration(root4, mutableSource);
            }
          }
          return new ReactDOMHydrationRoot(root4);
        }
        function isValidContainer(node2) {
          return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node2) {
          return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || node2.nodeType === COMMENT_NODE && node2.nodeValue === " react-mount-point-unstable "));
        }
        function warnIfReactDOMContainerInDEV(container) {
          {
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error2("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
            }
            if (isContainerMarkedAsRoot(container)) {
              if (container._reactRootContainer) {
                error2("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
              } else {
                error2("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
              }
            }
          }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
          topLevelUpdateWarnings = function(container) {
            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error2("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error2("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error2("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container) {
          if (!container) {
            return null;
          }
          if (container.nodeType === DOCUMENT_NODE) {
            return container.documentElement;
          } else {
            return container.firstChild;
          }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
          if (isHydrationContainer) {
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance2 = getPublicRootInstance(root4);
                originalCallback.call(instance2);
              };
            }
            var root4 = createHydrationContainer(initialChildren, callback, container, LegacyRoot, null, false, false, "", noopOnRecoverableError);
            container._reactRootContainer = root4;
            markContainerAsRoot(root4.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            flushSync();
            return root4;
          } else {
            var rootSibling;
            while (rootSibling = container.lastChild) {
              container.removeChild(rootSibling);
            }
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance2 = getPublicRootInstance(_root);
                _originalCallback.call(instance2);
              };
            }
            var _root = createContainer(container, LegacyRoot, null, false, false, "", noopOnRecoverableError);
            container._reactRootContainer = _root;
            markContainerAsRoot(_root.current, container);
            var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(_rootContainerElement);
            flushSync(function() {
              updateContainer(initialChildren, _root, parentComponent, callback);
            });
            return _root;
          }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error2("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var maybeRoot = container._reactRootContainer;
          var root4;
          if (!maybeRoot) {
            root4 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
          } else {
            root4 = maybeRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance2 = getPublicRootInstance(root4);
                originalCallback.call(instance2);
              };
            }
            updateContainer(children, root4, parentComponent, callback);
          }
          return getPublicRootInstance(root4);
        }
        function findDOMNode(componentOrElement) {
          {
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error2("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate(element4, container, callback) {
          {
            error2("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element4, container, true, callback);
        }
        function render3(element4, container, callback) {
          {
            error2("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element4, container, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element4, containerNode, callback) {
          {
            error2("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(containerNode)) {
            throw new Error("Target container is not a DOM element.");
          }
          if (parentComponent == null || !has(parentComponent)) {
            throw new Error("parentComponent must be a valid React Component");
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element4, containerNode, false, callback);
        }
        function unmountComponentAtNode(container) {
          if (!isValidContainerLegacy(container)) {
            throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error2("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            flushSync(function() {
              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                container._reactRootContainer = null;
                unmarkContainerAsRoot(container);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error2("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
          if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error2("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
        function createPortal$1(children, container) {
          var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          return createPortal(children, container, null, key);
        }
        function renderSubtreeIntoContainer(parentComponent, element4, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element4, containerNode, callback);
        }
        var Internals = {
          usingClientEntryPoint: false,
          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return createRoot10(container, options2);
        }
        function hydrateRoot$1(container, initialChildren, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error2('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return hydrateRoot(container, initialChildren, options2);
        }
        function flushSync$1(fn) {
          {
            if (isAlreadyRendering()) {
              error2("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
          }
          return flushSync(fn);
        }
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol = window.location.protocol;
              if (/^(https?|file):$/.test(protocol)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.createRoot = createRoot$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync$1;
        exports.hydrate = hydrate;
        exports.hydrateRoot = hydrateRoot$1;
        exports.render = render3;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    if (false) {
      checkDCE();
      module2.exports = null;
    } else {
      module2.exports = require_react_dom_development();
    }
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    var m = require_react_dom();
    if (false) {
      exports.createRoot = m.createRoot;
      exports.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c, h2, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h2, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module2) {
    module2.exports = function isBuffer3(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr2) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr2);
      }
      return toStr.call(arr2) === "[object Array]";
    };
    var isPlainObject5 = function isPlainObject6(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module2.exports = function extend3() {
      var options, name, src, copy2, copyIsArray, clone3;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy2 = getProperty(options, name);
            if (target !== copy2) {
              if (deep && copy2 && (isPlainObject5(copy2) || (copyIsArray = isArray2(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone3 = src && isArray2(src) ? src : [];
                } else {
                  clone3 = src && isPlainObject5(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend3(deep, clone3, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target, { name, newValue: copy2 });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType2(type2) {
          return typeof type2 === "string" || typeof type2 === "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element3 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment65 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer2(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element3;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment65;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer2;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty4 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s3 = 1; s3 < arguments.length; s3++) {
        from = Object(arguments[s3]);
        for (var key in from) {
          if (hasOwnProperty4.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text6) {
        var message = "Warning: " + text6;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values2, location3, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error2;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location3 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error2 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location3, null, ReactPropTypesSecret);
            } catch (ex) {
              error2 = ex;
            }
            if (error2 && !(error2 instanceof Error)) {
              printWarning((componentName || "React class") + ": type specification of " + location3 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
            }
            if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
              loggedTypeFailures[error2.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning("Failed " + location3 + " type: " + error2.message + (stack != null ? stack : ""));
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
    "use strict";
    var ReactIs2 = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text6) {
        var message = "Warning: " + text6;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is3(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location3, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location3 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location3 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location3, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location3, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location3, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error2 = typeChecker(propValue, i, componentName, location3, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location3, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location3, propFullName) {
          var propValue = props[propName];
          if (!ReactIs2.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location3, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location3, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is3(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type2 = getPreciseType(value);
            if (type2 === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location3, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error2 = typeChecker(propValue, key, componentName, location3, propFullName + "." + key, ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location3, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location3, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location3, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location3, propFullName, key, type2) {
        return new PropTypeError((componentName || "React class") + ": " + location3 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`.");
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location3, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location3, propFullName, key, getPreciseType(checker));
            }
            var error2 = checker(propValue, key, componentName, location3, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location3, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location3, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError("Invalid " + location3 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
            }
            var error2 = checker(propValue, key, componentName, location3, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type2 = getPreciseType(value);
        switch (type2) {
          case "array":
          case "object":
            return "an " + type2;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type2;
          default:
            return type2;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module2) {
    if (true) {
      ReactIs2 = require_react_is();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs2.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs2;
    var throwOnDirectAccess;
  }
});

// node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType2(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element3 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment65 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer2(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element3;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment65;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer2;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-markdown/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/react-markdown/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development2();
    }
  }
});

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module2) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module2.exports = function(style3, options) {
      if (typeof style3 !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style3)
        return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
      }
      function position6() {
        var start3 = { line: lineno, column };
        return function(node2) {
          node2.position = new Position(start3);
          whitespace2();
          return node2;
        };
      }
      function Position(start3) {
        this.start = start3;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style3;
      var errorsList = [];
      function error2(msg) {
        var err = new Error(options.source + ":" + lineno + ":" + column + ": " + msg);
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style3;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match3(re) {
        var m = re.exec(style3);
        if (!m)
          return;
        var str = m[0];
        updatePosition(str);
        style3 = style3.slice(str.length);
        return m;
      }
      function whitespace2() {
        match3(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment2()) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }
      function comment2() {
        var pos = position6();
        if (FORWARD_SLASH != style3.charAt(0) || ASTERISK != style3.charAt(1))
          return;
        var i = 2;
        while (EMPTY_STRING != style3.charAt(i) && (ASTERISK != style3.charAt(i) || FORWARD_SLASH != style3.charAt(i + 1))) {
          ++i;
        }
        i += 2;
        if (EMPTY_STRING === style3.charAt(i - 1)) {
          return error2("End of comment missing");
        }
        var str = style3.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style3 = style3.slice(i);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position6();
        var prop = match3(PROPERTY_REGEX);
        if (!prop)
          return;
        comment2();
        if (!match3(COLON_REGEX))
          return error2("property missing ':'");
        var val = match3(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim2(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim2(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match3(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim2(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/style-to-object/index.js
var require_style_to_object = __commonJS({
  "node_modules/style-to-object/index.js"(exports, module2) {
    var parse8 = require_inline_style_parser();
    function StyleToObject2(style3, iterator) {
      var output = null;
      if (!style3 || typeof style3 !== "string") {
        return output;
      }
      var declaration;
      var declarations = parse8(style3);
      var hasIterator = typeof iterator === "function";
      var property;
      var value;
      for (var i = 0, len = declarations.length; i < len; i++) {
        declaration = declarations[i];
        property = declaration.property;
        value = declaration.value;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }
      return output;
    }
    module2.exports = StyleToObject2;
    module2.exports.default = StyleToObject2;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/common/unicode.js
var require_unicode = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/common/unicode.js"(exports) {
    "use strict";
    var UNDEFINED_CODE_POINTS = [
      65534,
      65535,
      131070,
      131071,
      196606,
      196607,
      262142,
      262143,
      327678,
      327679,
      393214,
      393215,
      458750,
      458751,
      524286,
      524287,
      589822,
      589823,
      655358,
      655359,
      720894,
      720895,
      786430,
      786431,
      851966,
      851967,
      917502,
      917503,
      983038,
      983039,
      1048574,
      1048575,
      1114110,
      1114111
    ];
    exports.REPLACEMENT_CHARACTER = "\uFFFD";
    exports.CODE_POINTS = {
      EOF: -1,
      NULL: 0,
      TABULATION: 9,
      CARRIAGE_RETURN: 13,
      LINE_FEED: 10,
      FORM_FEED: 12,
      SPACE: 32,
      EXCLAMATION_MARK: 33,
      QUOTATION_MARK: 34,
      NUMBER_SIGN: 35,
      AMPERSAND: 38,
      APOSTROPHE: 39,
      HYPHEN_MINUS: 45,
      SOLIDUS: 47,
      DIGIT_0: 48,
      DIGIT_9: 57,
      SEMICOLON: 59,
      LESS_THAN_SIGN: 60,
      EQUALS_SIGN: 61,
      GREATER_THAN_SIGN: 62,
      QUESTION_MARK: 63,
      LATIN_CAPITAL_A: 65,
      LATIN_CAPITAL_F: 70,
      LATIN_CAPITAL_X: 88,
      LATIN_CAPITAL_Z: 90,
      RIGHT_SQUARE_BRACKET: 93,
      GRAVE_ACCENT: 96,
      LATIN_SMALL_A: 97,
      LATIN_SMALL_F: 102,
      LATIN_SMALL_X: 120,
      LATIN_SMALL_Z: 122,
      REPLACEMENT_CHARACTER: 65533
    };
    exports.CODE_POINT_SEQUENCES = {
      DASH_DASH_STRING: [45, 45],
      DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
      CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
      SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
      PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
      SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
    };
    exports.isSurrogate = function(cp) {
      return cp >= 55296 && cp <= 57343;
    };
    exports.isSurrogatePair = function(cp) {
      return cp >= 56320 && cp <= 57343;
    };
    exports.getSurrogatePairCodePoint = function(cp1, cp2) {
      return (cp1 - 55296) * 1024 + 9216 + cp2;
    };
    exports.isControlCodePoint = function(cp) {
      return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
    };
    exports.isUndefinedCodePoint = function(cp) {
      return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
    };
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/common/error-codes.js
var require_error_codes = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/common/error-codes.js"(exports, module2) {
    "use strict";
    module2.exports = {
      controlCharacterInInputStream: "control-character-in-input-stream",
      noncharacterInInputStream: "noncharacter-in-input-stream",
      surrogateInInputStream: "surrogate-in-input-stream",
      nonVoidHtmlElementStartTagWithTrailingSolidus: "non-void-html-element-start-tag-with-trailing-solidus",
      endTagWithAttributes: "end-tag-with-attributes",
      endTagWithTrailingSolidus: "end-tag-with-trailing-solidus",
      unexpectedSolidusInTag: "unexpected-solidus-in-tag",
      unexpectedNullCharacter: "unexpected-null-character",
      unexpectedQuestionMarkInsteadOfTagName: "unexpected-question-mark-instead-of-tag-name",
      invalidFirstCharacterOfTagName: "invalid-first-character-of-tag-name",
      unexpectedEqualsSignBeforeAttributeName: "unexpected-equals-sign-before-attribute-name",
      missingEndTagName: "missing-end-tag-name",
      unexpectedCharacterInAttributeName: "unexpected-character-in-attribute-name",
      unknownNamedCharacterReference: "unknown-named-character-reference",
      missingSemicolonAfterCharacterReference: "missing-semicolon-after-character-reference",
      unexpectedCharacterAfterDoctypeSystemIdentifier: "unexpected-character-after-doctype-system-identifier",
      unexpectedCharacterInUnquotedAttributeValue: "unexpected-character-in-unquoted-attribute-value",
      eofBeforeTagName: "eof-before-tag-name",
      eofInTag: "eof-in-tag",
      missingAttributeValue: "missing-attribute-value",
      missingWhitespaceBetweenAttributes: "missing-whitespace-between-attributes",
      missingWhitespaceAfterDoctypePublicKeyword: "missing-whitespace-after-doctype-public-keyword",
      missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: "missing-whitespace-between-doctype-public-and-system-identifiers",
      missingWhitespaceAfterDoctypeSystemKeyword: "missing-whitespace-after-doctype-system-keyword",
      missingQuoteBeforeDoctypePublicIdentifier: "missing-quote-before-doctype-public-identifier",
      missingQuoteBeforeDoctypeSystemIdentifier: "missing-quote-before-doctype-system-identifier",
      missingDoctypePublicIdentifier: "missing-doctype-public-identifier",
      missingDoctypeSystemIdentifier: "missing-doctype-system-identifier",
      abruptDoctypePublicIdentifier: "abrupt-doctype-public-identifier",
      abruptDoctypeSystemIdentifier: "abrupt-doctype-system-identifier",
      cdataInHtmlContent: "cdata-in-html-content",
      incorrectlyOpenedComment: "incorrectly-opened-comment",
      eofInScriptHtmlCommentLikeText: "eof-in-script-html-comment-like-text",
      eofInDoctype: "eof-in-doctype",
      nestedComment: "nested-comment",
      abruptClosingOfEmptyComment: "abrupt-closing-of-empty-comment",
      eofInComment: "eof-in-comment",
      incorrectlyClosedComment: "incorrectly-closed-comment",
      eofInCdata: "eof-in-cdata",
      absenceOfDigitsInNumericCharacterReference: "absence-of-digits-in-numeric-character-reference",
      nullCharacterReference: "null-character-reference",
      surrogateCharacterReference: "surrogate-character-reference",
      characterReferenceOutsideUnicodeRange: "character-reference-outside-unicode-range",
      controlCharacterReference: "control-character-reference",
      noncharacterCharacterReference: "noncharacter-character-reference",
      missingWhitespaceBeforeDoctypeName: "missing-whitespace-before-doctype-name",
      missingDoctypeName: "missing-doctype-name",
      invalidCharacterSequenceAfterDoctypeName: "invalid-character-sequence-after-doctype-name",
      duplicateAttribute: "duplicate-attribute",
      nonConformingDoctype: "non-conforming-doctype",
      missingDoctype: "missing-doctype",
      misplacedDoctype: "misplaced-doctype",
      endTagWithoutMatchingOpenElement: "end-tag-without-matching-open-element",
      closingOfElementWithOpenChildElements: "closing-of-element-with-open-child-elements",
      disallowedContentInNoscriptInHead: "disallowed-content-in-noscript-in-head",
      openElementsLeftAfterEof: "open-elements-left-after-eof",
      abandonedHeadElementChild: "abandoned-head-element-child",
      misplacedStartTagForHeadElement: "misplaced-start-tag-for-head-element",
      nestedNoscriptInHead: "nested-noscript-in-head",
      eofInElementThatCanContainOnlyText: "eof-in-element-that-can-contain-only-text"
    };
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/preprocessor.js
var require_preprocessor = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/preprocessor.js"(exports, module2) {
    "use strict";
    var unicode = require_unicode();
    var ERR = require_error_codes();
    var $ = unicode.CODE_POINTS;
    var DEFAULT_BUFFER_WATERLINE = 1 << 16;
    var Preprocessor = class {
      constructor() {
        this.html = null;
        this.pos = -1;
        this.lastGapPos = -1;
        this.lastCharPos = -1;
        this.gapStack = [];
        this.skipNextNewLine = false;
        this.lastChunkWritten = false;
        this.endOfChunkHit = false;
        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
      }
      _err() {
      }
      _addGap() {
        this.gapStack.push(this.lastGapPos);
        this.lastGapPos = this.pos;
      }
      _processSurrogate(cp) {
        if (this.pos !== this.lastCharPos) {
          const nextCp = this.html.charCodeAt(this.pos + 1);
          if (unicode.isSurrogatePair(nextCp)) {
            this.pos++;
            this._addGap();
            return unicode.getSurrogatePairCodePoint(cp, nextCp);
          }
        } else if (!this.lastChunkWritten) {
          this.endOfChunkHit = true;
          return $.EOF;
        }
        this._err(ERR.surrogateInInputStream);
        return cp;
      }
      dropParsedChunk() {
        if (this.pos > this.bufferWaterline) {
          this.lastCharPos -= this.pos;
          this.html = this.html.substring(this.pos);
          this.pos = 0;
          this.lastGapPos = -1;
          this.gapStack = [];
        }
      }
      write(chunk, isLastChunk) {
        if (this.html) {
          this.html += chunk;
        } else {
          this.html = chunk;
        }
        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
        this.lastChunkWritten = isLastChunk;
      }
      insertHtmlAtCurrentPos(chunk) {
        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);
        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
      }
      advance() {
        this.pos++;
        if (this.pos > this.lastCharPos) {
          this.endOfChunkHit = !this.lastChunkWritten;
          return $.EOF;
        }
        let cp = this.html.charCodeAt(this.pos);
        if (this.skipNextNewLine && cp === $.LINE_FEED) {
          this.skipNextNewLine = false;
          this._addGap();
          return this.advance();
        }
        if (cp === $.CARRIAGE_RETURN) {
          this.skipNextNewLine = true;
          return $.LINE_FEED;
        }
        this.skipNextNewLine = false;
        if (unicode.isSurrogate(cp)) {
          cp = this._processSurrogate(cp);
        }
        const isCommonValidRange = cp > 31 && cp < 127 || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 159 && cp < 64976;
        if (!isCommonValidRange) {
          this._checkForProblematicCharacters(cp);
        }
        return cp;
      }
      _checkForProblematicCharacters(cp) {
        if (unicode.isControlCodePoint(cp)) {
          this._err(ERR.controlCharacterInInputStream);
        } else if (unicode.isUndefinedCodePoint(cp)) {
          this._err(ERR.noncharacterInInputStream);
        }
      }
      retreat() {
        if (this.pos === this.lastGapPos) {
          this.lastGapPos = this.gapStack.pop();
          this.pos--;
        }
        this.pos--;
      }
    };
    module2.exports = Preprocessor;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/named-entity-data.js
var require_named_entity_data = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/named-entity-data.js"(exports, module2) {
    "use strict";
    module2.exports = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/index.js
var require_tokenizer = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/tokenizer/index.js"(exports, module2) {
    "use strict";
    var Preprocessor = require_preprocessor();
    var unicode = require_unicode();
    var neTree = require_named_entity_data();
    var ERR = require_error_codes();
    var $ = unicode.CODE_POINTS;
    var $$ = unicode.CODE_POINT_SEQUENCES;
    var C1_CONTROLS_REFERENCE_REPLACEMENTS = {
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376
    };
    var HAS_DATA_FLAG = 1 << 0;
    var DATA_DUPLET_FLAG = 1 << 1;
    var HAS_BRANCHES_FLAG = 1 << 2;
    var MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;
    var DATA_STATE = "DATA_STATE";
    var RCDATA_STATE = "RCDATA_STATE";
    var RAWTEXT_STATE = "RAWTEXT_STATE";
    var SCRIPT_DATA_STATE = "SCRIPT_DATA_STATE";
    var PLAINTEXT_STATE = "PLAINTEXT_STATE";
    var TAG_OPEN_STATE = "TAG_OPEN_STATE";
    var END_TAG_OPEN_STATE = "END_TAG_OPEN_STATE";
    var TAG_NAME_STATE = "TAG_NAME_STATE";
    var RCDATA_LESS_THAN_SIGN_STATE = "RCDATA_LESS_THAN_SIGN_STATE";
    var RCDATA_END_TAG_OPEN_STATE = "RCDATA_END_TAG_OPEN_STATE";
    var RCDATA_END_TAG_NAME_STATE = "RCDATA_END_TAG_NAME_STATE";
    var RAWTEXT_LESS_THAN_SIGN_STATE = "RAWTEXT_LESS_THAN_SIGN_STATE";
    var RAWTEXT_END_TAG_OPEN_STATE = "RAWTEXT_END_TAG_OPEN_STATE";
    var RAWTEXT_END_TAG_NAME_STATE = "RAWTEXT_END_TAG_NAME_STATE";
    var SCRIPT_DATA_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_LESS_THAN_SIGN_STATE";
    var SCRIPT_DATA_END_TAG_OPEN_STATE = "SCRIPT_DATA_END_TAG_OPEN_STATE";
    var SCRIPT_DATA_END_TAG_NAME_STATE = "SCRIPT_DATA_END_TAG_NAME_STATE";
    var SCRIPT_DATA_ESCAPE_START_STATE = "SCRIPT_DATA_ESCAPE_START_STATE";
    var SCRIPT_DATA_ESCAPE_START_DASH_STATE = "SCRIPT_DATA_ESCAPE_START_DASH_STATE";
    var SCRIPT_DATA_ESCAPED_STATE = "SCRIPT_DATA_ESCAPED_STATE";
    var SCRIPT_DATA_ESCAPED_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_STATE";
    var SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE";
    var SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE";
    var SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE";
    var SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE";
    var SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE";
    var SCRIPT_DATA_DOUBLE_ESCAPED_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE";
    var SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE";
    var SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE";
    var SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE";
    var SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE";
    var BEFORE_ATTRIBUTE_NAME_STATE = "BEFORE_ATTRIBUTE_NAME_STATE";
    var ATTRIBUTE_NAME_STATE = "ATTRIBUTE_NAME_STATE";
    var AFTER_ATTRIBUTE_NAME_STATE = "AFTER_ATTRIBUTE_NAME_STATE";
    var BEFORE_ATTRIBUTE_VALUE_STATE = "BEFORE_ATTRIBUTE_VALUE_STATE";
    var ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE";
    var ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE";
    var ATTRIBUTE_VALUE_UNQUOTED_STATE = "ATTRIBUTE_VALUE_UNQUOTED_STATE";
    var AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE";
    var SELF_CLOSING_START_TAG_STATE = "SELF_CLOSING_START_TAG_STATE";
    var BOGUS_COMMENT_STATE = "BOGUS_COMMENT_STATE";
    var MARKUP_DECLARATION_OPEN_STATE = "MARKUP_DECLARATION_OPEN_STATE";
    var COMMENT_START_STATE = "COMMENT_START_STATE";
    var COMMENT_START_DASH_STATE = "COMMENT_START_DASH_STATE";
    var COMMENT_STATE = "COMMENT_STATE";
    var COMMENT_LESS_THAN_SIGN_STATE = "COMMENT_LESS_THAN_SIGN_STATE";
    var COMMENT_LESS_THAN_SIGN_BANG_STATE = "COMMENT_LESS_THAN_SIGN_BANG_STATE";
    var COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE";
    var COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE";
    var COMMENT_END_DASH_STATE = "COMMENT_END_DASH_STATE";
    var COMMENT_END_STATE = "COMMENT_END_STATE";
    var COMMENT_END_BANG_STATE = "COMMENT_END_BANG_STATE";
    var DOCTYPE_STATE = "DOCTYPE_STATE";
    var BEFORE_DOCTYPE_NAME_STATE = "BEFORE_DOCTYPE_NAME_STATE";
    var DOCTYPE_NAME_STATE = "DOCTYPE_NAME_STATE";
    var AFTER_DOCTYPE_NAME_STATE = "AFTER_DOCTYPE_NAME_STATE";
    var AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = "AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE";
    var BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
    var DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE";
    var DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE";
    var AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
    var BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE";
    var AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = "AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE";
    var BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
    var DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE";
    var DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE";
    var AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
    var BOGUS_DOCTYPE_STATE = "BOGUS_DOCTYPE_STATE";
    var CDATA_SECTION_STATE = "CDATA_SECTION_STATE";
    var CDATA_SECTION_BRACKET_STATE = "CDATA_SECTION_BRACKET_STATE";
    var CDATA_SECTION_END_STATE = "CDATA_SECTION_END_STATE";
    var CHARACTER_REFERENCE_STATE = "CHARACTER_REFERENCE_STATE";
    var NAMED_CHARACTER_REFERENCE_STATE = "NAMED_CHARACTER_REFERENCE_STATE";
    var AMBIGUOUS_AMPERSAND_STATE = "AMBIGUOS_AMPERSAND_STATE";
    var NUMERIC_CHARACTER_REFERENCE_STATE = "NUMERIC_CHARACTER_REFERENCE_STATE";
    var HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_START_STATE";
    var DECIMAL_CHARACTER_REFERENCE_START_STATE = "DECIMAL_CHARACTER_REFERENCE_START_STATE";
    var HEXADEMICAL_CHARACTER_REFERENCE_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_STATE";
    var DECIMAL_CHARACTER_REFERENCE_STATE = "DECIMAL_CHARACTER_REFERENCE_STATE";
    var NUMERIC_CHARACTER_REFERENCE_END_STATE = "NUMERIC_CHARACTER_REFERENCE_END_STATE";
    function isWhitespace(cp) {
      return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;
    }
    function isAsciiDigit(cp) {
      return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;
    }
    function isAsciiUpper(cp) {
      return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;
    }
    function isAsciiLower(cp) {
      return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;
    }
    function isAsciiLetter(cp) {
      return isAsciiLower(cp) || isAsciiUpper(cp);
    }
    function isAsciiAlphaNumeric(cp) {
      return isAsciiLetter(cp) || isAsciiDigit(cp);
    }
    function isAsciiUpperHexDigit(cp) {
      return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F;
    }
    function isAsciiLowerHexDigit(cp) {
      return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F;
    }
    function isAsciiHexDigit(cp) {
      return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
    }
    function toAsciiLowerCodePoint(cp) {
      return cp + 32;
    }
    function toChar(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      }
      cp -= 65536;
      return String.fromCharCode(cp >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | cp & 1023);
    }
    function toAsciiLowerChar(cp) {
      return String.fromCharCode(toAsciiLowerCodePoint(cp));
    }
    function findNamedEntityTreeBranch(nodeIx, cp) {
      const branchCount = neTree[++nodeIx];
      let lo = ++nodeIx;
      let hi = lo + branchCount - 1;
      while (lo <= hi) {
        const mid = lo + hi >>> 1;
        const midCp = neTree[mid];
        if (midCp < cp) {
          lo = mid + 1;
        } else if (midCp > cp) {
          hi = mid - 1;
        } else {
          return neTree[mid + branchCount];
        }
      }
      return -1;
    }
    var Tokenizer = class {
      constructor() {
        this.preprocessor = new Preprocessor();
        this.tokenQueue = [];
        this.allowCDATA = false;
        this.state = DATA_STATE;
        this.returnState = "";
        this.charRefCode = -1;
        this.tempBuff = [];
        this.lastStartTagName = "";
        this.consumedAfterSnapshot = -1;
        this.active = false;
        this.currentCharacterToken = null;
        this.currentToken = null;
        this.currentAttr = null;
      }
      _err() {
      }
      _errOnNextCodePoint(err) {
        this._consume();
        this._err(err);
        this._unconsume();
      }
      getNextToken() {
        while (!this.tokenQueue.length && this.active) {
          this.consumedAfterSnapshot = 0;
          const cp = this._consume();
          if (!this._ensureHibernation()) {
            this[this.state](cp);
          }
        }
        return this.tokenQueue.shift();
      }
      write(chunk, isLastChunk) {
        this.active = true;
        this.preprocessor.write(chunk, isLastChunk);
      }
      insertHtmlAtCurrentPos(chunk) {
        this.active = true;
        this.preprocessor.insertHtmlAtCurrentPos(chunk);
      }
      _ensureHibernation() {
        if (this.preprocessor.endOfChunkHit) {
          for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
            this.preprocessor.retreat();
          }
          this.active = false;
          this.tokenQueue.push({ type: Tokenizer.HIBERNATION_TOKEN });
          return true;
        }
        return false;
      }
      _consume() {
        this.consumedAfterSnapshot++;
        return this.preprocessor.advance();
      }
      _unconsume() {
        this.consumedAfterSnapshot--;
        this.preprocessor.retreat();
      }
      _reconsumeInState(state) {
        this.state = state;
        this._unconsume();
      }
      _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
        let consumedCount = 0;
        let isMatch = true;
        const patternLength = pattern.length;
        let patternPos = 0;
        let cp = startCp;
        let patternCp = void 0;
        for (; patternPos < patternLength; patternPos++) {
          if (patternPos > 0) {
            cp = this._consume();
            consumedCount++;
          }
          if (cp === $.EOF) {
            isMatch = false;
            break;
          }
          patternCp = pattern[patternPos];
          if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
            isMatch = false;
            break;
          }
        }
        if (!isMatch) {
          while (consumedCount--) {
            this._unconsume();
          }
        }
        return isMatch;
      }
      _isTempBufferEqualToScriptString() {
        if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
          return false;
        }
        for (let i = 0; i < this.tempBuff.length; i++) {
          if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
            return false;
          }
        }
        return true;
      }
      _createStartTagToken() {
        this.currentToken = {
          type: Tokenizer.START_TAG_TOKEN,
          tagName: "",
          selfClosing: false,
          ackSelfClosing: false,
          attrs: []
        };
      }
      _createEndTagToken() {
        this.currentToken = {
          type: Tokenizer.END_TAG_TOKEN,
          tagName: "",
          selfClosing: false,
          attrs: []
        };
      }
      _createCommentToken() {
        this.currentToken = {
          type: Tokenizer.COMMENT_TOKEN,
          data: ""
        };
      }
      _createDoctypeToken(initialName) {
        this.currentToken = {
          type: Tokenizer.DOCTYPE_TOKEN,
          name: initialName,
          forceQuirks: false,
          publicId: null,
          systemId: null
        };
      }
      _createCharacterToken(type2, ch) {
        this.currentCharacterToken = {
          type: type2,
          chars: ch
        };
      }
      _createEOFToken() {
        this.currentToken = { type: Tokenizer.EOF_TOKEN };
      }
      _createAttr(attrNameFirstCh) {
        this.currentAttr = {
          name: attrNameFirstCh,
          value: ""
        };
      }
      _leaveAttrName(toState) {
        if (Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
          this.currentToken.attrs.push(this.currentAttr);
        } else {
          this._err(ERR.duplicateAttribute);
        }
        this.state = toState;
      }
      _leaveAttrValue(toState) {
        this.state = toState;
      }
      _emitCurrentToken() {
        this._emitCurrentCharacterToken();
        const ct = this.currentToken;
        this.currentToken = null;
        if (ct.type === Tokenizer.START_TAG_TOKEN) {
          this.lastStartTagName = ct.tagName;
        } else if (ct.type === Tokenizer.END_TAG_TOKEN) {
          if (ct.attrs.length > 0) {
            this._err(ERR.endTagWithAttributes);
          }
          if (ct.selfClosing) {
            this._err(ERR.endTagWithTrailingSolidus);
          }
        }
        this.tokenQueue.push(ct);
      }
      _emitCurrentCharacterToken() {
        if (this.currentCharacterToken) {
          this.tokenQueue.push(this.currentCharacterToken);
          this.currentCharacterToken = null;
        }
      }
      _emitEOFToken() {
        this._createEOFToken();
        this._emitCurrentToken();
      }
      _appendCharToCurrentCharacterToken(type2, ch) {
        if (this.currentCharacterToken && this.currentCharacterToken.type !== type2) {
          this._emitCurrentCharacterToken();
        }
        if (this.currentCharacterToken) {
          this.currentCharacterToken.chars += ch;
        } else {
          this._createCharacterToken(type2, ch);
        }
      }
      _emitCodePoint(cp) {
        let type2 = Tokenizer.CHARACTER_TOKEN;
        if (isWhitespace(cp)) {
          type2 = Tokenizer.WHITESPACE_CHARACTER_TOKEN;
        } else if (cp === $.NULL) {
          type2 = Tokenizer.NULL_CHARACTER_TOKEN;
        }
        this._appendCharToCurrentCharacterToken(type2, toChar(cp));
      }
      _emitSeveralCodePoints(codePoints) {
        for (let i = 0; i < codePoints.length; i++) {
          this._emitCodePoint(codePoints[i]);
        }
      }
      _emitChars(ch) {
        this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);
      }
      _matchNamedCharacterReference(startCp) {
        let result = null;
        let excess = 1;
        let i = findNamedEntityTreeBranch(0, startCp);
        this.tempBuff.push(startCp);
        while (i > -1) {
          const current = neTree[i];
          const inNode = current < MAX_BRANCH_MARKER_VALUE;
          const nodeWithData = inNode && current & HAS_DATA_FLAG;
          if (nodeWithData) {
            result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
            excess = 0;
          }
          const cp = this._consume();
          this.tempBuff.push(cp);
          excess++;
          if (cp === $.EOF) {
            break;
          }
          if (inNode) {
            i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
          } else {
            i = cp === current ? ++i : -1;
          }
        }
        while (excess--) {
          this.tempBuff.pop();
          this._unconsume();
        }
        return result;
      }
      _isCharacterReferenceInAttribute() {
        return this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE;
      }
      _isCharacterReferenceAttributeQuirk(withSemicolon) {
        if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
          const nextCp = this._consume();
          this._unconsume();
          return nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
        }
        return false;
      }
      _flushCodePointsConsumedAsCharacterReference() {
        if (this._isCharacterReferenceInAttribute()) {
          for (let i = 0; i < this.tempBuff.length; i++) {
            this.currentAttr.value += toChar(this.tempBuff[i]);
          }
        } else {
          this._emitSeveralCodePoints(this.tempBuff);
        }
        this.tempBuff = [];
      }
      [DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $.LESS_THAN_SIGN) {
          this.state = TAG_OPEN_STATE;
        } else if (cp === $.AMPERSAND) {
          this.returnState = DATA_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._emitCodePoint(cp);
        } else if (cp === $.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [RCDATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $.AMPERSAND) {
          this.returnState = RCDATA_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $.LESS_THAN_SIGN) {
          this.state = RCDATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [RAWTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $.LESS_THAN_SIGN) {
          this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [SCRIPT_DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [PLAINTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [TAG_OPEN_STATE](cp) {
        if (cp === $.EXCLAMATION_MARK) {
          this.state = MARKUP_DECLARATION_OPEN_STATE;
        } else if (cp === $.SOLIDUS) {
          this.state = END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
          this._createStartTagToken();
          this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $.QUESTION_MARK) {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken();
          this._reconsumeInState(BOGUS_COMMENT_STATE);
        } else if (cp === $.EOF) {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
        } else {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this._reconsumeInState(DATA_STATE);
        }
      }
      [END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.missingEndTagName);
          this.state = DATA_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
        } else {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken();
          this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
      }
      [TAG_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        } else if (cp === $.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.tagName += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentToken.tagName += toChar(cp);
        }
      }
      [RCDATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $.SOLIDUS) {
          this.tempBuff = [];
          this.state = RCDATA_END_TAG_OPEN_STATE;
        } else {
          this._emitChars("<");
          this._reconsumeInState(RCDATA_STATE);
        }
      }
      [RCDATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(RCDATA_STATE);
        }
      }
      [RCDATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            }
            if (cp === $.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            }
            if (cp === $.GREATER_THAN_SIGN) {
              this.state = DATA_STATE;
              this._emitCurrentToken();
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(RCDATA_STATE);
        }
      }
      [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $.SOLIDUS) {
          this.tempBuff = [];
          this.state = RAWTEXT_END_TAG_OPEN_STATE;
        } else {
          this._emitChars("<");
          this._reconsumeInState(RAWTEXT_STATE);
        }
      }
      [RAWTEXT_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(RAWTEXT_STATE);
        }
      }
      [RAWTEXT_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            }
            if (cp === $.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            }
            if (cp === $.GREATER_THAN_SIGN) {
              this._emitCurrentToken();
              this.state = DATA_STATE;
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(RAWTEXT_STATE);
        }
      }
      [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $.SOLIDUS) {
          this.tempBuff = [];
          this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
        } else if (cp === $.EXCLAMATION_MARK) {
          this.state = SCRIPT_DATA_ESCAPE_START_STATE;
          this._emitChars("<!");
        } else {
          this._emitChars("<");
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            } else if (cp === $.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            } else if (cp === $.GREATER_THAN_SIGN) {
              this._emitCurrentToken();
              this.state = DATA_STATE;
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
          this._emitChars("-");
        } else {
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
          this._emitChars("-");
        } else {
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      [SCRIPT_DATA_ESCAPED_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this._emitChars("-");
        } else if (cp === $.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this.state = SCRIPT_DATA_STATE;
          this._emitChars(">");
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $.SOLIDUS) {
          this.tempBuff = [];
          this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
          this.tempBuff = [];
          this._emitChars("<");
          this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
        } else {
          this._emitChars("<");
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            }
            if (cp === $.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            }
            if (cp === $.GREATER_THAN_SIGN) {
              this._emitCurrentToken();
              this.state = DATA_STATE;
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
          this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
          this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
          this.tempBuff.push(toAsciiLowerCodePoint(cp));
          this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
          this.tempBuff.push(cp);
          this._emitCodePoint(cp);
        } else {
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
          this._emitChars("<");
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
          this._emitChars("<");
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this._emitChars("-");
        } else if (cp === $.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
          this._emitChars("<");
        } else if (cp === $.GREATER_THAN_SIGN) {
          this.state = SCRIPT_DATA_STATE;
          this._emitChars(">");
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitChars(unicode.REPLACEMENT_CHARACTER);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $.SOLIDUS) {
          this.tempBuff = [];
          this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
          this._emitChars("/");
        } else {
          this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
      }
      [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
          this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
          this.tempBuff.push(toAsciiLowerCodePoint(cp));
          this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
          this.tempBuff.push(cp);
          this._emitCodePoint(cp);
        } else {
          this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
      }
      [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
          this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
        } else if (cp === $.EQUALS_SIGN) {
          this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
          this._createAttr("=");
          this.state = ATTRIBUTE_NAME_STATE;
        } else {
          this._createAttr("");
          this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
      }
      [ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
          this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
          this._unconsume();
        } else if (cp === $.EQUALS_SIGN) {
          this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
        } else if (isAsciiUpper(cp)) {
          this.currentAttr.name += toAsciiLowerChar(cp);
        } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {
          this._err(ERR.unexpectedCharacterInAttributeName);
          this.currentAttr.name += toChar(cp);
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.name += unicode.REPLACEMENT_CHARACTER;
        } else {
          this.currentAttr.name += toChar(cp);
        }
      }
      [AFTER_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $.EQUALS_SIGN) {
          this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
        } else {
          this._createAttr("");
          this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
      }
      [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.QUOTATION_MARK) {
          this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
        } else if (cp === $.APOSTROPHE) {
          this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.missingAttributeValue);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else {
          this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
        }
      }
      [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $.QUOTATION_MARK) {
          this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $.AMPERSAND) {
          this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentAttr.value += toChar(cp);
        }
      }
      [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
        if (cp === $.APOSTROPHE) {
          this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $.AMPERSAND) {
          this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentAttr.value += toChar(cp);
        }
      }
      [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
        if (isWhitespace(cp)) {
          this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $.AMPERSAND) {
          this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._leaveAttrValue(DATA_STATE);
          this._emitCurrentToken();
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN || cp === $.EQUALS_SIGN || cp === $.GRAVE_ACCENT) {
          this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
          this.currentAttr.value += toChar(cp);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentAttr.value += toChar(cp);
        }
      }
      [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
        if (isWhitespace(cp)) {
          this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $.SOLIDUS) {
          this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._leaveAttrValue(DATA_STATE);
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
        } else {
          this._err(ERR.missingWhitespaceBetweenAttributes);
          this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
      }
      [SELF_CLOSING_START_TAG_STATE](cp) {
        if (cp === $.GREATER_THAN_SIGN) {
          this.currentToken.selfClosing = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInTag);
          this._emitEOFToken();
        } else {
          this._err(ERR.unexpectedSolidusInTag);
          this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
      }
      [BOGUS_COMMENT_STATE](cp) {
        if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._emitCurrentToken();
          this._emitEOFToken();
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
        } else {
          this.currentToken.data += toChar(cp);
        }
      }
      [MARKUP_DECLARATION_OPEN_STATE](cp) {
        if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
          this._createCommentToken();
          this.state = COMMENT_START_STATE;
        } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
          this.state = DOCTYPE_STATE;
        } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
          if (this.allowCDATA) {
            this.state = CDATA_SECTION_STATE;
          } else {
            this._err(ERR.cdataInHtmlContent);
            this._createCommentToken();
            this.currentToken.data = "[CDATA[";
            this.state = BOGUS_COMMENT_STATE;
          }
        } else if (!this._ensureHibernation()) {
          this._err(ERR.incorrectlyOpenedComment);
          this._createCommentToken();
          this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
      }
      [COMMENT_START_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = COMMENT_START_DASH_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.abruptClosingOfEmptyComment);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else {
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      [COMMENT_START_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = COMMENT_END_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.abruptClosingOfEmptyComment);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "-";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      [COMMENT_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $.LESS_THAN_SIGN) {
          this.currentToken.data += "<";
          this.state = COMMENT_LESS_THAN_SIGN_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += toChar(cp);
        }
      }
      [COMMENT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $.EXCLAMATION_MARK) {
          this.currentToken.data += "!";
          this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
        } else if (cp === $.LESS_THAN_SIGN) {
          this.currentToken.data += "!";
        } else {
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
        } else {
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
        } else {
          this._reconsumeInState(COMMENT_END_DASH_STATE);
        }
      }
      [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
        if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {
          this._err(ERR.nestedComment);
        }
        this._reconsumeInState(COMMENT_END_STATE);
      }
      [COMMENT_END_DASH_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.state = COMMENT_END_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "-";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      [COMMENT_END_STATE](cp) {
        if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EXCLAMATION_MARK) {
          this.state = COMMENT_END_BANG_STATE;
        } else if (cp === $.HYPHEN_MINUS) {
          this.currentToken.data += "-";
        } else if (cp === $.EOF) {
          this._err(ERR.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "--";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      [COMMENT_END_BANG_STATE](cp) {
        if (cp === $.HYPHEN_MINUS) {
          this.currentToken.data += "--!";
          this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.incorrectlyClosedComment);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "--!";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      [DOCTYPE_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_DOCTYPE_NAME_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.missingWhitespaceBeforeDoctypeName);
          this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        }
      }
      [BEFORE_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (isAsciiUpper(cp)) {
          this._createDoctypeToken(toAsciiLowerChar(cp));
          this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(unicode.REPLACEMENT_CHARACTER);
          this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._createDoctypeToken(toChar(cp));
          this.state = DOCTYPE_NAME_STATE;
        }
      }
      [DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = AFTER_DOCTYPE_NAME_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
          this.currentToken.name += toAsciiLowerChar(cp);
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.name += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.name += toChar(cp);
        }
      }
      [AFTER_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
          this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
        } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
          this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $.QUOTATION_MARK) {
          this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $.APOSTROPHE) {
          this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.missingDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.QUOTATION_MARK) {
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $.APOSTROPHE) {
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.missingDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $.QUOTATION_MARK) {
          this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.abruptDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.publicId += toChar(cp);
        }
      }
      [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $.APOSTROPHE) {
          this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.abruptDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.publicId += toChar(cp);
        }
      }
      [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.QUOTATION_MARK) {
          this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $.APOSTROPHE) {
          this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.QUOTATION_MARK) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $.APOSTROPHE) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $.QUOTATION_MARK) {
          this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $.APOSTROPHE) {
          this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.missingDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.QUOTATION_MARK) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $.APOSTROPHE) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.missingDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $.QUOTATION_MARK) {
          this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.abruptDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.systemId += toChar(cp);
        }
      }
      [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $.APOSTROPHE) {
          this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
          this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._err(ERR.abruptDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.systemId += toChar(cp);
        }
      }
      [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      [BOGUS_DOCTYPE_STATE](cp) {
        if (cp === $.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $.NULL) {
          this._err(ERR.unexpectedNullCharacter);
        } else if (cp === $.EOF) {
          this._emitCurrentToken();
          this._emitEOFToken();
        }
      }
      [CDATA_SECTION_STATE](cp) {
        if (cp === $.RIGHT_SQUARE_BRACKET) {
          this.state = CDATA_SECTION_BRACKET_STATE;
        } else if (cp === $.EOF) {
          this._err(ERR.eofInCdata);
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      [CDATA_SECTION_BRACKET_STATE](cp) {
        if (cp === $.RIGHT_SQUARE_BRACKET) {
          this.state = CDATA_SECTION_END_STATE;
        } else {
          this._emitChars("]");
          this._reconsumeInState(CDATA_SECTION_STATE);
        }
      }
      [CDATA_SECTION_END_STATE](cp) {
        if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
        } else if (cp === $.RIGHT_SQUARE_BRACKET) {
          this._emitChars("]");
        } else {
          this._emitChars("]]");
          this._reconsumeInState(CDATA_SECTION_STATE);
        }
      }
      [CHARACTER_REFERENCE_STATE](cp) {
        this.tempBuff = [$.AMPERSAND];
        if (cp === $.NUMBER_SIGN) {
          this.tempBuff.push(cp);
          this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
        } else if (isAsciiAlphaNumeric(cp)) {
          this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
        } else {
          this._flushCodePointsConsumedAsCharacterReference();
          this._reconsumeInState(this.returnState);
        }
      }
      [NAMED_CHARACTER_REFERENCE_STATE](cp) {
        const matchResult = this._matchNamedCharacterReference(cp);
        if (this._ensureHibernation()) {
          this.tempBuff = [$.AMPERSAND];
        } else if (matchResult) {
          const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $.SEMICOLON;
          if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
            if (!withSemicolon) {
              this._errOnNextCodePoint(ERR.missingSemicolonAfterCharacterReference);
            }
            this.tempBuff = matchResult;
          }
          this._flushCodePointsConsumedAsCharacterReference();
          this.state = this.returnState;
        } else {
          this._flushCodePointsConsumedAsCharacterReference();
          this.state = AMBIGUOUS_AMPERSAND_STATE;
        }
      }
      [AMBIGUOUS_AMPERSAND_STATE](cp) {
        if (isAsciiAlphaNumeric(cp)) {
          if (this._isCharacterReferenceInAttribute()) {
            this.currentAttr.value += toChar(cp);
          } else {
            this._emitCodePoint(cp);
          }
        } else {
          if (cp === $.SEMICOLON) {
            this._err(ERR.unknownNamedCharacterReference);
          }
          this._reconsumeInState(this.returnState);
        }
      }
      [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
        this.charRefCode = 0;
        if (cp === $.LATIN_SMALL_X || cp === $.LATIN_CAPITAL_X) {
          this.tempBuff.push(cp);
          this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
        } else {
          this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
        }
      }
      [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiHexDigit(cp)) {
          this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
        } else {
          this._err(ERR.absenceOfDigitsInNumericCharacterReference);
          this._flushCodePointsConsumedAsCharacterReference();
          this._reconsumeInState(this.returnState);
        }
      }
      [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiDigit(cp)) {
          this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
        } else {
          this._err(ERR.absenceOfDigitsInNumericCharacterReference);
          this._flushCodePointsConsumedAsCharacterReference();
          this._reconsumeInState(this.returnState);
        }
      }
      [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiUpperHexDigit(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 55;
        } else if (isAsciiLowerHexDigit(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 87;
        } else if (isAsciiDigit(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 48;
        } else if (cp === $.SEMICOLON) {
          this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
          this._err(ERR.missingSemicolonAfterCharacterReference);
          this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
      }
      [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiDigit(cp)) {
          this.charRefCode = this.charRefCode * 10 + cp - 48;
        } else if (cp === $.SEMICOLON) {
          this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
          this._err(ERR.missingSemicolonAfterCharacterReference);
          this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
      }
      [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
        if (this.charRefCode === $.NULL) {
          this._err(ERR.nullCharacterReference);
          this.charRefCode = $.REPLACEMENT_CHARACTER;
        } else if (this.charRefCode > 1114111) {
          this._err(ERR.characterReferenceOutsideUnicodeRange);
          this.charRefCode = $.REPLACEMENT_CHARACTER;
        } else if (unicode.isSurrogate(this.charRefCode)) {
          this._err(ERR.surrogateCharacterReference);
          this.charRefCode = $.REPLACEMENT_CHARACTER;
        } else if (unicode.isUndefinedCodePoint(this.charRefCode)) {
          this._err(ERR.noncharacterCharacterReference);
        } else if (unicode.isControlCodePoint(this.charRefCode) || this.charRefCode === $.CARRIAGE_RETURN) {
          this._err(ERR.controlCharacterReference);
          const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];
          if (replacement) {
            this.charRefCode = replacement;
          }
        }
        this.tempBuff = [this.charRefCode];
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    };
    Tokenizer.CHARACTER_TOKEN = "CHARACTER_TOKEN";
    Tokenizer.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
    Tokenizer.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
    Tokenizer.START_TAG_TOKEN = "START_TAG_TOKEN";
    Tokenizer.END_TAG_TOKEN = "END_TAG_TOKEN";
    Tokenizer.COMMENT_TOKEN = "COMMENT_TOKEN";
    Tokenizer.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
    Tokenizer.EOF_TOKEN = "EOF_TOKEN";
    Tokenizer.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
    Tokenizer.MODE = {
      DATA: DATA_STATE,
      RCDATA: RCDATA_STATE,
      RAWTEXT: RAWTEXT_STATE,
      SCRIPT_DATA: SCRIPT_DATA_STATE,
      PLAINTEXT: PLAINTEXT_STATE
    };
    Tokenizer.getTokenAttr = function(token, attrName) {
      for (let i = token.attrs.length - 1; i >= 0; i--) {
        if (token.attrs[i].name === attrName) {
          return token.attrs[i].value;
        }
      }
      return null;
    };
    module2.exports = Tokenizer;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/common/html.js
var require_html = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/common/html.js"(exports) {
    "use strict";
    var NS = exports.NAMESPACES = {
      HTML: "http://www.w3.org/1999/xhtml",
      MATHML: "http://www.w3.org/1998/Math/MathML",
      SVG: "http://www.w3.org/2000/svg",
      XLINK: "http://www.w3.org/1999/xlink",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    };
    exports.ATTRS = {
      TYPE: "type",
      ACTION: "action",
      ENCODING: "encoding",
      PROMPT: "prompt",
      NAME: "name",
      COLOR: "color",
      FACE: "face",
      SIZE: "size"
    };
    exports.DOCUMENT_MODE = {
      NO_QUIRKS: "no-quirks",
      QUIRKS: "quirks",
      LIMITED_QUIRKS: "limited-quirks"
    };
    var $ = exports.TAG_NAMES = {
      A: "a",
      ADDRESS: "address",
      ANNOTATION_XML: "annotation-xml",
      APPLET: "applet",
      AREA: "area",
      ARTICLE: "article",
      ASIDE: "aside",
      B: "b",
      BASE: "base",
      BASEFONT: "basefont",
      BGSOUND: "bgsound",
      BIG: "big",
      BLOCKQUOTE: "blockquote",
      BODY: "body",
      BR: "br",
      BUTTON: "button",
      CAPTION: "caption",
      CENTER: "center",
      CODE: "code",
      COL: "col",
      COLGROUP: "colgroup",
      DD: "dd",
      DESC: "desc",
      DETAILS: "details",
      DIALOG: "dialog",
      DIR: "dir",
      DIV: "div",
      DL: "dl",
      DT: "dt",
      EM: "em",
      EMBED: "embed",
      FIELDSET: "fieldset",
      FIGCAPTION: "figcaption",
      FIGURE: "figure",
      FONT: "font",
      FOOTER: "footer",
      FOREIGN_OBJECT: "foreignObject",
      FORM: "form",
      FRAME: "frame",
      FRAMESET: "frameset",
      H1: "h1",
      H2: "h2",
      H3: "h3",
      H4: "h4",
      H5: "h5",
      H6: "h6",
      HEAD: "head",
      HEADER: "header",
      HGROUP: "hgroup",
      HR: "hr",
      HTML: "html",
      I: "i",
      IMG: "img",
      IMAGE: "image",
      INPUT: "input",
      IFRAME: "iframe",
      KEYGEN: "keygen",
      LABEL: "label",
      LI: "li",
      LINK: "link",
      LISTING: "listing",
      MAIN: "main",
      MALIGNMARK: "malignmark",
      MARQUEE: "marquee",
      MATH: "math",
      MENU: "menu",
      META: "meta",
      MGLYPH: "mglyph",
      MI: "mi",
      MO: "mo",
      MN: "mn",
      MS: "ms",
      MTEXT: "mtext",
      NAV: "nav",
      NOBR: "nobr",
      NOFRAMES: "noframes",
      NOEMBED: "noembed",
      NOSCRIPT: "noscript",
      OBJECT: "object",
      OL: "ol",
      OPTGROUP: "optgroup",
      OPTION: "option",
      P: "p",
      PARAM: "param",
      PLAINTEXT: "plaintext",
      PRE: "pre",
      RB: "rb",
      RP: "rp",
      RT: "rt",
      RTC: "rtc",
      RUBY: "ruby",
      S: "s",
      SCRIPT: "script",
      SECTION: "section",
      SELECT: "select",
      SOURCE: "source",
      SMALL: "small",
      SPAN: "span",
      STRIKE: "strike",
      STRONG: "strong",
      STYLE: "style",
      SUB: "sub",
      SUMMARY: "summary",
      SUP: "sup",
      TABLE: "table",
      TBODY: "tbody",
      TEMPLATE: "template",
      TEXTAREA: "textarea",
      TFOOT: "tfoot",
      TD: "td",
      TH: "th",
      THEAD: "thead",
      TITLE: "title",
      TR: "tr",
      TRACK: "track",
      TT: "tt",
      U: "u",
      UL: "ul",
      SVG: "svg",
      VAR: "var",
      WBR: "wbr",
      XMP: "xmp"
    };
    exports.SPECIAL_ELEMENTS = {
      [NS.HTML]: {
        [$.ADDRESS]: true,
        [$.APPLET]: true,
        [$.AREA]: true,
        [$.ARTICLE]: true,
        [$.ASIDE]: true,
        [$.BASE]: true,
        [$.BASEFONT]: true,
        [$.BGSOUND]: true,
        [$.BLOCKQUOTE]: true,
        [$.BODY]: true,
        [$.BR]: true,
        [$.BUTTON]: true,
        [$.CAPTION]: true,
        [$.CENTER]: true,
        [$.COL]: true,
        [$.COLGROUP]: true,
        [$.DD]: true,
        [$.DETAILS]: true,
        [$.DIR]: true,
        [$.DIV]: true,
        [$.DL]: true,
        [$.DT]: true,
        [$.EMBED]: true,
        [$.FIELDSET]: true,
        [$.FIGCAPTION]: true,
        [$.FIGURE]: true,
        [$.FOOTER]: true,
        [$.FORM]: true,
        [$.FRAME]: true,
        [$.FRAMESET]: true,
        [$.H1]: true,
        [$.H2]: true,
        [$.H3]: true,
        [$.H4]: true,
        [$.H5]: true,
        [$.H6]: true,
        [$.HEAD]: true,
        [$.HEADER]: true,
        [$.HGROUP]: true,
        [$.HR]: true,
        [$.HTML]: true,
        [$.IFRAME]: true,
        [$.IMG]: true,
        [$.INPUT]: true,
        [$.LI]: true,
        [$.LINK]: true,
        [$.LISTING]: true,
        [$.MAIN]: true,
        [$.MARQUEE]: true,
        [$.MENU]: true,
        [$.META]: true,
        [$.NAV]: true,
        [$.NOEMBED]: true,
        [$.NOFRAMES]: true,
        [$.NOSCRIPT]: true,
        [$.OBJECT]: true,
        [$.OL]: true,
        [$.P]: true,
        [$.PARAM]: true,
        [$.PLAINTEXT]: true,
        [$.PRE]: true,
        [$.SCRIPT]: true,
        [$.SECTION]: true,
        [$.SELECT]: true,
        [$.SOURCE]: true,
        [$.STYLE]: true,
        [$.SUMMARY]: true,
        [$.TABLE]: true,
        [$.TBODY]: true,
        [$.TD]: true,
        [$.TEMPLATE]: true,
        [$.TEXTAREA]: true,
        [$.TFOOT]: true,
        [$.TH]: true,
        [$.THEAD]: true,
        [$.TITLE]: true,
        [$.TR]: true,
        [$.TRACK]: true,
        [$.UL]: true,
        [$.WBR]: true,
        [$.XMP]: true
      },
      [NS.MATHML]: {
        [$.MI]: true,
        [$.MO]: true,
        [$.MN]: true,
        [$.MS]: true,
        [$.MTEXT]: true,
        [$.ANNOTATION_XML]: true
      },
      [NS.SVG]: {
        [$.TITLE]: true,
        [$.FOREIGN_OBJECT]: true,
        [$.DESC]: true
      }
    };
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/parser/open-element-stack.js
var require_open_element_stack = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/parser/open-element-stack.js"(exports, module2) {
    "use strict";
    var HTML = require_html();
    var $ = HTML.TAG_NAMES;
    var NS = HTML.NAMESPACES;
    function isImpliedEndTagRequired(tn) {
      switch (tn.length) {
        case 1:
          return tn === $.P;
        case 2:
          return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;
        case 3:
          return tn === $.RTC;
        case 6:
          return tn === $.OPTION;
        case 8:
          return tn === $.OPTGROUP;
      }
      return false;
    }
    function isImpliedEndTagRequiredThoroughly(tn) {
      switch (tn.length) {
        case 1:
          return tn === $.P;
        case 2:
          return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI || tn === $.TD || tn === $.TH || tn === $.TR;
        case 3:
          return tn === $.RTC;
        case 5:
          return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;
        case 6:
          return tn === $.OPTION;
        case 7:
          return tn === $.CAPTION;
        case 8:
          return tn === $.OPTGROUP || tn === $.COLGROUP;
      }
      return false;
    }
    function isScopingElement(tn, ns) {
      switch (tn.length) {
        case 2:
          if (tn === $.TD || tn === $.TH) {
            return ns === NS.HTML;
          } else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {
            return ns === NS.MATHML;
          }
          break;
        case 4:
          if (tn === $.HTML) {
            return ns === NS.HTML;
          } else if (tn === $.DESC) {
            return ns === NS.SVG;
          }
          break;
        case 5:
          if (tn === $.TABLE) {
            return ns === NS.HTML;
          } else if (tn === $.MTEXT) {
            return ns === NS.MATHML;
          } else if (tn === $.TITLE) {
            return ns === NS.SVG;
          }
          break;
        case 6:
          return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;
        case 7:
          return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;
        case 8:
          return tn === $.TEMPLATE && ns === NS.HTML;
        case 13:
          return tn === $.FOREIGN_OBJECT && ns === NS.SVG;
        case 14:
          return tn === $.ANNOTATION_XML && ns === NS.MATHML;
      }
      return false;
    }
    var OpenElementStack = class {
      constructor(document4, treeAdapter) {
        this.stackTop = -1;
        this.items = [];
        this.current = document4;
        this.currentTagName = null;
        this.currentTmplContent = null;
        this.tmplCount = 0;
        this.treeAdapter = treeAdapter;
      }
      _indexOf(element4) {
        let idx = -1;
        for (let i = this.stackTop; i >= 0; i--) {
          if (this.items[i] === element4) {
            idx = i;
            break;
          }
        }
        return idx;
      }
      _isInTemplate() {
        return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
      }
      _updateCurrentElement() {
        this.current = this.items[this.stackTop];
        this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
        this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
      }
      push(element4) {
        this.items[++this.stackTop] = element4;
        this._updateCurrentElement();
        if (this._isInTemplate()) {
          this.tmplCount++;
        }
      }
      pop() {
        this.stackTop--;
        if (this.tmplCount > 0 && this._isInTemplate()) {
          this.tmplCount--;
        }
        this._updateCurrentElement();
      }
      replace(oldElement, newElement) {
        const idx = this._indexOf(oldElement);
        this.items[idx] = newElement;
        if (idx === this.stackTop) {
          this._updateCurrentElement();
        }
      }
      insertAfter(referenceElement, newElement) {
        const insertionIdx = this._indexOf(referenceElement) + 1;
        this.items.splice(insertionIdx, 0, newElement);
        if (insertionIdx === ++this.stackTop) {
          this._updateCurrentElement();
        }
      }
      popUntilTagNamePopped(tagName) {
        while (this.stackTop > -1) {
          const tn = this.currentTagName;
          const ns = this.treeAdapter.getNamespaceURI(this.current);
          this.pop();
          if (tn === tagName && ns === NS.HTML) {
            break;
          }
        }
      }
      popUntilElementPopped(element4) {
        while (this.stackTop > -1) {
          const poppedElement = this.current;
          this.pop();
          if (poppedElement === element4) {
            break;
          }
        }
      }
      popUntilNumberedHeaderPopped() {
        while (this.stackTop > -1) {
          const tn = this.currentTagName;
          const ns = this.treeAdapter.getNamespaceURI(this.current);
          this.pop();
          if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6 && ns === NS.HTML) {
            break;
          }
        }
      }
      popUntilTableCellPopped() {
        while (this.stackTop > -1) {
          const tn = this.currentTagName;
          const ns = this.treeAdapter.getNamespaceURI(this.current);
          this.pop();
          if (tn === $.TD || tn === $.TH && ns === NS.HTML) {
            break;
          }
        }
      }
      popAllUpToHtmlElement() {
        this.stackTop = 0;
        this._updateCurrentElement();
      }
      clearBackToTableContext() {
        while (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {
          this.pop();
        }
      }
      clearBackToTableBodyContext() {
        while (this.currentTagName !== $.TBODY && this.currentTagName !== $.TFOOT && this.currentTagName !== $.THEAD && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {
          this.pop();
        }
      }
      clearBackToTableRowContext() {
        while (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {
          this.pop();
        }
      }
      remove(element4) {
        for (let i = this.stackTop; i >= 0; i--) {
          if (this.items[i] === element4) {
            this.items.splice(i, 1);
            this.stackTop--;
            this._updateCurrentElement();
            break;
          }
        }
      }
      tryPeekProperlyNestedBodyElement() {
        const element4 = this.items[1];
        return element4 && this.treeAdapter.getTagName(element4) === $.BODY ? element4 : null;
      }
      contains(element4) {
        return this._indexOf(element4) > -1;
      }
      getCommonAncestor(element4) {
        let elementIdx = this._indexOf(element4);
        return --elementIdx >= 0 ? this.items[elementIdx] : null;
      }
      isRootHtmlElementCurrent() {
        return this.stackTop === 0 && this.currentTagName === $.HTML;
      }
      hasInScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.treeAdapter.getTagName(this.items[i]);
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (tn === tagName && ns === NS.HTML) {
            return true;
          }
          if (isScopingElement(tn, ns)) {
            return false;
          }
        }
        return true;
      }
      hasNumberedHeaderInScope() {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.treeAdapter.getTagName(this.items[i]);
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if ((tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) && ns === NS.HTML) {
            return true;
          }
          if (isScopingElement(tn, ns)) {
            return false;
          }
        }
        return true;
      }
      hasInListItemScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.treeAdapter.getTagName(this.items[i]);
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (tn === tagName && ns === NS.HTML) {
            return true;
          }
          if ((tn === $.UL || tn === $.OL) && ns === NS.HTML || isScopingElement(tn, ns)) {
            return false;
          }
        }
        return true;
      }
      hasInButtonScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.treeAdapter.getTagName(this.items[i]);
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (tn === tagName && ns === NS.HTML) {
            return true;
          }
          if (tn === $.BUTTON && ns === NS.HTML || isScopingElement(tn, ns)) {
            return false;
          }
        }
        return true;
      }
      hasInTableScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.treeAdapter.getTagName(this.items[i]);
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (ns !== NS.HTML) {
            continue;
          }
          if (tn === tagName) {
            return true;
          }
          if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {
            return false;
          }
        }
        return true;
      }
      hasTableBodyContextInTableScope() {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.treeAdapter.getTagName(this.items[i]);
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (ns !== NS.HTML) {
            continue;
          }
          if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {
            return true;
          }
          if (tn === $.TABLE || tn === $.HTML) {
            return false;
          }
        }
        return true;
      }
      hasInSelectScope(tagName) {
        for (let i = this.stackTop; i >= 0; i--) {
          const tn = this.treeAdapter.getTagName(this.items[i]);
          const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
          if (ns !== NS.HTML) {
            continue;
          }
          if (tn === tagName) {
            return true;
          }
          if (tn !== $.OPTION && tn !== $.OPTGROUP) {
            return false;
          }
        }
        return true;
      }
      generateImpliedEndTags() {
        while (isImpliedEndTagRequired(this.currentTagName)) {
          this.pop();
        }
      }
      generateImpliedEndTagsThoroughly() {
        while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
          this.pop();
        }
      }
      generateImpliedEndTagsWithExclusion(exclusionTagName) {
        while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
          this.pop();
        }
      }
    };
    module2.exports = OpenElementStack;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/parser/formatting-element-list.js
var require_formatting_element_list = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/parser/formatting-element-list.js"(exports, module2) {
    "use strict";
    var NOAH_ARK_CAPACITY = 3;
    var FormattingElementList = class {
      constructor(treeAdapter) {
        this.length = 0;
        this.entries = [];
        this.treeAdapter = treeAdapter;
        this.bookmark = null;
      }
      _getNoahArkConditionCandidates(newElement) {
        const candidates = [];
        if (this.length >= NOAH_ARK_CAPACITY) {
          const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
          const neTagName = this.treeAdapter.getTagName(newElement);
          const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
          for (let i = this.length - 1; i >= 0; i--) {
            const entry = this.entries[i];
            if (entry.type === FormattingElementList.MARKER_ENTRY) {
              break;
            }
            const element4 = entry.element;
            const elementAttrs = this.treeAdapter.getAttrList(element4);
            const isCandidate = this.treeAdapter.getTagName(element4) === neTagName && this.treeAdapter.getNamespaceURI(element4) === neNamespaceURI && elementAttrs.length === neAttrsLength;
            if (isCandidate) {
              candidates.push({ idx: i, attrs: elementAttrs });
            }
          }
        }
        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
      }
      _ensureNoahArkCondition(newElement) {
        const candidates = this._getNoahArkConditionCandidates(newElement);
        let cLength = candidates.length;
        if (cLength) {
          const neAttrs = this.treeAdapter.getAttrList(newElement);
          const neAttrsLength = neAttrs.length;
          const neAttrsMap = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < neAttrsLength; i++) {
            const neAttr = neAttrs[i];
            neAttrsMap[neAttr.name] = neAttr.value;
          }
          for (let i = 0; i < neAttrsLength; i++) {
            for (let j = 0; j < cLength; j++) {
              const cAttr = candidates[j].attrs[i];
              if (neAttrsMap[cAttr.name] !== cAttr.value) {
                candidates.splice(j, 1);
                cLength--;
              }
              if (candidates.length < NOAH_ARK_CAPACITY) {
                return;
              }
            }
          }
          for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
            this.entries.splice(candidates[i].idx, 1);
            this.length--;
          }
        }
      }
      insertMarker() {
        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });
        this.length++;
      }
      pushElement(element4, token) {
        this._ensureNoahArkCondition(element4);
        this.entries.push({
          type: FormattingElementList.ELEMENT_ENTRY,
          element: element4,
          token
        });
        this.length++;
      }
      insertElementAfterBookmark(element4, token) {
        let bookmarkIdx = this.length - 1;
        for (; bookmarkIdx >= 0; bookmarkIdx--) {
          if (this.entries[bookmarkIdx] === this.bookmark) {
            break;
          }
        }
        this.entries.splice(bookmarkIdx + 1, 0, {
          type: FormattingElementList.ELEMENT_ENTRY,
          element: element4,
          token
        });
        this.length++;
      }
      removeEntry(entry) {
        for (let i = this.length - 1; i >= 0; i--) {
          if (this.entries[i] === entry) {
            this.entries.splice(i, 1);
            this.length--;
            break;
          }
        }
      }
      clearToLastMarker() {
        while (this.length) {
          const entry = this.entries.pop();
          this.length--;
          if (entry.type === FormattingElementList.MARKER_ENTRY) {
            break;
          }
        }
      }
      getElementEntryInScopeWithTagName(tagName) {
        for (let i = this.length - 1; i >= 0; i--) {
          const entry = this.entries[i];
          if (entry.type === FormattingElementList.MARKER_ENTRY) {
            return null;
          }
          if (this.treeAdapter.getTagName(entry.element) === tagName) {
            return entry;
          }
        }
        return null;
      }
      getElementEntry(element4) {
        for (let i = this.length - 1; i >= 0; i--) {
          const entry = this.entries[i];
          if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element4) {
            return entry;
          }
        }
        return null;
      }
    };
    FormattingElementList.MARKER_ENTRY = "MARKER_ENTRY";
    FormattingElementList.ELEMENT_ENTRY = "ELEMENT_ENTRY";
    module2.exports = FormattingElementList;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js
var require_mixin = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/utils/mixin.js"(exports, module2) {
    "use strict";
    var Mixin = class {
      constructor(host) {
        const originalMethods = {};
        const overriddenMethods = this._getOverriddenMethods(this, originalMethods);
        for (const key of Object.keys(overriddenMethods)) {
          if (typeof overriddenMethods[key] === "function") {
            originalMethods[key] = host[key];
            host[key] = overriddenMethods[key];
          }
        }
      }
      _getOverriddenMethods() {
        throw new Error("Not implemented");
      }
    };
    Mixin.install = function(host, Ctor, opts) {
      if (!host.__mixins) {
        host.__mixins = [];
      }
      for (let i = 0; i < host.__mixins.length; i++) {
        if (host.__mixins[i].constructor === Ctor) {
          return host.__mixins[i];
        }
      }
      const mixin = new Ctor(host, opts);
      host.__mixins.push(mixin);
      return mixin;
    };
    module2.exports = Mixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js
var require_preprocessor_mixin = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js"(exports, module2) {
    "use strict";
    var Mixin = require_mixin();
    var PositionTrackingPreprocessorMixin = class extends Mixin {
      constructor(preprocessor) {
        super(preprocessor);
        this.preprocessor = preprocessor;
        this.isEol = false;
        this.lineStartPos = 0;
        this.droppedBufferSize = 0;
        this.offset = 0;
        this.col = 0;
        this.line = 1;
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          advance() {
            const pos = this.pos + 1;
            const ch = this.html[pos];
            if (mxn.isEol) {
              mxn.isEol = false;
              mxn.line++;
              mxn.lineStartPos = pos;
            }
            if (ch === "\n" || ch === "\r" && this.html[pos + 1] !== "\n") {
              mxn.isEol = true;
            }
            mxn.col = pos - mxn.lineStartPos + 1;
            mxn.offset = mxn.droppedBufferSize + pos;
            return orig.advance.call(this);
          },
          retreat() {
            orig.retreat.call(this);
            mxn.isEol = false;
            mxn.col = this.pos - mxn.lineStartPos + 1;
          },
          dropParsedChunk() {
            const prevPos = this.pos;
            orig.dropParsedChunk.call(this);
            const reduction = prevPos - this.pos;
            mxn.lineStartPos -= reduction;
            mxn.droppedBufferSize += reduction;
            mxn.offset = mxn.droppedBufferSize + this.pos;
          }
        };
      }
    };
    module2.exports = PositionTrackingPreprocessorMixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js
var require_tokenizer_mixin = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js"(exports, module2) {
    "use strict";
    var Mixin = require_mixin();
    var Tokenizer = require_tokenizer();
    var PositionTrackingPreprocessorMixin = require_preprocessor_mixin();
    var LocationInfoTokenizerMixin = class extends Mixin {
      constructor(tokenizer) {
        super(tokenizer);
        this.tokenizer = tokenizer;
        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);
        this.currentAttrLocation = null;
        this.ctLoc = null;
      }
      _getCurrentLocation() {
        return {
          startLine: this.posTracker.line,
          startCol: this.posTracker.col,
          startOffset: this.posTracker.offset,
          endLine: -1,
          endCol: -1,
          endOffset: -1
        };
      }
      _attachCurrentAttrLocationInfo() {
        this.currentAttrLocation.endLine = this.posTracker.line;
        this.currentAttrLocation.endCol = this.posTracker.col;
        this.currentAttrLocation.endOffset = this.posTracker.offset;
        const currentToken = this.tokenizer.currentToken;
        const currentAttr = this.tokenizer.currentAttr;
        if (!currentToken.location.attrs) {
          currentToken.location.attrs = /* @__PURE__ */ Object.create(null);
        }
        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
      }
      _getOverriddenMethods(mxn, orig) {
        const methods = {
          _createStartTagToken() {
            orig._createStartTagToken.call(this);
            this.currentToken.location = mxn.ctLoc;
          },
          _createEndTagToken() {
            orig._createEndTagToken.call(this);
            this.currentToken.location = mxn.ctLoc;
          },
          _createCommentToken() {
            orig._createCommentToken.call(this);
            this.currentToken.location = mxn.ctLoc;
          },
          _createDoctypeToken(initialName) {
            orig._createDoctypeToken.call(this, initialName);
            this.currentToken.location = mxn.ctLoc;
          },
          _createCharacterToken(type2, ch) {
            orig._createCharacterToken.call(this, type2, ch);
            this.currentCharacterToken.location = mxn.ctLoc;
          },
          _createEOFToken() {
            orig._createEOFToken.call(this);
            this.currentToken.location = mxn._getCurrentLocation();
          },
          _createAttr(attrNameFirstCh) {
            orig._createAttr.call(this, attrNameFirstCh);
            mxn.currentAttrLocation = mxn._getCurrentLocation();
          },
          _leaveAttrName(toState) {
            orig._leaveAttrName.call(this, toState);
            mxn._attachCurrentAttrLocationInfo();
          },
          _leaveAttrValue(toState) {
            orig._leaveAttrValue.call(this, toState);
            mxn._attachCurrentAttrLocationInfo();
          },
          _emitCurrentToken() {
            const ctLoc = this.currentToken.location;
            if (this.currentCharacterToken) {
              this.currentCharacterToken.location.endLine = ctLoc.startLine;
              this.currentCharacterToken.location.endCol = ctLoc.startCol;
              this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
            }
            if (this.currentToken.type === Tokenizer.EOF_TOKEN) {
              ctLoc.endLine = ctLoc.startLine;
              ctLoc.endCol = ctLoc.startCol;
              ctLoc.endOffset = ctLoc.startOffset;
            } else {
              ctLoc.endLine = mxn.posTracker.line;
              ctLoc.endCol = mxn.posTracker.col + 1;
              ctLoc.endOffset = mxn.posTracker.offset + 1;
            }
            orig._emitCurrentToken.call(this);
          },
          _emitCurrentCharacterToken() {
            const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;
            if (ctLoc && ctLoc.endOffset === -1) {
              ctLoc.endLine = mxn.posTracker.line;
              ctLoc.endCol = mxn.posTracker.col;
              ctLoc.endOffset = mxn.posTracker.offset;
            }
            orig._emitCurrentCharacterToken.call(this);
          }
        };
        Object.keys(Tokenizer.MODE).forEach((modeName) => {
          const state = Tokenizer.MODE[modeName];
          methods[state] = function(cp) {
            mxn.ctLoc = mxn._getCurrentLocation();
            orig[state].call(this, cp);
          };
        });
        return methods;
      }
    };
    module2.exports = LocationInfoTokenizerMixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js
var require_open_element_stack_mixin = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js"(exports, module2) {
    "use strict";
    var Mixin = require_mixin();
    var LocationInfoOpenElementStackMixin = class extends Mixin {
      constructor(stack, opts) {
        super(stack);
        this.onItemPop = opts.onItemPop;
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          pop() {
            mxn.onItemPop(this.current);
            orig.pop.call(this);
          },
          popAllUpToHtmlElement() {
            for (let i = this.stackTop; i > 0; i--) {
              mxn.onItemPop(this.items[i]);
            }
            orig.popAllUpToHtmlElement.call(this);
          },
          remove(element4) {
            mxn.onItemPop(this.current);
            orig.remove.call(this, element4);
          }
        };
      }
    };
    module2.exports = LocationInfoOpenElementStackMixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/parser-mixin.js
var require_parser_mixin = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/location-info/parser-mixin.js"(exports, module2) {
    "use strict";
    var Mixin = require_mixin();
    var Tokenizer = require_tokenizer();
    var LocationInfoTokenizerMixin = require_tokenizer_mixin();
    var LocationInfoOpenElementStackMixin = require_open_element_stack_mixin();
    var HTML = require_html();
    var $ = HTML.TAG_NAMES;
    var LocationInfoParserMixin = class extends Mixin {
      constructor(parser) {
        super(parser);
        this.parser = parser;
        this.treeAdapter = this.parser.treeAdapter;
        this.posTracker = null;
        this.lastStartTagToken = null;
        this.lastFosterParentingLocation = null;
        this.currentToken = null;
      }
      _setStartLocation(element4) {
        let loc = null;
        if (this.lastStartTagToken) {
          loc = Object.assign({}, this.lastStartTagToken.location);
          loc.startTag = this.lastStartTagToken.location;
        }
        this.treeAdapter.setNodeSourceCodeLocation(element4, loc);
      }
      _setEndLocation(element4, closingToken) {
        const loc = this.treeAdapter.getNodeSourceCodeLocation(element4);
        if (loc) {
          if (closingToken.location) {
            const ctLoc = closingToken.location;
            const tn = this.treeAdapter.getTagName(element4);
            const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;
            const endLoc = {};
            if (isClosingEndTag) {
              endLoc.endTag = Object.assign({}, ctLoc);
              endLoc.endLine = ctLoc.endLine;
              endLoc.endCol = ctLoc.endCol;
              endLoc.endOffset = ctLoc.endOffset;
            } else {
              endLoc.endLine = ctLoc.startLine;
              endLoc.endCol = ctLoc.startCol;
              endLoc.endOffset = ctLoc.startOffset;
            }
            this.treeAdapter.updateNodeSourceCodeLocation(element4, endLoc);
          }
        }
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          _bootstrap(document4, fragmentContext) {
            orig._bootstrap.call(this, document4, fragmentContext);
            mxn.lastStartTagToken = null;
            mxn.lastFosterParentingLocation = null;
            mxn.currentToken = null;
            const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
            mxn.posTracker = tokenizerMixin.posTracker;
            Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
              onItemPop: function(element4) {
                mxn._setEndLocation(element4, mxn.currentToken);
              }
            });
          },
          _runParsingLoop(scriptHandler) {
            orig._runParsingLoop.call(this, scriptHandler);
            for (let i = this.openElements.stackTop; i >= 0; i--) {
              mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
            }
          },
          _processTokenInForeignContent(token) {
            mxn.currentToken = token;
            orig._processTokenInForeignContent.call(this, token);
          },
          _processToken(token) {
            mxn.currentToken = token;
            orig._processToken.call(this, token);
            const requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));
            if (requireExplicitUpdate) {
              for (let i = this.openElements.stackTop; i >= 0; i--) {
                const element4 = this.openElements.items[i];
                if (this.treeAdapter.getTagName(element4) === token.tagName) {
                  mxn._setEndLocation(element4, token);
                  break;
                }
              }
            }
          },
          _setDocumentType(token) {
            orig._setDocumentType.call(this, token);
            const documentChildren = this.treeAdapter.getChildNodes(this.document);
            const cnLength = documentChildren.length;
            for (let i = 0; i < cnLength; i++) {
              const node2 = documentChildren[i];
              if (this.treeAdapter.isDocumentTypeNode(node2)) {
                this.treeAdapter.setNodeSourceCodeLocation(node2, token.location);
                break;
              }
            }
          },
          _attachElementToTree(element4) {
            mxn._setStartLocation(element4);
            mxn.lastStartTagToken = null;
            orig._attachElementToTree.call(this, element4);
          },
          _appendElement(token, namespaceURI) {
            mxn.lastStartTagToken = token;
            orig._appendElement.call(this, token, namespaceURI);
          },
          _insertElement(token, namespaceURI) {
            mxn.lastStartTagToken = token;
            orig._insertElement.call(this, token, namespaceURI);
          },
          _insertTemplate(token) {
            mxn.lastStartTagToken = token;
            orig._insertTemplate.call(this, token);
            const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
            this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
          },
          _insertFakeRootElement() {
            orig._insertFakeRootElement.call(this);
            this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
          },
          _appendCommentNode(token, parent) {
            orig._appendCommentNode.call(this, token, parent);
            const children = this.treeAdapter.getChildNodes(parent);
            const commentNode = children[children.length - 1];
            this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
          },
          _findFosterParentingLocation() {
            mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
            return mxn.lastFosterParentingLocation;
          },
          _insertCharacters(token) {
            orig._insertCharacters.call(this, token);
            const hasFosterParent = this._shouldFosterParentOnInsertion();
            const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
            const siblings = this.treeAdapter.getChildNodes(parent);
            const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;
            const textNode = siblings[textNodeIdx];
            const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
            if (tnLoc) {
              const { endLine, endCol, endOffset } = token.location;
              this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
            } else {
              this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
            }
          }
        };
      }
    };
    module2.exports = LocationInfoParserMixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js
var require_mixin_base = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js"(exports, module2) {
    "use strict";
    var Mixin = require_mixin();
    var ErrorReportingMixinBase = class extends Mixin {
      constructor(host, opts) {
        super(host);
        this.posTracker = null;
        this.onParseError = opts.onParseError;
      }
      _setErrorLocation(err) {
        err.startLine = err.endLine = this.posTracker.line;
        err.startCol = err.endCol = this.posTracker.col;
        err.startOffset = err.endOffset = this.posTracker.offset;
      }
      _reportError(code2) {
        const err = {
          code: code2,
          startLine: -1,
          startCol: -1,
          startOffset: -1,
          endLine: -1,
          endCol: -1,
          endOffset: -1
        };
        this._setErrorLocation(err);
        this.onParseError(err);
      }
      _getOverriddenMethods(mxn) {
        return {
          _err(code2) {
            mxn._reportError(code2);
          }
        };
      }
    };
    module2.exports = ErrorReportingMixinBase;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js
var require_preprocessor_mixin2 = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js"(exports, module2) {
    "use strict";
    var ErrorReportingMixinBase = require_mixin_base();
    var PositionTrackingPreprocessorMixin = require_preprocessor_mixin();
    var Mixin = require_mixin();
    var ErrorReportingPreprocessorMixin = class extends ErrorReportingMixinBase {
      constructor(preprocessor, opts) {
        super(preprocessor, opts);
        this.posTracker = Mixin.install(preprocessor, PositionTrackingPreprocessorMixin);
        this.lastErrOffset = -1;
      }
      _reportError(code2) {
        if (this.lastErrOffset !== this.posTracker.offset) {
          this.lastErrOffset = this.posTracker.offset;
          super._reportError(code2);
        }
      }
    };
    module2.exports = ErrorReportingPreprocessorMixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js
var require_tokenizer_mixin2 = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js"(exports, module2) {
    "use strict";
    var ErrorReportingMixinBase = require_mixin_base();
    var ErrorReportingPreprocessorMixin = require_preprocessor_mixin2();
    var Mixin = require_mixin();
    var ErrorReportingTokenizerMixin = class extends ErrorReportingMixinBase {
      constructor(tokenizer, opts) {
        super(tokenizer, opts);
        const preprocessorMixin = Mixin.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);
        this.posTracker = preprocessorMixin.posTracker;
      }
    };
    module2.exports = ErrorReportingTokenizerMixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js
var require_parser_mixin2 = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js"(exports, module2) {
    "use strict";
    var ErrorReportingMixinBase = require_mixin_base();
    var ErrorReportingTokenizerMixin = require_tokenizer_mixin2();
    var LocationInfoTokenizerMixin = require_tokenizer_mixin();
    var Mixin = require_mixin();
    var ErrorReportingParserMixin = class extends ErrorReportingMixinBase {
      constructor(parser, opts) {
        super(parser, opts);
        this.opts = opts;
        this.ctLoc = null;
        this.locBeforeToken = false;
      }
      _setErrorLocation(err) {
        if (this.ctLoc) {
          err.startLine = this.ctLoc.startLine;
          err.startCol = this.ctLoc.startCol;
          err.startOffset = this.ctLoc.startOffset;
          err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
          err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
          err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
        }
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          _bootstrap(document4, fragmentContext) {
            orig._bootstrap.call(this, document4, fragmentContext);
            Mixin.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
            Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
          },
          _processInputToken(token) {
            mxn.ctLoc = token.location;
            orig._processInputToken.call(this, token);
          },
          _err(code2, options) {
            mxn.locBeforeToken = options && options.beforeToken;
            mxn._reportError(code2);
          }
        };
      }
    };
    module2.exports = ErrorReportingParserMixin;
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/tree-adapters/default.js
var require_default = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/tree-adapters/default.js"(exports) {
    "use strict";
    var { DOCUMENT_MODE } = require_html();
    exports.createDocument = function() {
      return {
        nodeName: "#document",
        mode: DOCUMENT_MODE.NO_QUIRKS,
        childNodes: []
      };
    };
    exports.createDocumentFragment = function() {
      return {
        nodeName: "#document-fragment",
        childNodes: []
      };
    };
    exports.createElement = function(tagName, namespaceURI, attrs) {
      return {
        nodeName: tagName,
        tagName,
        attrs,
        namespaceURI,
        childNodes: [],
        parentNode: null
      };
    };
    exports.createCommentNode = function(data) {
      return {
        nodeName: "#comment",
        data,
        parentNode: null
      };
    };
    var createTextNode = function(value) {
      return {
        nodeName: "#text",
        value,
        parentNode: null
      };
    };
    var appendChild = exports.appendChild = function(parentNode, newNode) {
      parentNode.childNodes.push(newNode);
      newNode.parentNode = parentNode;
    };
    var insertBefore = exports.insertBefore = function(parentNode, newNode, referenceNode) {
      const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
      parentNode.childNodes.splice(insertionIdx, 0, newNode);
      newNode.parentNode = parentNode;
    };
    exports.setTemplateContent = function(templateElement, contentElement) {
      templateElement.content = contentElement;
    };
    exports.getTemplateContent = function(templateElement) {
      return templateElement.content;
    };
    exports.setDocumentType = function(document4, name, publicId, systemId) {
      let doctypeNode = null;
      for (let i = 0; i < document4.childNodes.length; i++) {
        if (document4.childNodes[i].nodeName === "#documentType") {
          doctypeNode = document4.childNodes[i];
          break;
        }
      }
      if (doctypeNode) {
        doctypeNode.name = name;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
      } else {
        appendChild(document4, {
          nodeName: "#documentType",
          name,
          publicId,
          systemId
        });
      }
    };
    exports.setDocumentMode = function(document4, mode) {
      document4.mode = mode;
    };
    exports.getDocumentMode = function(document4) {
      return document4.mode;
    };
    exports.detachNode = function(node2) {
      if (node2.parentNode) {
        const idx = node2.parentNode.childNodes.indexOf(node2);
        node2.parentNode.childNodes.splice(idx, 1);
        node2.parentNode = null;
      }
    };
    exports.insertText = function(parentNode, text6) {
      if (parentNode.childNodes.length) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
        if (prevNode.nodeName === "#text") {
          prevNode.value += text6;
          return;
        }
      }
      appendChild(parentNode, createTextNode(text6));
    };
    exports.insertTextBefore = function(parentNode, text6, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode && prevNode.nodeName === "#text") {
        prevNode.value += text6;
      } else {
        insertBefore(parentNode, createTextNode(text6), referenceNode);
      }
    };
    exports.adoptAttributes = function(recipient, attrs) {
      const recipientAttrsMap = [];
      for (let i = 0; i < recipient.attrs.length; i++) {
        recipientAttrsMap.push(recipient.attrs[i].name);
      }
      for (let j = 0; j < attrs.length; j++) {
        if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
          recipient.attrs.push(attrs[j]);
        }
      }
    };
    exports.getFirstChild = function(node2) {
      return node2.childNodes[0];
    };
    exports.getChildNodes = function(node2) {
      return node2.childNodes;
    };
    exports.getParentNode = function(node2) {
      return node2.parentNode;
    };
    exports.getAttrList = function(element4) {
      return element4.attrs;
    };
    exports.getTagName = function(element4) {
      return element4.tagName;
    };
    exports.getNamespaceURI = function(element4) {
      return element4.namespaceURI;
    };
    exports.getTextNodeContent = function(textNode) {
      return textNode.value;
    };
    exports.getCommentNodeContent = function(commentNode) {
      return commentNode.data;
    };
    exports.getDocumentTypeNodeName = function(doctypeNode) {
      return doctypeNode.name;
    };
    exports.getDocumentTypeNodePublicId = function(doctypeNode) {
      return doctypeNode.publicId;
    };
    exports.getDocumentTypeNodeSystemId = function(doctypeNode) {
      return doctypeNode.systemId;
    };
    exports.isTextNode = function(node2) {
      return node2.nodeName === "#text";
    };
    exports.isCommentNode = function(node2) {
      return node2.nodeName === "#comment";
    };
    exports.isDocumentTypeNode = function(node2) {
      return node2.nodeName === "#documentType";
    };
    exports.isElementNode = function(node2) {
      return !!node2.tagName;
    };
    exports.setNodeSourceCodeLocation = function(node2, location3) {
      node2.sourceCodeLocation = location3;
    };
    exports.getNodeSourceCodeLocation = function(node2) {
      return node2.sourceCodeLocation;
    };
    exports.updateNodeSourceCodeLocation = function(node2, endLocation) {
      node2.sourceCodeLocation = Object.assign(node2.sourceCodeLocation, endLocation);
    };
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/utils/merge-options.js
var require_merge_options = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/utils/merge-options.js"(exports, module2) {
    "use strict";
    module2.exports = function mergeOptions(defaults4, options) {
      options = options || /* @__PURE__ */ Object.create(null);
      return [defaults4, options].reduce((merged, optObj) => {
        Object.keys(optObj).forEach((key) => {
          merged[key] = optObj[key];
        });
        return merged;
      }, /* @__PURE__ */ Object.create(null));
    };
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/common/doctype.js
var require_doctype = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/common/doctype.js"(exports) {
    "use strict";
    var { DOCUMENT_MODE } = require_html();
    var VALID_DOCTYPE_NAME = "html";
    var VALID_SYSTEM_ID = "about:legacy-compat";
    var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
    var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
      "+//silmaril//dtd html pro v0r11 19970101//",
      "-//as//dtd html 3.0 aswedit + extensions//",
      "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
      "-//ietf//dtd html 2.0 level 1//",
      "-//ietf//dtd html 2.0 level 2//",
      "-//ietf//dtd html 2.0 strict level 1//",
      "-//ietf//dtd html 2.0 strict level 2//",
      "-//ietf//dtd html 2.0 strict//",
      "-//ietf//dtd html 2.0//",
      "-//ietf//dtd html 2.1e//",
      "-//ietf//dtd html 3.0//",
      "-//ietf//dtd html 3.2 final//",
      "-//ietf//dtd html 3.2//",
      "-//ietf//dtd html 3//",
      "-//ietf//dtd html level 0//",
      "-//ietf//dtd html level 1//",
      "-//ietf//dtd html level 2//",
      "-//ietf//dtd html level 3//",
      "-//ietf//dtd html strict level 0//",
      "-//ietf//dtd html strict level 1//",
      "-//ietf//dtd html strict level 2//",
      "-//ietf//dtd html strict level 3//",
      "-//ietf//dtd html strict//",
      "-//ietf//dtd html//",
      "-//metrius//dtd metrius presentational//",
      "-//microsoft//dtd internet explorer 2.0 html strict//",
      "-//microsoft//dtd internet explorer 2.0 html//",
      "-//microsoft//dtd internet explorer 2.0 tables//",
      "-//microsoft//dtd internet explorer 3.0 html strict//",
      "-//microsoft//dtd internet explorer 3.0 html//",
      "-//microsoft//dtd internet explorer 3.0 tables//",
      "-//netscape comm. corp.//dtd html//",
      "-//netscape comm. corp.//dtd strict html//",
      "-//o'reilly and associates//dtd html 2.0//",
      "-//o'reilly and associates//dtd html extended 1.0//",
      "-//o'reilly and associates//dtd html extended relaxed 1.0//",
      "-//sq//dtd html 2.0 hotmetal + extensions//",
      "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
      "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
      "-//spyglass//dtd html 2.0 extended//",
      "-//sun microsystems corp.//dtd hotjava html//",
      "-//sun microsystems corp.//dtd hotjava strict html//",
      "-//w3c//dtd html 3 1995-03-24//",
      "-//w3c//dtd html 3.2 draft//",
      "-//w3c//dtd html 3.2 final//",
      "-//w3c//dtd html 3.2//",
      "-//w3c//dtd html 3.2s draft//",
      "-//w3c//dtd html 4.0 frameset//",
      "-//w3c//dtd html 4.0 transitional//",
      "-//w3c//dtd html experimental 19960712//",
      "-//w3c//dtd html experimental 970421//",
      "-//w3c//dtd w3 html//",
      "-//w3o//dtd w3 html 3.0//",
      "-//webtechs//dtd mozilla html 2.0//",
      "-//webtechs//dtd mozilla html//"
    ];
    var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
      "-//w3c//dtd html 4.01 frameset//",
      "-//w3c//dtd html 4.01 transitional//"
    ]);
    var QUIRKS_MODE_PUBLIC_IDS = ["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"];
    var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
    var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
      "-//w3c//dtd html 4.01 frameset//",
      "-//w3c//dtd html 4.01 transitional//"
    ]);
    function enquoteDoctypeId(id) {
      const quote = id.indexOf('"') !== -1 ? "'" : '"';
      return quote + id + quote;
    }
    function hasPrefix(publicId, prefixes2) {
      for (let i = 0; i < prefixes2.length; i++) {
        if (publicId.indexOf(prefixes2[i]) === 0) {
          return true;
        }
      }
      return false;
    }
    exports.isConforming = function(token) {
      return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
    };
    exports.getDocumentMode = function(token) {
      if (token.name !== VALID_DOCTYPE_NAME) {
        return DOCUMENT_MODE.QUIRKS;
      }
      const systemId = token.systemId;
      if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
        return DOCUMENT_MODE.QUIRKS;
      }
      let publicId = token.publicId;
      if (publicId !== null) {
        publicId = publicId.toLowerCase();
        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
          return DOCUMENT_MODE.QUIRKS;
        }
        let prefixes2 = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
        if (hasPrefix(publicId, prefixes2)) {
          return DOCUMENT_MODE.QUIRKS;
        }
        prefixes2 = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
        if (hasPrefix(publicId, prefixes2)) {
          return DOCUMENT_MODE.LIMITED_QUIRKS;
        }
      }
      return DOCUMENT_MODE.NO_QUIRKS;
    };
    exports.serializeContent = function(name, publicId, systemId) {
      let str = "!DOCTYPE ";
      if (name) {
        str += name;
      }
      if (publicId) {
        str += " PUBLIC " + enquoteDoctypeId(publicId);
      } else if (systemId) {
        str += " SYSTEM";
      }
      if (systemId !== null) {
        str += " " + enquoteDoctypeId(systemId);
      }
      return str;
    };
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/common/foreign-content.js
var require_foreign_content = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/common/foreign-content.js"(exports) {
    "use strict";
    var Tokenizer = require_tokenizer();
    var HTML = require_html();
    var $ = HTML.TAG_NAMES;
    var NS = HTML.NAMESPACES;
    var ATTRS = HTML.ATTRS;
    var MIME_TYPES = {
      TEXT_HTML: "text/html",
      APPLICATION_XML: "application/xhtml+xml"
    };
    var DEFINITION_URL_ATTR = "definitionurl";
    var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
    var SVG_ATTRS_ADJUSTMENT_MAP = {
      attributename: "attributeName",
      attributetype: "attributeType",
      basefrequency: "baseFrequency",
      baseprofile: "baseProfile",
      calcmode: "calcMode",
      clippathunits: "clipPathUnits",
      diffuseconstant: "diffuseConstant",
      edgemode: "edgeMode",
      filterunits: "filterUnits",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      limitingconeangle: "limitingConeAngle",
      markerheight: "markerHeight",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      numoctaves: "numOctaves",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      refx: "refX",
      refy: "refY",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stitchtiles: "stitchTiles",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textlength: "textLength",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      xchannelselector: "xChannelSelector",
      ychannelselector: "yChannelSelector",
      zoomandpan: "zoomAndPan"
    };
    var XML_ATTRS_ADJUSTMENT_MAP = {
      "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: NS.XLINK },
      "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: NS.XLINK },
      "xlink:href": { prefix: "xlink", name: "href", namespace: NS.XLINK },
      "xlink:role": { prefix: "xlink", name: "role", namespace: NS.XLINK },
      "xlink:show": { prefix: "xlink", name: "show", namespace: NS.XLINK },
      "xlink:title": { prefix: "xlink", name: "title", namespace: NS.XLINK },
      "xlink:type": { prefix: "xlink", name: "type", namespace: NS.XLINK },
      "xml:base": { prefix: "xml", name: "base", namespace: NS.XML },
      "xml:lang": { prefix: "xml", name: "lang", namespace: NS.XML },
      "xml:space": { prefix: "xml", name: "space", namespace: NS.XML },
      xmlns: { prefix: "", name: "xmlns", namespace: NS.XMLNS },
      "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }
    };
    var SVG_TAG_NAMES_ADJUSTMENT_MAP = exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
      altglyph: "altGlyph",
      altglyphdef: "altGlyphDef",
      altglyphitem: "altGlyphItem",
      animatecolor: "animateColor",
      animatemotion: "animateMotion",
      animatetransform: "animateTransform",
      clippath: "clipPath",
      feblend: "feBlend",
      fecolormatrix: "feColorMatrix",
      fecomponenttransfer: "feComponentTransfer",
      fecomposite: "feComposite",
      feconvolvematrix: "feConvolveMatrix",
      fediffuselighting: "feDiffuseLighting",
      fedisplacementmap: "feDisplacementMap",
      fedistantlight: "feDistantLight",
      feflood: "feFlood",
      fefunca: "feFuncA",
      fefuncb: "feFuncB",
      fefuncg: "feFuncG",
      fefuncr: "feFuncR",
      fegaussianblur: "feGaussianBlur",
      feimage: "feImage",
      femerge: "feMerge",
      femergenode: "feMergeNode",
      femorphology: "feMorphology",
      feoffset: "feOffset",
      fepointlight: "fePointLight",
      fespecularlighting: "feSpecularLighting",
      fespotlight: "feSpotLight",
      fetile: "feTile",
      feturbulence: "feTurbulence",
      foreignobject: "foreignObject",
      glyphref: "glyphRef",
      lineargradient: "linearGradient",
      radialgradient: "radialGradient",
      textpath: "textPath"
    };
    var EXITS_FOREIGN_CONTENT = {
      [$.B]: true,
      [$.BIG]: true,
      [$.BLOCKQUOTE]: true,
      [$.BODY]: true,
      [$.BR]: true,
      [$.CENTER]: true,
      [$.CODE]: true,
      [$.DD]: true,
      [$.DIV]: true,
      [$.DL]: true,
      [$.DT]: true,
      [$.EM]: true,
      [$.EMBED]: true,
      [$.H1]: true,
      [$.H2]: true,
      [$.H3]: true,
      [$.H4]: true,
      [$.H5]: true,
      [$.H6]: true,
      [$.HEAD]: true,
      [$.HR]: true,
      [$.I]: true,
      [$.IMG]: true,
      [$.LI]: true,
      [$.LISTING]: true,
      [$.MENU]: true,
      [$.META]: true,
      [$.NOBR]: true,
      [$.OL]: true,
      [$.P]: true,
      [$.PRE]: true,
      [$.RUBY]: true,
      [$.S]: true,
      [$.SMALL]: true,
      [$.SPAN]: true,
      [$.STRONG]: true,
      [$.STRIKE]: true,
      [$.SUB]: true,
      [$.SUP]: true,
      [$.TABLE]: true,
      [$.TT]: true,
      [$.U]: true,
      [$.UL]: true,
      [$.VAR]: true
    };
    exports.causesExit = function(startTagToken2) {
      const tn = startTagToken2.tagName;
      const isFontWithAttrs = tn === $.FONT && (Tokenizer.getTokenAttr(startTagToken2, ATTRS.COLOR) !== null || Tokenizer.getTokenAttr(startTagToken2, ATTRS.SIZE) !== null || Tokenizer.getTokenAttr(startTagToken2, ATTRS.FACE) !== null);
      return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
    };
    exports.adjustTokenMathMLAttrs = function(token) {
      for (let i = 0; i < token.attrs.length; i++) {
        if (token.attrs[i].name === DEFINITION_URL_ATTR) {
          token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
          break;
        }
      }
    };
    exports.adjustTokenSVGAttrs = function(token) {
      for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
        if (adjustedAttrName) {
          token.attrs[i].name = adjustedAttrName;
        }
      }
    };
    exports.adjustTokenXMLAttrs = function(token) {
      for (let i = 0; i < token.attrs.length; i++) {
        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
        if (adjustedAttrEntry) {
          token.attrs[i].prefix = adjustedAttrEntry.prefix;
          token.attrs[i].name = adjustedAttrEntry.name;
          token.attrs[i].namespace = adjustedAttrEntry.namespace;
        }
      }
    };
    exports.adjustTokenSVGTagName = function(token) {
      const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];
      if (adjustedTagName) {
        token.tagName = adjustedTagName;
      }
    };
    function isMathMLTextIntegrationPoint(tn, ns) {
      return ns === NS.MATHML && (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT);
    }
    function isHtmlIntegrationPoint(tn, ns, attrs) {
      if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {
        for (let i = 0; i < attrs.length; i++) {
          if (attrs[i].name === ATTRS.ENCODING) {
            const value = attrs[i].value.toLowerCase();
            return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
          }
        }
      }
      return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);
    }
    exports.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
      if ((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
        return true;
      }
      if ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/hast-util-raw/node_modules/parse5/lib/parser/index.js
var require_parser = __commonJS({
  "node_modules/hast-util-raw/node_modules/parse5/lib/parser/index.js"(exports, module2) {
    "use strict";
    var Tokenizer = require_tokenizer();
    var OpenElementStack = require_open_element_stack();
    var FormattingElementList = require_formatting_element_list();
    var LocationInfoParserMixin = require_parser_mixin();
    var ErrorReportingParserMixin = require_parser_mixin2();
    var Mixin = require_mixin();
    var defaultTreeAdapter = require_default();
    var mergeOptions = require_merge_options();
    var doctype2 = require_doctype();
    var foreignContent = require_foreign_content();
    var ERR = require_error_codes();
    var unicode = require_unicode();
    var HTML = require_html();
    var $ = HTML.TAG_NAMES;
    var NS = HTML.NAMESPACES;
    var ATTRS = HTML.ATTRS;
    var DEFAULT_OPTIONS = {
      scriptingEnabled: true,
      sourceCodeLocationInfo: false,
      onParseError: null,
      treeAdapter: defaultTreeAdapter
    };
    var HIDDEN_INPUT_TYPE = "hidden";
    var AA_OUTER_LOOP_ITER = 8;
    var AA_INNER_LOOP_ITER = 3;
    var INITIAL_MODE = "INITIAL_MODE";
    var BEFORE_HTML_MODE = "BEFORE_HTML_MODE";
    var BEFORE_HEAD_MODE = "BEFORE_HEAD_MODE";
    var IN_HEAD_MODE = "IN_HEAD_MODE";
    var IN_HEAD_NO_SCRIPT_MODE = "IN_HEAD_NO_SCRIPT_MODE";
    var AFTER_HEAD_MODE = "AFTER_HEAD_MODE";
    var IN_BODY_MODE = "IN_BODY_MODE";
    var TEXT_MODE = "TEXT_MODE";
    var IN_TABLE_MODE = "IN_TABLE_MODE";
    var IN_TABLE_TEXT_MODE = "IN_TABLE_TEXT_MODE";
    var IN_CAPTION_MODE = "IN_CAPTION_MODE";
    var IN_COLUMN_GROUP_MODE = "IN_COLUMN_GROUP_MODE";
    var IN_TABLE_BODY_MODE = "IN_TABLE_BODY_MODE";
    var IN_ROW_MODE = "IN_ROW_MODE";
    var IN_CELL_MODE = "IN_CELL_MODE";
    var IN_SELECT_MODE = "IN_SELECT_MODE";
    var IN_SELECT_IN_TABLE_MODE = "IN_SELECT_IN_TABLE_MODE";
    var IN_TEMPLATE_MODE = "IN_TEMPLATE_MODE";
    var AFTER_BODY_MODE = "AFTER_BODY_MODE";
    var IN_FRAMESET_MODE = "IN_FRAMESET_MODE";
    var AFTER_FRAMESET_MODE = "AFTER_FRAMESET_MODE";
    var AFTER_AFTER_BODY_MODE = "AFTER_AFTER_BODY_MODE";
    var AFTER_AFTER_FRAMESET_MODE = "AFTER_AFTER_FRAMESET_MODE";
    var INSERTION_MODE_RESET_MAP = {
      [$.TR]: IN_ROW_MODE,
      [$.TBODY]: IN_TABLE_BODY_MODE,
      [$.THEAD]: IN_TABLE_BODY_MODE,
      [$.TFOOT]: IN_TABLE_BODY_MODE,
      [$.CAPTION]: IN_CAPTION_MODE,
      [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
      [$.TABLE]: IN_TABLE_MODE,
      [$.BODY]: IN_BODY_MODE,
      [$.FRAMESET]: IN_FRAMESET_MODE
    };
    var TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
      [$.CAPTION]: IN_TABLE_MODE,
      [$.COLGROUP]: IN_TABLE_MODE,
      [$.TBODY]: IN_TABLE_MODE,
      [$.TFOOT]: IN_TABLE_MODE,
      [$.THEAD]: IN_TABLE_MODE,
      [$.COL]: IN_COLUMN_GROUP_MODE,
      [$.TR]: IN_TABLE_BODY_MODE,
      [$.TD]: IN_ROW_MODE,
      [$.TH]: IN_ROW_MODE
    };
    var TOKEN_HANDLERS = {
      [INITIAL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.EOF_TOKEN]: tokenInInitialMode
      },
      [BEFORE_HTML_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
      },
      [BEFORE_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHead
      },
      [IN_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHead,
        [Tokenizer.END_TAG_TOKEN]: endTagInHead,
        [Tokenizer.EOF_TOKEN]: tokenInHead
      },
      [IN_HEAD_NO_SCRIPT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
      },
      [AFTER_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
        [Tokenizer.EOF_TOKEN]: tokenAfterHead
      },
      [IN_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: ignoreToken,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: ignoreToken,
        [Tokenizer.END_TAG_TOKEN]: endTagInText,
        [Tokenizer.EOF_TOKEN]: eofInText
      },
      [IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_TABLE_TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.EOF_TOKEN]: tokenInTableText
      },
      [IN_CAPTION_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_COLUMN_GROUP_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_TABLE_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_ROW_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInRow,
        [Tokenizer.END_TAG_TOKEN]: endTagInRow,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_CELL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCell,
        [Tokenizer.END_TAG_TOKEN]: endTagInCell,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_SELECT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_SELECT_IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_TEMPLATE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
        [Tokenizer.EOF_TOKEN]: eofInTemplate
      },
      [AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [IN_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [AFTER_AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [AFTER_AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: ignoreToken,
        [Tokenizer.EOF_TOKEN]: stopParsing
      }
    };
    var Parser2 = class {
      constructor(options) {
        this.options = mergeOptions(DEFAULT_OPTIONS, options);
        this.treeAdapter = this.options.treeAdapter;
        this.pendingScript = null;
        if (this.options.sourceCodeLocationInfo) {
          Mixin.install(this, LocationInfoParserMixin);
        }
        if (this.options.onParseError) {
          Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
        }
      }
      parse(html4) {
        const document4 = this.treeAdapter.createDocument();
        this._bootstrap(document4, null);
        this.tokenizer.write(html4, true);
        this._runParsingLoop(null);
        return document4;
      }
      parseFragment(html4, fragmentContext) {
        if (!fragmentContext) {
          fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
        }
        const documentMock = this.treeAdapter.createElement("documentmock", NS.HTML, []);
        this._bootstrap(documentMock, fragmentContext);
        if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
          this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
        }
        this._initTokenizerForFragmentParsing();
        this._insertFakeRootElement();
        this._resetInsertionMode();
        this._findFormInFragmentContext();
        this.tokenizer.write(html4, true);
        this._runParsingLoop(null);
        const rootElement = this.treeAdapter.getFirstChild(documentMock);
        const fragment2 = this.treeAdapter.createDocumentFragment();
        this._adoptNodes(rootElement, fragment2);
        return fragment2;
      }
      _bootstrap(document4, fragmentContext) {
        this.tokenizer = new Tokenizer(this.options);
        this.stopped = false;
        this.insertionMode = INITIAL_MODE;
        this.originalInsertionMode = "";
        this.document = document4;
        this.fragmentContext = fragmentContext;
        this.headElement = null;
        this.formElement = null;
        this.openElements = new OpenElementStack(this.document, this.treeAdapter);
        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
        this.tmplInsertionModeStack = [];
        this.tmplInsertionModeStackTop = -1;
        this.currentTmplInsertionMode = null;
        this.pendingCharacterTokens = [];
        this.hasNonWhitespacePendingCharacterToken = false;
        this.framesetOk = true;
        this.skipNextNewLine = false;
        this.fosterParentingEnabled = false;
      }
      _err() {
      }
      _runParsingLoop(scriptHandler) {
        while (!this.stopped) {
          this._setupTokenizerCDATAMode();
          const token = this.tokenizer.getNextToken();
          if (token.type === Tokenizer.HIBERNATION_TOKEN) {
            break;
          }
          if (this.skipNextNewLine) {
            this.skipNextNewLine = false;
            if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === "\n") {
              if (token.chars.length === 1) {
                continue;
              }
              token.chars = token.chars.substr(1);
            }
          }
          this._processInputToken(token);
          if (scriptHandler && this.pendingScript) {
            break;
          }
        }
      }
      runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
        this._runParsingLoop(scriptHandler);
        if (scriptHandler && this.pendingScript) {
          const script = this.pendingScript;
          this.pendingScript = null;
          scriptHandler(script);
          return;
        }
        if (writeCallback) {
          writeCallback();
        }
      }
      _setupTokenizerCDATAMode() {
        const current = this._getAdjustedCurrentElement();
        this.tokenizer.allowCDATA = current && current !== this.document && this.treeAdapter.getNamespaceURI(current) !== NS.HTML && !this._isIntegrationPoint(current);
      }
      _switchToTextParsing(currentToken, nextTokenizerState) {
        this._insertElement(currentToken, NS.HTML);
        this.tokenizer.state = nextTokenizerState;
        this.originalInsertionMode = this.insertionMode;
        this.insertionMode = TEXT_MODE;
      }
      switchToPlaintextParsing() {
        this.insertionMode = TEXT_MODE;
        this.originalInsertionMode = IN_BODY_MODE;
        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
      }
      _getAdjustedCurrentElement() {
        return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
      }
      _findFormInFragmentContext() {
        let node2 = this.fragmentContext;
        do {
          if (this.treeAdapter.getTagName(node2) === $.FORM) {
            this.formElement = node2;
            break;
          }
          node2 = this.treeAdapter.getParentNode(node2);
        } while (node2);
      }
      _initTokenizerForFragmentParsing() {
        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
          const tn = this.treeAdapter.getTagName(this.fragmentContext);
          if (tn === $.TITLE || tn === $.TEXTAREA) {
            this.tokenizer.state = Tokenizer.MODE.RCDATA;
          } else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME || tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {
            this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
          } else if (tn === $.SCRIPT) {
            this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
          } else if (tn === $.PLAINTEXT) {
            this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
          }
        }
      }
      _setDocumentType(token) {
        const name = token.name || "";
        const publicId = token.publicId || "";
        const systemId = token.systemId || "";
        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
      }
      _attachElementToTree(element4) {
        if (this._shouldFosterParentOnInsertion()) {
          this._fosterParentElement(element4);
        } else {
          const parent = this.openElements.currentTmplContent || this.openElements.current;
          this.treeAdapter.appendChild(parent, element4);
        }
      }
      _appendElement(token, namespaceURI) {
        const element4 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
        this._attachElementToTree(element4);
      }
      _insertElement(token, namespaceURI) {
        const element4 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
        this._attachElementToTree(element4);
        this.openElements.push(element4);
      }
      _insertFakeElement(tagName) {
        const element4 = this.treeAdapter.createElement(tagName, NS.HTML, []);
        this._attachElementToTree(element4);
        this.openElements.push(element4);
      }
      _insertTemplate(token) {
        const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
        const content3 = this.treeAdapter.createDocumentFragment();
        this.treeAdapter.setTemplateContent(tmpl, content3);
        this._attachElementToTree(tmpl);
        this.openElements.push(tmpl);
      }
      _insertFakeRootElement() {
        const element4 = this.treeAdapter.createElement($.HTML, NS.HTML, []);
        this.treeAdapter.appendChild(this.openElements.current, element4);
        this.openElements.push(element4);
      }
      _appendCommentNode(token, parent) {
        const commentNode = this.treeAdapter.createCommentNode(token.data);
        this.treeAdapter.appendChild(parent, commentNode);
      }
      _insertCharacters(token) {
        if (this._shouldFosterParentOnInsertion()) {
          this._fosterParentText(token.chars);
        } else {
          const parent = this.openElements.currentTmplContent || this.openElements.current;
          this.treeAdapter.insertText(parent, token.chars);
        }
      }
      _adoptNodes(donor, recipient) {
        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
          this.treeAdapter.detachNode(child);
          this.treeAdapter.appendChild(recipient, child);
        }
      }
      _shouldProcessTokenInForeignContent(token) {
        const current = this._getAdjustedCurrentElement();
        if (!current || current === this.document) {
          return false;
        }
        const ns = this.treeAdapter.getNamespaceURI(current);
        if (ns === NS.HTML) {
          return false;
        }
        if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns === NS.MATHML && token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG) {
          return false;
        }
        const isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;
        const isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;
        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {
          return false;
        }
        if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS.HTML)) {
          return false;
        }
        return token.type !== Tokenizer.EOF_TOKEN;
      }
      _processToken(token) {
        TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
      }
      _processTokenInBodyMode(token) {
        TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
      }
      _processTokenInForeignContent(token) {
        if (token.type === Tokenizer.CHARACTER_TOKEN) {
          characterInForeignContent(this, token);
        } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
          nullCharacterInForeignContent(this, token);
        } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
          insertCharacters(this, token);
        } else if (token.type === Tokenizer.COMMENT_TOKEN) {
          appendComment(this, token);
        } else if (token.type === Tokenizer.START_TAG_TOKEN) {
          startTagInForeignContent(this, token);
        } else if (token.type === Tokenizer.END_TAG_TOKEN) {
          endTagInForeignContent(this, token);
        }
      }
      _processInputToken(token) {
        if (this._shouldProcessTokenInForeignContent(token)) {
          this._processTokenInForeignContent(token);
        } else {
          this._processToken(token);
        }
        if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
          this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
        }
      }
      _isIntegrationPoint(element4, foreignNS) {
        const tn = this.treeAdapter.getTagName(element4);
        const ns = this.treeAdapter.getNamespaceURI(element4);
        const attrs = this.treeAdapter.getAttrList(element4);
        return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
      }
      _reconstructActiveFormattingElements() {
        const listLength = this.activeFormattingElements.length;
        if (listLength) {
          let unopenIdx = listLength;
          let entry = null;
          do {
            unopenIdx--;
            entry = this.activeFormattingElements.entries[unopenIdx];
            if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
              unopenIdx++;
              break;
            }
          } while (unopenIdx > 0);
          for (let i = unopenIdx; i < listLength; i++) {
            entry = this.activeFormattingElements.entries[i];
            this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
            entry.element = this.openElements.current;
          }
        }
      }
      _closeTableCell() {
        this.openElements.generateImpliedEndTags();
        this.openElements.popUntilTableCellPopped();
        this.activeFormattingElements.clearToLastMarker();
        this.insertionMode = IN_ROW_MODE;
      }
      _closePElement() {
        this.openElements.generateImpliedEndTagsWithExclusion($.P);
        this.openElements.popUntilTagNamePopped($.P);
      }
      _resetInsertionMode() {
        for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
          let element4 = this.openElements.items[i];
          if (i === 0) {
            last = true;
            if (this.fragmentContext) {
              element4 = this.fragmentContext;
            }
          }
          const tn = this.treeAdapter.getTagName(element4);
          const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];
          if (newInsertionMode) {
            this.insertionMode = newInsertionMode;
            break;
          } else if (!last && (tn === $.TD || tn === $.TH)) {
            this.insertionMode = IN_CELL_MODE;
            break;
          } else if (!last && tn === $.HEAD) {
            this.insertionMode = IN_HEAD_MODE;
            break;
          } else if (tn === $.SELECT) {
            this._resetInsertionModeForSelect(i);
            break;
          } else if (tn === $.TEMPLATE) {
            this.insertionMode = this.currentTmplInsertionMode;
            break;
          } else if (tn === $.HTML) {
            this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
            break;
          } else if (last) {
            this.insertionMode = IN_BODY_MODE;
            break;
          }
        }
      }
      _resetInsertionModeForSelect(selectIdx) {
        if (selectIdx > 0) {
          for (let i = selectIdx - 1; i > 0; i--) {
            const ancestor = this.openElements.items[i];
            const tn = this.treeAdapter.getTagName(ancestor);
            if (tn === $.TEMPLATE) {
              break;
            } else if (tn === $.TABLE) {
              this.insertionMode = IN_SELECT_IN_TABLE_MODE;
              return;
            }
          }
        }
        this.insertionMode = IN_SELECT_MODE;
      }
      _pushTmplInsertionMode(mode) {
        this.tmplInsertionModeStack.push(mode);
        this.tmplInsertionModeStackTop++;
        this.currentTmplInsertionMode = mode;
      }
      _popTmplInsertionMode() {
        this.tmplInsertionModeStack.pop();
        this.tmplInsertionModeStackTop--;
        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
      }
      _isElementCausesFosterParenting(element4) {
        const tn = this.treeAdapter.getTagName(element4);
        return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
      }
      _shouldFosterParentOnInsertion() {
        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
      }
      _findFosterParentingLocation() {
        const location3 = {
          parent: null,
          beforeElement: null
        };
        for (let i = this.openElements.stackTop; i >= 0; i--) {
          const openElement = this.openElements.items[i];
          const tn = this.treeAdapter.getTagName(openElement);
          const ns = this.treeAdapter.getNamespaceURI(openElement);
          if (tn === $.TEMPLATE && ns === NS.HTML) {
            location3.parent = this.treeAdapter.getTemplateContent(openElement);
            break;
          } else if (tn === $.TABLE) {
            location3.parent = this.treeAdapter.getParentNode(openElement);
            if (location3.parent) {
              location3.beforeElement = openElement;
            } else {
              location3.parent = this.openElements.items[i - 1];
            }
            break;
          }
        }
        if (!location3.parent) {
          location3.parent = this.openElements.items[0];
        }
        return location3;
      }
      _fosterParentElement(element4) {
        const location3 = this._findFosterParentingLocation();
        if (location3.beforeElement) {
          this.treeAdapter.insertBefore(location3.parent, element4, location3.beforeElement);
        } else {
          this.treeAdapter.appendChild(location3.parent, element4);
        }
      }
      _fosterParentText(chars2) {
        const location3 = this._findFosterParentingLocation();
        if (location3.beforeElement) {
          this.treeAdapter.insertTextBefore(location3.parent, chars2, location3.beforeElement);
        } else {
          this.treeAdapter.insertText(location3.parent, chars2);
        }
      }
      _isSpecialElement(element4) {
        const tn = this.treeAdapter.getTagName(element4);
        const ns = this.treeAdapter.getNamespaceURI(element4);
        return HTML.SPECIAL_ELEMENTS[ns][tn];
      }
    };
    module2.exports = Parser2;
    function aaObtainFormattingElementEntry(p2, token) {
      let formattingElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
      if (formattingElementEntry) {
        if (!p2.openElements.contains(formattingElementEntry.element)) {
          p2.activeFormattingElements.removeEntry(formattingElementEntry);
          formattingElementEntry = null;
        } else if (!p2.openElements.hasInScope(token.tagName)) {
          formattingElementEntry = null;
        }
      } else {
        genericEndTagInBody(p2, token);
      }
      return formattingElementEntry;
    }
    function aaObtainFurthestBlock(p2, formattingElementEntry) {
      let furthestBlock = null;
      for (let i = p2.openElements.stackTop; i >= 0; i--) {
        const element4 = p2.openElements.items[i];
        if (element4 === formattingElementEntry.element) {
          break;
        }
        if (p2._isSpecialElement(element4)) {
          furthestBlock = element4;
        }
      }
      if (!furthestBlock) {
        p2.openElements.popUntilElementPopped(formattingElementEntry.element);
        p2.activeFormattingElements.removeEntry(formattingElementEntry);
      }
      return furthestBlock;
    }
    function aaInnerLoop(p2, furthestBlock, formattingElement) {
      let lastElement = furthestBlock;
      let nextElement = p2.openElements.getCommonAncestor(furthestBlock);
      for (let i = 0, element4 = nextElement; element4 !== formattingElement; i++, element4 = nextElement) {
        nextElement = p2.openElements.getCommonAncestor(element4);
        const elementEntry = p2.activeFormattingElements.getElementEntry(element4);
        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
        if (shouldRemoveFromOpenElements) {
          if (counterOverflow) {
            p2.activeFormattingElements.removeEntry(elementEntry);
          }
          p2.openElements.remove(element4);
        } else {
          element4 = aaRecreateElementFromEntry(p2, elementEntry);
          if (lastElement === furthestBlock) {
            p2.activeFormattingElements.bookmark = elementEntry;
          }
          p2.treeAdapter.detachNode(lastElement);
          p2.treeAdapter.appendChild(element4, lastElement);
          lastElement = element4;
        }
      }
      return lastElement;
    }
    function aaRecreateElementFromEntry(p2, elementEntry) {
      const ns = p2.treeAdapter.getNamespaceURI(elementEntry.element);
      const newElement = p2.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
      p2.openElements.replace(elementEntry.element, newElement);
      elementEntry.element = newElement;
      return newElement;
    }
    function aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement) {
      if (p2._isElementCausesFosterParenting(commonAncestor)) {
        p2._fosterParentElement(lastElement);
      } else {
        const tn = p2.treeAdapter.getTagName(commonAncestor);
        const ns = p2.treeAdapter.getNamespaceURI(commonAncestor);
        if (tn === $.TEMPLATE && ns === NS.HTML) {
          commonAncestor = p2.treeAdapter.getTemplateContent(commonAncestor);
        }
        p2.treeAdapter.appendChild(commonAncestor, lastElement);
      }
    }
    function aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry) {
      const ns = p2.treeAdapter.getNamespaceURI(formattingElementEntry.element);
      const token = formattingElementEntry.token;
      const newElement = p2.treeAdapter.createElement(token.tagName, ns, token.attrs);
      p2._adoptNodes(furthestBlock, newElement);
      p2.treeAdapter.appendChild(furthestBlock, newElement);
      p2.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
      p2.activeFormattingElements.removeEntry(formattingElementEntry);
      p2.openElements.remove(formattingElementEntry.element);
      p2.openElements.insertAfter(furthestBlock, newElement);
    }
    function callAdoptionAgency(p2, token) {
      let formattingElementEntry;
      for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
        formattingElementEntry = aaObtainFormattingElementEntry(p2, token, formattingElementEntry);
        if (!formattingElementEntry) {
          break;
        }
        const furthestBlock = aaObtainFurthestBlock(p2, formattingElementEntry);
        if (!furthestBlock) {
          break;
        }
        p2.activeFormattingElements.bookmark = formattingElementEntry;
        const lastElement = aaInnerLoop(p2, furthestBlock, formattingElementEntry.element);
        const commonAncestor = p2.openElements.getCommonAncestor(formattingElementEntry.element);
        p2.treeAdapter.detachNode(lastElement);
        aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement);
        aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry);
      }
    }
    function ignoreToken() {
    }
    function misplacedDoctype(p2) {
      p2._err(ERR.misplacedDoctype);
    }
    function appendComment(p2, token) {
      p2._appendCommentNode(token, p2.openElements.currentTmplContent || p2.openElements.current);
    }
    function appendCommentToRootHtmlElement(p2, token) {
      p2._appendCommentNode(token, p2.openElements.items[0]);
    }
    function appendCommentToDocument(p2, token) {
      p2._appendCommentNode(token, p2.document);
    }
    function insertCharacters(p2, token) {
      p2._insertCharacters(token);
    }
    function stopParsing(p2) {
      p2.stopped = true;
    }
    function doctypeInInitialMode(p2, token) {
      p2._setDocumentType(token);
      const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype2.getDocumentMode(token);
      if (!doctype2.isConforming(token)) {
        p2._err(ERR.nonConformingDoctype);
      }
      p2.treeAdapter.setDocumentMode(p2.document, mode);
      p2.insertionMode = BEFORE_HTML_MODE;
    }
    function tokenInInitialMode(p2, token) {
      p2._err(ERR.missingDoctype, { beforeToken: true });
      p2.treeAdapter.setDocumentMode(p2.document, HTML.DOCUMENT_MODE.QUIRKS);
      p2.insertionMode = BEFORE_HTML_MODE;
      p2._processToken(token);
    }
    function startTagBeforeHtml(p2, token) {
      if (token.tagName === $.HTML) {
        p2._insertElement(token, NS.HTML);
        p2.insertionMode = BEFORE_HEAD_MODE;
      } else {
        tokenBeforeHtml(p2, token);
      }
    }
    function endTagBeforeHtml(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
        tokenBeforeHtml(p2, token);
      }
    }
    function tokenBeforeHtml(p2, token) {
      p2._insertFakeRootElement();
      p2.insertionMode = BEFORE_HEAD_MODE;
      p2._processToken(token);
    }
    function startTagBeforeHead(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.HEAD) {
        p2._insertElement(token, NS.HTML);
        p2.headElement = p2.openElements.current;
        p2.insertionMode = IN_HEAD_MODE;
      } else {
        tokenBeforeHead(p2, token);
      }
    }
    function endTagBeforeHead(p2, token) {
      const tn = token.tagName;
      if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
        tokenBeforeHead(p2, token);
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenBeforeHead(p2, token) {
      p2._insertFakeElement($.HEAD);
      p2.headElement = p2.openElements.current;
      p2.insertionMode = IN_HEAD_MODE;
      p2._processToken(token);
    }
    function startTagInHead(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {
        p2._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
      } else if (tn === $.TITLE) {
        p2._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
      } else if (tn === $.NOSCRIPT) {
        if (p2.options.scriptingEnabled) {
          p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
        } else {
          p2._insertElement(token, NS.HTML);
          p2.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
        }
      } else if (tn === $.NOFRAMES || tn === $.STYLE) {
        p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
      } else if (tn === $.SCRIPT) {
        p2._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
      } else if (tn === $.TEMPLATE) {
        p2._insertTemplate(token, NS.HTML);
        p2.activeFormattingElements.insertMarker();
        p2.framesetOk = false;
        p2.insertionMode = IN_TEMPLATE_MODE;
        p2._pushTmplInsertionMode(IN_TEMPLATE_MODE);
      } else if (tn === $.HEAD) {
        p2._err(ERR.misplacedStartTagForHeadElement);
      } else {
        tokenInHead(p2, token);
      }
    }
    function endTagInHead(p2, token) {
      const tn = token.tagName;
      if (tn === $.HEAD) {
        p2.openElements.pop();
        p2.insertionMode = AFTER_HEAD_MODE;
      } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
        tokenInHead(p2, token);
      } else if (tn === $.TEMPLATE) {
        if (p2.openElements.tmplCount > 0) {
          p2.openElements.generateImpliedEndTagsThoroughly();
          if (p2.openElements.currentTagName !== $.TEMPLATE) {
            p2._err(ERR.closingOfElementWithOpenChildElements);
          }
          p2.openElements.popUntilTagNamePopped($.TEMPLATE);
          p2.activeFormattingElements.clearToLastMarker();
          p2._popTmplInsertionMode();
          p2._resetInsertionMode();
        } else {
          p2._err(ERR.endTagWithoutMatchingOpenElement);
        }
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenInHead(p2, token) {
      p2.openElements.pop();
      p2.insertionMode = AFTER_HEAD_MODE;
      p2._processToken(token);
    }
    function startTagInHeadNoScript(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.BASEFONT || tn === $.BGSOUND || tn === $.HEAD || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.STYLE) {
        startTagInHead(p2, token);
      } else if (tn === $.NOSCRIPT) {
        p2._err(ERR.nestedNoscriptInHead);
      } else {
        tokenInHeadNoScript(p2, token);
      }
    }
    function endTagInHeadNoScript(p2, token) {
      const tn = token.tagName;
      if (tn === $.NOSCRIPT) {
        p2.openElements.pop();
        p2.insertionMode = IN_HEAD_MODE;
      } else if (tn === $.BR) {
        tokenInHeadNoScript(p2, token);
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenInHeadNoScript(p2, token) {
      const errCode = token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
      p2._err(errCode);
      p2.openElements.pop();
      p2.insertionMode = IN_HEAD_MODE;
      p2._processToken(token);
    }
    function startTagAfterHead(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.BODY) {
        p2._insertElement(token, NS.HTML);
        p2.framesetOk = false;
        p2.insertionMode = IN_BODY_MODE;
      } else if (tn === $.FRAMESET) {
        p2._insertElement(token, NS.HTML);
        p2.insertionMode = IN_FRAMESET_MODE;
      } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
        p2._err(ERR.abandonedHeadElementChild);
        p2.openElements.push(p2.headElement);
        startTagInHead(p2, token);
        p2.openElements.remove(p2.headElement);
      } else if (tn === $.HEAD) {
        p2._err(ERR.misplacedStartTagForHeadElement);
      } else {
        tokenAfterHead(p2, token);
      }
    }
    function endTagAfterHead(p2, token) {
      const tn = token.tagName;
      if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
        tokenAfterHead(p2, token);
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token);
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenAfterHead(p2, token) {
      p2._insertFakeElement($.BODY);
      p2.insertionMode = IN_BODY_MODE;
      p2._processToken(token);
    }
    function whitespaceCharacterInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._insertCharacters(token);
    }
    function characterInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._insertCharacters(token);
      p2.framesetOk = false;
    }
    function htmlStartTagInBody(p2, token) {
      if (p2.openElements.tmplCount === 0) {
        p2.treeAdapter.adoptAttributes(p2.openElements.items[0], token.attrs);
      }
    }
    function bodyStartTagInBody(p2, token) {
      const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement && p2.openElements.tmplCount === 0) {
        p2.framesetOk = false;
        p2.treeAdapter.adoptAttributes(bodyElement, token.attrs);
      }
    }
    function framesetStartTagInBody(p2, token) {
      const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
      if (p2.framesetOk && bodyElement) {
        p2.treeAdapter.detachNode(bodyElement);
        p2.openElements.popAllUpToHtmlElement();
        p2._insertElement(token, NS.HTML);
        p2.insertionMode = IN_FRAMESET_MODE;
      }
    }
    function addressStartTagInBody(p2, token) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
    }
    function numberedHeaderStartTagInBody(p2, token) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      const tn = p2.openElements.currentTagName;
      if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
        p2.openElements.pop();
      }
      p2._insertElement(token, NS.HTML);
    }
    function preStartTagInBody(p2, token) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
      p2.skipNextNewLine = true;
      p2.framesetOk = false;
    }
    function formStartTagInBody(p2, token) {
      const inTemplate = p2.openElements.tmplCount > 0;
      if (!p2.formElement || inTemplate) {
        if (p2.openElements.hasInButtonScope($.P)) {
          p2._closePElement();
        }
        p2._insertElement(token, NS.HTML);
        if (!inTemplate) {
          p2.formElement = p2.openElements.current;
        }
      }
    }
    function listItemStartTagInBody(p2, token) {
      p2.framesetOk = false;
      const tn = token.tagName;
      for (let i = p2.openElements.stackTop; i >= 0; i--) {
        const element4 = p2.openElements.items[i];
        const elementTn = p2.treeAdapter.getTagName(element4);
        let closeTn = null;
        if (tn === $.LI && elementTn === $.LI) {
          closeTn = $.LI;
        } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
          closeTn = elementTn;
        }
        if (closeTn) {
          p2.openElements.generateImpliedEndTagsWithExclusion(closeTn);
          p2.openElements.popUntilTagNamePopped(closeTn);
          break;
        }
        if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p2._isSpecialElement(element4)) {
          break;
        }
      }
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
    }
    function plaintextStartTagInBody(p2, token) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
      p2.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
    }
    function buttonStartTagInBody(p2, token) {
      if (p2.openElements.hasInScope($.BUTTON)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped($.BUTTON);
      }
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token, NS.HTML);
      p2.framesetOk = false;
    }
    function aStartTagInBody(p2, token) {
      const activeElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName($.A);
      if (activeElementEntry) {
        callAdoptionAgency(p2, token);
        p2.openElements.remove(activeElementEntry.element);
        p2.activeFormattingElements.removeEntry(activeElementEntry);
      }
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token, NS.HTML);
      p2.activeFormattingElements.pushElement(p2.openElements.current, token);
    }
    function bStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token, NS.HTML);
      p2.activeFormattingElements.pushElement(p2.openElements.current, token);
    }
    function nobrStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      if (p2.openElements.hasInScope($.NOBR)) {
        callAdoptionAgency(p2, token);
        p2._reconstructActiveFormattingElements();
      }
      p2._insertElement(token, NS.HTML);
      p2.activeFormattingElements.pushElement(p2.openElements.current, token);
    }
    function appletStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token, NS.HTML);
      p2.activeFormattingElements.insertMarker();
      p2.framesetOk = false;
    }
    function tableStartTagInBody(p2, token) {
      if (p2.treeAdapter.getDocumentMode(p2.document) !== HTML.DOCUMENT_MODE.QUIRKS && p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
      p2.framesetOk = false;
      p2.insertionMode = IN_TABLE_MODE;
    }
    function areaStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._appendElement(token, NS.HTML);
      p2.framesetOk = false;
      token.ackSelfClosing = true;
    }
    function inputStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._appendElement(token, NS.HTML);
      const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
      if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
        p2.framesetOk = false;
      }
      token.ackSelfClosing = true;
    }
    function paramStartTagInBody(p2, token) {
      p2._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
    }
    function hrStartTagInBody(p2, token) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._appendElement(token, NS.HTML);
      p2.framesetOk = false;
      token.ackSelfClosing = true;
    }
    function imageStartTagInBody(p2, token) {
      token.tagName = $.IMG;
      areaStartTagInBody(p2, token);
    }
    function textareaStartTagInBody(p2, token) {
      p2._insertElement(token, NS.HTML);
      p2.skipNextNewLine = true;
      p2.tokenizer.state = Tokenizer.MODE.RCDATA;
      p2.originalInsertionMode = p2.insertionMode;
      p2.framesetOk = false;
      p2.insertionMode = TEXT_MODE;
    }
    function xmpStartTagInBody(p2, token) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._reconstructActiveFormattingElements();
      p2.framesetOk = false;
      p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    }
    function iframeStartTagInBody(p2, token) {
      p2.framesetOk = false;
      p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    }
    function noembedStartTagInBody(p2, token) {
      p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    }
    function selectStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token, NS.HTML);
      p2.framesetOk = false;
      if (p2.insertionMode === IN_TABLE_MODE || p2.insertionMode === IN_CAPTION_MODE || p2.insertionMode === IN_TABLE_BODY_MODE || p2.insertionMode === IN_ROW_MODE || p2.insertionMode === IN_CELL_MODE) {
        p2.insertionMode = IN_SELECT_IN_TABLE_MODE;
      } else {
        p2.insertionMode = IN_SELECT_MODE;
      }
    }
    function optgroupStartTagInBody(p2, token) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token, NS.HTML);
    }
    function rbStartTagInBody(p2, token) {
      if (p2.openElements.hasInScope($.RUBY)) {
        p2.openElements.generateImpliedEndTags();
      }
      p2._insertElement(token, NS.HTML);
    }
    function rtStartTagInBody(p2, token) {
      if (p2.openElements.hasInScope($.RUBY)) {
        p2.openElements.generateImpliedEndTagsWithExclusion($.RTC);
      }
      p2._insertElement(token, NS.HTML);
    }
    function menuStartTagInBody(p2, token) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token, NS.HTML);
    }
    function mathStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      foreignContent.adjustTokenMathMLAttrs(token);
      foreignContent.adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p2._appendElement(token, NS.MATHML);
      } else {
        p2._insertElement(token, NS.MATHML);
      }
      token.ackSelfClosing = true;
    }
    function svgStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      foreignContent.adjustTokenSVGAttrs(token);
      foreignContent.adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p2._appendElement(token, NS.SVG);
      } else {
        p2._insertElement(token, NS.SVG);
      }
      token.ackSelfClosing = true;
    }
    function genericStartTagInBody(p2, token) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token, NS.HTML);
    }
    function startTagInBody(p2, token) {
      const tn = token.tagName;
      switch (tn.length) {
        case 1:
          if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
            bStartTagInBody(p2, token);
          } else if (tn === $.P) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.A) {
            aStartTagInBody(p2, token);
          } else {
            genericStartTagInBody(p2, token);
          }
          break;
        case 2:
          if (tn === $.DL || tn === $.OL || tn === $.UL) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
            numberedHeaderStartTagInBody(p2, token);
          } else if (tn === $.LI || tn === $.DD || tn === $.DT) {
            listItemStartTagInBody(p2, token);
          } else if (tn === $.EM || tn === $.TT) {
            bStartTagInBody(p2, token);
          } else if (tn === $.BR) {
            areaStartTagInBody(p2, token);
          } else if (tn === $.HR) {
            hrStartTagInBody(p2, token);
          } else if (tn === $.RB) {
            rbStartTagInBody(p2, token);
          } else if (tn === $.RT || tn === $.RP) {
            rtStartTagInBody(p2, token);
          } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
            genericStartTagInBody(p2, token);
          }
          break;
        case 3:
          if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.PRE) {
            preStartTagInBody(p2, token);
          } else if (tn === $.BIG) {
            bStartTagInBody(p2, token);
          } else if (tn === $.IMG || tn === $.WBR) {
            areaStartTagInBody(p2, token);
          } else if (tn === $.XMP) {
            xmpStartTagInBody(p2, token);
          } else if (tn === $.SVG) {
            svgStartTagInBody(p2, token);
          } else if (tn === $.RTC) {
            rbStartTagInBody(p2, token);
          } else if (tn !== $.COL) {
            genericStartTagInBody(p2, token);
          }
          break;
        case 4:
          if (tn === $.HTML) {
            htmlStartTagInBody(p2, token);
          } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
            startTagInHead(p2, token);
          } else if (tn === $.BODY) {
            bodyStartTagInBody(p2, token);
          } else if (tn === $.MAIN || tn === $.MENU) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.FORM) {
            formStartTagInBody(p2, token);
          } else if (tn === $.CODE || tn === $.FONT) {
            bStartTagInBody(p2, token);
          } else if (tn === $.NOBR) {
            nobrStartTagInBody(p2, token);
          } else if (tn === $.AREA) {
            areaStartTagInBody(p2, token);
          } else if (tn === $.MATH) {
            mathStartTagInBody(p2, token);
          } else if (tn === $.MENU) {
            menuStartTagInBody(p2, token);
          } else if (tn !== $.HEAD) {
            genericStartTagInBody(p2, token);
          }
          break;
        case 5:
          if (tn === $.STYLE || tn === $.TITLE) {
            startTagInHead(p2, token);
          } else if (tn === $.ASIDE) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.SMALL) {
            bStartTagInBody(p2, token);
          } else if (tn === $.TABLE) {
            tableStartTagInBody(p2, token);
          } else if (tn === $.EMBED) {
            areaStartTagInBody(p2, token);
          } else if (tn === $.INPUT) {
            inputStartTagInBody(p2, token);
          } else if (tn === $.PARAM || tn === $.TRACK) {
            paramStartTagInBody(p2, token);
          } else if (tn === $.IMAGE) {
            imageStartTagInBody(p2, token);
          } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
            genericStartTagInBody(p2, token);
          }
          break;
        case 6:
          if (tn === $.SCRIPT) {
            startTagInHead(p2, token);
          } else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.BUTTON) {
            buttonStartTagInBody(p2, token);
          } else if (tn === $.STRIKE || tn === $.STRONG) {
            bStartTagInBody(p2, token);
          } else if (tn === $.APPLET || tn === $.OBJECT) {
            appletStartTagInBody(p2, token);
          } else if (tn === $.KEYGEN) {
            areaStartTagInBody(p2, token);
          } else if (tn === $.SOURCE) {
            paramStartTagInBody(p2, token);
          } else if (tn === $.IFRAME) {
            iframeStartTagInBody(p2, token);
          } else if (tn === $.SELECT) {
            selectStartTagInBody(p2, token);
          } else if (tn === $.OPTION) {
            optgroupStartTagInBody(p2, token);
          } else {
            genericStartTagInBody(p2, token);
          }
          break;
        case 7:
          if (tn === $.BGSOUND) {
            startTagInHead(p2, token);
          } else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.LISTING) {
            preStartTagInBody(p2, token);
          } else if (tn === $.MARQUEE) {
            appletStartTagInBody(p2, token);
          } else if (tn === $.NOEMBED) {
            noembedStartTagInBody(p2, token);
          } else if (tn !== $.CAPTION) {
            genericStartTagInBody(p2, token);
          }
          break;
        case 8:
          if (tn === $.BASEFONT) {
            startTagInHead(p2, token);
          } else if (tn === $.FRAMESET) {
            framesetStartTagInBody(p2, token);
          } else if (tn === $.FIELDSET) {
            addressStartTagInBody(p2, token);
          } else if (tn === $.TEXTAREA) {
            textareaStartTagInBody(p2, token);
          } else if (tn === $.TEMPLATE) {
            startTagInHead(p2, token);
          } else if (tn === $.NOSCRIPT) {
            if (p2.options.scriptingEnabled) {
              noembedStartTagInBody(p2, token);
            } else {
              genericStartTagInBody(p2, token);
            }
          } else if (tn === $.OPTGROUP) {
            optgroupStartTagInBody(p2, token);
          } else if (tn !== $.COLGROUP) {
            genericStartTagInBody(p2, token);
          }
          break;
        case 9:
          if (tn === $.PLAINTEXT) {
            plaintextStartTagInBody(p2, token);
          } else {
            genericStartTagInBody(p2, token);
          }
          break;
        case 10:
          if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
            addressStartTagInBody(p2, token);
          } else {
            genericStartTagInBody(p2, token);
          }
          break;
        default:
          genericStartTagInBody(p2, token);
      }
    }
    function bodyEndTagInBody(p2) {
      if (p2.openElements.hasInScope($.BODY)) {
        p2.insertionMode = AFTER_BODY_MODE;
      }
    }
    function htmlEndTagInBody(p2, token) {
      if (p2.openElements.hasInScope($.BODY)) {
        p2.insertionMode = AFTER_BODY_MODE;
        p2._processToken(token);
      }
    }
    function addressEndTagInBody(p2, token) {
      const tn = token.tagName;
      if (p2.openElements.hasInScope(tn)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn);
      }
    }
    function formEndTagInBody(p2) {
      const inTemplate = p2.openElements.tmplCount > 0;
      const formElement = p2.formElement;
      if (!inTemplate) {
        p2.formElement = null;
      }
      if ((formElement || inTemplate) && p2.openElements.hasInScope($.FORM)) {
        p2.openElements.generateImpliedEndTags();
        if (inTemplate) {
          p2.openElements.popUntilTagNamePopped($.FORM);
        } else {
          p2.openElements.remove(formElement);
        }
      }
    }
    function pEndTagInBody(p2) {
      if (!p2.openElements.hasInButtonScope($.P)) {
        p2._insertFakeElement($.P);
      }
      p2._closePElement();
    }
    function liEndTagInBody(p2) {
      if (p2.openElements.hasInListItemScope($.LI)) {
        p2.openElements.generateImpliedEndTagsWithExclusion($.LI);
        p2.openElements.popUntilTagNamePopped($.LI);
      }
    }
    function ddEndTagInBody(p2, token) {
      const tn = token.tagName;
      if (p2.openElements.hasInScope(tn)) {
        p2.openElements.generateImpliedEndTagsWithExclusion(tn);
        p2.openElements.popUntilTagNamePopped(tn);
      }
    }
    function numberedHeaderEndTagInBody(p2) {
      if (p2.openElements.hasNumberedHeaderInScope()) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilNumberedHeaderPopped();
      }
    }
    function appletEndTagInBody(p2, token) {
      const tn = token.tagName;
      if (p2.openElements.hasInScope(tn)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn);
        p2.activeFormattingElements.clearToLastMarker();
      }
    }
    function brEndTagInBody(p2) {
      p2._reconstructActiveFormattingElements();
      p2._insertFakeElement($.BR);
      p2.openElements.pop();
      p2.framesetOk = false;
    }
    function genericEndTagInBody(p2, token) {
      const tn = token.tagName;
      for (let i = p2.openElements.stackTop; i > 0; i--) {
        const element4 = p2.openElements.items[i];
        if (p2.treeAdapter.getTagName(element4) === tn) {
          p2.openElements.generateImpliedEndTagsWithExclusion(tn);
          p2.openElements.popUntilElementPopped(element4);
          break;
        }
        if (p2._isSpecialElement(element4)) {
          break;
        }
      }
    }
    function endTagInBody(p2, token) {
      const tn = token.tagName;
      switch (tn.length) {
        case 1:
          if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
            callAdoptionAgency(p2, token);
          } else if (tn === $.P) {
            pEndTagInBody(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 2:
          if (tn === $.DL || tn === $.UL || tn === $.OL) {
            addressEndTagInBody(p2, token);
          } else if (tn === $.LI) {
            liEndTagInBody(p2, token);
          } else if (tn === $.DD || tn === $.DT) {
            ddEndTagInBody(p2, token);
          } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
            numberedHeaderEndTagInBody(p2, token);
          } else if (tn === $.BR) {
            brEndTagInBody(p2, token);
          } else if (tn === $.EM || tn === $.TT) {
            callAdoptionAgency(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 3:
          if (tn === $.BIG) {
            callAdoptionAgency(p2, token);
          } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
            addressEndTagInBody(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 4:
          if (tn === $.BODY) {
            bodyEndTagInBody(p2, token);
          } else if (tn === $.HTML) {
            htmlEndTagInBody(p2, token);
          } else if (tn === $.FORM) {
            formEndTagInBody(p2, token);
          } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
            callAdoptionAgency(p2, token);
          } else if (tn === $.MAIN || tn === $.MENU) {
            addressEndTagInBody(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 5:
          if (tn === $.ASIDE) {
            addressEndTagInBody(p2, token);
          } else if (tn === $.SMALL) {
            callAdoptionAgency(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 6:
          if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
            addressEndTagInBody(p2, token);
          } else if (tn === $.APPLET || tn === $.OBJECT) {
            appletEndTagInBody(p2, token);
          } else if (tn === $.STRIKE || tn === $.STRONG) {
            callAdoptionAgency(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 7:
          if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY || tn === $.LISTING) {
            addressEndTagInBody(p2, token);
          } else if (tn === $.MARQUEE) {
            appletEndTagInBody(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 8:
          if (tn === $.FIELDSET) {
            addressEndTagInBody(p2, token);
          } else if (tn === $.TEMPLATE) {
            endTagInHead(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        case 10:
          if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
            addressEndTagInBody(p2, token);
          } else {
            genericEndTagInBody(p2, token);
          }
          break;
        default:
          genericEndTagInBody(p2, token);
      }
    }
    function eofInBody(p2, token) {
      if (p2.tmplInsertionModeStackTop > -1) {
        eofInTemplate(p2, token);
      } else {
        p2.stopped = true;
      }
    }
    function endTagInText(p2, token) {
      if (token.tagName === $.SCRIPT) {
        p2.pendingScript = p2.openElements.current;
      }
      p2.openElements.pop();
      p2.insertionMode = p2.originalInsertionMode;
    }
    function eofInText(p2, token) {
      p2._err(ERR.eofInElementThatCanContainOnlyText);
      p2.openElements.pop();
      p2.insertionMode = p2.originalInsertionMode;
      p2._processToken(token);
    }
    function characterInTable(p2, token) {
      const curTn = p2.openElements.currentTagName;
      if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
        p2.pendingCharacterTokens = [];
        p2.hasNonWhitespacePendingCharacterToken = false;
        p2.originalInsertionMode = p2.insertionMode;
        p2.insertionMode = IN_TABLE_TEXT_MODE;
        p2._processToken(token);
      } else {
        tokenInTable(p2, token);
      }
    }
    function captionStartTagInTable(p2, token) {
      p2.openElements.clearBackToTableContext();
      p2.activeFormattingElements.insertMarker();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_CAPTION_MODE;
    }
    function colgroupStartTagInTable(p2, token) {
      p2.openElements.clearBackToTableContext();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_COLUMN_GROUP_MODE;
    }
    function colStartTagInTable(p2, token) {
      p2.openElements.clearBackToTableContext();
      p2._insertFakeElement($.COLGROUP);
      p2.insertionMode = IN_COLUMN_GROUP_MODE;
      p2._processToken(token);
    }
    function tbodyStartTagInTable(p2, token) {
      p2.openElements.clearBackToTableContext();
      p2._insertElement(token, NS.HTML);
      p2.insertionMode = IN_TABLE_BODY_MODE;
    }
    function tdStartTagInTable(p2, token) {
      p2.openElements.clearBackToTableContext();
      p2._insertFakeElement($.TBODY);
      p2.insertionMode = IN_TABLE_BODY_MODE;
      p2._processToken(token);
    }
    function tableStartTagInTable(p2, token) {
      if (p2.openElements.hasInTableScope($.TABLE)) {
        p2.openElements.popUntilTagNamePopped($.TABLE);
        p2._resetInsertionMode();
        p2._processToken(token);
      }
    }
    function inputStartTagInTable(p2, token) {
      const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
      if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
        p2._appendElement(token, NS.HTML);
      } else {
        tokenInTable(p2, token);
      }
      token.ackSelfClosing = true;
    }
    function formStartTagInTable(p2, token) {
      if (!p2.formElement && p2.openElements.tmplCount === 0) {
        p2._insertElement(token, NS.HTML);
        p2.formElement = p2.openElements.current;
        p2.openElements.pop();
      }
    }
    function startTagInTable(p2, token) {
      const tn = token.tagName;
      switch (tn.length) {
        case 2:
          if (tn === $.TD || tn === $.TH || tn === $.TR) {
            tdStartTagInTable(p2, token);
          } else {
            tokenInTable(p2, token);
          }
          break;
        case 3:
          if (tn === $.COL) {
            colStartTagInTable(p2, token);
          } else {
            tokenInTable(p2, token);
          }
          break;
        case 4:
          if (tn === $.FORM) {
            formStartTagInTable(p2, token);
          } else {
            tokenInTable(p2, token);
          }
          break;
        case 5:
          if (tn === $.TABLE) {
            tableStartTagInTable(p2, token);
          } else if (tn === $.STYLE) {
            startTagInHead(p2, token);
          } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
            tbodyStartTagInTable(p2, token);
          } else if (tn === $.INPUT) {
            inputStartTagInTable(p2, token);
          } else {
            tokenInTable(p2, token);
          }
          break;
        case 6:
          if (tn === $.SCRIPT) {
            startTagInHead(p2, token);
          } else {
            tokenInTable(p2, token);
          }
          break;
        case 7:
          if (tn === $.CAPTION) {
            captionStartTagInTable(p2, token);
          } else {
            tokenInTable(p2, token);
          }
          break;
        case 8:
          if (tn === $.COLGROUP) {
            colgroupStartTagInTable(p2, token);
          } else if (tn === $.TEMPLATE) {
            startTagInHead(p2, token);
          } else {
            tokenInTable(p2, token);
          }
          break;
        default:
          tokenInTable(p2, token);
      }
    }
    function endTagInTable(p2, token) {
      const tn = token.tagName;
      if (tn === $.TABLE) {
        if (p2.openElements.hasInTableScope($.TABLE)) {
          p2.openElements.popUntilTagNamePopped($.TABLE);
          p2._resetInsertionMode();
        }
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token);
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
        tokenInTable(p2, token);
      }
    }
    function tokenInTable(p2, token) {
      const savedFosterParentingState = p2.fosterParentingEnabled;
      p2.fosterParentingEnabled = true;
      p2._processTokenInBodyMode(token);
      p2.fosterParentingEnabled = savedFosterParentingState;
    }
    function whitespaceCharacterInTableText(p2, token) {
      p2.pendingCharacterTokens.push(token);
    }
    function characterInTableText(p2, token) {
      p2.pendingCharacterTokens.push(token);
      p2.hasNonWhitespacePendingCharacterToken = true;
    }
    function tokenInTableText(p2, token) {
      let i = 0;
      if (p2.hasNonWhitespacePendingCharacterToken) {
        for (; i < p2.pendingCharacterTokens.length; i++) {
          tokenInTable(p2, p2.pendingCharacterTokens[i]);
        }
      } else {
        for (; i < p2.pendingCharacterTokens.length; i++) {
          p2._insertCharacters(p2.pendingCharacterTokens[i]);
        }
      }
      p2.insertionMode = p2.originalInsertionMode;
      p2._processToken(token);
    }
    function startTagInCaption(p2, token) {
      const tn = token.tagName;
      if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope($.CAPTION)) {
          p2.openElements.generateImpliedEndTags();
          p2.openElements.popUntilTagNamePopped($.CAPTION);
          p2.activeFormattingElements.clearToLastMarker();
          p2.insertionMode = IN_TABLE_MODE;
          p2._processToken(token);
        }
      } else {
        startTagInBody(p2, token);
      }
    }
    function endTagInCaption(p2, token) {
      const tn = token.tagName;
      if (tn === $.CAPTION || tn === $.TABLE) {
        if (p2.openElements.hasInTableScope($.CAPTION)) {
          p2.openElements.generateImpliedEndTags();
          p2.openElements.popUntilTagNamePopped($.CAPTION);
          p2.activeFormattingElements.clearToLastMarker();
          p2.insertionMode = IN_TABLE_MODE;
          if (tn === $.TABLE) {
            p2._processToken(token);
          }
        }
      } else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
        endTagInBody(p2, token);
      }
    }
    function startTagInColumnGroup(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.COL) {
        p2._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
      } else if (tn === $.TEMPLATE) {
        startTagInHead(p2, token);
      } else {
        tokenInColumnGroup(p2, token);
      }
    }
    function endTagInColumnGroup(p2, token) {
      const tn = token.tagName;
      if (tn === $.COLGROUP) {
        if (p2.openElements.currentTagName === $.COLGROUP) {
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
        }
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token);
      } else if (tn !== $.COL) {
        tokenInColumnGroup(p2, token);
      }
    }
    function tokenInColumnGroup(p2, token) {
      if (p2.openElements.currentTagName === $.COLGROUP) {
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token);
      }
    }
    function startTagInTableBody(p2, token) {
      const tn = token.tagName;
      if (tn === $.TR) {
        p2.openElements.clearBackToTableBodyContext();
        p2._insertElement(token, NS.HTML);
        p2.insertionMode = IN_ROW_MODE;
      } else if (tn === $.TH || tn === $.TD) {
        p2.openElements.clearBackToTableBodyContext();
        p2._insertFakeElement($.TR);
        p2.insertionMode = IN_ROW_MODE;
        p2._processToken(token);
      } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p2.openElements.hasTableBodyContextInTableScope()) {
          p2.openElements.clearBackToTableBodyContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
          p2._processToken(token);
        }
      } else {
        startTagInTable(p2, token);
      }
    }
    function endTagInTableBody(p2, token) {
      const tn = token.tagName;
      if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2.openElements.clearBackToTableBodyContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
        }
      } else if (tn === $.TABLE) {
        if (p2.openElements.hasTableBodyContextInTableScope()) {
          p2.openElements.clearBackToTableBodyContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
          p2._processToken(token);
        }
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR) {
        endTagInTable(p2, token);
      }
    }
    function startTagInRow(p2, token) {
      const tn = token.tagName;
      if (tn === $.TH || tn === $.TD) {
        p2.openElements.clearBackToTableRowContext();
        p2._insertElement(token, NS.HTML);
        p2.insertionMode = IN_CELL_MODE;
        p2.activeFormattingElements.insertMarker();
      } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
          p2._processToken(token);
        }
      } else {
        startTagInTable(p2, token);
      }
    }
    function endTagInRow(p2, token) {
      const tn = token.tagName;
      if (tn === $.TR) {
        if (p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
        }
      } else if (tn === $.TABLE) {
        if (p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
          p2._processToken(token);
        }
      } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p2.openElements.hasInTableScope(tn) || p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
          p2._processToken(token);
        }
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH) {
        endTagInTable(p2, token);
      }
    }
    function startTagInCell(p2, token) {
      const tn = token.tagName;
      if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope($.TD) || p2.openElements.hasInTableScope($.TH)) {
          p2._closeTableCell();
          p2._processToken(token);
        }
      } else {
        startTagInBody(p2, token);
      }
    }
    function endTagInCell(p2, token) {
      const tn = token.tagName;
      if (tn === $.TD || tn === $.TH) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2.openElements.generateImpliedEndTags();
          p2.openElements.popUntilTagNamePopped(tn);
          p2.activeFormattingElements.clearToLastMarker();
          p2.insertionMode = IN_ROW_MODE;
        }
      } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2._closeTableCell();
          p2._processToken(token);
        }
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {
        endTagInBody(p2, token);
      }
    }
    function startTagInSelect(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.OPTION) {
        if (p2.openElements.currentTagName === $.OPTION) {
          p2.openElements.pop();
        }
        p2._insertElement(token, NS.HTML);
      } else if (tn === $.OPTGROUP) {
        if (p2.openElements.currentTagName === $.OPTION) {
          p2.openElements.pop();
        }
        if (p2.openElements.currentTagName === $.OPTGROUP) {
          p2.openElements.pop();
        }
        p2._insertElement(token, NS.HTML);
      } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
        if (p2.openElements.hasInSelectScope($.SELECT)) {
          p2.openElements.popUntilTagNamePopped($.SELECT);
          p2._resetInsertionMode();
          if (tn !== $.SELECT) {
            p2._processToken(token);
          }
        }
      } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
        startTagInHead(p2, token);
      }
    }
    function endTagInSelect(p2, token) {
      const tn = token.tagName;
      if (tn === $.OPTGROUP) {
        const prevOpenElement = p2.openElements.items[p2.openElements.stackTop - 1];
        const prevOpenElementTn = prevOpenElement && p2.treeAdapter.getTagName(prevOpenElement);
        if (p2.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
          p2.openElements.pop();
        }
        if (p2.openElements.currentTagName === $.OPTGROUP) {
          p2.openElements.pop();
        }
      } else if (tn === $.OPTION) {
        if (p2.openElements.currentTagName === $.OPTION) {
          p2.openElements.pop();
        }
      } else if (tn === $.SELECT && p2.openElements.hasInSelectScope($.SELECT)) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token);
      }
    }
    function startTagInSelectInTable(p2, token) {
      const tn = token.tagName;
      if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
        p2._processToken(token);
      } else {
        startTagInSelect(p2, token);
      }
    }
    function endTagInSelectInTable(p2, token) {
      const tn = token.tagName;
      if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2.openElements.popUntilTagNamePopped($.SELECT);
          p2._resetInsertionMode();
          p2._processToken(token);
        }
      } else {
        endTagInSelect(p2, token);
      }
    }
    function startTagInTemplate(p2, token) {
      const tn = token.tagName;
      if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
        startTagInHead(p2, token);
      } else {
        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
        p2._popTmplInsertionMode();
        p2._pushTmplInsertionMode(newInsertionMode);
        p2.insertionMode = newInsertionMode;
        p2._processToken(token);
      }
    }
    function endTagInTemplate(p2, token) {
      if (token.tagName === $.TEMPLATE) {
        endTagInHead(p2, token);
      }
    }
    function eofInTemplate(p2, token) {
      if (p2.openElements.tmplCount > 0) {
        p2.openElements.popUntilTagNamePopped($.TEMPLATE);
        p2.activeFormattingElements.clearToLastMarker();
        p2._popTmplInsertionMode();
        p2._resetInsertionMode();
        p2._processToken(token);
      } else {
        p2.stopped = true;
      }
    }
    function startTagAfterBody(p2, token) {
      if (token.tagName === $.HTML) {
        startTagInBody(p2, token);
      } else {
        tokenAfterBody(p2, token);
      }
    }
    function endTagAfterBody(p2, token) {
      if (token.tagName === $.HTML) {
        if (!p2.fragmentContext) {
          p2.insertionMode = AFTER_AFTER_BODY_MODE;
        }
      } else {
        tokenAfterBody(p2, token);
      }
    }
    function tokenAfterBody(p2, token) {
      p2.insertionMode = IN_BODY_MODE;
      p2._processToken(token);
    }
    function startTagInFrameset(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.FRAMESET) {
        p2._insertElement(token, NS.HTML);
      } else if (tn === $.FRAME) {
        p2._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
      } else if (tn === $.NOFRAMES) {
        startTagInHead(p2, token);
      }
    }
    function endTagInFrameset(p2, token) {
      if (token.tagName === $.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
        p2.openElements.pop();
        if (!p2.fragmentContext && p2.openElements.currentTagName !== $.FRAMESET) {
          p2.insertionMode = AFTER_FRAMESET_MODE;
        }
      }
    }
    function startTagAfterFrameset(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.NOFRAMES) {
        startTagInHead(p2, token);
      }
    }
    function endTagAfterFrameset(p2, token) {
      if (token.tagName === $.HTML) {
        p2.insertionMode = AFTER_AFTER_FRAMESET_MODE;
      }
    }
    function startTagAfterAfterBody(p2, token) {
      if (token.tagName === $.HTML) {
        startTagInBody(p2, token);
      } else {
        tokenAfterAfterBody(p2, token);
      }
    }
    function tokenAfterAfterBody(p2, token) {
      p2.insertionMode = IN_BODY_MODE;
      p2._processToken(token);
    }
    function startTagAfterAfterFrameset(p2, token) {
      const tn = token.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token);
      } else if (tn === $.NOFRAMES) {
        startTagInHead(p2, token);
      }
    }
    function nullCharacterInForeignContent(p2, token) {
      token.chars = unicode.REPLACEMENT_CHARACTER;
      p2._insertCharacters(token);
    }
    function characterInForeignContent(p2, token) {
      p2._insertCharacters(token);
      p2.framesetOk = false;
    }
    function startTagInForeignContent(p2, token) {
      if (foreignContent.causesExit(token) && !p2.fragmentContext) {
        while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== NS.HTML && !p2._isIntegrationPoint(p2.openElements.current)) {
          p2.openElements.pop();
        }
        p2._processToken(token);
      } else {
        const current = p2._getAdjustedCurrentElement();
        const currentNs = p2.treeAdapter.getNamespaceURI(current);
        if (currentNs === NS.MATHML) {
          foreignContent.adjustTokenMathMLAttrs(token);
        } else if (currentNs === NS.SVG) {
          foreignContent.adjustTokenSVGTagName(token);
          foreignContent.adjustTokenSVGAttrs(token);
        }
        foreignContent.adjustTokenXMLAttrs(token);
        if (token.selfClosing) {
          p2._appendElement(token, currentNs);
        } else {
          p2._insertElement(token, currentNs);
        }
        token.ackSelfClosing = true;
      }
    }
    function endTagInForeignContent(p2, token) {
      for (let i = p2.openElements.stackTop; i > 0; i--) {
        const element4 = p2.openElements.items[i];
        if (p2.treeAdapter.getNamespaceURI(element4) === NS.HTML) {
          p2._processToken(token);
          break;
        }
        if (p2.treeAdapter.getTagName(element4).toLowerCase() === token.tagName) {
          p2.openElements.popUntilElementPopped(element4);
          break;
        }
      }
    }
  }
});

// node_modules/flatpickr/dist/flatpickr.js
var require_flatpickr = __commonJS({
  "node_modules/flatpickr/dist/flatpickr.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.flatpickr = factory());
    })(exports, function() {
      "use strict";
      var __assign = function() {
        __assign = Object.assign || function __assign2(t2) {
          for (var s3, i = 1, n2 = arguments.length; i < n2; i++) {
            s3 = arguments[i];
            for (var p2 in s3)
              if (Object.prototype.hasOwnProperty.call(s3, p2))
                t2[p2] = s3[p2];
          }
          return t2;
        };
        return __assign.apply(this, arguments);
      };
      function __spreadArrays() {
        for (var s3 = 0, i = 0, il = arguments.length; i < il; i++)
          s3 += arguments[i].length;
        for (var r = Array(s3), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      }
      var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition"
      ];
      var defaults4 = {
        _disable: [],
        allowInput: false,
        allowInvalidPreload: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        autoFillDefaultTime: true,
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enableSeconds: false,
        enableTime: false,
        errorHandler: function(err) {
          return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function(givenDate) {
          var date2 = new Date(givenDate.getTime());
          date2.setHours(0, 0, 0, 0);
          date2.setDate(date2.getDate() + 3 - (date2.getDay() + 6) % 7);
          var week1 = new Date(date2.getFullYear(), 0, 4);
          return 1 + Math.round(((date2.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        monthSelectorType: "dropdown",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: void 0,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
      };
      var english = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function(nth) {
          var s3 = nth % 100;
          if (s3 > 3 && s3 < 21)
            return "th";
          switch (s3 % 10) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        monthAriaLabel: "Month",
        hourAriaLabel: "Hour",
        minuteAriaLabel: "Minute",
        time_24hr: false
      };
      var pad = function(number2, length) {
        if (length === void 0) {
          length = 2;
        }
        return ("000" + number2).slice(length * -1);
      };
      var int2 = function(bool) {
        return bool === true ? 1 : 0;
      };
      function debounce(fn, wait) {
        var t2;
        return function() {
          var _this = this;
          var args = arguments;
          clearTimeout(t2);
          t2 = setTimeout(function() {
            return fn.apply(_this, args);
          }, wait);
        };
      }
      var arrayify = function(obj) {
        return obj instanceof Array ? obj : [obj];
      };
      function toggleClass(elem, className, bool) {
        if (bool === true)
          return elem.classList.add(className);
        elem.classList.remove(className);
      }
      function createElement133(tag, className, content3) {
        var e2 = window.document.createElement(tag);
        className = className || "";
        content3 = content3 || "";
        e2.className = className;
        if (content3 !== void 0)
          e2.textContent = content3;
        return e2;
      }
      function clearNode(node2) {
        while (node2.firstChild)
          node2.removeChild(node2.firstChild);
      }
      function findParent(node2, condition) {
        if (condition(node2))
          return node2;
        else if (node2.parentNode)
          return findParent(node2.parentNode, condition);
        return void 0;
      }
      function createNumberInput(inputClassName, opts) {
        var wrapper = createElement133("div", "numInputWrapper"), numInput = createElement133("input", "numInput " + inputClassName), arrowUp2 = createElement133("span", "arrowUp"), arrowDown2 = createElement133("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
          numInput.type = "number";
        } else {
          numInput.type = "text";
          numInput.pattern = "\\d*";
        }
        if (opts !== void 0)
          for (var key in opts)
            numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp2);
        wrapper.appendChild(arrowDown2);
        return wrapper;
      }
      function getEventTarget(event) {
        try {
          if (typeof event.composedPath === "function") {
            var path4 = event.composedPath();
            return path4[0];
          }
          return event.target;
        } catch (error2) {
          return event.target;
        }
      }
      var doNothing = function() {
        return void 0;
      };
      var monthToStr = function(monthNumber, shorthand, locale) {
        return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
      };
      var revFormat = {
        D: doNothing,
        F: function(dateObj, monthName, locale) {
          dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function(dateObj, hour) {
          dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
        },
        H: function(dateObj, hour) {
          dateObj.setHours(parseFloat(hour));
        },
        J: function(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        K: function(dateObj, amPM, locale) {
          dateObj.setHours(dateObj.getHours() % 12 + 12 * int2(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function(dateObj, shortMonth, locale) {
          dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function(dateObj, seconds) {
          dateObj.setSeconds(parseFloat(seconds));
        },
        U: function(_2, unixSeconds) {
          return new Date(parseFloat(unixSeconds) * 1e3);
        },
        W: function(dateObj, weekNum, locale) {
          var weekNumber = parseInt(weekNum);
          var date2 = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
          date2.setDate(date2.getDate() - date2.getDay() + locale.firstDayOfWeek);
          return date2;
        },
        Y: function(dateObj, year) {
          dateObj.setFullYear(parseFloat(year));
        },
        Z: function(_2, ISODate) {
          return new Date(ISODate);
        },
        d: function(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        h: function(dateObj, hour) {
          dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
        },
        i: function(dateObj, minutes) {
          dateObj.setMinutes(parseFloat(minutes));
        },
        j: function(dateObj, day) {
          dateObj.setDate(parseFloat(day));
        },
        l: doNothing,
        m: function(dateObj, month) {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function(dateObj, month) {
          dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function(dateObj, seconds) {
          dateObj.setSeconds(parseFloat(seconds));
        },
        u: function(_2, unixMillSeconds) {
          return new Date(parseFloat(unixMillSeconds));
        },
        w: doNothing,
        y: function(dateObj, year) {
          dateObj.setFullYear(2e3 + parseFloat(year));
        }
      };
      var tokenRegex = {
        D: "",
        F: "",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
      };
      var formats = {
        Z: function(date2) {
          return date2.toISOString();
        },
        D: function(date2, locale, options) {
          return locale.weekdays.shorthand[formats.w(date2, locale, options)];
        },
        F: function(date2, locale, options) {
          return monthToStr(formats.n(date2, locale, options) - 1, false, locale);
        },
        G: function(date2, locale, options) {
          return pad(formats.h(date2, locale, options));
        },
        H: function(date2) {
          return pad(date2.getHours());
        },
        J: function(date2, locale) {
          return locale.ordinal !== void 0 ? date2.getDate() + locale.ordinal(date2.getDate()) : date2.getDate();
        },
        K: function(date2, locale) {
          return locale.amPM[int2(date2.getHours() > 11)];
        },
        M: function(date2, locale) {
          return monthToStr(date2.getMonth(), true, locale);
        },
        S: function(date2) {
          return pad(date2.getSeconds());
        },
        U: function(date2) {
          return date2.getTime() / 1e3;
        },
        W: function(date2, _2, options) {
          return options.getWeek(date2);
        },
        Y: function(date2) {
          return pad(date2.getFullYear(), 4);
        },
        d: function(date2) {
          return pad(date2.getDate());
        },
        h: function(date2) {
          return date2.getHours() % 12 ? date2.getHours() % 12 : 12;
        },
        i: function(date2) {
          return pad(date2.getMinutes());
        },
        j: function(date2) {
          return date2.getDate();
        },
        l: function(date2, locale) {
          return locale.weekdays.longhand[date2.getDay()];
        },
        m: function(date2) {
          return pad(date2.getMonth() + 1);
        },
        n: function(date2) {
          return date2.getMonth() + 1;
        },
        s: function(date2) {
          return date2.getSeconds();
        },
        u: function(date2) {
          return date2.getTime();
        },
        w: function(date2) {
          return date2.getDay();
        },
        y: function(date2) {
          return String(date2.getFullYear()).substring(2);
        }
      };
      var createDateFormatter = function(_a) {
        var _b = _a.config, config3 = _b === void 0 ? defaults4 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
        return function(dateObj, frmt, overrideLocale) {
          var locale = overrideLocale || l10n;
          if (config3.formatDate !== void 0 && !isMobile) {
            return config3.formatDate(dateObj, frmt, locale);
          }
          return frmt.split("").map(function(c, i, arr2) {
            return formats[c] && arr2[i - 1] !== "\\" ? formats[c](dateObj, locale, config3) : c !== "\\" ? c : "";
          }).join("");
        };
      };
      var createDateParser = function(_a) {
        var _b = _a.config, config3 = _b === void 0 ? defaults4 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function(date2, givenFormat, timeless, customLocale) {
          if (date2 !== 0 && !date2)
            return void 0;
          var locale = customLocale || l10n;
          var parsedDate;
          var dateOrig = date2;
          if (date2 instanceof Date)
            parsedDate = new Date(date2.getTime());
          else if (typeof date2 !== "string" && date2.toFixed !== void 0)
            parsedDate = new Date(date2);
          else if (typeof date2 === "string") {
            var format = givenFormat || (config3 || defaults4).dateFormat;
            var datestr = String(date2).trim();
            if (datestr === "today") {
              parsedDate = new Date();
              timeless = true;
            } else if (config3 && config3.parseDate) {
              parsedDate = config3.parseDate(date2, format);
            } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
              parsedDate = new Date(date2);
            } else {
              var matched = void 0, ops = [];
              for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                var token_1 = format[i];
                var isBackSlash = token_1 === "\\";
                var escaped = format[i - 1] === "\\" || isBackSlash;
                if (tokenRegex[token_1] && !escaped) {
                  regexStr += tokenRegex[token_1];
                  var match3 = new RegExp(regexStr).exec(date2);
                  if (match3 && (matched = true)) {
                    ops[token_1 !== "Y" ? "push" : "unshift"]({
                      fn: revFormat[token_1],
                      val: match3[++matchIndex]
                    });
                  }
                } else if (!isBackSlash)
                  regexStr += ".";
              }
              parsedDate = !config3 || !config3.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
              ops.forEach(function(_a2) {
                var fn = _a2.fn, val = _a2.val;
                return parsedDate = fn(parsedDate, val, locale) || parsedDate;
              });
              parsedDate = matched ? parsedDate : void 0;
            }
          }
          if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
            config3.errorHandler(new Error("Invalid date provided: " + dateOrig));
            return void 0;
          }
          if (timeless === true)
            parsedDate.setHours(0, 0, 0, 0);
          return parsedDate;
        };
      };
      function compareDates(date1, date2, timeless) {
        if (timeless === void 0) {
          timeless = true;
        }
        if (timeless !== false) {
          return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
        }
        return date1.getTime() - date2.getTime();
      }
      var isBetween = function(ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
      };
      var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
        return hours * 3600 + minutes * 60 + seconds;
      };
      var parseSeconds = function(secondsSinceMidnight) {
        var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
        return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
      };
      var duration2 = {
        DAY: 864e5
      };
      function getDefaultHours(config3) {
        var hours = config3.defaultHour;
        var minutes = config3.defaultMinute;
        var seconds = config3.defaultSeconds;
        if (config3.minDate !== void 0) {
          var minHour = config3.minDate.getHours();
          var minMinutes = config3.minDate.getMinutes();
          var minSeconds = config3.minDate.getSeconds();
          if (hours < minHour) {
            hours = minHour;
          }
          if (hours === minHour && minutes < minMinutes) {
            minutes = minMinutes;
          }
          if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
            seconds = config3.minDate.getSeconds();
        }
        if (config3.maxDate !== void 0) {
          var maxHr = config3.maxDate.getHours();
          var maxMinutes = config3.maxDate.getMinutes();
          hours = Math.min(hours, maxHr);
          if (hours === maxHr)
            minutes = Math.min(maxMinutes, minutes);
          if (hours === maxHr && minutes === maxMinutes)
            seconds = config3.maxDate.getSeconds();
        }
        return { hours, minutes, seconds };
      }
      if (typeof Object.assign !== "function") {
        Object.assign = function(target) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (!target) {
            throw TypeError("Cannot convert undefined or null to object");
          }
          var _loop_1 = function(source2) {
            if (source2) {
              Object.keys(source2).forEach(function(key) {
                return target[key] = source2[key];
              });
            }
          };
          for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var source = args_1[_a];
            _loop_1(source);
          }
          return target;
        };
      }
      var DEBOUNCED_CHANGE_MS = 300;
      function FlatpickrInstance(element4, instanceConfig) {
        var self2 = {
          config: __assign(__assign({}, defaults4), flatpickr.defaultConfig),
          l10n: english
        };
        self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
        self2._handlers = [];
        self2.pluginElements = [];
        self2.loadedPlugins = [];
        self2._bind = bind2;
        self2._setHoursFromDate = setHoursFromDate;
        self2._positionCalendar = positionCalendar;
        self2.changeMonth = changeMonth;
        self2.changeYear = changeYear;
        self2.clear = clear;
        self2.close = close;
        self2.onMouseOver = onMouseOver;
        self2._createElement = createElement133;
        self2.createDay = createDay;
        self2.destroy = destroy;
        self2.isEnabled = isEnabled;
        self2.jumpToDate = jumpToDate;
        self2.updateValue = updateValue;
        self2.open = open;
        self2.redraw = redraw;
        self2.set = set2;
        self2.setDate = setDate;
        self2.toggle = toggle;
        function setupHelperFunctions() {
          self2.utils = {
            getDaysInMonth: function(month, yr) {
              if (month === void 0) {
                month = self2.currentMonth;
              }
              if (yr === void 0) {
                yr = self2.currentYear;
              }
              if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
                return 29;
              return self2.l10n.daysInMonth[month];
            }
          };
        }
        function init2() {
          self2.element = self2.input = element4;
          self2.isOpen = false;
          parseConfig();
          setupLocale();
          setupInputs();
          setupDates();
          setupHelperFunctions();
          if (!self2.isMobile)
            build3();
          bindEvents2();
          if (self2.selectedDates.length || self2.config.noCalendar) {
            if (self2.config.enableTime) {
              setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
            }
            updateValue(false);
          }
          setCalendarWidth();
          var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          if (!self2.isMobile && isSafari) {
            positionCalendar();
          }
          triggerEvent("onReady");
        }
        function getClosestActiveElement() {
          var _a;
          return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
        }
        function bindToInstance(fn) {
          return fn.bind(self2);
        }
        function setCalendarWidth() {
          var config3 = self2.config;
          if (config3.weekNumbers === false && config3.showMonths === 1) {
            return;
          } else if (config3.noCalendar !== true) {
            window.requestAnimationFrame(function() {
              if (self2.calendarContainer !== void 0) {
                self2.calendarContainer.style.visibility = "hidden";
                self2.calendarContainer.style.display = "block";
              }
              if (self2.daysContainer !== void 0) {
                var daysWidth = (self2.days.offsetWidth + 1) * config3.showMonths;
                self2.daysContainer.style.width = daysWidth + "px";
                self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
                self2.calendarContainer.style.removeProperty("visibility");
                self2.calendarContainer.style.removeProperty("display");
              }
            });
          }
        }
        function updateTime(e2) {
          if (self2.selectedDates.length === 0) {
            var defaultDate = self2.config.minDate === void 0 || compareDates(new Date(), self2.config.minDate) >= 0 ? new Date() : new Date(self2.config.minDate.getTime());
            var defaults5 = getDefaultHours(self2.config);
            defaultDate.setHours(defaults5.hours, defaults5.minutes, defaults5.seconds, defaultDate.getMilliseconds());
            self2.selectedDates = [defaultDate];
            self2.latestSelectedDateObj = defaultDate;
          }
          if (e2 !== void 0 && e2.type !== "blur") {
            timeWrapper(e2);
          }
          var prevValue = self2._input.value;
          setHoursFromInputs();
          updateValue();
          if (self2._input.value !== prevValue) {
            self2._debouncedChange();
          }
        }
        function ampm2military(hour, amPM) {
          return hour % 12 + 12 * int2(amPM === self2.l10n.amPM[1]);
        }
        function military2ampm(hour) {
          switch (hour % 24) {
            case 0:
            case 12:
              return 12;
            default:
              return hour % 12;
          }
        }
        function setHoursFromInputs() {
          if (self2.hourElement === void 0 || self2.minuteElement === void 0)
            return;
          var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
          if (self2.amPM !== void 0) {
            hours = ampm2military(hours, self2.amPM.textContent);
          }
          var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
          var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
          if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
            var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
            var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
            var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
            if (currentTime > maxBound && currentTime < minBound) {
              var result = parseSeconds(minBound);
              hours = result[0];
              minutes = result[1];
              seconds = result[2];
            }
          } else {
            if (limitMaxHours) {
              var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
              hours = Math.min(hours, maxTime.getHours());
              if (hours === maxTime.getHours())
                minutes = Math.min(minutes, maxTime.getMinutes());
              if (minutes === maxTime.getMinutes())
                seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
              var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
              hours = Math.max(hours, minTime.getHours());
              if (hours === minTime.getHours() && minutes < minTime.getMinutes())
                minutes = minTime.getMinutes();
              if (minutes === minTime.getMinutes())
                seconds = Math.max(seconds, minTime.getSeconds());
            }
          }
          setHours(hours, minutes, seconds);
        }
        function setHoursFromDate(dateObj) {
          var date2 = dateObj || self2.latestSelectedDateObj;
          if (date2 && date2 instanceof Date) {
            setHours(date2.getHours(), date2.getMinutes(), date2.getSeconds());
          }
        }
        function setHours(hours, minutes, seconds) {
          if (self2.latestSelectedDateObj !== void 0) {
            self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
          }
          if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
            return;
          self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int2(hours % 12 === 0) : hours);
          self2.minuteElement.value = pad(minutes);
          if (self2.amPM !== void 0)
            self2.amPM.textContent = self2.l10n.amPM[int2(hours >= 12)];
          if (self2.secondElement !== void 0)
            self2.secondElement.value = pad(seconds);
        }
        function onYearInput(event) {
          var eventTarget = getEventTarget(event);
          var year = parseInt(eventTarget.value) + (event.delta || 0);
          if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
            changeYear(year);
          }
        }
        function bind2(element5, event, handler, options) {
          if (event instanceof Array)
            return event.forEach(function(ev) {
              return bind2(element5, ev, handler, options);
            });
          if (element5 instanceof Array)
            return element5.forEach(function(el) {
              return bind2(el, event, handler, options);
            });
          element5.addEventListener(event, handler, options);
          self2._handlers.push({
            remove: function() {
              return element5.removeEventListener(event, handler, options);
            }
          });
        }
        function triggerChange() {
          triggerEvent("onChange");
        }
        function bindEvents2() {
          if (self2.config.wrap) {
            ["open", "close", "toggle", "clear"].forEach(function(evt) {
              Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
                return bind2(el, "click", self2[evt]);
              });
            });
          }
          if (self2.isMobile) {
            setupMobile();
            return;
          }
          var debouncedResize = debounce(onResize, 50);
          self2._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
          if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
            bind2(self2.daysContainer, "mouseover", function(e2) {
              if (self2.config.mode === "range")
                onMouseOver(getEventTarget(e2));
            });
          bind2(self2._input, "keydown", onKeyDown);
          if (self2.calendarContainer !== void 0) {
            bind2(self2.calendarContainer, "keydown", onKeyDown);
          }
          if (!self2.config.inline && !self2.config.static)
            bind2(window, "resize", debouncedResize);
          if (window.ontouchstart !== void 0)
            bind2(window.document, "touchstart", documentClick);
          else
            bind2(window.document, "mousedown", documentClick);
          bind2(window.document, "focus", documentClick, { capture: true });
          if (self2.config.clickOpens === true) {
            bind2(self2._input, "focus", self2.open);
            bind2(self2._input, "click", self2.open);
          }
          if (self2.daysContainer !== void 0) {
            bind2(self2.monthNav, "click", onMonthNavClick);
            bind2(self2.monthNav, ["keyup", "increment"], onYearInput);
            bind2(self2.daysContainer, "click", selectDate);
          }
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
            var selText = function(e2) {
              return getEventTarget(e2).select();
            };
            bind2(self2.timeContainer, ["increment"], updateTime);
            bind2(self2.timeContainer, "blur", updateTime, { capture: true });
            bind2(self2.timeContainer, "click", timeIncrement);
            bind2([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
            if (self2.secondElement !== void 0)
              bind2(self2.secondElement, "focus", function() {
                return self2.secondElement && self2.secondElement.select();
              });
            if (self2.amPM !== void 0) {
              bind2(self2.amPM, "click", function(e2) {
                updateTime(e2);
              });
            }
          }
          if (self2.config.allowInput) {
            bind2(self2._input, "blur", onBlur);
          }
        }
        function jumpToDate(jumpDate, triggerChange2) {
          var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
          var oldYear = self2.currentYear;
          var oldMonth = self2.currentMonth;
          try {
            if (jumpTo !== void 0) {
              self2.currentYear = jumpTo.getFullYear();
              self2.currentMonth = jumpTo.getMonth();
            }
          } catch (e2) {
            e2.message = "Invalid date supplied: " + jumpTo;
            self2.config.errorHandler(e2);
          }
          if (triggerChange2 && self2.currentYear !== oldYear) {
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
          if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
            triggerEvent("onMonthChange");
          }
          self2.redraw();
        }
        function timeIncrement(e2) {
          var eventTarget = getEventTarget(e2);
          if (~eventTarget.className.indexOf("arrow"))
            incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
        }
        function incrementNumInput(e2, delta, inputElem) {
          var target = e2 && getEventTarget(e2);
          var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
          var event = createEvent("increment");
          event.delta = delta;
          input && input.dispatchEvent(event);
        }
        function build3() {
          var fragment2 = window.document.createDocumentFragment();
          self2.calendarContainer = createElement133("div", "flatpickr-calendar");
          self2.calendarContainer.tabIndex = -1;
          if (!self2.config.noCalendar) {
            fragment2.appendChild(buildMonthNav());
            self2.innerContainer = createElement133("div", "flatpickr-innerContainer");
            if (self2.config.weekNumbers) {
              var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
              self2.innerContainer.appendChild(weekWrapper);
              self2.weekNumbers = weekNumbers;
              self2.weekWrapper = weekWrapper;
            }
            self2.rContainer = createElement133("div", "flatpickr-rContainer");
            self2.rContainer.appendChild(buildWeekdays());
            if (!self2.daysContainer) {
              self2.daysContainer = createElement133("div", "flatpickr-days");
              self2.daysContainer.tabIndex = -1;
            }
            buildDays();
            self2.rContainer.appendChild(self2.daysContainer);
            self2.innerContainer.appendChild(self2.rContainer);
            fragment2.appendChild(self2.innerContainer);
          }
          if (self2.config.enableTime) {
            fragment2.appendChild(buildTime());
          }
          toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
          toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
          toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
          self2.calendarContainer.appendChild(fragment2);
          var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
          if (self2.config.inline || self2.config.static) {
            self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
            if (self2.config.inline) {
              if (!customAppend && self2.element.parentNode)
                self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
              else if (self2.config.appendTo !== void 0)
                self2.config.appendTo.appendChild(self2.calendarContainer);
            }
            if (self2.config.static) {
              var wrapper = createElement133("div", "flatpickr-wrapper");
              if (self2.element.parentNode)
                self2.element.parentNode.insertBefore(wrapper, self2.element);
              wrapper.appendChild(self2.element);
              if (self2.altInput)
                wrapper.appendChild(self2.altInput);
              wrapper.appendChild(self2.calendarContainer);
            }
          }
          if (!self2.config.static && !self2.config.inline)
            (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
        }
        function createDay(className, date2, _dayNumber, i) {
          var dateIsEnabled = isEnabled(date2, true), dayElement = createElement133("span", className, date2.getDate().toString());
          dayElement.dateObj = date2;
          dayElement.$i = i;
          dayElement.setAttribute("aria-label", self2.formatDate(date2, self2.config.ariaDateFormat));
          if (className.indexOf("hidden") === -1 && compareDates(date2, self2.now) === 0) {
            self2.todayDateElem = dayElement;
            dayElement.classList.add("today");
            dayElement.setAttribute("aria-current", "date");
          }
          if (dateIsEnabled) {
            dayElement.tabIndex = -1;
            if (isDateSelected(date2)) {
              dayElement.classList.add("selected");
              self2.selectedDateElem = dayElement;
              if (self2.config.mode === "range") {
                toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date2, self2.selectedDates[0], true) === 0);
                toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date2, self2.selectedDates[1], true) === 0);
                if (className === "nextMonthDay")
                  dayElement.classList.add("inRange");
              }
            }
          } else {
            dayElement.classList.add("flatpickr-disabled");
          }
          if (self2.config.mode === "range") {
            if (isDateInRange(date2) && !isDateSelected(date2))
              dayElement.classList.add("inRange");
          }
          if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
            self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date2) + "</span>");
          }
          triggerEvent("onDayCreate", dayElement);
          return dayElement;
        }
        function focusOnDayElem(targetNode) {
          targetNode.focus();
          if (self2.config.mode === "range")
            onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
          var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
          var endMonth = delta > 0 ? self2.config.showMonths : -1;
          for (var m = startMonth; m != endMonth; m += delta) {
            var month = self2.daysContainer.children[m];
            var startIndex = delta > 0 ? 0 : month.children.length - 1;
            var endIndex = delta > 0 ? month.children.length : -1;
            for (var i = startIndex; i != endIndex; i += delta) {
              var c = month.children[i];
              if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                return c;
            }
          }
          return void 0;
        }
        function getNextAvailableDay(current, delta) {
          var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
          var endMonth = delta > 0 ? self2.config.showMonths : -1;
          var loopDelta = delta > 0 ? 1 : -1;
          for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
            var month = self2.daysContainer.children[m];
            var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
            var numMonthDays = month.children.length;
            for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
              var c = month.children[i];
              if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
                return focusOnDayElem(c);
            }
          }
          self2.changeMonth(loopDelta);
          focusOnDay(getFirstAvailableDay(loopDelta), 0);
          return void 0;
        }
        function focusOnDay(current, offset4) {
          var activeElement = getClosestActiveElement();
          var dayFocused = isInView(activeElement || document.body);
          var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset4 > 0 ? 1 : -1);
          if (startElem === void 0) {
            self2._input.focus();
          } else if (!dayFocused) {
            focusOnDayElem(startElem);
          } else {
            getNextAvailableDay(startElem, offset4);
          }
        }
        function buildMonthDays(year, month) {
          var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
          var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
          var daysInMonth2 = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
          var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
          for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
            days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
          }
          for (dayNumber = 1; dayNumber <= daysInMonth2; dayNumber++, dayIndex++) {
            days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
          }
          for (var dayNum = daysInMonth2 + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
            days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth2), dayNum, dayIndex));
          }
          var dayContainer = createElement133("div", "dayContainer");
          dayContainer.appendChild(days);
          return dayContainer;
        }
        function buildDays() {
          if (self2.daysContainer === void 0) {
            return;
          }
          clearNode(self2.daysContainer);
          if (self2.weekNumbers)
            clearNode(self2.weekNumbers);
          var frag = document.createDocumentFragment();
          for (var i = 0; i < self2.config.showMonths; i++) {
            var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
            d2.setMonth(self2.currentMonth + i);
            frag.appendChild(buildMonthDays(d2.getFullYear(), d2.getMonth()));
          }
          self2.daysContainer.appendChild(frag);
          self2.days = self2.daysContainer.firstChild;
          if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
            onMouseOver();
          }
        }
        function buildMonthSwitch() {
          if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
            return;
          var shouldBuildMonth = function(month2) {
            if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
              return false;
            }
            return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
          };
          self2.monthsDropdownContainer.tabIndex = -1;
          self2.monthsDropdownContainer.innerHTML = "";
          for (var i = 0; i < 12; i++) {
            if (!shouldBuildMonth(i))
              continue;
            var month = createElement133("option", "flatpickr-monthDropdown-month");
            month.value = new Date(self2.currentYear, i).getMonth().toString();
            month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
            month.tabIndex = -1;
            if (self2.currentMonth === i) {
              month.selected = true;
            }
            self2.monthsDropdownContainer.appendChild(month);
          }
        }
        function buildMonth() {
          var container = createElement133("div", "flatpickr-month");
          var monthNavFragment = window.document.createDocumentFragment();
          var monthElement;
          if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
            monthElement = createElement133("span", "cur-month");
          } else {
            self2.monthsDropdownContainer = createElement133("select", "flatpickr-monthDropdown-months");
            self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
            bind2(self2.monthsDropdownContainer, "change", function(e2) {
              var target = getEventTarget(e2);
              var selectedMonth = parseInt(target.value, 10);
              self2.changeMonth(selectedMonth - self2.currentMonth);
              triggerEvent("onMonthChange");
            });
            buildMonthSwitch();
            monthElement = self2.monthsDropdownContainer;
          }
          var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
          var yearElement = yearInput.getElementsByTagName("input")[0];
          yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
          if (self2.config.minDate) {
            yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
          }
          if (self2.config.maxDate) {
            yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
            yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
          }
          var currentMonth = createElement133("div", "flatpickr-current-month");
          currentMonth.appendChild(monthElement);
          currentMonth.appendChild(yearInput);
          monthNavFragment.appendChild(currentMonth);
          container.appendChild(monthNavFragment);
          return {
            container,
            yearElement,
            monthElement
          };
        }
        function buildMonths() {
          clearNode(self2.monthNav);
          self2.monthNav.appendChild(self2.prevMonthNav);
          if (self2.config.showMonths) {
            self2.yearElements = [];
            self2.monthElements = [];
          }
          for (var m = self2.config.showMonths; m--; ) {
            var month = buildMonth();
            self2.yearElements.push(month.yearElement);
            self2.monthElements.push(month.monthElement);
            self2.monthNav.appendChild(month.container);
          }
          self2.monthNav.appendChild(self2.nextMonthNav);
        }
        function buildMonthNav() {
          self2.monthNav = createElement133("div", "flatpickr-months");
          self2.yearElements = [];
          self2.monthElements = [];
          self2.prevMonthNav = createElement133("span", "flatpickr-prev-month");
          self2.prevMonthNav.innerHTML = self2.config.prevArrow;
          self2.nextMonthNav = createElement133("span", "flatpickr-next-month");
          self2.nextMonthNav.innerHTML = self2.config.nextArrow;
          buildMonths();
          Object.defineProperty(self2, "_hidePrevMonthArrow", {
            get: function() {
              return self2.__hidePrevMonthArrow;
            },
            set: function(bool) {
              if (self2.__hidePrevMonthArrow !== bool) {
                toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
                self2.__hidePrevMonthArrow = bool;
              }
            }
          });
          Object.defineProperty(self2, "_hideNextMonthArrow", {
            get: function() {
              return self2.__hideNextMonthArrow;
            },
            set: function(bool) {
              if (self2.__hideNextMonthArrow !== bool) {
                toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
                self2.__hideNextMonthArrow = bool;
              }
            }
          });
          self2.currentYearElement = self2.yearElements[0];
          updateNavigationCurrentMonth();
          return self2.monthNav;
        }
        function buildTime() {
          self2.calendarContainer.classList.add("hasTime");
          if (self2.config.noCalendar)
            self2.calendarContainer.classList.add("noCalendar");
          var defaults5 = getDefaultHours(self2.config);
          self2.timeContainer = createElement133("div", "flatpickr-time");
          self2.timeContainer.tabIndex = -1;
          var separator = createElement133("span", "flatpickr-time-separator", ":");
          var hourInput = createNumberInput("flatpickr-hour", {
            "aria-label": self2.l10n.hourAriaLabel
          });
          self2.hourElement = hourInput.getElementsByTagName("input")[0];
          var minuteInput = createNumberInput("flatpickr-minute", {
            "aria-label": self2.l10n.minuteAriaLabel
          });
          self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
          self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
          self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults5.hours : military2ampm(defaults5.hours));
          self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults5.minutes);
          self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
          self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
          self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
          self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
          self2.hourElement.setAttribute("maxlength", "2");
          self2.minuteElement.setAttribute("min", "0");
          self2.minuteElement.setAttribute("max", "59");
          self2.minuteElement.setAttribute("maxlength", "2");
          self2.timeContainer.appendChild(hourInput);
          self2.timeContainer.appendChild(separator);
          self2.timeContainer.appendChild(minuteInput);
          if (self2.config.time_24hr)
            self2.timeContainer.classList.add("time24hr");
          if (self2.config.enableSeconds) {
            self2.timeContainer.classList.add("hasSeconds");
            var secondInput = createNumberInput("flatpickr-second");
            self2.secondElement = secondInput.getElementsByTagName("input")[0];
            self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults5.seconds);
            self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
            self2.secondElement.setAttribute("min", "0");
            self2.secondElement.setAttribute("max", "59");
            self2.secondElement.setAttribute("maxlength", "2");
            self2.timeContainer.appendChild(createElement133("span", "flatpickr-time-separator", ":"));
            self2.timeContainer.appendChild(secondInput);
          }
          if (!self2.config.time_24hr) {
            self2.amPM = createElement133("span", "flatpickr-am-pm", self2.l10n.amPM[int2((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
            self2.amPM.title = self2.l10n.toggleTitle;
            self2.amPM.tabIndex = -1;
            self2.timeContainer.appendChild(self2.amPM);
          }
          return self2.timeContainer;
        }
        function buildWeekdays() {
          if (!self2.weekdayContainer)
            self2.weekdayContainer = createElement133("div", "flatpickr-weekdays");
          else
            clearNode(self2.weekdayContainer);
          for (var i = self2.config.showMonths; i--; ) {
            var container = createElement133("div", "flatpickr-weekdaycontainer");
            self2.weekdayContainer.appendChild(container);
          }
          updateWeekdays();
          return self2.weekdayContainer;
        }
        function updateWeekdays() {
          if (!self2.weekdayContainer) {
            return;
          }
          var firstDayOfWeek = self2.l10n.firstDayOfWeek;
          var weekdays2 = __spreadArrays(self2.l10n.weekdays.shorthand);
          if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays2.length) {
            weekdays2 = __spreadArrays(weekdays2.splice(firstDayOfWeek, weekdays2.length), weekdays2.splice(0, firstDayOfWeek));
          }
          for (var i = self2.config.showMonths; i--; ) {
            self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays2.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
          }
        }
        function buildWeeks() {
          self2.calendarContainer.classList.add("hasWeeks");
          var weekWrapper = createElement133("div", "flatpickr-weekwrapper");
          weekWrapper.appendChild(createElement133("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
          var weekNumbers = createElement133("div", "flatpickr-weeks");
          weekWrapper.appendChild(weekNumbers);
          return {
            weekWrapper,
            weekNumbers
          };
        }
        function changeMonth(value, isOffset) {
          if (isOffset === void 0) {
            isOffset = true;
          }
          var delta = isOffset ? value : value - self2.currentMonth;
          if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
            return;
          self2.currentMonth += delta;
          if (self2.currentMonth < 0 || self2.currentMonth > 11) {
            self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
            self2.currentMonth = (self2.currentMonth + 12) % 12;
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
          buildDays();
          triggerEvent("onMonthChange");
          updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
          if (triggerChangeEvent === void 0) {
            triggerChangeEvent = true;
          }
          if (toInitial === void 0) {
            toInitial = true;
          }
          self2.input.value = "";
          if (self2.altInput !== void 0)
            self2.altInput.value = "";
          if (self2.mobileInput !== void 0)
            self2.mobileInput.value = "";
          self2.selectedDates = [];
          self2.latestSelectedDateObj = void 0;
          if (toInitial === true) {
            self2.currentYear = self2._initialDate.getFullYear();
            self2.currentMonth = self2._initialDate.getMonth();
          }
          if (self2.config.enableTime === true) {
            var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
            setHours(hours, minutes, seconds);
          }
          self2.redraw();
          if (triggerChangeEvent)
            triggerEvent("onChange");
        }
        function close() {
          self2.isOpen = false;
          if (!self2.isMobile) {
            if (self2.calendarContainer !== void 0) {
              self2.calendarContainer.classList.remove("open");
            }
            if (self2._input !== void 0) {
              self2._input.classList.remove("active");
            }
          }
          triggerEvent("onClose");
        }
        function destroy() {
          if (self2.config !== void 0)
            triggerEvent("onDestroy");
          for (var i = self2._handlers.length; i--; ) {
            self2._handlers[i].remove();
          }
          self2._handlers = [];
          if (self2.mobileInput) {
            if (self2.mobileInput.parentNode)
              self2.mobileInput.parentNode.removeChild(self2.mobileInput);
            self2.mobileInput = void 0;
          } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
            if (self2.config.static && self2.calendarContainer.parentNode) {
              var wrapper = self2.calendarContainer.parentNode;
              wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
              if (wrapper.parentNode) {
                while (wrapper.firstChild)
                  wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                wrapper.parentNode.removeChild(wrapper);
              }
            } else
              self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
          }
          if (self2.altInput) {
            self2.input.type = "text";
            if (self2.altInput.parentNode)
              self2.altInput.parentNode.removeChild(self2.altInput);
            delete self2.altInput;
          }
          if (self2.input) {
            self2.input.type = self2.input._type;
            self2.input.classList.remove("flatpickr-input");
            self2.input.removeAttribute("readonly");
          }
          [
            "_showTimeInput",
            "latestSelectedDateObj",
            "_hideNextMonthArrow",
            "_hidePrevMonthArrow",
            "__hideNextMonthArrow",
            "__hidePrevMonthArrow",
            "isMobile",
            "isOpen",
            "selectedDateElem",
            "minDateHasTime",
            "maxDateHasTime",
            "days",
            "daysContainer",
            "_input",
            "_positionElement",
            "innerContainer",
            "rContainer",
            "monthNav",
            "todayDateElem",
            "calendarContainer",
            "weekdayContainer",
            "prevMonthNav",
            "nextMonthNav",
            "monthsDropdownContainer",
            "currentMonthElement",
            "currentYearElement",
            "navigationCurrentMonth",
            "selectedDateElem",
            "config"
          ].forEach(function(k) {
            try {
              delete self2[k];
            } catch (_2) {
            }
          });
        }
        function isCalendarElem(elem) {
          return self2.calendarContainer.contains(elem);
        }
        function documentClick(e2) {
          if (self2.isOpen && !self2.config.inline) {
            var eventTarget_1 = getEventTarget(e2);
            var isCalendarElement = isCalendarElem(eventTarget_1);
            var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
            var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
            var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
              return elem.contains(eventTarget_1);
            });
            if (lostFocus && isIgnored) {
              if (self2.config.allowInput) {
                self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
              }
              if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
                updateTime();
              }
              self2.close();
              if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
                self2.clear(false);
            }
          }
        }
        function changeYear(newYear) {
          if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
            return;
          var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
          self2.currentYear = newYearNum || self2.currentYear;
          if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
            self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
          } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
            self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
          }
          if (isNewYear) {
            self2.redraw();
            triggerEvent("onYearChange");
            buildMonthSwitch();
          }
        }
        function isEnabled(date2, timeless) {
          var _a;
          if (timeless === void 0) {
            timeless = true;
          }
          var dateToCheck = self2.parseDate(date2, void 0, timeless);
          if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
            return false;
          if (!self2.config.enable && self2.config.disable.length === 0)
            return true;
          if (dateToCheck === void 0)
            return false;
          var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
          for (var i = 0, d2 = void 0; i < array.length; i++) {
            d2 = array[i];
            if (typeof d2 === "function" && d2(dateToCheck))
              return bool;
            else if (d2 instanceof Date && dateToCheck !== void 0 && d2.getTime() === dateToCheck.getTime())
              return bool;
            else if (typeof d2 === "string") {
              var parsed = self2.parseDate(d2, void 0, true);
              return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
            } else if (typeof d2 === "object" && dateToCheck !== void 0 && d2.from && d2.to && dateToCheck.getTime() >= d2.from.getTime() && dateToCheck.getTime() <= d2.to.getTime())
              return bool;
          }
          return !bool;
        }
        function isInView(elem) {
          if (self2.daysContainer !== void 0)
            return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
          return false;
        }
        function onBlur(e2) {
          var isInput = e2.target === self2._input;
          var valueChanged = self2._input.value.trimEnd() !== getDateStr();
          if (isInput && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
            self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          }
        }
        function onKeyDown(e2) {
          var eventTarget = getEventTarget(e2);
          var isInput = self2.config.wrap ? element4.contains(eventTarget) : eventTarget === self2._input;
          var allowInput = self2.config.allowInput;
          var allowKeydown = self2.isOpen && (!allowInput || !isInput);
          var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
          if (e2.keyCode === 13 && isInput) {
            if (allowInput) {
              self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
              self2.close();
              return eventTarget.blur();
            } else {
              self2.open();
            }
          } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
            var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
            switch (e2.keyCode) {
              case 13:
                if (isTimeObj) {
                  e2.preventDefault();
                  updateTime();
                  focusAndClose();
                } else
                  selectDate(e2);
                break;
              case 27:
                e2.preventDefault();
                focusAndClose();
                break;
              case 8:
              case 46:
                if (isInput && !self2.config.allowInput) {
                  e2.preventDefault();
                  self2.clear();
                }
                break;
              case 37:
              case 39:
                if (!isTimeObj && !isInput) {
                  e2.preventDefault();
                  var activeElement = getClosestActiveElement();
                  if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                    var delta_1 = e2.keyCode === 39 ? 1 : -1;
                    if (!e2.ctrlKey)
                      focusOnDay(void 0, delta_1);
                    else {
                      e2.stopPropagation();
                      changeMonth(delta_1);
                      focusOnDay(getFirstAvailableDay(1), 0);
                    }
                  }
                } else if (self2.hourElement)
                  self2.hourElement.focus();
                break;
              case 38:
              case 40:
                e2.preventDefault();
                var delta = e2.keyCode === 40 ? 1 : -1;
                if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
                  if (e2.ctrlKey) {
                    e2.stopPropagation();
                    changeYear(self2.currentYear - delta);
                    focusOnDay(getFirstAvailableDay(1), 0);
                  } else if (!isTimeObj)
                    focusOnDay(void 0, delta * 7);
                } else if (eventTarget === self2.currentYearElement) {
                  changeYear(self2.currentYear - delta);
                } else if (self2.config.enableTime) {
                  if (!isTimeObj && self2.hourElement)
                    self2.hourElement.focus();
                  updateTime(e2);
                  self2._debouncedChange();
                }
                break;
              case 9:
                if (isTimeObj) {
                  var elems = [
                    self2.hourElement,
                    self2.minuteElement,
                    self2.secondElement,
                    self2.amPM
                  ].concat(self2.pluginElements).filter(function(x) {
                    return x;
                  });
                  var i = elems.indexOf(eventTarget);
                  if (i !== -1) {
                    var target = elems[i + (e2.shiftKey ? -1 : 1)];
                    e2.preventDefault();
                    (target || self2._input).focus();
                  }
                } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
                  e2.preventDefault();
                  self2._input.focus();
                }
                break;
            }
          }
          if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
            switch (e2.key) {
              case self2.l10n.amPM[0].charAt(0):
              case self2.l10n.amPM[0].charAt(0).toLowerCase():
                self2.amPM.textContent = self2.l10n.amPM[0];
                setHoursFromInputs();
                updateValue();
                break;
              case self2.l10n.amPM[1].charAt(0):
              case self2.l10n.amPM[1].charAt(0).toLowerCase():
                self2.amPM.textContent = self2.l10n.amPM[1];
                setHoursFromInputs();
                updateValue();
                break;
            }
          }
          if (isInput || isCalendarElem(eventTarget)) {
            triggerEvent("onKeyDown", e2);
          }
        }
        function onMouseOver(elem, cellClass) {
          if (cellClass === void 0) {
            cellClass = "flatpickr-day";
          }
          if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
            return;
          var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
          var containsDisabled = false;
          var minRange = 0, maxRange = 0;
          for (var t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration2.DAY) {
            if (!isEnabled(new Date(t2), true)) {
              containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
              if (t2 < initialDate && (!minRange || t2 > minRange))
                minRange = t2;
              else if (t2 > initialDate && (!maxRange || t2 < maxRange))
                maxRange = t2;
            }
          }
          var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
          hoverableCells.forEach(function(dayElem) {
            var date2 = dayElem.dateObj;
            var timestamp = date2.getTime();
            var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
            if (outOfRange) {
              dayElem.classList.add("notAllowed");
              ["inRange", "startRange", "endRange"].forEach(function(c) {
                dayElem.classList.remove(c);
              });
              return;
            } else if (containsDisabled && !outOfRange)
              return;
            ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
              dayElem.classList.remove(c);
            });
            if (elem !== void 0) {
              elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
              if (initialDate < hoverDate && timestamp === initialDate)
                dayElem.classList.add("startRange");
              else if (initialDate > hoverDate && timestamp === initialDate)
                dayElem.classList.add("endRange");
              if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
                dayElem.classList.add("inRange");
            }
          });
        }
        function onResize() {
          if (self2.isOpen && !self2.config.static && !self2.config.inline)
            positionCalendar();
        }
        function open(e2, positionElement) {
          if (positionElement === void 0) {
            positionElement = self2._positionElement;
          }
          if (self2.isMobile === true) {
            if (e2) {
              e2.preventDefault();
              var eventTarget = getEventTarget(e2);
              if (eventTarget) {
                eventTarget.blur();
              }
            }
            if (self2.mobileInput !== void 0) {
              self2.mobileInput.focus();
              self2.mobileInput.click();
            }
            triggerEvent("onOpen");
            return;
          } else if (self2._input.disabled || self2.config.inline) {
            return;
          }
          var wasOpen = self2.isOpen;
          self2.isOpen = true;
          if (!wasOpen) {
            self2.calendarContainer.classList.add("open");
            self2._input.classList.add("active");
            triggerEvent("onOpen");
            positionCalendar(positionElement);
          }
          if (self2.config.enableTime === true && self2.config.noCalendar === true) {
            if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
              setTimeout(function() {
                return self2.hourElement.select();
              }, 50);
            }
          }
        }
        function minMaxDateSetter(type2) {
          return function(date2) {
            var dateObj = self2.config["_" + type2 + "Date"] = self2.parseDate(date2, self2.config.dateFormat);
            var inverseDateObj = self2.config["_" + (type2 === "min" ? "max" : "min") + "Date"];
            if (dateObj !== void 0) {
              self2[type2 === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
            }
            if (self2.selectedDates) {
              self2.selectedDates = self2.selectedDates.filter(function(d2) {
                return isEnabled(d2);
              });
              if (!self2.selectedDates.length && type2 === "min")
                setHoursFromDate(dateObj);
              updateValue();
            }
            if (self2.daysContainer) {
              redraw();
              if (dateObj !== void 0)
                self2.currentYearElement[type2] = dateObj.getFullYear().toString();
              else
                self2.currentYearElement.removeAttribute(type2);
              self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
            }
          };
        }
        function parseConfig() {
          var boolOpts = [
            "wrap",
            "weekNumbers",
            "allowInput",
            "allowInvalidPreload",
            "clickOpens",
            "time_24hr",
            "enableTime",
            "noCalendar",
            "altInput",
            "shorthandCurrentMonth",
            "inline",
            "static",
            "enableSeconds",
            "disableMobile"
          ];
          var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element4.dataset || {}))), instanceConfig);
          var formats2 = {};
          self2.config.parseDate = userConfig.parseDate;
          self2.config.formatDate = userConfig.formatDate;
          Object.defineProperty(self2.config, "enable", {
            get: function() {
              return self2.config._enable;
            },
            set: function(dates) {
              self2.config._enable = parseDateRules(dates);
            }
          });
          Object.defineProperty(self2.config, "disable", {
            get: function() {
              return self2.config._disable;
            },
            set: function(dates) {
              self2.config._disable = parseDateRules(dates);
            }
          });
          var timeMode = userConfig.mode === "time";
          if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
            var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults4.dateFormat;
            formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
          }
          if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
            var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults4.altFormat;
            formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
          }
          Object.defineProperty(self2.config, "minDate", {
            get: function() {
              return self2.config._minDate;
            },
            set: minMaxDateSetter("min")
          });
          Object.defineProperty(self2.config, "maxDate", {
            get: function() {
              return self2.config._maxDate;
            },
            set: minMaxDateSetter("max")
          });
          var minMaxTimeSetter = function(type2) {
            return function(val) {
              self2.config[type2 === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
            };
          };
          Object.defineProperty(self2.config, "minTime", {
            get: function() {
              return self2.config._minTime;
            },
            set: minMaxTimeSetter("min")
          });
          Object.defineProperty(self2.config, "maxTime", {
            get: function() {
              return self2.config._maxTime;
            },
            set: minMaxTimeSetter("max")
          });
          if (userConfig.mode === "time") {
            self2.config.noCalendar = true;
            self2.config.enableTime = true;
          }
          Object.assign(self2.config, formats2, userConfig);
          for (var i = 0; i < boolOpts.length; i++)
            self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
          HOOKS.filter(function(hook) {
            return self2.config[hook] !== void 0;
          }).forEach(function(hook) {
            self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
          });
          self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          for (var i = 0; i < self2.config.plugins.length; i++) {
            var pluginConf = self2.config.plugins[i](self2) || {};
            for (var key in pluginConf) {
              if (HOOKS.indexOf(key) > -1) {
                self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
              } else if (typeof userConfig[key] === "undefined")
                self2.config[key] = pluginConf[key];
            }
          }
          if (!userConfig.altInputClass) {
            self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
          }
          triggerEvent("onParseConfig");
        }
        function getInputElem() {
          return self2.config.wrap ? element4.querySelector("[data-input]") : element4;
        }
        function setupLocale() {
          if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
            self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
          self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
          tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
          tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
          tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
          tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
          tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
          var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element4.dataset || {})));
          if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
            self2.config.time_24hr = self2.l10n.time_24hr;
          }
          self2.formatDate = createDateFormatter(self2);
          self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
        }
        function positionCalendar(customPositionElement) {
          if (typeof self2.config.position === "function") {
            return void self2.config.position(self2, customPositionElement);
          }
          if (self2.calendarContainer === void 0)
            return;
          triggerEvent("onPreCalendarPosition");
          var positionElement = customPositionElement || self2._positionElement;
          var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
            return acc + child.offsetHeight;
          }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
          var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
          toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
          toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
          if (self2.config.inline)
            return;
          var left = window.pageXOffset + inputBounds.left;
          var isCenter = false;
          var isRight = false;
          if (configPosHorizontal === "center") {
            left -= (calendarWidth - inputBounds.width) / 2;
            isCenter = true;
          } else if (configPosHorizontal === "right") {
            left -= calendarWidth - inputBounds.width;
            isRight = true;
          }
          toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
          toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
          toggleClass(self2.calendarContainer, "arrowRight", isRight);
          var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
          var rightMost = left + calendarWidth > window.document.body.offsetWidth;
          var centerMost = right + calendarWidth > window.document.body.offsetWidth;
          toggleClass(self2.calendarContainer, "rightMost", rightMost);
          if (self2.config.static)
            return;
          self2.calendarContainer.style.top = top + "px";
          if (!rightMost) {
            self2.calendarContainer.style.left = left + "px";
            self2.calendarContainer.style.right = "auto";
          } else if (!centerMost) {
            self2.calendarContainer.style.left = "auto";
            self2.calendarContainer.style.right = right + "px";
          } else {
            var doc = getDocumentStyleSheet();
            if (doc === void 0)
              return;
            var bodyWidth = window.document.body.offsetWidth;
            var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
            var centerBefore = ".flatpickr-calendar.centerMost:before";
            var centerAfter = ".flatpickr-calendar.centerMost:after";
            var centerIndex = doc.cssRules.length;
            var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
            toggleClass(self2.calendarContainer, "rightMost", false);
            toggleClass(self2.calendarContainer, "centerMost", true);
            doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
            self2.calendarContainer.style.left = centerLeft + "px";
            self2.calendarContainer.style.right = "auto";
          }
        }
        function getDocumentStyleSheet() {
          var editableSheet = null;
          for (var i = 0; i < document.styleSheets.length; i++) {
            var sheet = document.styleSheets[i];
            if (!sheet.cssRules)
              continue;
            try {
              sheet.cssRules;
            } catch (err) {
              continue;
            }
            editableSheet = sheet;
            break;
          }
          return editableSheet != null ? editableSheet : createStyleSheet();
        }
        function createStyleSheet() {
          var style3 = document.createElement("style");
          document.head.appendChild(style3);
          return style3.sheet;
        }
        function redraw() {
          if (self2.config.noCalendar || self2.isMobile)
            return;
          buildMonthSwitch();
          updateNavigationCurrentMonth();
          buildDays();
        }
        function focusAndClose() {
          self2._input.focus();
          if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
            setTimeout(self2.close, 0);
          } else {
            self2.close();
          }
        }
        function selectDate(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          var isSelectable = function(day) {
            return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
          };
          var t2 = findParent(getEventTarget(e2), isSelectable);
          if (t2 === void 0)
            return;
          var target = t2;
          var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
          var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
          self2.selectedDateElem = target;
          if (self2.config.mode === "single")
            self2.selectedDates = [selectedDate];
          else if (self2.config.mode === "multiple") {
            var selectedIndex = isDateSelected(selectedDate);
            if (selectedIndex)
              self2.selectedDates.splice(parseInt(selectedIndex), 1);
            else
              self2.selectedDates.push(selectedDate);
          } else if (self2.config.mode === "range") {
            if (self2.selectedDates.length === 2) {
              self2.clear(false, false);
            }
            self2.latestSelectedDateObj = selectedDate;
            self2.selectedDates.push(selectedDate);
            if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
              self2.selectedDates.sort(function(a, b) {
                return a.getTime() - b.getTime();
              });
          }
          setHoursFromInputs();
          if (shouldChangeMonth) {
            var isNewYear = self2.currentYear !== selectedDate.getFullYear();
            self2.currentYear = selectedDate.getFullYear();
            self2.currentMonth = selectedDate.getMonth();
            if (isNewYear) {
              triggerEvent("onYearChange");
              buildMonthSwitch();
            }
            triggerEvent("onMonthChange");
          }
          updateNavigationCurrentMonth();
          buildDays();
          updateValue();
          if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
            focusOnDayElem(target);
          else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
            self2.selectedDateElem && self2.selectedDateElem.focus();
          }
          if (self2.hourElement !== void 0)
            self2.hourElement !== void 0 && self2.hourElement.focus();
          if (self2.config.closeOnSelect) {
            var single = self2.config.mode === "single" && !self2.config.enableTime;
            var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
            if (single || range) {
              focusAndClose();
            }
          }
          triggerChange();
        }
        var CALLBACKS = {
          locale: [setupLocale, updateWeekdays],
          showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
          minDate: [jumpToDate],
          maxDate: [jumpToDate],
          positionElement: [updatePositionElement],
          clickOpens: [
            function() {
              if (self2.config.clickOpens === true) {
                bind2(self2._input, "focus", self2.open);
                bind2(self2._input, "click", self2.open);
              } else {
                self2._input.removeEventListener("focus", self2.open);
                self2._input.removeEventListener("click", self2.open);
              }
            }
          ]
        };
        function set2(option, value) {
          if (option !== null && typeof option === "object") {
            Object.assign(self2.config, option);
            for (var key in option) {
              if (CALLBACKS[key] !== void 0)
                CALLBACKS[key].forEach(function(x) {
                  return x();
                });
            }
          } else {
            self2.config[option] = value;
            if (CALLBACKS[option] !== void 0)
              CALLBACKS[option].forEach(function(x) {
                return x();
              });
            else if (HOOKS.indexOf(option) > -1)
              self2.config[option] = arrayify(value);
          }
          self2.redraw();
          updateValue(true);
        }
        function setSelectedDate(inputDate, format) {
          var dates = [];
          if (inputDate instanceof Array)
            dates = inputDate.map(function(d2) {
              return self2.parseDate(d2, format);
            });
          else if (inputDate instanceof Date || typeof inputDate === "number")
            dates = [self2.parseDate(inputDate, format)];
          else if (typeof inputDate === "string") {
            switch (self2.config.mode) {
              case "single":
              case "time":
                dates = [self2.parseDate(inputDate, format)];
                break;
              case "multiple":
                dates = inputDate.split(self2.config.conjunction).map(function(date2) {
                  return self2.parseDate(date2, format);
                });
                break;
              case "range":
                dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date2) {
                  return self2.parseDate(date2, format);
                });
                break;
            }
          } else
            self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
          self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d2) {
            return d2 instanceof Date && isEnabled(d2, false);
          });
          if (self2.config.mode === "range")
            self2.selectedDates.sort(function(a, b) {
              return a.getTime() - b.getTime();
            });
        }
        function setDate(date2, triggerChange2, format) {
          if (triggerChange2 === void 0) {
            triggerChange2 = false;
          }
          if (format === void 0) {
            format = self2.config.dateFormat;
          }
          if (date2 !== 0 && !date2 || date2 instanceof Array && date2.length === 0)
            return self2.clear(triggerChange2);
          setSelectedDate(date2, format);
          self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
          self2.redraw();
          jumpToDate(void 0, triggerChange2);
          setHoursFromDate();
          if (self2.selectedDates.length === 0) {
            self2.clear(false);
          }
          updateValue(triggerChange2);
          if (triggerChange2)
            triggerEvent("onChange");
        }
        function parseDateRules(arr2) {
          return arr2.slice().map(function(rule) {
            if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
              return self2.parseDate(rule, void 0, true);
            } else if (rule && typeof rule === "object" && rule.from && rule.to)
              return {
                from: self2.parseDate(rule.from, void 0),
                to: self2.parseDate(rule.to, void 0)
              };
            return rule;
          }).filter(function(x) {
            return x;
          });
        }
        function setupDates() {
          self2.selectedDates = [];
          self2.now = self2.parseDate(self2.config.now) || new Date();
          var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
          if (preloadedDate)
            setSelectedDate(preloadedDate, self2.config.dateFormat);
          self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
          self2.currentYear = self2._initialDate.getFullYear();
          self2.currentMonth = self2._initialDate.getMonth();
          if (self2.selectedDates.length > 0)
            self2.latestSelectedDateObj = self2.selectedDates[0];
          if (self2.config.minTime !== void 0)
            self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
          if (self2.config.maxTime !== void 0)
            self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
          self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
          self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
        }
        function setupInputs() {
          self2.input = getInputElem();
          if (!self2.input) {
            self2.config.errorHandler(new Error("Invalid input element specified"));
            return;
          }
          self2.input._type = self2.input.type;
          self2.input.type = "text";
          self2.input.classList.add("flatpickr-input");
          self2._input = self2.input;
          if (self2.config.altInput) {
            self2.altInput = createElement133(self2.input.nodeName, self2.config.altInputClass);
            self2._input = self2.altInput;
            self2.altInput.placeholder = self2.input.placeholder;
            self2.altInput.disabled = self2.input.disabled;
            self2.altInput.required = self2.input.required;
            self2.altInput.tabIndex = self2.input.tabIndex;
            self2.altInput.type = "text";
            self2.input.setAttribute("type", "hidden");
            if (!self2.config.static && self2.input.parentNode)
              self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
          }
          if (!self2.config.allowInput)
            self2._input.setAttribute("readonly", "readonly");
          updatePositionElement();
        }
        function updatePositionElement() {
          self2._positionElement = self2.config.positionElement || self2._input;
        }
        function setupMobile() {
          var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
          self2.mobileInput = createElement133("input", self2.input.className + " flatpickr-mobile");
          self2.mobileInput.tabIndex = 1;
          self2.mobileInput.type = inputType;
          self2.mobileInput.disabled = self2.input.disabled;
          self2.mobileInput.required = self2.input.required;
          self2.mobileInput.placeholder = self2.input.placeholder;
          self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
          if (self2.selectedDates.length > 0) {
            self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
          }
          if (self2.config.minDate)
            self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
          if (self2.config.maxDate)
            self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
          if (self2.input.getAttribute("step"))
            self2.mobileInput.step = String(self2.input.getAttribute("step"));
          self2.input.type = "hidden";
          if (self2.altInput !== void 0)
            self2.altInput.type = "hidden";
          try {
            if (self2.input.parentNode)
              self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
          } catch (_a) {
          }
          bind2(self2.mobileInput, "change", function(e2) {
            self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
            triggerEvent("onChange");
            triggerEvent("onClose");
          });
        }
        function toggle(e2) {
          if (self2.isOpen === true)
            return self2.close();
          self2.open(e2);
        }
        function triggerEvent(event, data) {
          if (self2.config === void 0)
            return;
          var hooks8 = self2.config[event];
          if (hooks8 !== void 0 && hooks8.length > 0) {
            for (var i = 0; hooks8[i] && i < hooks8.length; i++)
              hooks8[i](self2.selectedDates, self2.input.value, self2, data);
          }
          if (event === "onChange") {
            self2.input.dispatchEvent(createEvent("change"));
            self2.input.dispatchEvent(createEvent("input"));
          }
        }
        function createEvent(name) {
          var e2 = document.createEvent("Event");
          e2.initEvent(name, true, true);
          return e2;
        }
        function isDateSelected(date2) {
          for (var i = 0; i < self2.selectedDates.length; i++) {
            var selectedDate = self2.selectedDates[i];
            if (selectedDate instanceof Date && compareDates(selectedDate, date2) === 0)
              return "" + i;
          }
          return false;
        }
        function isDateInRange(date2) {
          if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
            return false;
          return compareDates(date2, self2.selectedDates[0]) >= 0 && compareDates(date2, self2.selectedDates[1]) <= 0;
        }
        function updateNavigationCurrentMonth() {
          if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
            return;
          self2.yearElements.forEach(function(yearElement, i) {
            var d2 = new Date(self2.currentYear, self2.currentMonth, 1);
            d2.setMonth(self2.currentMonth + i);
            if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
              self2.monthElements[i].textContent = monthToStr(d2.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
            } else {
              self2.monthsDropdownContainer.value = d2.getMonth().toString();
            }
            yearElement.value = d2.getFullYear().toString();
          });
          self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
          self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
        }
        function getDateStr(specificFormat) {
          var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
          return self2.selectedDates.map(function(dObj) {
            return self2.formatDate(dObj, format);
          }).filter(function(d2, i, arr2) {
            return self2.config.mode !== "range" || self2.config.enableTime || arr2.indexOf(d2) === i;
          }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
        }
        function updateValue(triggerChange2) {
          if (triggerChange2 === void 0) {
            triggerChange2 = true;
          }
          if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
            self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
          }
          self2.input.value = getDateStr(self2.config.dateFormat);
          if (self2.altInput !== void 0) {
            self2.altInput.value = getDateStr(self2.config.altFormat);
          }
          if (triggerChange2 !== false)
            triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e2) {
          var eventTarget = getEventTarget(e2);
          var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
          var isNextMonth = self2.nextMonthNav.contains(eventTarget);
          if (isPrevMonth || isNextMonth) {
            changeMonth(isPrevMonth ? -1 : 1);
          } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
            eventTarget.select();
          } else if (eventTarget.classList.contains("arrowUp")) {
            self2.changeYear(self2.currentYear + 1);
          } else if (eventTarget.classList.contains("arrowDown")) {
            self2.changeYear(self2.currentYear - 1);
          }
        }
        function timeWrapper(e2) {
          e2.preventDefault();
          var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
          if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
            self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
          }
          var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
          var newValue = curValue + step * delta;
          if (typeof input.value !== "undefined" && input.value.length === 2) {
            var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
            if (newValue < min) {
              newValue = max + newValue + int2(!isHourElem) + (int2(isHourElem) && int2(!self2.amPM));
              if (isMinuteElem)
                incrementNumInput(void 0, -1, self2.hourElement);
            } else if (newValue > max) {
              newValue = input === self2.hourElement ? newValue - max - int2(!self2.amPM) : min;
              if (isMinuteElem)
                incrementNumInput(void 0, 1, self2.hourElement);
            }
            if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
              self2.amPM.textContent = self2.l10n.amPM[int2(self2.amPM.textContent === self2.l10n.amPM[0])];
            }
            input.value = pad(newValue);
          }
        }
        init2();
        return self2;
      }
      function _flatpickr(nodeList, config3) {
        var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
          return x instanceof HTMLElement;
        });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
          var node2 = nodes[i];
          try {
            if (node2.getAttribute("data-fp-omit") !== null)
              continue;
            if (node2._flatpickr !== void 0) {
              node2._flatpickr.destroy();
              node2._flatpickr = void 0;
            }
            node2._flatpickr = FlatpickrInstance(node2, config3 || {});
            instances.push(node2._flatpickr);
          } catch (e2) {
            console.error(e2);
          }
        }
        return instances.length === 1 ? instances[0] : instances;
      }
      if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config3) {
          return _flatpickr(this, config3);
        };
        HTMLElement.prototype.flatpickr = function(config3) {
          return _flatpickr([this], config3);
        };
      }
      var flatpickr = function(selector, config3) {
        if (typeof selector === "string") {
          return _flatpickr(window.document.querySelectorAll(selector), config3);
        } else if (selector instanceof Node) {
          return _flatpickr([selector], config3);
        } else {
          return _flatpickr(selector, config3);
        }
      };
      flatpickr.defaultConfig = {};
      flatpickr.l10ns = {
        en: __assign({}, english),
        default: __assign({}, english)
      };
      flatpickr.localize = function(l10n) {
        flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
      };
      flatpickr.setDefaults = function(config3) {
        flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config3);
      };
      flatpickr.parseDate = createDateParser({});
      flatpickr.formatDate = createDateFormatter({});
      flatpickr.compareDates = compareDates;
      if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
        jQuery.fn.flatpickr = function(config3) {
          return _flatpickr(this, config3);
        };
      }
      Date.prototype.fp_incr = function(days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
      };
      if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
      }
      return flatpickr;
    });
  }
});

// node_modules/react-flatpickr/build/index.js
var require_build = __commonJS({
  "node_modules/react-flatpickr/build/index.js"(exports) {
    "use strict";
    function _typeof4(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof4 = function _typeof5(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof4 = function _typeof5(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof4(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _flatpickr = _interopRequireDefault(require_flatpickr());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof4(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _toConsumableArray3(arr2) {
      return _arrayWithoutHoles3(arr2) || _iterableToArray3(arr2) || _unsupportedIterableToArray3(arr2) || _nonIterableSpread3();
    }
    function _nonIterableSpread3() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray3(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray3(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray3(o, minLen);
    }
    function _iterableToArray3(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
        return Array.from(iter);
    }
    function _arrayWithoutHoles3(arr2) {
      if (Array.isArray(arr2))
        return _arrayLikeToArray3(arr2);
    }
    function _arrayLikeToArray3(arr2, len) {
      if (len == null || len > arr2.length)
        len = arr2.length;
      for (var i = 0, arr22 = new Array(len); i < len; i++) {
        arr22[i] = arr2[i];
      }
      return arr22;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose3(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose3(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function ownKeys4(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys4(Object(source), true).forEach(function(key) {
            _defineProperty4(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys4(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck3(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties3(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass3(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties3(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties3(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o, p2) {
      _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      return _setPrototypeOf2(o, p2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof4(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty4(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var hooks8 = ["onChange", "onOpen", "onClose", "onMonthChange", "onYearChange", "onReady", "onValueUpdate", "onDayCreate"];
    var hookPropType = _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].arrayOf(_propTypes["default"].func)]);
    var callbacks = ["onCreate", "onDestroy"];
    var callbackPropTypes = _propTypes["default"].func;
    var DateTimePicker = /* @__PURE__ */ function(_Component) {
      _inherits(DateTimePicker2, _Component);
      var _super = _createSuper(DateTimePicker2);
      function DateTimePicker2() {
        var _this;
        _classCallCheck3(this, DateTimePicker2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty4(_assertThisInitialized(_this), "createFlatpickrInstance", function() {
          var options = _objectSpread({
            onClose: function onClose() {
              _this.node.blur && _this.node.blur();
            }
          }, _this.props.options);
          options = mergeHooks(options, _this.props);
          _this.flatpickr = (0, _flatpickr["default"])(_this.node, options);
          if (_this.props.hasOwnProperty("value")) {
            _this.flatpickr.setDate(_this.props.value, false);
          }
          var onCreate = _this.props.onCreate;
          if (onCreate)
            onCreate(_this.flatpickr);
        });
        _defineProperty4(_assertThisInitialized(_this), "destroyFlatpickrInstance", function() {
          var onDestroy = _this.props.onDestroy;
          if (onDestroy)
            onDestroy(_this.flatpickr);
          _this.flatpickr.destroy();
          _this.flatpickr = null;
        });
        _defineProperty4(_assertThisInitialized(_this), "handleNodeChange", function(node2) {
          _this.node = node2;
          if (_this.flatpickr) {
            _this.destroyFlatpickrInstance();
            _this.createFlatpickrInstance();
          }
        });
        return _this;
      }
      _createClass3(DateTimePicker2, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var options = this.props.options;
          var prevOptions = prevProps.options;
          options = mergeHooks(options, this.props);
          prevOptions = mergeHooks(prevOptions, prevProps);
          var optionsKeys = Object.getOwnPropertyNames(options);
          for (var index2 = optionsKeys.length - 1; index2 >= 0; index2--) {
            var key = optionsKeys[index2];
            var value = options[key];
            if (value !== prevOptions[key]) {
              if (hooks8.indexOf(key) !== -1 && !Array.isArray(value)) {
                value = [value];
              }
              this.flatpickr.set(key, value);
            }
          }
          if (this.props.hasOwnProperty("value") && !(this.props.value && Array.isArray(this.props.value) && prevProps.value && Array.isArray(prevProps.value) && this.props.value.every(function(v, i) {
            prevProps[i] === v;
          })) && this.props.value !== prevProps.value) {
            this.flatpickr.setDate(this.props.value, false);
          }
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          this.createFlatpickrInstance();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.destroyFlatpickrInstance();
        }
      }, {
        key: "render",
        value: function render3() {
          var _this$props = this.props, options = _this$props.options, defaultValue = _this$props.defaultValue, value = _this$props.value, children = _this$props.children, render4 = _this$props.render, props = _objectWithoutProperties2(_this$props, ["options", "defaultValue", "value", "children", "render"]);
          hooks8.forEach(function(hook) {
            delete props[hook];
          });
          callbacks.forEach(function(callback) {
            delete props[callback];
          });
          if (render4)
            return render4(_objectSpread(_objectSpread({}, props), {}, {
              defaultValue,
              value
            }), this.handleNodeChange);
          return options.wrap ? /* @__PURE__ */ _react["default"].createElement("div", _extends2({}, props, {
            ref: this.handleNodeChange
          }), children) : /* @__PURE__ */ _react["default"].createElement("input", _extends2({}, props, {
            defaultValue,
            ref: this.handleNodeChange
          }));
        }
      }]);
      return DateTimePicker2;
    }(_react.Component);
    _defineProperty4(DateTimePicker, "propTypes", {
      defaultValue: _propTypes["default"].string,
      options: _propTypes["default"].object,
      onChange: hookPropType,
      onOpen: hookPropType,
      onClose: hookPropType,
      onMonthChange: hookPropType,
      onYearChange: hookPropType,
      onReady: hookPropType,
      onValueUpdate: hookPropType,
      onDayCreate: hookPropType,
      onCreate: callbackPropTypes,
      onDestroy: callbackPropTypes,
      value: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object, _propTypes["default"].number]),
      children: _propTypes["default"].node,
      className: _propTypes["default"].string,
      render: _propTypes["default"].func
    });
    _defineProperty4(DateTimePicker, "defaultProps", {
      options: {}
    });
    function mergeHooks(inputOptions, props) {
      var options = _objectSpread({}, inputOptions);
      hooks8.forEach(function(hook) {
        if (props.hasOwnProperty(hook)) {
          var _options$hook;
          if (options[hook] && !Array.isArray(options[hook])) {
            options[hook] = [options[hook]];
          } else if (!options[hook]) {
            options[hook] = [];
          }
          var propHook = Array.isArray(props[hook]) ? props[hook] : [props[hook]];
          (_options$hook = options[hook]).push.apply(_options$hook, _toConsumableArray3(propHook));
        }
      });
      return options;
    }
    var _default2 = DateTimePicker;
    exports["default"] = _default2;
  }
});

// node_modules/d3-array/dist/d3-array.js
var require_d3_array = __commonJS({
  "node_modules/d3-array/dist/d3-array.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.d3 = global2.d3 || {}));
    })(exports, function(exports2) {
      "use strict";
      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      function bisector(f) {
        let delta = f;
        let compare = f;
        if (f.length === 1) {
          delta = (d2, x) => f(d2) - x;
          compare = ascendingComparator(f);
        }
        function left(a, x, lo, hi) {
          if (lo == null)
            lo = 0;
          if (hi == null)
            hi = a.length;
          while (lo < hi) {
            const mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0)
              lo = mid + 1;
            else
              hi = mid;
          }
          return lo;
        }
        function right(a, x, lo, hi) {
          if (lo == null)
            lo = 0;
          if (hi == null)
            hi = a.length;
          while (lo < hi) {
            const mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0)
              hi = mid;
            else
              lo = mid + 1;
          }
          return lo;
        }
        function center(a, x, lo, hi) {
          if (lo == null)
            lo = 0;
          if (hi == null)
            hi = a.length;
          const i = left(a, x, lo, hi - 1);
          return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
        }
        return { left, center, right };
      }
      function ascendingComparator(f) {
        return (d2, x) => ascending(f(d2), x);
      }
      function number2(x) {
        return x === null ? NaN : +x;
      }
      function* numbers(values2, valueof) {
        if (valueof === void 0) {
          for (let value of values2) {
            if (value != null && (value = +value) >= value) {
              yield value;
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (value = +value) >= value) {
              yield value;
            }
          }
        }
      }
      const ascendingBisect = bisector(ascending);
      const bisectRight = ascendingBisect.right;
      const bisectLeft = ascendingBisect.left;
      const bisectCenter = bisector(number2).center;
      function count2(values2, valueof) {
        let count3 = 0;
        if (valueof === void 0) {
          for (let value of values2) {
            if (value != null && (value = +value) >= value) {
              ++count3;
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (value = +value) >= value) {
              ++count3;
            }
          }
        }
        return count3;
      }
      function length$1(array2) {
        return array2.length | 0;
      }
      function empty2(length2) {
        return !(length2 > 0);
      }
      function arrayify(values2) {
        return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
      }
      function reducer2(reduce3) {
        return (values2) => reduce3(...values2);
      }
      function cross(...values2) {
        const reduce3 = typeof values2[values2.length - 1] === "function" && reducer2(values2.pop());
        values2 = values2.map(arrayify);
        const lengths = values2.map(length$1);
        const j = values2.length - 1;
        const index3 = new Array(j + 1).fill(0);
        const product = [];
        if (j < 0 || lengths.some(empty2))
          return product;
        while (true) {
          product.push(index3.map((j2, i2) => values2[i2][j2]));
          let i = j;
          while (++index3[i] === lengths[i]) {
            if (i === 0)
              return reduce3 ? product.map(reduce3) : product;
            index3[i--] = 0;
          }
        }
      }
      function cumsum(values2, valueof) {
        var sum2 = 0, index3 = 0;
        return Float64Array.from(values2, valueof === void 0 ? (v) => sum2 += +v || 0 : (v) => sum2 += +valueof(v, index3++, values2) || 0);
      }
      function descending(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      }
      function variance(values2, valueof) {
        let count3 = 0;
        let delta;
        let mean2 = 0;
        let sum2 = 0;
        if (valueof === void 0) {
          for (let value of values2) {
            if (value != null && (value = +value) >= value) {
              delta = value - mean2;
              mean2 += delta / ++count3;
              sum2 += delta * (value - mean2);
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (value = +value) >= value) {
              delta = value - mean2;
              mean2 += delta / ++count3;
              sum2 += delta * (value - mean2);
            }
          }
        }
        if (count3 > 1)
          return sum2 / (count3 - 1);
      }
      function deviation(values2, valueof) {
        const v = variance(values2, valueof);
        return v ? Math.sqrt(v) : v;
      }
      function extent(values2, valueof) {
        let min2;
        let max2;
        if (valueof === void 0) {
          for (const value of values2) {
            if (value != null) {
              if (min2 === void 0) {
                if (value >= value)
                  min2 = max2 = value;
              } else {
                if (min2 > value)
                  min2 = value;
                if (max2 < value)
                  max2 = value;
              }
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null) {
              if (min2 === void 0) {
                if (value >= value)
                  min2 = max2 = value;
              } else {
                if (min2 > value)
                  min2 = value;
                if (max2 < value)
                  max2 = value;
              }
            }
          }
        }
        return [min2, max2];
      }
      class Adder {
        constructor() {
          this._partials = new Float64Array(32);
          this._n = 0;
        }
        add(x) {
          const p2 = this._partials;
          let i = 0;
          for (let j = 0; j < this._n && j < 32; j++) {
            const y = p2[j], hi = x + y, lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
            if (lo)
              p2[i++] = lo;
            x = hi;
          }
          p2[i] = x;
          this._n = i + 1;
          return this;
        }
        valueOf() {
          const p2 = this._partials;
          let n2 = this._n, x, y, lo, hi = 0;
          if (n2 > 0) {
            hi = p2[--n2];
            while (n2 > 0) {
              x = hi;
              y = p2[--n2];
              hi = x + y;
              lo = y - (hi - x);
              if (lo)
                break;
            }
            if (n2 > 0 && (lo < 0 && p2[n2 - 1] < 0 || lo > 0 && p2[n2 - 1] > 0)) {
              y = lo * 2;
              x = hi + y;
              if (y == x - hi)
                hi = x;
            }
          }
          return hi;
        }
      }
      function fsum(values2, valueof) {
        const adder = new Adder();
        if (valueof === void 0) {
          for (let value of values2) {
            if (value = +value) {
              adder.add(value);
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if (value = +valueof(value, ++index3, values2)) {
              adder.add(value);
            }
          }
        }
        return +adder;
      }
      function fcumsum(values2, valueof) {
        const adder = new Adder();
        let index3 = -1;
        return Float64Array.from(values2, valueof === void 0 ? (v) => adder.add(+v || 0) : (v) => adder.add(+valueof(v, ++index3, values2) || 0));
      }
      class InternMap extends Map {
        constructor(entries, key = keyof) {
          super();
          Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
          if (entries != null)
            for (const [key2, value] of entries)
              this.set(key2, value);
        }
        get(key) {
          return super.get(intern_get(this, key));
        }
        has(key) {
          return super.has(intern_get(this, key));
        }
        set(key, value) {
          return super.set(intern_set(this, key), value);
        }
        delete(key) {
          return super.delete(intern_delete(this, key));
        }
      }
      class InternSet extends Set {
        constructor(values2, key = keyof) {
          super();
          Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
          if (values2 != null)
            for (const value of values2)
              this.add(value);
        }
        has(value) {
          return super.has(intern_get(this, value));
        }
        add(value) {
          return super.add(intern_set(this, value));
        }
        delete(value) {
          return super.delete(intern_delete(this, value));
        }
      }
      function intern_get({ _intern, _key }, value) {
        const key = _key(value);
        return _intern.has(key) ? _intern.get(key) : value;
      }
      function intern_set({ _intern, _key }, value) {
        const key = _key(value);
        if (_intern.has(key))
          return _intern.get(key);
        _intern.set(key, value);
        return value;
      }
      function intern_delete({ _intern, _key }, value) {
        const key = _key(value);
        if (_intern.has(key)) {
          value = _intern.get(value);
          _intern.delete(key);
        }
        return value;
      }
      function keyof(value) {
        return value !== null && typeof value === "object" ? value.valueOf() : value;
      }
      function identity(x) {
        return x;
      }
      function group(values2, ...keys2) {
        return nest2(values2, identity, identity, keys2);
      }
      function groups(values2, ...keys2) {
        return nest2(values2, Array.from, identity, keys2);
      }
      function rollup(values2, reduce3, ...keys2) {
        return nest2(values2, identity, reduce3, keys2);
      }
      function rollups(values2, reduce3, ...keys2) {
        return nest2(values2, Array.from, reduce3, keys2);
      }
      function index2(values2, ...keys2) {
        return nest2(values2, identity, unique, keys2);
      }
      function indexes(values2, ...keys2) {
        return nest2(values2, Array.from, unique, keys2);
      }
      function unique(values2) {
        if (values2.length !== 1)
          throw new Error("duplicate key");
        return values2[0];
      }
      function nest2(values2, map2, reduce3, keys2) {
        return function regroup(values3, i) {
          if (i >= keys2.length)
            return reduce3(values3);
          const groups2 = new InternMap();
          const keyof2 = keys2[i++];
          let index3 = -1;
          for (const value of values3) {
            const key = keyof2(value, ++index3, values3);
            const group2 = groups2.get(key);
            if (group2)
              group2.push(value);
            else
              groups2.set(key, [value]);
          }
          for (const [key, values4] of groups2) {
            groups2.set(key, regroup(values4, i));
          }
          return map2(groups2);
        }(values2, 0);
      }
      function permute(source, keys2) {
        return Array.from(keys2, (key) => source[key]);
      }
      function sort(values2, ...F) {
        if (typeof values2[Symbol.iterator] !== "function")
          throw new TypeError("values is not iterable");
        values2 = Array.from(values2);
        let [f = ascending] = F;
        if (f.length === 1 || F.length > 1) {
          const index3 = Uint32Array.from(values2, (d2, i) => i);
          if (F.length > 1) {
            F = F.map((f2) => values2.map(f2));
            index3.sort((i, j) => {
              for (const f2 of F) {
                const c = ascending(f2[i], f2[j]);
                if (c)
                  return c;
              }
            });
          } else {
            f = values2.map(f);
            index3.sort((i, j) => ascending(f[i], f[j]));
          }
          return permute(values2, index3);
        }
        return values2.sort(f);
      }
      function groupSort(values2, reduce3, key) {
        return (reduce3.length === 1 ? sort(rollup(values2, reduce3, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce3(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
      }
      var array = Array.prototype;
      var slice2 = array.slice;
      function constant(x) {
        return function() {
          return x;
        };
      }
      var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
      function ticks(start3, stop, count3) {
        var reverse2, i = -1, n2, ticks2, step;
        stop = +stop, start3 = +start3, count3 = +count3;
        if (start3 === stop && count3 > 0)
          return [start3];
        if (reverse2 = stop < start3)
          n2 = start3, start3 = stop, stop = n2;
        if ((step = tickIncrement(start3, stop, count3)) === 0 || !isFinite(step))
          return [];
        if (step > 0) {
          let r0 = Math.round(start3 / step), r1 = Math.round(stop / step);
          if (r0 * step < start3)
            ++r0;
          if (r1 * step > stop)
            --r1;
          ticks2 = new Array(n2 = r1 - r0 + 1);
          while (++i < n2)
            ticks2[i] = (r0 + i) * step;
        } else {
          step = -step;
          let r0 = Math.round(start3 * step), r1 = Math.round(stop * step);
          if (r0 / step < start3)
            ++r0;
          if (r1 / step > stop)
            --r1;
          ticks2 = new Array(n2 = r1 - r0 + 1);
          while (++i < n2)
            ticks2[i] = (r0 + i) / step;
        }
        if (reverse2)
          ticks2.reverse();
        return ticks2;
      }
      function tickIncrement(start3, stop, count3) {
        var step = (stop - start3) / Math.max(0, count3), power = Math.floor(Math.log(step) / Math.LN10), error2 = step / Math.pow(10, power);
        return power >= 0 ? (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
      }
      function tickStep(start3, stop, count3) {
        var step0 = Math.abs(stop - start3) / Math.max(0, count3), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error2 = step0 / step1;
        if (error2 >= e10)
          step1 *= 10;
        else if (error2 >= e5)
          step1 *= 5;
        else if (error2 >= e2)
          step1 *= 2;
        return stop < start3 ? -step1 : step1;
      }
      function nice(start3, stop, count3) {
        let prestep;
        while (true) {
          const step = tickIncrement(start3, stop, count3);
          if (step === prestep || step === 0 || !isFinite(step)) {
            return [start3, stop];
          } else if (step > 0) {
            start3 = Math.floor(start3 / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start3 = Math.ceil(start3 * step) / step;
            stop = Math.floor(stop * step) / step;
          }
          prestep = step;
        }
      }
      function sturges(values2) {
        return Math.ceil(Math.log(count2(values2)) / Math.LN2) + 1;
      }
      function bin() {
        var value = identity, domain = extent, threshold = sturges;
        function histogram(data) {
          if (!Array.isArray(data))
            data = Array.from(data);
          var i, n2 = data.length, x, values2 = new Array(n2);
          for (i = 0; i < n2; ++i) {
            values2[i] = value(data[i], i, data);
          }
          var xz = domain(values2), x0 = xz[0], x1 = xz[1], tz = threshold(values2, x0, x1);
          if (!Array.isArray(tz)) {
            const max2 = x1, tn = +tz;
            if (domain === extent)
              [x0, x1] = nice(x0, x1, tn);
            tz = ticks(x0, x1, tn);
            if (tz[tz.length - 1] >= x1) {
              if (max2 >= x1 && domain === extent) {
                const step = tickIncrement(x0, x1, tn);
                if (isFinite(step)) {
                  if (step > 0) {
                    x1 = (Math.floor(x1 / step) + 1) * step;
                  } else if (step < 0) {
                    x1 = (Math.ceil(x1 * -step) + 1) / -step;
                  }
                }
              } else {
                tz.pop();
              }
            }
          }
          var m = tz.length;
          while (tz[0] <= x0)
            tz.shift(), --m;
          while (tz[m - 1] > x1)
            tz.pop(), --m;
          var bins = new Array(m + 1), bin2;
          for (i = 0; i <= m; ++i) {
            bin2 = bins[i] = [];
            bin2.x0 = i > 0 ? tz[i - 1] : x0;
            bin2.x1 = i < m ? tz[i] : x1;
          }
          for (i = 0; i < n2; ++i) {
            x = values2[i];
            if (x0 <= x && x <= x1) {
              bins[bisectRight(tz, x, 0, m)].push(data[i]);
            }
          }
          return bins;
        }
        histogram.value = function(_2) {
          return arguments.length ? (value = typeof _2 === "function" ? _2 : constant(_2), histogram) : value;
        };
        histogram.domain = function(_2) {
          return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant([_2[0], _2[1]]), histogram) : domain;
        };
        histogram.thresholds = function(_2) {
          return arguments.length ? (threshold = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant(slice2.call(_2)) : constant(_2), histogram) : threshold;
        };
        return histogram;
      }
      function max(values2, valueof) {
        let max2;
        if (valueof === void 0) {
          for (const value of values2) {
            if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
              max2 = value;
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (max2 < value || max2 === void 0 && value >= value)) {
              max2 = value;
            }
          }
        }
        return max2;
      }
      function min(values2, valueof) {
        let min2;
        if (valueof === void 0) {
          for (const value of values2) {
            if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
              min2 = value;
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (min2 > value || min2 === void 0 && value >= value)) {
              min2 = value;
            }
          }
        }
        return min2;
      }
      function quickselect(array2, k, left = 0, right = array2.length - 1, compare = ascending) {
        while (right > left) {
          if (right - left > 600) {
            const n2 = right - left + 1;
            const m = k - left + 1;
            const z = Math.log(n2);
            const s3 = 0.5 * Math.exp(2 * z / 3);
            const sd = 0.5 * Math.sqrt(z * s3 * (n2 - s3) / n2) * (m - n2 / 2 < 0 ? -1 : 1);
            const newLeft = Math.max(left, Math.floor(k - m * s3 / n2 + sd));
            const newRight = Math.min(right, Math.floor(k + (n2 - m) * s3 / n2 + sd));
            quickselect(array2, k, newLeft, newRight, compare);
          }
          const t2 = array2[k];
          let i = left;
          let j = right;
          swap(array2, left, k);
          if (compare(array2[right], t2) > 0)
            swap(array2, left, right);
          while (i < j) {
            swap(array2, i, j), ++i, --j;
            while (compare(array2[i], t2) < 0)
              ++i;
            while (compare(array2[j], t2) > 0)
              --j;
          }
          if (compare(array2[left], t2) === 0)
            swap(array2, left, j);
          else
            ++j, swap(array2, j, right);
          if (j <= k)
            left = j + 1;
          if (k <= j)
            right = j - 1;
        }
        return array2;
      }
      function swap(array2, i, j) {
        const t2 = array2[i];
        array2[i] = array2[j];
        array2[j] = t2;
      }
      function quantile(values2, p2, valueof) {
        values2 = Float64Array.from(numbers(values2, valueof));
        if (!(n2 = values2.length))
          return;
        if ((p2 = +p2) <= 0 || n2 < 2)
          return min(values2);
        if (p2 >= 1)
          return max(values2);
        var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
        return value0 + (value1 - value0) * (i - i0);
      }
      function quantileSorted(values2, p2, valueof = number2) {
        if (!(n2 = values2.length))
          return;
        if ((p2 = +p2) <= 0 || n2 < 2)
          return +valueof(values2[0], 0, values2);
        if (p2 >= 1)
          return +valueof(values2[n2 - 1], n2 - 1, values2);
        var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
        return value0 + (value1 - value0) * (i - i0);
      }
      function freedmanDiaconis(values2, min2, max2) {
        return Math.ceil((max2 - min2) / (2 * (quantile(values2, 0.75) - quantile(values2, 0.25)) * Math.pow(count2(values2), -1 / 3)));
      }
      function scott(values2, min2, max2) {
        return Math.ceil((max2 - min2) / (3.5 * deviation(values2) * Math.pow(count2(values2), -1 / 3)));
      }
      function maxIndex(values2, valueof) {
        let max2;
        let maxIndex2 = -1;
        let index3 = -1;
        if (valueof === void 0) {
          for (const value of values2) {
            ++index3;
            if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
              max2 = value, maxIndex2 = index3;
            }
          }
        } else {
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (max2 < value || max2 === void 0 && value >= value)) {
              max2 = value, maxIndex2 = index3;
            }
          }
        }
        return maxIndex2;
      }
      function mean(values2, valueof) {
        let count3 = 0;
        let sum2 = 0;
        if (valueof === void 0) {
          for (let value of values2) {
            if (value != null && (value = +value) >= value) {
              ++count3, sum2 += value;
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (value = +value) >= value) {
              ++count3, sum2 += value;
            }
          }
        }
        if (count3)
          return sum2 / count3;
      }
      function median(values2, valueof) {
        return quantile(values2, 0.5, valueof);
      }
      function* flatten(arrays) {
        for (const array2 of arrays) {
          yield* array2;
        }
      }
      function merge3(arrays) {
        return Array.from(flatten(arrays));
      }
      function minIndex(values2, valueof) {
        let min2;
        let minIndex2 = -1;
        let index3 = -1;
        if (valueof === void 0) {
          for (const value of values2) {
            ++index3;
            if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
              min2 = value, minIndex2 = index3;
            }
          }
        } else {
          for (let value of values2) {
            if ((value = valueof(value, ++index3, values2)) != null && (min2 > value || min2 === void 0 && value >= value)) {
              min2 = value, minIndex2 = index3;
            }
          }
        }
        return minIndex2;
      }
      function pairs(values2, pairof = pair) {
        const pairs2 = [];
        let previous2;
        let first = false;
        for (const value of values2) {
          if (first)
            pairs2.push(pairof(previous2, value));
          previous2 = value;
          first = true;
        }
        return pairs2;
      }
      function pair(a, b) {
        return [a, b];
      }
      function range(start3, stop, step) {
        start3 = +start3, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start3, start3 = 0, 1) : n2 < 3 ? 1 : +step;
        var i = -1, n2 = Math.max(0, Math.ceil((stop - start3) / step)) | 0, range2 = new Array(n2);
        while (++i < n2) {
          range2[i] = start3 + i * step;
        }
        return range2;
      }
      function least(values2, compare = ascending) {
        let min2;
        let defined = false;
        if (compare.length === 1) {
          let minValue;
          for (const element4 of values2) {
            const value = compare(element4);
            if (defined ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
              min2 = element4;
              minValue = value;
              defined = true;
            }
          }
        } else {
          for (const value of values2) {
            if (defined ? compare(value, min2) < 0 : compare(value, value) === 0) {
              min2 = value;
              defined = true;
            }
          }
        }
        return min2;
      }
      function leastIndex(values2, compare = ascending) {
        if (compare.length === 1)
          return minIndex(values2, compare);
        let minValue;
        let min2 = -1;
        let index3 = -1;
        for (const value of values2) {
          ++index3;
          if (min2 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
            minValue = value;
            min2 = index3;
          }
        }
        return min2;
      }
      function greatest(values2, compare = ascending) {
        let max2;
        let defined = false;
        if (compare.length === 1) {
          let maxValue;
          for (const element4 of values2) {
            const value = compare(element4);
            if (defined ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
              max2 = element4;
              maxValue = value;
              defined = true;
            }
          }
        } else {
          for (const value of values2) {
            if (defined ? compare(value, max2) > 0 : compare(value, value) === 0) {
              max2 = value;
              defined = true;
            }
          }
        }
        return max2;
      }
      function greatestIndex(values2, compare = ascending) {
        if (compare.length === 1)
          return maxIndex(values2, compare);
        let maxValue;
        let max2 = -1;
        let index3 = -1;
        for (const value of values2) {
          ++index3;
          if (max2 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
            maxValue = value;
            max2 = index3;
          }
        }
        return max2;
      }
      function scan(values2, compare) {
        const index3 = leastIndex(values2, compare);
        return index3 < 0 ? void 0 : index3;
      }
      var shuffle = shuffler(Math.random);
      function shuffler(random) {
        return function shuffle2(array2, i0 = 0, i1 = array2.length) {
          let m = i1 - (i0 = +i0);
          while (m) {
            const i = random() * m-- | 0, t2 = array2[m + i0];
            array2[m + i0] = array2[i + i0];
            array2[i + i0] = t2;
          }
          return array2;
        };
      }
      function sum(values2, valueof) {
        let sum2 = 0;
        if (valueof === void 0) {
          for (let value of values2) {
            if (value = +value) {
              sum2 += value;
            }
          }
        } else {
          let index3 = -1;
          for (let value of values2) {
            if (value = +valueof(value, ++index3, values2)) {
              sum2 += value;
            }
          }
        }
        return sum2;
      }
      function transpose(matrix) {
        if (!(n2 = matrix.length))
          return [];
        for (var i = -1, m = min(matrix, length), transpose2 = new Array(m); ++i < m; ) {
          for (var j = -1, n2, row = transpose2[i] = new Array(n2); ++j < n2; ) {
            row[j] = matrix[j][i];
          }
        }
        return transpose2;
      }
      function length(d2) {
        return d2.length;
      }
      function zip() {
        return transpose(arguments);
      }
      function every(values2, test) {
        if (typeof test !== "function")
          throw new TypeError("test is not a function");
        let index3 = -1;
        for (const value of values2) {
          if (!test(value, ++index3, values2)) {
            return false;
          }
        }
        return true;
      }
      function some(values2, test) {
        if (typeof test !== "function")
          throw new TypeError("test is not a function");
        let index3 = -1;
        for (const value of values2) {
          if (test(value, ++index3, values2)) {
            return true;
          }
        }
        return false;
      }
      function filter2(values2, test) {
        if (typeof test !== "function")
          throw new TypeError("test is not a function");
        const array2 = [];
        let index3 = -1;
        for (const value of values2) {
          if (test(value, ++index3, values2)) {
            array2.push(value);
          }
        }
        return array2;
      }
      function map(values2, mapper) {
        if (typeof values2[Symbol.iterator] !== "function")
          throw new TypeError("values is not iterable");
        if (typeof mapper !== "function")
          throw new TypeError("mapper is not a function");
        return Array.from(values2, (value, index3) => mapper(value, index3, values2));
      }
      function reduce2(values2, reducer3, value) {
        if (typeof reducer3 !== "function")
          throw new TypeError("reducer is not a function");
        const iterator = values2[Symbol.iterator]();
        let done, next, index3 = -1;
        if (arguments.length < 3) {
          ({ done, value } = iterator.next());
          if (done)
            return;
          ++index3;
        }
        while ({ done, value: next } = iterator.next(), !done) {
          value = reducer3(value, next, ++index3, values2);
        }
        return value;
      }
      function reverse(values2) {
        if (typeof values2[Symbol.iterator] !== "function")
          throw new TypeError("values is not iterable");
        return Array.from(values2).reverse();
      }
      function difference(values2, ...others) {
        values2 = new Set(values2);
        for (const other of others) {
          for (const value of other) {
            values2.delete(value);
          }
        }
        return values2;
      }
      function disjoint(values2, other) {
        const iterator = other[Symbol.iterator](), set3 = /* @__PURE__ */ new Set();
        for (const v of values2) {
          if (set3.has(v))
            return false;
          let value, done;
          while ({ value, done } = iterator.next()) {
            if (done)
              break;
            if (Object.is(v, value))
              return false;
            set3.add(value);
          }
        }
        return true;
      }
      function set2(values2) {
        return values2 instanceof Set ? values2 : new Set(values2);
      }
      function intersection(values2, ...others) {
        values2 = new Set(values2);
        others = others.map(set2);
        out:
          for (const value of values2) {
            for (const other of others) {
              if (!other.has(value)) {
                values2.delete(value);
                continue out;
              }
            }
          }
        return values2;
      }
      function superset(values2, other) {
        const iterator = values2[Symbol.iterator](), set3 = /* @__PURE__ */ new Set();
        for (const o of other) {
          if (set3.has(o))
            continue;
          let value, done;
          while ({ value, done } = iterator.next()) {
            if (done)
              return false;
            set3.add(value);
            if (Object.is(o, value))
              break;
          }
        }
        return true;
      }
      function subset(values2, other) {
        return superset(other, values2);
      }
      function union(...others) {
        const set3 = /* @__PURE__ */ new Set();
        for (const other of others) {
          for (const o of other) {
            set3.add(o);
          }
        }
        return set3;
      }
      exports2.Adder = Adder;
      exports2.InternMap = InternMap;
      exports2.InternSet = InternSet;
      exports2.ascending = ascending;
      exports2.bin = bin;
      exports2.bisect = bisectRight;
      exports2.bisectCenter = bisectCenter;
      exports2.bisectLeft = bisectLeft;
      exports2.bisectRight = bisectRight;
      exports2.bisector = bisector;
      exports2.count = count2;
      exports2.cross = cross;
      exports2.cumsum = cumsum;
      exports2.descending = descending;
      exports2.deviation = deviation;
      exports2.difference = difference;
      exports2.disjoint = disjoint;
      exports2.every = every;
      exports2.extent = extent;
      exports2.fcumsum = fcumsum;
      exports2.filter = filter2;
      exports2.fsum = fsum;
      exports2.greatest = greatest;
      exports2.greatestIndex = greatestIndex;
      exports2.group = group;
      exports2.groupSort = groupSort;
      exports2.groups = groups;
      exports2.histogram = bin;
      exports2.index = index2;
      exports2.indexes = indexes;
      exports2.intersection = intersection;
      exports2.least = least;
      exports2.leastIndex = leastIndex;
      exports2.map = map;
      exports2.max = max;
      exports2.maxIndex = maxIndex;
      exports2.mean = mean;
      exports2.median = median;
      exports2.merge = merge3;
      exports2.min = min;
      exports2.minIndex = minIndex;
      exports2.nice = nice;
      exports2.pairs = pairs;
      exports2.permute = permute;
      exports2.quantile = quantile;
      exports2.quantileSorted = quantileSorted;
      exports2.quickselect = quickselect;
      exports2.range = range;
      exports2.reduce = reduce2;
      exports2.reverse = reverse;
      exports2.rollup = rollup;
      exports2.rollups = rollups;
      exports2.scan = scan;
      exports2.shuffle = shuffle;
      exports2.shuffler = shuffler;
      exports2.some = some;
      exports2.sort = sort;
      exports2.subset = subset;
      exports2.sum = sum;
      exports2.superset = superset;
      exports2.thresholdFreedmanDiaconis = freedmanDiaconis;
      exports2.thresholdScott = scott;
      exports2.thresholdSturges = sturges;
      exports2.tickIncrement = tickIncrement;
      exports2.tickStep = tickStep;
      exports2.ticks = ticks;
      exports2.transpose = transpose;
      exports2.union = union;
      exports2.variance = variance;
      exports2.zip = zip;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-geo/dist/d3-geo.js
var require_d3_geo = __commonJS({
  "node_modules/d3-geo/dist/d3-geo.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_d3_array()) : typeof define === "function" && define.amd ? define(["exports", "d3-array"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
    })(exports, function(exports2, d3Array) {
      "use strict";
      var epsilon = 1e-6;
      var epsilon2 = 1e-12;
      var pi = Math.PI;
      var halfPi = pi / 2;
      var quarterPi = pi / 4;
      var tau = pi * 2;
      var degrees = 180 / pi;
      var radians = pi / 180;
      var abs = Math.abs;
      var atan = Math.atan;
      var atan2 = Math.atan2;
      var cos = Math.cos;
      var ceil = Math.ceil;
      var exp = Math.exp;
      var hypot = Math.hypot;
      var log3 = Math.log;
      var pow = Math.pow;
      var sin = Math.sin;
      var sign = Math.sign || function(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      };
      var sqrt = Math.sqrt;
      var tan = Math.tan;
      function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
      }
      function asin(x) {
        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
      }
      function haversin(x) {
        return (x = sin(x / 2)) * x;
      }
      function noop8() {
      }
      function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
          streamGeometryType[geometry.type](geometry, stream);
        }
      }
      var streamObjectType = {
        Feature: function(object2, stream) {
          streamGeometry(object2.geometry, stream);
        },
        FeatureCollection: function(object2, stream) {
          var features = object2.features, i = -1, n2 = features.length;
          while (++i < n2)
            streamGeometry(features[i].geometry, stream);
        }
      };
      var streamGeometryType = {
        Sphere: function(object2, stream) {
          stream.sphere();
        },
        Point: function(object2, stream) {
          object2 = object2.coordinates;
          stream.point(object2[0], object2[1], object2[2]);
        },
        MultiPoint: function(object2, stream) {
          var coordinates2 = object2.coordinates, i = -1, n2 = coordinates2.length;
          while (++i < n2)
            object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
        },
        LineString: function(object2, stream) {
          streamLine(object2.coordinates, stream, 0);
        },
        MultiLineString: function(object2, stream) {
          var coordinates2 = object2.coordinates, i = -1, n2 = coordinates2.length;
          while (++i < n2)
            streamLine(coordinates2[i], stream, 0);
        },
        Polygon: function(object2, stream) {
          streamPolygon(object2.coordinates, stream);
        },
        MultiPolygon: function(object2, stream) {
          var coordinates2 = object2.coordinates, i = -1, n2 = coordinates2.length;
          while (++i < n2)
            streamPolygon(coordinates2[i], stream);
        },
        GeometryCollection: function(object2, stream) {
          var geometries = object2.geometries, i = -1, n2 = geometries.length;
          while (++i < n2)
            streamGeometry(geometries[i], stream);
        }
      };
      function streamLine(coordinates2, stream, closed) {
        var i = -1, n2 = coordinates2.length - closed, coordinate;
        stream.lineStart();
        while (++i < n2)
          coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
        stream.lineEnd();
      }
      function streamPolygon(coordinates2, stream) {
        var i = -1, n2 = coordinates2.length;
        stream.polygonStart();
        while (++i < n2)
          streamLine(coordinates2[i], stream, 1);
        stream.polygonEnd();
      }
      function geoStream(object2, stream) {
        if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
          streamObjectType[object2.type](object2, stream);
        } else {
          streamGeometry(object2, stream);
        }
      }
      var areaRingSum = new d3Array.Adder();
      var areaSum = new d3Array.Adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;
      var areaStream = {
        point: noop8,
        lineStart: noop8,
        lineEnd: noop8,
        polygonStart: function() {
          areaRingSum = new d3Array.Adder();
          areaStream.lineStart = areaRingStart;
          areaStream.lineEnd = areaRingEnd;
        },
        polygonEnd: function() {
          var areaRing = +areaRingSum;
          areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
          this.lineStart = this.lineEnd = this.point = noop8;
        },
        sphere: function() {
          areaSum.add(tau);
        }
      };
      function areaRingStart() {
        areaStream.point = areaPointFirst;
      }
      function areaRingEnd() {
        areaPoint(lambda00, phi00);
      }
      function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint;
        lambda00 = lambda, phi00 = phi;
        lambda *= radians, phi *= radians;
        lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
      }
      function areaPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        phi = phi / 2 + quarterPi;
        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);
        areaRingSum.add(atan2(v, u));
        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
      }
      function area(object2) {
        areaSum = new d3Array.Adder();
        geoStream(object2, areaStream);
        return areaSum * 2;
      }
      function spherical(cartesian2) {
        return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
      }
      function cartesian(spherical2) {
        var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
        return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
      }
      function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2];
      }
      function cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function cartesianNormalizeInPlace(d2) {
        var l2 = sqrt(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
        d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
      }
      var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum, ranges, range;
      var boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function() {
          boundsStream.point = boundsRingPoint;
          boundsStream.lineStart = boundsRingStart;
          boundsStream.lineEnd = boundsRingEnd;
          deltaSum = new d3Array.Adder();
          areaStream.polygonStart();
        },
        polygonEnd: function() {
          areaStream.polygonEnd();
          boundsStream.point = boundsPoint;
          boundsStream.lineStart = boundsLineStart;
          boundsStream.lineEnd = boundsLineEnd;
          if (areaRingSum < 0)
            lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
          else if (deltaSum > epsilon)
            phi1 = 90;
          else if (deltaSum < -epsilon)
            phi0 = -90;
          range[0] = lambda0$1, range[1] = lambda1;
        },
        sphere: function() {
          lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        }
      };
      function boundsPoint(lambda, phi) {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
        if (phi < phi0)
          phi0 = phi;
        if (phi > phi1)
          phi1 = phi;
      }
      function linePoint(lambda, phi) {
        var p2 = cartesian([lambda * radians, phi * radians]);
        if (p0) {
          var normal = cartesianCross(p0, p2), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
          cartesianNormalizeInPlace(inflection);
          inflection = spherical(inflection);
          var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs(delta) > 180;
          if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
            phii = inflection[1] * degrees;
            if (phii > phi1)
              phi1 = phii;
          } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
            phii = -inflection[1] * degrees;
            if (phii < phi0)
              phi0 = phii;
          } else {
            if (phi < phi0)
              phi0 = phi;
            if (phi > phi1)
              phi1 = phi;
          }
          if (antimeridian) {
            if (lambda < lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                lambda0$1 = lambda;
            }
          } else {
            if (lambda1 >= lambda0$1) {
              if (lambda < lambda0$1)
                lambda0$1 = lambda;
              if (lambda > lambda1)
                lambda1 = lambda;
            } else {
              if (lambda > lambda2) {
                if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                  lambda1 = lambda;
              } else {
                if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                  lambda0$1 = lambda;
              }
            }
          }
        } else {
          ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
        }
        if (phi < phi0)
          phi0 = phi;
        if (phi > phi1)
          phi1 = phi;
        p0 = p2, lambda2 = lambda;
      }
      function boundsLineStart() {
        boundsStream.point = linePoint;
      }
      function boundsLineEnd() {
        range[0] = lambda0$1, range[1] = lambda1;
        boundsStream.point = boundsPoint;
        p0 = null;
      }
      function boundsRingPoint(lambda, phi) {
        if (p0) {
          var delta = lambda - lambda2;
          deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
        } else {
          lambda00$1 = lambda, phi00$1 = phi;
        }
        areaStream.point(lambda, phi);
        linePoint(lambda, phi);
      }
      function boundsRingStart() {
        areaStream.lineStart();
      }
      function boundsRingEnd() {
        boundsRingPoint(lambda00$1, phi00$1);
        areaStream.lineEnd();
        if (abs(deltaSum) > epsilon)
          lambda0$1 = -(lambda1 = 180);
        range[0] = lambda0$1, range[1] = lambda1;
        p0 = null;
      }
      function angle(lambda02, lambda12) {
        return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
      }
      function rangeCompare(a, b) {
        return a[0] - b[0];
      }
      function rangeContains(range2, x) {
        return range2[0] <= range2[1] ? range2[0] <= x && x <= range2[1] : x < range2[0] || range2[1] < x;
      }
      function bounds(feature) {
        var i, n2, a, b, merged, deltaMax, delta;
        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
        ranges = [];
        geoStream(feature, boundsStream);
        if (n2 = ranges.length) {
          ranges.sort(rangeCompare);
          for (i = 1, a = ranges[0], merged = [a]; i < n2; ++i) {
            b = ranges[i];
            if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
              if (angle(a[0], b[1]) > angle(a[0], a[1]))
                a[1] = b[1];
              if (angle(b[0], a[1]) > angle(a[0], a[1]))
                a[0] = b[0];
            } else {
              merged.push(a = b);
            }
          }
          for (deltaMax = -Infinity, n2 = merged.length - 1, i = 0, a = merged[n2]; i <= n2; a = b, ++i) {
            b = merged[i];
            if ((delta = angle(a[1], b[0])) > deltaMax)
              deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
          }
        }
        ranges = range = null;
        return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
      }
      var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, x0, y0, z0;
      var centroidStream = {
        sphere: noop8,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function() {
          centroidStream.lineStart = centroidRingStart;
          centroidStream.lineEnd = centroidRingEnd;
        },
        polygonEnd: function() {
          centroidStream.lineStart = centroidLineStart;
          centroidStream.lineEnd = centroidLineEnd;
        }
      };
      function centroidPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
      }
      function centroidPointCartesian(x, y, z) {
        ++W0;
        X0 += (x - X0) / W0;
        Y0 += (y - Y0) / W0;
        Z0 += (z - Z0) / W0;
      }
      function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst;
      }
      function centroidLinePointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda);
        y0 = cosPhi * sin(lambda);
        z0 = sin(phi);
        centroidStream.point = centroidLinePoint;
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidLinePoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w2 = atan2(sqrt((w2 = y0 * z - z0 * y) * w2 + (w2 = z0 * x - x0 * z) * w2 + (w2 = x0 * y - y0 * x) * w2), x0 * x + y0 * y + z0 * z);
        W1 += w2;
        X1 += w2 * (x0 + (x0 = x));
        Y1 += w2 * (y0 + (y0 = y));
        Z1 += w2 * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidLineEnd() {
        centroidStream.point = centroidPoint;
      }
      function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst;
      }
      function centroidRingEnd() {
        centroidRingPoint(lambda00$2, phi00$2);
        centroidStream.point = centroidPoint;
      }
      function centroidRingPointFirst(lambda, phi) {
        lambda00$2 = lambda, phi00$2 = phi;
        lambda *= radians, phi *= radians;
        centroidStream.point = centroidRingPoint;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda);
        y0 = cosPhi * sin(lambda);
        z0 = sin(phi);
        centroidPointCartesian(x0, y0, z0);
      }
      function centroidRingPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = hypot(cx, cy, cz), w2 = asin(m), v = m && -w2 / m;
        X2.add(v * cx);
        Y2.add(v * cy);
        Z2.add(v * cz);
        W1 += w2;
        X1 += w2 * (x0 + (x0 = x));
        Y1 += w2 * (y0 + (y0 = y));
        Z1 += w2 * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
      }
      function centroid(object2) {
        W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
        X2 = new d3Array.Adder();
        Y2 = new d3Array.Adder();
        Z2 = new d3Array.Adder();
        geoStream(object2, centroidStream);
        var x = +X2, y = +Y2, z = +Z2, m = hypot(x, y, z);
        if (m < epsilon2) {
          x = X1, y = Y1, z = Z1;
          if (W1 < epsilon)
            x = X0, y = Y0, z = Z0;
          m = hypot(x, y, z);
          if (m < epsilon2)
            return [NaN, NaN];
        }
        return [atan2(y, x) * degrees, asin(z / m) * degrees];
      }
      function constant(x) {
        return function() {
          return x;
        };
      }
      function compose2(a, b) {
        function compose3(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
          compose3.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
          };
        return compose3;
      }
      function rotationIdentity(lambda, phi) {
        return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
      }
      rotationIdentity.invert = rotationIdentity;
      function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose2(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
      }
      function forwardRotationLambda(deltaLambda) {
        return function(lambda, phi) {
          return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
        };
      }
      function rotationLambda(deltaLambda) {
        var rotation2 = forwardRotationLambda(deltaLambda);
        rotation2.invert = forwardRotationLambda(-deltaLambda);
        return rotation2;
      }
      function rotationPhiGamma(deltaPhi, deltaGamma) {
        var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
        function rotation2(lambda, phi) {
          var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
          return [
            atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
            asin(k * cosDeltaGamma + y * sinDeltaGamma)
          ];
        }
        rotation2.invert = function(lambda, phi) {
          var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
          return [
            atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
            asin(k * cosDeltaPhi - x * sinDeltaPhi)
          ];
        };
        return rotation2;
      }
      function rotation(rotate) {
        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
        function forward(coordinates2) {
          coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
          return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
        }
        forward.invert = function(coordinates2) {
          coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
          return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
        };
        return forward;
      }
      function circleStream(stream, radius, delta, direction, t0, t1) {
        if (!delta)
          return;
        var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
        if (t0 == null) {
          t0 = radius + direction * tau;
          t1 = radius - step / 2;
        } else {
          t0 = circleRadius(cosRadius, t0);
          t1 = circleRadius(cosRadius, t1);
          if (direction > 0 ? t0 < t1 : t0 > t1)
            t0 += direction * tau;
        }
        for (var point5, t2 = t0; direction > 0 ? t2 > t1 : t2 < t1; t2 -= step) {
          point5 = spherical([cosRadius, -sinRadius * cos(t2), -sinRadius * sin(t2)]);
          stream.point(point5[0], point5[1]);
        }
      }
      function circleRadius(cosRadius, point5) {
        point5 = cartesian(point5), point5[0] -= cosRadius;
        cartesianNormalizeInPlace(point5);
        var radius = acos(-point5[1]);
        return ((-point5[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
      }
      function circle() {
        var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point: point5 };
        function point5(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= degrees, x[1] *= degrees;
        }
        function circle2() {
          var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p2 = precision.apply(this, arguments) * radians;
          ring = [];
          rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
          circleStream(stream, r, p2, 1);
          c = { type: "Polygon", coordinates: [ring] };
          ring = rotate = null;
          return c;
        }
        circle2.center = function(_2) {
          return arguments.length ? (center = typeof _2 === "function" ? _2 : constant([+_2[0], +_2[1]]), circle2) : center;
        };
        circle2.radius = function(_2) {
          return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant(+_2), circle2) : radius;
        };
        circle2.precision = function(_2) {
          return arguments.length ? (precision = typeof _2 === "function" ? _2 : constant(+_2), circle2) : precision;
        };
        return circle2;
      }
      function clipBuffer() {
        var lines = [], line;
        return {
          point: function(x, y, m) {
            line.push([x, y, m]);
          },
          lineStart: function() {
            lines.push(line = []);
          },
          lineEnd: noop8,
          rejoin: function() {
            if (lines.length > 1)
              lines.push(lines.pop().concat(lines.shift()));
          },
          result: function() {
            var result = lines;
            lines = [];
            line = null;
            return result;
          }
        };
      }
      function pointEqual(a, b) {
        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
      }
      function Intersection(point5, points, other, entry) {
        this.x = point5;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
        var subject = [], clip4 = [], i, n2;
        segments.forEach(function(segment) {
          if ((n3 = segment.length - 1) <= 0)
            return;
          var n3, p02 = segment[0], p1 = segment[n3], x;
          if (pointEqual(p02, p1)) {
            if (!p02[2] && !p1[2]) {
              stream.lineStart();
              for (i = 0; i < n3; ++i)
                stream.point((p02 = segment[i])[0], p02[1]);
              stream.lineEnd();
              return;
            }
            p1[0] += 2 * epsilon;
          }
          subject.push(x = new Intersection(p02, segment, null, true));
          clip4.push(x.o = new Intersection(p02, null, x, false));
          subject.push(x = new Intersection(p1, segment, null, false));
          clip4.push(x.o = new Intersection(p1, null, x, true));
        });
        if (!subject.length)
          return;
        clip4.sort(compareIntersection2);
        link2(subject);
        link2(clip4);
        for (i = 0, n2 = clip4.length; i < n2; ++i) {
          clip4[i].e = startInside = !startInside;
        }
        var start3 = subject[0], points, point5;
        while (1) {
          var current = start3, isSubject = true;
          while (current.v)
            if ((current = current.n) === start3)
              return;
          points = current.z;
          stream.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (i = 0, n2 = points.length; i < n2; ++i)
                  stream.point((point5 = points[i])[0], point5[1]);
              } else {
                interpolate2(current.x, current.n.x, 1, stream);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (i = points.length - 1; i >= 0; --i)
                  stream.point((point5 = points[i])[0], point5[1]);
              } else {
                interpolate2(current.x, current.p.x, -1, stream);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          stream.lineEnd();
        }
      }
      function link2(array) {
        if (!(n2 = array.length))
          return;
        var n2, i = 0, a = array[0], b;
        while (++i < n2) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      function longitude(point5) {
        if (abs(point5[0]) <= pi)
          return point5[0];
        else
          return sign(point5[0]) * ((abs(point5[0]) + pi) % tau - pi);
      }
      function polygonContains(polygon, point5) {
        var lambda = longitude(point5), phi = point5[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
        var sum = new d3Array.Adder();
        if (sinPhi === 1)
          phi = halfPi + epsilon;
        else if (sinPhi === -1)
          phi = -halfPi - epsilon;
        for (var i = 0, n2 = polygon.length; i < n2; ++i) {
          if (!(m = (ring = polygon[i]).length))
            continue;
          var ring, m, point0 = ring[m - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin(phi02), cosPhi02 = cos(phi02);
          for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
            var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi02 * sinPhi1;
            sum.add(atan2(k * sign2 * sin(absDelta), cosPhi02 * cosPhi1 + k * cos(absDelta)));
            angle2 += antimeridian ? delta + sign2 * tau : delta;
            if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
              var arc2 = cartesianCross(cartesian(point0), cartesian(point1));
              cartesianNormalizeInPlace(arc2);
              var intersection = cartesianCross(normal, arc2);
              cartesianNormalizeInPlace(intersection);
              var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
              if (phi > phiArc || phi === phiArc && (arc2[0] || arc2[1])) {
                winding += antimeridian ^ delta >= 0 ? 1 : -1;
              }
            }
          }
        }
        return (angle2 < -epsilon || angle2 < epsilon && sum < -epsilon2) ^ winding & 1;
      }
      function clip3(pointVisible, clipLine2, interpolate2, start3) {
        return function(sink) {
          var line = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
          var clip4 = {
            point: point5,
            lineStart,
            lineEnd,
            polygonStart: function() {
              clip4.point = pointRing;
              clip4.lineStart = ringStart;
              clip4.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function() {
              clip4.point = point5;
              clip4.lineStart = lineStart;
              clip4.lineEnd = lineEnd;
              segments = d3Array.merge(segments);
              var startInside = polygonContains(polygon, start3);
              if (segments.length) {
                if (!polygonStarted)
                  sink.polygonStart(), polygonStarted = true;
                clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
              } else if (startInside) {
                if (!polygonStarted)
                  sink.polygonStart(), polygonStarted = true;
                sink.lineStart();
                interpolate2(null, null, 1, sink);
                sink.lineEnd();
              }
              if (polygonStarted)
                sink.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function() {
              sink.polygonStart();
              sink.lineStart();
              interpolate2(null, null, 1, sink);
              sink.lineEnd();
              sink.polygonEnd();
            }
          };
          function point5(lambda, phi) {
            if (pointVisible(lambda, phi))
              sink.point(lambda, phi);
          }
          function pointLine(lambda, phi) {
            line.point(lambda, phi);
          }
          function lineStart() {
            clip4.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip4.point = point5;
            line.lineEnd();
          }
          function pointRing(lambda, phi) {
            ring.push([lambda, phi]);
            ringSink.point(lambda, phi);
          }
          function ringStart() {
            ringSink.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringSink.lineEnd();
            var clean5 = ringSink.clean(), ringSegments = ringBuffer.result(), i, n2 = ringSegments.length, m, segment, point6;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n2)
              return;
            if (clean5 & 1) {
              segment = ringSegments[0];
              if ((m = segment.length - 1) > 0) {
                if (!polygonStarted)
                  sink.polygonStart(), polygonStarted = true;
                sink.lineStart();
                for (i = 0; i < m; ++i)
                  sink.point((point6 = segment[i])[0], point6[1]);
                sink.lineEnd();
              }
              return;
            }
            if (n2 > 1 && clean5 & 2)
              ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(validSegment));
          }
          return clip4;
        };
      }
      function validSegment(segment) {
        return segment.length > 1;
      }
      function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
      }
      var clipAntimeridian = clip3(function() {
        return true;
      }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);
      function clipAntimeridianLine(stream) {
        var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean5;
        return {
          lineStart: function() {
            stream.lineStart();
            clean5 = 1;
          },
          point: function(lambda12, phi12) {
            var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda02);
            if (abs(delta - pi) < epsilon) {
              stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
              stream.point(sign0, phi02);
              stream.lineEnd();
              stream.lineStart();
              stream.point(sign1, phi02);
              stream.point(lambda12, phi02);
              clean5 = 0;
            } else if (sign0 !== sign1 && delta >= pi) {
              if (abs(lambda02 - sign0) < epsilon)
                lambda02 -= sign0 * epsilon;
              if (abs(lambda12 - sign1) < epsilon)
                lambda12 -= sign1 * epsilon;
              phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
              stream.point(sign0, phi02);
              stream.lineEnd();
              stream.lineStart();
              stream.point(sign1, phi02);
              clean5 = 0;
            }
            stream.point(lambda02 = lambda12, phi02 = phi12);
            sign0 = sign1;
          },
          lineEnd: function() {
            stream.lineEnd();
            lambda02 = phi02 = NaN;
          },
          clean: function() {
            return 2 - clean5;
          }
        };
      }
      function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
        var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin(lambda02 - lambda12);
        return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi02 = cos(phi02)) * sin(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
      }
      function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi;
        if (from == null) {
          phi = direction * halfPi;
          stream.point(-pi, phi);
          stream.point(0, phi);
          stream.point(pi, phi);
          stream.point(pi, 0);
          stream.point(pi, -phi);
          stream.point(0, -phi);
          stream.point(-pi, -phi);
          stream.point(-pi, 0);
          stream.point(-pi, phi);
        } else if (abs(from[0] - to[0]) > epsilon) {
          var lambda = from[0] < to[0] ? pi : -pi;
          phi = direction * lambda / 2;
          stream.point(-lambda, phi);
          stream.point(0, phi);
          stream.point(lambda, phi);
        } else {
          stream.point(to[0], to[1]);
        }
      }
      function clipCircle(radius) {
        var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
        function interpolate2(from, to, direction, stream) {
          circleStream(stream, radius, delta, direction, from, to);
        }
        function visible(lambda, phi) {
          return cos(lambda) * cos(phi) > cr;
        }
        function clipLine2(stream) {
          var point0, c0, v0, v00, clean5;
          return {
            lineStart: function() {
              v00 = v0 = false;
              clean5 = 1;
            },
            point: function(lambda, phi) {
              var point1 = [lambda, phi], point22, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code2(lambda, phi) : v ? code2(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
              if (!point0 && (v00 = v0 = v))
                stream.lineStart();
              if (v !== v0) {
                point22 = intersect(point0, point1);
                if (!point22 || pointEqual(point0, point22) || pointEqual(point1, point22))
                  point1[2] = 1;
              }
              if (v !== v0) {
                clean5 = 0;
                if (v) {
                  stream.lineStart();
                  point22 = intersect(point1, point0);
                  stream.point(point22[0], point22[1]);
                } else {
                  point22 = intersect(point0, point1);
                  stream.point(point22[0], point22[1], 2);
                  stream.lineEnd();
                }
                point0 = point22;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t2;
                if (!(c & c0) && (t2 = intersect(point1, point0, true))) {
                  clean5 = 0;
                  if (smallRadius) {
                    stream.lineStart();
                    stream.point(t2[0][0], t2[0][1]);
                    stream.point(t2[1][0], t2[1][1]);
                    stream.lineEnd();
                  } else {
                    stream.point(t2[1][0], t2[1][1]);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(t2[0][0], t2[0][1], 3);
                  }
                }
              }
              if (v && (!point0 || !pointEqual(point0, point1))) {
                stream.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function() {
              if (v0)
                stream.lineEnd();
              point0 = null;
            },
            clean: function() {
              return clean5 | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = cartesian(a), pb = cartesian(b);
          var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
          if (!determinant)
            return !two && a;
          var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
          cartesianAddInPlace(A, B);
          var u = n1xn2, w2 = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w2 * w2 - uu * (cartesianDot(A, A) - 1);
          if (t2 < 0)
            return;
          var t3 = sqrt(t2), q = cartesianScale(u, (-w2 - t3) / uu);
          cartesianAddInPlace(q, A);
          q = spherical(q);
          if (!two)
            return q;
          var lambda02 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
          if (lambda12 < lambda02)
            z = lambda02, lambda02 = lambda12, lambda12 = z;
          var delta2 = lambda12 - lambda02, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
          if (!polar && phi12 < phi02)
            z = phi02, phi02 = phi12, phi12 = z;
          if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda02) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
            var q1 = cartesianScale(u, (-w2 + t3) / uu);
            cartesianAddInPlace(q1, A);
            return [q, spherical(q1)];
          }
        }
        function code2(lambda, phi) {
          var r = smallRadius ? radius : pi - radius, code3 = 0;
          if (lambda < -r)
            code3 |= 1;
          else if (lambda > r)
            code3 |= 2;
          if (phi < -r)
            code3 |= 4;
          else if (phi > r)
            code3 |= 8;
          return code3;
        }
        return clip3(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi, radius - pi]);
      }
      function clipLine(a, b, x02, y02, x12, y12) {
        var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
        r = x02 - ax;
        if (!dx && r > 0)
          return;
        r /= dx;
        if (dx < 0) {
          if (r < t0)
            return;
          if (r < t1)
            t1 = r;
        } else if (dx > 0) {
          if (r > t1)
            return;
          if (r > t0)
            t0 = r;
        }
        r = x12 - ax;
        if (!dx && r < 0)
          return;
        r /= dx;
        if (dx < 0) {
          if (r > t1)
            return;
          if (r > t0)
            t0 = r;
        } else if (dx > 0) {
          if (r < t0)
            return;
          if (r < t1)
            t1 = r;
        }
        r = y02 - ay;
        if (!dy && r > 0)
          return;
        r /= dy;
        if (dy < 0) {
          if (r < t0)
            return;
          if (r < t1)
            t1 = r;
        } else if (dy > 0) {
          if (r > t1)
            return;
          if (r > t0)
            t0 = r;
        }
        r = y12 - ay;
        if (!dy && r < 0)
          return;
        r /= dy;
        if (dy < 0) {
          if (r > t1)
            return;
          if (r > t0)
            t0 = r;
        } else if (dy > 0) {
          if (r < t0)
            return;
          if (r < t1)
            t1 = r;
        }
        if (t0 > 0)
          a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
        if (t1 < 1)
          b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
        return true;
      }
      var clipMax = 1e9, clipMin = -clipMax;
      function clipRectangle(x02, y02, x12, y12) {
        function visible(x, y) {
          return x02 <= x && x <= x12 && y02 <= y && y <= y12;
        }
        function interpolate2(from, to, direction, stream) {
          var a = 0, a1 = 0;
          if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
            do
              stream.point(a === 0 || a === 3 ? x02 : x12, a > 1 ? y12 : y02);
            while ((a = (a + direction + 4) % 4) !== a1);
          } else {
            stream.point(to[0], to[1]);
          }
        }
        function corner(p2, direction) {
          return abs(p2[0] - x02) < epsilon ? direction > 0 ? 0 : 3 : abs(p2[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p2[1] - y02) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compareIntersection2(a, b) {
          return comparePoint(a.x, b.x);
        }
        function comparePoint(a, b) {
          var ca = corner(a, 1), cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
        return function(stream) {
          var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean5;
          var clipStream = {
            point: point5,
            lineStart,
            lineEnd,
            polygonStart,
            polygonEnd
          };
          function point5(x, y) {
            if (visible(x, y))
              activeStream.point(x, y);
          }
          function polygonInside() {
            var winding = 0;
            for (var i = 0, n2 = polygon.length; i < n2; ++i) {
              for (var ring2 = polygon[i], j = 1, m = ring2.length, point6 = ring2[0], a0, a1, b0 = point6[0], b1 = point6[1]; j < m; ++j) {
                a0 = b0, a1 = b1, point6 = ring2[j], b0 = point6[0], b1 = point6[1];
                if (a1 <= y12) {
                  if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                    ++winding;
                } else {
                  if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                    --winding;
                }
              }
            }
            return winding;
          }
          function polygonStart() {
            activeStream = bufferStream, segments = [], polygon = [], clean5 = true;
          }
          function polygonEnd() {
            var startInside = polygonInside(), cleanInside = clean5 && startInside, visible2 = (segments = d3Array.merge(segments)).length;
            if (cleanInside || visible2) {
              stream.polygonStart();
              if (cleanInside) {
                stream.lineStart();
                interpolate2(null, null, 1, stream);
                stream.lineEnd();
              }
              if (visible2) {
                clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
              }
              stream.polygonEnd();
            }
            activeStream = stream, segments = polygon = ring = null;
          }
          function lineStart() {
            clipStream.point = linePoint2;
            if (polygon)
              polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint2(x__, y__);
              if (v__ && v_)
                bufferStream.rejoin();
              segments.push(bufferStream.result());
            }
            clipStream.point = point5;
            if (v_)
              activeStream.lineEnd();
          }
          function linePoint2(x, y) {
            var v = visible(x, y);
            if (polygon)
              ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
              }
            } else {
              if (v && v_)
                activeStream.point(x, y);
              else {
                var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                if (clipLine(a, b, x02, y02, x12, y12)) {
                  if (!v_) {
                    activeStream.lineStart();
                    activeStream.point(a[0], a[1]);
                  }
                  activeStream.point(b[0], b[1]);
                  if (!v)
                    activeStream.lineEnd();
                  clean5 = false;
                } else if (v) {
                  activeStream.lineStart();
                  activeStream.point(x, y);
                  clean5 = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clipStream;
        };
      }
      function extent() {
        var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip4;
        return clip4 = {
          stream: function(stream) {
            return cache && cacheStream === stream ? cache : cache = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
          },
          extent: function(_2) {
            return arguments.length ? (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1], cache = cacheStream = null, clip4) : [[x02, y02], [x12, y12]];
          }
        };
      }
      var lengthSum, lambda0$2, sinPhi0$1, cosPhi0$1;
      var lengthStream = {
        sphere: noop8,
        point: noop8,
        lineStart: lengthLineStart,
        lineEnd: noop8,
        polygonStart: noop8,
        polygonEnd: noop8
      };
      function lengthLineStart() {
        lengthStream.point = lengthPointFirst;
        lengthStream.lineEnd = lengthLineEnd;
      }
      function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = noop8;
      }
      function lengthPointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
        lengthStream.point = lengthPoint;
      }
      function lengthPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
        lengthSum.add(atan2(sqrt(x * x + y * y), z));
        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
      }
      function length(object2) {
        lengthSum = new d3Array.Adder();
        geoStream(object2, lengthStream);
        return +lengthSum;
      }
      var coordinates = [null, null], object = { type: "LineString", coordinates };
      function distance3(a, b) {
        coordinates[0] = a;
        coordinates[1] = b;
        return length(object);
      }
      var containsObjectType = {
        Feature: function(object2, point5) {
          return containsGeometry(object2.geometry, point5);
        },
        FeatureCollection: function(object2, point5) {
          var features = object2.features, i = -1, n2 = features.length;
          while (++i < n2)
            if (containsGeometry(features[i].geometry, point5))
              return true;
          return false;
        }
      };
      var containsGeometryType = {
        Sphere: function() {
          return true;
        },
        Point: function(object2, point5) {
          return containsPoint(object2.coordinates, point5);
        },
        MultiPoint: function(object2, point5) {
          var coordinates2 = object2.coordinates, i = -1, n2 = coordinates2.length;
          while (++i < n2)
            if (containsPoint(coordinates2[i], point5))
              return true;
          return false;
        },
        LineString: function(object2, point5) {
          return containsLine(object2.coordinates, point5);
        },
        MultiLineString: function(object2, point5) {
          var coordinates2 = object2.coordinates, i = -1, n2 = coordinates2.length;
          while (++i < n2)
            if (containsLine(coordinates2[i], point5))
              return true;
          return false;
        },
        Polygon: function(object2, point5) {
          return containsPolygon(object2.coordinates, point5);
        },
        MultiPolygon: function(object2, point5) {
          var coordinates2 = object2.coordinates, i = -1, n2 = coordinates2.length;
          while (++i < n2)
            if (containsPolygon(coordinates2[i], point5))
              return true;
          return false;
        },
        GeometryCollection: function(object2, point5) {
          var geometries = object2.geometries, i = -1, n2 = geometries.length;
          while (++i < n2)
            if (containsGeometry(geometries[i], point5))
              return true;
          return false;
        }
      };
      function containsGeometry(geometry, point5) {
        return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point5) : false;
      }
      function containsPoint(coordinates2, point5) {
        return distance3(coordinates2, point5) === 0;
      }
      function containsLine(coordinates2, point5) {
        var ao, bo, ab;
        for (var i = 0, n2 = coordinates2.length; i < n2; i++) {
          bo = distance3(coordinates2[i], point5);
          if (bo === 0)
            return true;
          if (i > 0) {
            ab = distance3(coordinates2[i], coordinates2[i - 1]);
            if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)
              return true;
          }
          ao = bo;
        }
        return false;
      }
      function containsPolygon(coordinates2, point5) {
        return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point5));
      }
      function ringRadians(ring) {
        return ring = ring.map(pointRadians), ring.pop(), ring;
      }
      function pointRadians(point5) {
        return [point5[0] * radians, point5[1] * radians];
      }
      function contains(object2, point5) {
        return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point5);
      }
      function graticuleX(y02, y12, dy) {
        var y = d3Array.range(y02, y12 - epsilon, dy).concat(y12);
        return function(x) {
          return y.map(function(y2) {
            return [x, y2];
          });
        };
      }
      function graticuleY(x02, x12, dx) {
        var x = d3Array.range(x02, x12 - epsilon, dx).concat(x12);
        return function(y) {
          return x.map(function(x2) {
            return [x2, y];
          });
        };
      }
      function graticule() {
        var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule2() {
          return { type: "MultiLineString", coordinates: lines() };
        }
        function lines() {
          return d3Array.range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(d3Array.range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(d3Array.range(ceil(x02 / dx) * dx, x12, dx).filter(function(x2) {
            return abs(x2 % DX) > epsilon;
          }).map(x)).concat(d3Array.range(ceil(y02 / dy) * dy, y12, dy).filter(function(y2) {
            return abs(y2 % DY) > epsilon;
          }).map(y));
        }
        graticule2.lines = function() {
          return lines().map(function(coordinates2) {
            return { type: "LineString", coordinates: coordinates2 };
          });
        };
        graticule2.outline = function() {
          return {
            type: "Polygon",
            coordinates: [
              X(X02).concat(Y(Y12).slice(1), X(X12).reverse().slice(1), Y(Y02).reverse().slice(1))
            ]
          };
        };
        graticule2.extent = function(_2) {
          if (!arguments.length)
            return graticule2.extentMinor();
          return graticule2.extentMajor(_2).extentMinor(_2);
        };
        graticule2.extentMajor = function(_2) {
          if (!arguments.length)
            return [[X02, Y02], [X12, Y12]];
          X02 = +_2[0][0], X12 = +_2[1][0];
          Y02 = +_2[0][1], Y12 = +_2[1][1];
          if (X02 > X12)
            _2 = X02, X02 = X12, X12 = _2;
          if (Y02 > Y12)
            _2 = Y02, Y02 = Y12, Y12 = _2;
          return graticule2.precision(precision);
        };
        graticule2.extentMinor = function(_2) {
          if (!arguments.length)
            return [[x02, y02], [x12, y12]];
          x02 = +_2[0][0], x12 = +_2[1][0];
          y02 = +_2[0][1], y12 = +_2[1][1];
          if (x02 > x12)
            _2 = x02, x02 = x12, x12 = _2;
          if (y02 > y12)
            _2 = y02, y02 = y12, y12 = _2;
          return graticule2.precision(precision);
        };
        graticule2.step = function(_2) {
          if (!arguments.length)
            return graticule2.stepMinor();
          return graticule2.stepMajor(_2).stepMinor(_2);
        };
        graticule2.stepMajor = function(_2) {
          if (!arguments.length)
            return [DX, DY];
          DX = +_2[0], DY = +_2[1];
          return graticule2;
        };
        graticule2.stepMinor = function(_2) {
          if (!arguments.length)
            return [dx, dy];
          dx = +_2[0], dy = +_2[1];
          return graticule2;
        };
        graticule2.precision = function(_2) {
          if (!arguments.length)
            return precision;
          precision = +_2;
          x = graticuleX(y02, y12, 90);
          y = graticuleY(x02, x12, precision);
          X = graticuleX(Y02, Y12, 90);
          Y = graticuleY(X02, X12, precision);
          return graticule2;
        };
        return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
      }
      function graticule10() {
        return graticule()();
      }
      function interpolate(a, b) {
        var x02 = a[0] * radians, y02 = a[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos(y02), sy0 = sin(y02), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x02), ky0 = cy0 * sin(x02), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d2 = 2 * asin(sqrt(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k = sin(d2);
        var interpolate2 = d2 ? function(t2) {
          var B = sin(t2 *= d2) / k, A = sin(d2 - t2) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
          return [
            atan2(y, x) * degrees,
            atan2(z, sqrt(x * x + y * y)) * degrees
          ];
        } : function() {
          return [x02 * degrees, y02 * degrees];
        };
        interpolate2.distance = d2;
        return interpolate2;
      }
      var identity = (x) => x;
      var areaSum$1 = new d3Array.Adder(), areaRingSum$1 = new d3Array.Adder(), x00, y00, x0$1, y0$1;
      var areaStream$1 = {
        point: noop8,
        lineStart: noop8,
        lineEnd: noop8,
        polygonStart: function() {
          areaStream$1.lineStart = areaRingStart$1;
          areaStream$1.lineEnd = areaRingEnd$1;
        },
        polygonEnd: function() {
          areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop8;
          areaSum$1.add(abs(areaRingSum$1));
          areaRingSum$1 = new d3Array.Adder();
        },
        result: function() {
          var area2 = areaSum$1 / 2;
          areaSum$1 = new d3Array.Adder();
          return area2;
        }
      };
      function areaRingStart$1() {
        areaStream$1.point = areaPointFirst$1;
      }
      function areaPointFirst$1(x, y) {
        areaStream$1.point = areaPoint$1;
        x00 = x0$1 = x, y00 = y0$1 = y;
      }
      function areaPoint$1(x, y) {
        areaRingSum$1.add(y0$1 * x - x0$1 * y);
        x0$1 = x, y0$1 = y;
      }
      function areaRingEnd$1() {
        areaPoint$1(x00, y00);
      }
      var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
      var boundsStream$1 = {
        point: boundsPoint$1,
        lineStart: noop8,
        lineEnd: noop8,
        polygonStart: noop8,
        polygonEnd: noop8,
        result: function() {
          var bounds2 = [[x0$2, y0$2], [x1, y1]];
          x1 = y1 = -(y0$2 = x0$2 = Infinity);
          return bounds2;
        }
      };
      function boundsPoint$1(x, y) {
        if (x < x0$2)
          x0$2 = x;
        if (x > x1)
          x1 = x;
        if (y < y0$2)
          y0$2 = y;
        if (y > y1)
          y1 = y;
      }
      var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;
      var centroidStream$1 = {
        point: centroidPoint$1,
        lineStart: centroidLineStart$1,
        lineEnd: centroidLineEnd$1,
        polygonStart: function() {
          centroidStream$1.lineStart = centroidRingStart$1;
          centroidStream$1.lineEnd = centroidRingEnd$1;
        },
        polygonEnd: function() {
          centroidStream$1.point = centroidPoint$1;
          centroidStream$1.lineStart = centroidLineStart$1;
          centroidStream$1.lineEnd = centroidLineEnd$1;
        },
        result: function() {
          var centroid2 = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] : [NaN, NaN];
          X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
          return centroid2;
        }
      };
      function centroidPoint$1(x, y) {
        X0$1 += x;
        Y0$1 += y;
        ++Z0$1;
      }
      function centroidLineStart$1() {
        centroidStream$1.point = centroidPointFirstLine;
      }
      function centroidPointFirstLine(x, y) {
        centroidStream$1.point = centroidPointLine;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function centroidPointLine(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function centroidLineEnd$1() {
        centroidStream$1.point = centroidPoint$1;
      }
      function centroidRingStart$1() {
        centroidStream$1.point = centroidPointFirstRing;
      }
      function centroidRingEnd$1() {
        centroidPointRing(x00$1, y00$1);
      }
      function centroidPointFirstRing(x, y) {
        centroidStream$1.point = centroidPointRing;
        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
      }
      function centroidPointRing(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        z = y0$3 * x - x0$3 * y;
        X2$1 += z * (x0$3 + x);
        Y2$1 += z * (y0$3 + y);
        Z2$1 += z * 3;
        centroidPoint$1(x0$3 = x, y0$3 = y);
      }
      function PathContext(context) {
        this._context = context;
      }
      PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function(_2) {
          return this._radius = _2, this;
        },
        polygonStart: function() {
          this._line = 0;
        },
        polygonEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          if (this._line === 0)
            this._context.closePath();
          this._point = NaN;
        },
        point: function(x, y) {
          switch (this._point) {
            case 0: {
              this._context.moveTo(x, y);
              this._point = 1;
              break;
            }
            case 1: {
              this._context.lineTo(x, y);
              break;
            }
            default: {
              this._context.moveTo(x + this._radius, y);
              this._context.arc(x, y, this._radius, 0, tau);
              break;
            }
          }
        },
        result: noop8
      };
      var lengthSum$1 = new d3Array.Adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;
      var lengthStream$1 = {
        point: noop8,
        lineStart: function() {
          lengthStream$1.point = lengthPointFirst$1;
        },
        lineEnd: function() {
          if (lengthRing)
            lengthPoint$1(x00$2, y00$2);
          lengthStream$1.point = noop8;
        },
        polygonStart: function() {
          lengthRing = true;
        },
        polygonEnd: function() {
          lengthRing = null;
        },
        result: function() {
          var length2 = +lengthSum$1;
          lengthSum$1 = new d3Array.Adder();
          return length2;
        }
      };
      function lengthPointFirst$1(x, y) {
        lengthStream$1.point = lengthPoint$1;
        x00$2 = x0$4 = x, y00$2 = y0$4 = y;
      }
      function lengthPoint$1(x, y) {
        x0$4 -= x, y0$4 -= y;
        lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
        x0$4 = x, y0$4 = y;
      }
      function PathString() {
        this._string = [];
      }
      PathString.prototype = {
        _radius: 4.5,
        _circle: circle$1(4.5),
        pointRadius: function(_2) {
          if ((_2 = +_2) !== this._radius)
            this._radius = _2, this._circle = null;
          return this;
        },
        polygonStart: function() {
          this._line = 0;
        },
        polygonEnd: function() {
          this._line = NaN;
        },
        lineStart: function() {
          this._point = 0;
        },
        lineEnd: function() {
          if (this._line === 0)
            this._string.push("Z");
          this._point = NaN;
        },
        point: function(x, y) {
          switch (this._point) {
            case 0: {
              this._string.push("M", x, ",", y);
              this._point = 1;
              break;
            }
            case 1: {
              this._string.push("L", x, ",", y);
              break;
            }
            default: {
              if (this._circle == null)
                this._circle = circle$1(this._radius);
              this._string.push("M", x, ",", y, this._circle);
              break;
            }
          }
        },
        result: function() {
          if (this._string.length) {
            var result = this._string.join("");
            this._string = [];
            return result;
          } else {
            return null;
          }
        }
      };
      function circle$1(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      function index2(projection2, context) {
        var pointRadius = 4.5, projectionStream, contextStream;
        function path4(object2) {
          if (object2) {
            if (typeof pointRadius === "function")
              contextStream.pointRadius(+pointRadius.apply(this, arguments));
            geoStream(object2, projectionStream(contextStream));
          }
          return contextStream.result();
        }
        path4.area = function(object2) {
          geoStream(object2, projectionStream(areaStream$1));
          return areaStream$1.result();
        };
        path4.measure = function(object2) {
          geoStream(object2, projectionStream(lengthStream$1));
          return lengthStream$1.result();
        };
        path4.bounds = function(object2) {
          geoStream(object2, projectionStream(boundsStream$1));
          return boundsStream$1.result();
        };
        path4.centroid = function(object2) {
          geoStream(object2, projectionStream(centroidStream$1));
          return centroidStream$1.result();
        };
        path4.projection = function(_2) {
          return arguments.length ? (projectionStream = _2 == null ? (projection2 = null, identity) : (projection2 = _2).stream, path4) : projection2;
        };
        path4.context = function(_2) {
          if (!arguments.length)
            return context;
          contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
          if (typeof pointRadius !== "function")
            contextStream.pointRadius(pointRadius);
          return path4;
        };
        path4.pointRadius = function(_2) {
          if (!arguments.length)
            return pointRadius;
          pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
          return path4;
        };
        return path4.projection(projection2).context(context);
      }
      function transform(methods) {
        return {
          stream: transformer(methods)
        };
      }
      function transformer(methods) {
        return function(stream) {
          var s3 = new TransformStream();
          for (var key in methods)
            s3[key] = methods[key];
          s3.stream = stream;
          return s3;
        };
      }
      function TransformStream() {
      }
      TransformStream.prototype = {
        constructor: TransformStream,
        point: function(x, y) {
          this.stream.point(x, y);
        },
        sphere: function() {
          this.stream.sphere();
        },
        lineStart: function() {
          this.stream.lineStart();
        },
        lineEnd: function() {
          this.stream.lineEnd();
        },
        polygonStart: function() {
          this.stream.polygonStart();
        },
        polygonEnd: function() {
          this.stream.polygonEnd();
        }
      };
      function fit(projection2, fitBounds, object2) {
        var clip4 = projection2.clipExtent && projection2.clipExtent();
        projection2.scale(150).translate([0, 0]);
        if (clip4 != null)
          projection2.clipExtent(null);
        geoStream(object2, projection2.stream(boundsStream$1));
        fitBounds(boundsStream$1.result());
        if (clip4 != null)
          projection2.clipExtent(clip4);
        return projection2;
      }
      function fitExtent(projection2, extent2, object2) {
        return fit(projection2, function(b) {
          var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k = Math.min(w2 / (b[1][0] - b[0][0]), h2 / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w2 - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h2 - k * (b[1][1] + b[0][1])) / 2;
          projection2.scale(150 * k).translate([x, y]);
        }, object2);
      }
      function fitSize(projection2, size, object2) {
        return fitExtent(projection2, [[0, 0], size], object2);
      }
      function fitWidth(projection2, width, object2) {
        return fit(projection2, function(b) {
          var w2 = +width, k = w2 / (b[1][0] - b[0][0]), x = (w2 - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
          projection2.scale(150 * k).translate([x, y]);
        }, object2);
      }
      function fitHeight(projection2, height, object2) {
        return fit(projection2, function(b) {
          var h2 = +height, k = h2 / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h2 - k * (b[1][1] + b[0][1])) / 2;
          projection2.scale(150 * k).translate([x, y]);
        }, object2);
      }
      var maxDepth = 16, cosMinDistance = cos(30 * radians);
      function resample(project, delta2) {
        return +delta2 ? resample$1(project, delta2) : resampleNone(project);
      }
      function resampleNone(project) {
        return transformer({
          point: function(x, y) {
            x = project(x, y);
            this.stream.point(x[0], x[1]);
          }
        });
      }
      function resample$1(project, delta2) {
        function resampleLineTo(x02, y02, lambda02, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth, stream) {
          var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
          if (d2 > 4 * delta2 && depth--) {
            var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda22 = abs(abs(c) - 1) < epsilon || abs(lambda02 - lambda12) < epsilon ? (lambda02 + lambda12) / 2 : atan2(b, a), p2 = project(lambda22, phi2), x2 = p2[0], y2 = p2[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x02, y02, lambda02, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, lambda22, a, b, c, x12, y12, lambda12, a1, b1, c1, depth, stream);
            }
          }
        }
        return function(stream) {
          var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b0, c0;
          var resampleStream = {
            point: point5,
            lineStart,
            lineEnd,
            polygonStart: function() {
              stream.polygonStart();
              resampleStream.lineStart = ringStart;
            },
            polygonEnd: function() {
              stream.polygonEnd();
              resampleStream.lineStart = lineStart;
            }
          };
          function point5(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x02 = NaN;
            resampleStream.point = linePoint2;
            stream.lineStart();
          }
          function linePoint2(lambda, phi) {
            var c = cartesian([lambda, phi]), p2 = project(lambda, phi);
            resampleLineTo(x02, y02, lambda02, a0, b0, c0, x02 = p2[0], y02 = p2[1], lambda02 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x02, y02);
          }
          function lineEnd() {
            resampleStream.point = point5;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resampleStream.point = ringPoint;
            resampleStream.lineEnd = ringEnd;
          }
          function ringPoint(lambda, phi) {
            linePoint2(lambda002 = lambda, phi), x002 = x02, y002 = y02, a00 = a0, b00 = b0, c00 = c0;
            resampleStream.point = linePoint2;
          }
          function ringEnd() {
            resampleLineTo(x02, y02, lambda02, a0, b0, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
            resampleStream.lineEnd = lineEnd;
            lineEnd();
          }
          return resampleStream;
        };
      }
      var transformRadians = transformer({
        point: function(x, y) {
          this.stream.point(x * radians, y * radians);
        }
      });
      function transformRotate(rotate) {
        return transformer({
          point: function(x, y) {
            var r = rotate(x, y);
            return this.stream.point(r[0], r[1]);
          }
        });
      }
      function scaleTranslate(k, dx, dy, sx, sy) {
        function transform2(x, y) {
          x *= sx;
          y *= sy;
          return [dx + k * x, dy - k * y];
        }
        transform2.invert = function(x, y) {
          return [(x - dx) / k * sx, (dy - y) / k * sy];
        };
        return transform2;
      }
      function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
        if (!alpha)
          return scaleTranslate(k, dx, dy, sx, sy);
        var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
        function transform2(x, y) {
          x *= sx;
          y *= sy;
          return [a * x - b * y + dx, dy - b * x - a * y];
        }
        transform2.invert = function(x, y) {
          return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
        };
        return transform2;
      }
      function projection(project) {
        return projectionMutator(function() {
          return project;
        })();
      }
      function projectionMutator(projectAt) {
        var project, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
        function projection2(point5) {
          return projectRotateTransform(point5[0] * radians, point5[1] * radians);
        }
        function invert(point5) {
          point5 = projectRotateTransform.invert(point5[0], point5[1]);
          return point5 && [point5[0] * degrees, point5[1] * degrees];
        }
        projection2.stream = function(stream) {
          return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
        };
        projection2.preclip = function(_2) {
          return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
        };
        projection2.postclip = function(_2) {
          return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset()) : postclip;
        };
        projection2.clipAngle = function(_2) {
          return arguments.length ? (preclip = +_2 ? clipCircle(theta = _2 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
        };
        projection2.clipExtent = function(_2) {
          return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
        };
        projection2.scale = function(_2) {
          return arguments.length ? (k = +_2, recenter()) : k;
        };
        projection2.translate = function(_2) {
          return arguments.length ? (x = +_2[0], y = +_2[1], recenter()) : [x, y];
        };
        projection2.center = function(_2) {
          return arguments.length ? (lambda = _2[0] % 360 * radians, phi = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
        };
        projection2.rotate = function(_2) {
          return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
        };
        projection2.angle = function(_2) {
          return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
        };
        projection2.reflectX = function(_2) {
          return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
        };
        projection2.reflectY = function(_2) {
          return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
        };
        projection2.precision = function(_2) {
          return arguments.length ? (projectResample = resample(projectTransform, delta2 = _2 * _2), reset()) : sqrt(delta2);
        };
        projection2.fitExtent = function(extent2, object2) {
          return fitExtent(projection2, extent2, object2);
        };
        projection2.fitSize = function(size, object2) {
          return fitSize(projection2, size, object2);
        };
        projection2.fitWidth = function(width, object2) {
          return fitWidth(projection2, width, object2);
        };
        projection2.fitHeight = function(height, object2) {
          return fitHeight(projection2, height, object2);
        };
        function recenter() {
          var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform2 = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
          rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
          projectTransform = compose2(project, transform2);
          projectRotateTransform = compose2(rotate, projectTransform);
          projectResample = resample(projectTransform, delta2);
          return reset();
        }
        function reset() {
          cache = cacheStream = null;
          return projection2;
        }
        return function() {
          project = projectAt.apply(this, arguments);
          projection2.invert = project.invert && invert;
          return recenter();
        };
      }
      function conicProjection(projectAt) {
        var phi02 = 0, phi12 = pi / 3, m = projectionMutator(projectAt), p2 = m(phi02, phi12);
        p2.parallels = function(_2) {
          return arguments.length ? m(phi02 = _2[0] * radians, phi12 = _2[1] * radians) : [phi02 * degrees, phi12 * degrees];
        };
        return p2;
      }
      function cylindricalEqualAreaRaw(phi02) {
        var cosPhi02 = cos(phi02);
        function forward(lambda, phi) {
          return [lambda * cosPhi02, sin(phi) / cosPhi02];
        }
        forward.invert = function(x, y) {
          return [x / cosPhi02, asin(y * cosPhi02)];
        };
        return forward;
      }
      function conicEqualAreaRaw(y02, y12) {
        var sy0 = sin(y02), n2 = (sy0 + sin(y12)) / 2;
        if (abs(n2) < epsilon)
          return cylindricalEqualAreaRaw(y02);
        var c = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt(c) / n2;
        function project(x, y) {
          var r = sqrt(c - 2 * n2 * sin(y)) / n2;
          return [r * sin(x *= n2), r0 - r * cos(x)];
        }
        project.invert = function(x, y) {
          var r0y = r0 - y, l2 = atan2(x, abs(r0y)) * sign(r0y);
          if (r0y * n2 < 0)
            l2 -= pi * sign(x) * sign(r0y);
          return [l2 / n2, asin((c - (x * x + r0y * r0y) * n2 * n2) / (2 * n2))];
        };
        return project;
      }
      function conicEqualArea() {
        return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
      }
      function albers() {
        return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
      }
      function multiplex(streams) {
        var n2 = streams.length;
        return {
          point: function(x, y) {
            var i = -1;
            while (++i < n2)
              streams[i].point(x, y);
          },
          sphere: function() {
            var i = -1;
            while (++i < n2)
              streams[i].sphere();
          },
          lineStart: function() {
            var i = -1;
            while (++i < n2)
              streams[i].lineStart();
          },
          lineEnd: function() {
            var i = -1;
            while (++i < n2)
              streams[i].lineEnd();
          },
          polygonStart: function() {
            var i = -1;
            while (++i < n2)
              streams[i].polygonStart();
          },
          polygonEnd: function() {
            var i = -1;
            while (++i < n2)
              streams[i].polygonEnd();
          }
        };
      }
      function albersUsa() {
        var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point5, pointStream = { point: function(x, y) {
          point5 = [x, y];
        } };
        function albersUsa2(coordinates2) {
          var x = coordinates2[0], y = coordinates2[1];
          return point5 = null, (lower48Point.point(x, y), point5) || (alaskaPoint.point(x, y), point5) || (hawaiiPoint.point(x, y), point5);
        }
        albersUsa2.invert = function(coordinates2) {
          var k = lower48.scale(), t2 = lower48.translate(), x = (coordinates2[0] - t2[0]) / k, y = (coordinates2[1] - t2[1]) / k;
          return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates2);
        };
        albersUsa2.stream = function(stream) {
          return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
        };
        albersUsa2.precision = function(_2) {
          if (!arguments.length)
            return lower48.precision();
          lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
          return reset();
        };
        albersUsa2.scale = function(_2) {
          if (!arguments.length)
            return lower48.scale();
          lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
          return albersUsa2.translate(lower48.translate());
        };
        albersUsa2.translate = function(_2) {
          if (!arguments.length)
            return lower48.translate();
          var k = lower48.scale(), x = +_2[0], y = +_2[1];
          lower48Point = lower48.translate(_2).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
          alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + epsilon, y + 0.12 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
          hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]]).stream(pointStream);
          return reset();
        };
        albersUsa2.fitExtent = function(extent2, object2) {
          return fitExtent(albersUsa2, extent2, object2);
        };
        albersUsa2.fitSize = function(size, object2) {
          return fitSize(albersUsa2, size, object2);
        };
        albersUsa2.fitWidth = function(width, object2) {
          return fitWidth(albersUsa2, width, object2);
        };
        albersUsa2.fitHeight = function(height, object2) {
          return fitHeight(albersUsa2, height, object2);
        };
        function reset() {
          cache = cacheStream = null;
          return albersUsa2;
        }
        return albersUsa2.scale(1070);
      }
      function azimuthalRaw(scale) {
        return function(x, y) {
          var cx = cos(x), cy = cos(y), k = scale(cx * cy);
          if (k === Infinity)
            return [2, 0];
          return [
            k * cy * sin(x),
            k * sin(y)
          ];
        };
      }
      function azimuthalInvert(angle2) {
        return function(x, y) {
          var z = sqrt(x * x + y * y), c = angle2(z), sc = sin(c), cc = cos(c);
          return [
            atan2(x * sc, z * cc),
            asin(z && y * sc / z)
          ];
        };
      }
      var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
        return sqrt(2 / (1 + cxcy));
      });
      azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
        return 2 * asin(z / 2);
      });
      function azimuthalEqualArea() {
        return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
      }
      var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
        return (c = acos(c)) && c / sin(c);
      });
      azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
        return z;
      });
      function azimuthalEquidistant() {
        return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
      }
      function mercatorRaw(lambda, phi) {
        return [lambda, log3(tan((halfPi + phi) / 2))];
      }
      mercatorRaw.invert = function(x, y) {
        return [x, 2 * atan(exp(y)) - halfPi];
      };
      function mercator() {
        return mercatorProjection(mercatorRaw).scale(961 / tau);
      }
      function mercatorProjection(project) {
        var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
        m.scale = function(_2) {
          return arguments.length ? (scale(_2), reclip()) : scale();
        };
        m.translate = function(_2) {
          return arguments.length ? (translate(_2), reclip()) : translate();
        };
        m.center = function(_2) {
          return arguments.length ? (center(_2), reclip()) : center();
        };
        m.clipExtent = function(_2) {
          return arguments.length ? (_2 == null ? x02 = y02 = x12 = y12 = null : (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
        };
        function reclip() {
          var k = pi * scale(), t2 = m(rotation(m.rotate()).invert([0, 0]));
          return clipExtent(x02 == null ? [[t2[0] - k, t2[1] - k], [t2[0] + k, t2[1] + k]] : project === mercatorRaw ? [[Math.max(t2[0] - k, x02), y02], [Math.min(t2[0] + k, x12), y12]] : [[x02, Math.max(t2[1] - k, y02)], [x12, Math.min(t2[1] + k, y12)]]);
        }
        return reclip();
      }
      function tany(y) {
        return tan((halfPi + y) / 2);
      }
      function conicConformalRaw(y02, y12) {
        var cy0 = cos(y02), n2 = y02 === y12 ? sin(y02) : log3(cy0 / cos(y12)) / log3(tany(y12) / tany(y02)), f = cy0 * pow(tany(y02), n2) / n2;
        if (!n2)
          return mercatorRaw;
        function project(x, y) {
          if (f > 0) {
            if (y < -halfPi + epsilon)
              y = -halfPi + epsilon;
          } else {
            if (y > halfPi - epsilon)
              y = halfPi - epsilon;
          }
          var r = f / pow(tany(y), n2);
          return [r * sin(n2 * x), f - r * cos(n2 * x)];
        }
        project.invert = function(x, y) {
          var fy = f - y, r = sign(n2) * sqrt(x * x + fy * fy), l2 = atan2(x, abs(fy)) * sign(fy);
          if (fy * n2 < 0)
            l2 -= pi * sign(x) * sign(fy);
          return [l2 / n2, 2 * atan(pow(f / r, 1 / n2)) - halfPi];
        };
        return project;
      }
      function conicConformal() {
        return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
      }
      function equirectangularRaw(lambda, phi) {
        return [lambda, phi];
      }
      equirectangularRaw.invert = equirectangularRaw;
      function equirectangular() {
        return projection(equirectangularRaw).scale(152.63);
      }
      function conicEquidistantRaw(y02, y12) {
        var cy0 = cos(y02), n2 = y02 === y12 ? sin(y02) : (cy0 - cos(y12)) / (y12 - y02), g = cy0 / n2 + y02;
        if (abs(n2) < epsilon)
          return equirectangularRaw;
        function project(x, y) {
          var gy = g - y, nx = n2 * x;
          return [gy * sin(nx), g - gy * cos(nx)];
        }
        project.invert = function(x, y) {
          var gy = g - y, l2 = atan2(x, abs(gy)) * sign(gy);
          if (gy * n2 < 0)
            l2 -= pi * sign(x) * sign(gy);
          return [l2 / n2, g - sign(n2) * sqrt(x * x + gy * gy)];
        };
        return project;
      }
      function conicEquidistant() {
        return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
      }
      var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt(3) / 2, iterations = 12;
      function equalEarthRaw(lambda, phi) {
        var l2 = asin(M * sin(phi)), l22 = l2 * l2, l6 = l22 * l22 * l22;
        return [
          lambda * cos(l2) / (M * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
          l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22))
        ];
      }
      equalEarthRaw.invert = function(x, y) {
        var l2 = y, l22 = l2 * l2, l6 = l22 * l22 * l22;
        for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
          fy = l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22)) - y;
          fpy = A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
          l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
          if (abs(delta) < epsilon2)
            break;
        }
        return [
          M * x * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos(l2),
          asin(sin(l2) / M)
        ];
      };
      function equalEarth() {
        return projection(equalEarthRaw).scale(177.158);
      }
      function gnomonicRaw(x, y) {
        var cy = cos(y), k = cos(x) * cy;
        return [cy * sin(x) / k, sin(y) / k];
      }
      gnomonicRaw.invert = azimuthalInvert(atan);
      function gnomonic() {
        return projection(gnomonicRaw).scale(144.049).clipAngle(60);
      }
      function identity$1() {
        var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x02 = null, y02, x12, y12, kx = 1, ky = 1, transform2 = transformer({
          point: function(x, y) {
            var p2 = projection2([x, y]);
            this.stream.point(p2[0], p2[1]);
          }
        }), postclip = identity, cache, cacheStream;
        function reset() {
          kx = k * sx;
          ky = k * sy;
          cache = cacheStream = null;
          return projection2;
        }
        function projection2(p2) {
          var x = p2[0] * kx, y = p2[1] * ky;
          if (alpha) {
            var t2 = y * ca - x * sa;
            x = x * ca + y * sa;
            y = t2;
          }
          return [x + tx, y + ty];
        }
        projection2.invert = function(p2) {
          var x = p2[0] - tx, y = p2[1] - ty;
          if (alpha) {
            var t2 = y * ca + x * sa;
            x = x * ca - y * sa;
            y = t2;
          }
          return [x / kx, y / ky];
        };
        projection2.stream = function(stream) {
          return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
        };
        projection2.postclip = function(_2) {
          return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset()) : postclip;
        };
        projection2.clipExtent = function(_2) {
          return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
        };
        projection2.scale = function(_2) {
          return arguments.length ? (k = +_2, reset()) : k;
        };
        projection2.translate = function(_2) {
          return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
        };
        projection2.angle = function(_2) {
          return arguments.length ? (alpha = _2 % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
        };
        projection2.reflectX = function(_2) {
          return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
        };
        projection2.reflectY = function(_2) {
          return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
        };
        projection2.fitExtent = function(extent2, object2) {
          return fitExtent(projection2, extent2, object2);
        };
        projection2.fitSize = function(size, object2) {
          return fitSize(projection2, size, object2);
        };
        projection2.fitWidth = function(width, object2) {
          return fitWidth(projection2, width, object2);
        };
        projection2.fitHeight = function(height, object2) {
          return fitHeight(projection2, height, object2);
        };
        return projection2;
      }
      function naturalEarth1Raw(lambda, phi) {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        return [
          lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
          phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
        ];
      }
      naturalEarth1Raw.invert = function(x, y) {
        var phi = y, i = 25, delta;
        do {
          var phi2 = phi * phi, phi4 = phi2 * phi2;
          phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
        } while (abs(delta) > epsilon && --i > 0);
        return [
          x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
          phi
        ];
      };
      function naturalEarth1() {
        return projection(naturalEarth1Raw).scale(175.295);
      }
      function orthographicRaw(x, y) {
        return [cos(y) * sin(x), sin(y)];
      }
      orthographicRaw.invert = azimuthalInvert(asin);
      function orthographic() {
        return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon);
      }
      function stereographicRaw(x, y) {
        var cy = cos(y), k = 1 + cos(x) * cy;
        return [cy * sin(x) / k, sin(y) / k];
      }
      stereographicRaw.invert = azimuthalInvert(function(z) {
        return 2 * atan(z);
      });
      function stereographic() {
        return projection(stereographicRaw).scale(250).clipAngle(142);
      }
      function transverseMercatorRaw(lambda, phi) {
        return [log3(tan((halfPi + phi) / 2)), -lambda];
      }
      transverseMercatorRaw.invert = function(x, y) {
        return [-y, 2 * atan(exp(x)) - halfPi];
      };
      function transverseMercator() {
        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
        m.center = function(_2) {
          return arguments.length ? center([-_2[1], _2[0]]) : (_2 = center(), [_2[1], -_2[0]]);
        };
        m.rotate = function(_2) {
          return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
        };
        return rotate([0, 0, 90]).scale(159.155);
      }
      exports2.geoAlbers = albers;
      exports2.geoAlbersUsa = albersUsa;
      exports2.geoArea = area;
      exports2.geoAzimuthalEqualArea = azimuthalEqualArea;
      exports2.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
      exports2.geoAzimuthalEquidistant = azimuthalEquidistant;
      exports2.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
      exports2.geoBounds = bounds;
      exports2.geoCentroid = centroid;
      exports2.geoCircle = circle;
      exports2.geoClipAntimeridian = clipAntimeridian;
      exports2.geoClipCircle = clipCircle;
      exports2.geoClipExtent = extent;
      exports2.geoClipRectangle = clipRectangle;
      exports2.geoConicConformal = conicConformal;
      exports2.geoConicConformalRaw = conicConformalRaw;
      exports2.geoConicEqualArea = conicEqualArea;
      exports2.geoConicEqualAreaRaw = conicEqualAreaRaw;
      exports2.geoConicEquidistant = conicEquidistant;
      exports2.geoConicEquidistantRaw = conicEquidistantRaw;
      exports2.geoContains = contains;
      exports2.geoDistance = distance3;
      exports2.geoEqualEarth = equalEarth;
      exports2.geoEqualEarthRaw = equalEarthRaw;
      exports2.geoEquirectangular = equirectangular;
      exports2.geoEquirectangularRaw = equirectangularRaw;
      exports2.geoGnomonic = gnomonic;
      exports2.geoGnomonicRaw = gnomonicRaw;
      exports2.geoGraticule = graticule;
      exports2.geoGraticule10 = graticule10;
      exports2.geoIdentity = identity$1;
      exports2.geoInterpolate = interpolate;
      exports2.geoLength = length;
      exports2.geoMercator = mercator;
      exports2.geoMercatorRaw = mercatorRaw;
      exports2.geoNaturalEarth1 = naturalEarth1;
      exports2.geoNaturalEarth1Raw = naturalEarth1Raw;
      exports2.geoOrthographic = orthographic;
      exports2.geoOrthographicRaw = orthographicRaw;
      exports2.geoPath = index2;
      exports2.geoProjection = projection;
      exports2.geoProjectionMutator = projectionMutator;
      exports2.geoRotation = rotation;
      exports2.geoStereographic = stereographic;
      exports2.geoStereographicRaw = stereographicRaw;
      exports2.geoStream = geoStream;
      exports2.geoTransform = transform;
      exports2.geoTransverseMercator = transverseMercator;
      exports2.geoTransverseMercatorRaw = transverseMercatorRaw;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/topojson-client/dist/topojson-client.js
var require_topojson_client = __commonJS({
  "node_modules/topojson-client/dist/topojson-client.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.topojson = global2.topojson || {}));
    })(exports, function(exports2) {
      "use strict";
      function identity(x) {
        return x;
      }
      function transform(transform2) {
        if (transform2 == null)
          return identity;
        var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
        return function(input, i) {
          if (!i)
            x0 = y0 = 0;
          var j = 2, n2 = input.length, output = new Array(n2);
          output[0] = (x0 += input[0]) * kx + dx;
          output[1] = (y0 += input[1]) * ky + dy;
          while (j < n2)
            output[j] = input[j], ++j;
          return output;
        };
      }
      function bbox(topology) {
        var t2 = transform(topology.transform), key, x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;
        function bboxPoint(p2) {
          p2 = t2(p2);
          if (p2[0] < x0)
            x0 = p2[0];
          if (p2[0] > x1)
            x1 = p2[0];
          if (p2[1] < y0)
            y0 = p2[1];
          if (p2[1] > y1)
            y1 = p2[1];
        }
        function bboxGeometry(o) {
          switch (o.type) {
            case "GeometryCollection":
              o.geometries.forEach(bboxGeometry);
              break;
            case "Point":
              bboxPoint(o.coordinates);
              break;
            case "MultiPoint":
              o.coordinates.forEach(bboxPoint);
              break;
          }
        }
        topology.arcs.forEach(function(arc2) {
          var i = -1, n2 = arc2.length, p2;
          while (++i < n2) {
            p2 = t2(arc2[i], i);
            if (p2[0] < x0)
              x0 = p2[0];
            if (p2[0] > x1)
              x1 = p2[0];
            if (p2[1] < y0)
              y0 = p2[1];
            if (p2[1] > y1)
              y1 = p2[1];
          }
        });
        for (key in topology.objects) {
          bboxGeometry(topology.objects[key]);
        }
        return [x0, y0, x1, y1];
      }
      function reverse(array, n2) {
        var t2, j = array.length, i = j - n2;
        while (i < --j)
          t2 = array[i], array[i++] = array[j], array[j] = t2;
      }
      function feature(topology, o) {
        if (typeof o === "string")
          o = topology.objects[o];
        return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
          return feature$1(topology, o2);
        }) } : feature$1(topology, o);
      }
      function feature$1(topology, o) {
        var id = o.id, bbox2 = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
        return id == null && bbox2 == null ? { type: "Feature", properties, geometry } : bbox2 == null ? { type: "Feature", id, properties, geometry } : { type: "Feature", id, bbox: bbox2, properties, geometry };
      }
      function object(topology, o) {
        var transformPoint = transform(topology.transform), arcs = topology.arcs;
        function arc2(i, points) {
          if (points.length)
            points.pop();
          for (var a = arcs[i < 0 ? ~i : i], k = 0, n2 = a.length; k < n2; ++k) {
            points.push(transformPoint(a[k], k));
          }
          if (i < 0)
            reverse(points, n2);
        }
        function point5(p2) {
          return transformPoint(p2);
        }
        function line(arcs2) {
          var points = [];
          for (var i = 0, n2 = arcs2.length; i < n2; ++i)
            arc2(arcs2[i], points);
          if (points.length < 2)
            points.push(points[0]);
          return points;
        }
        function ring(arcs2) {
          var points = line(arcs2);
          while (points.length < 4)
            points.push(points[0]);
          return points;
        }
        function polygon(arcs2) {
          return arcs2.map(ring);
        }
        function geometry(o2) {
          var type2 = o2.type, coordinates;
          switch (type2) {
            case "GeometryCollection":
              return { type: type2, geometries: o2.geometries.map(geometry) };
            case "Point":
              coordinates = point5(o2.coordinates);
              break;
            case "MultiPoint":
              coordinates = o2.coordinates.map(point5);
              break;
            case "LineString":
              coordinates = line(o2.arcs);
              break;
            case "MultiLineString":
              coordinates = o2.arcs.map(line);
              break;
            case "Polygon":
              coordinates = polygon(o2.arcs);
              break;
            case "MultiPolygon":
              coordinates = o2.arcs.map(polygon);
              break;
            default:
              return null;
          }
          return { type: type2, coordinates };
        }
        return geometry(o);
      }
      function stitch(topology, arcs) {
        var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
        arcs.forEach(function(i, j) {
          var arc2 = topology.arcs[i < 0 ? ~i : i], t2;
          if (arc2.length < 3 && !arc2[1][0] && !arc2[1][1]) {
            t2 = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t2;
          }
        });
        arcs.forEach(function(i) {
          var e2 = ends(i), start3 = e2[0], end4 = e2[1], f, g;
          if (f = fragmentByEnd[start3]) {
            delete fragmentByEnd[f.end];
            f.push(i);
            f.end = end4;
            if (g = fragmentByStart[end4]) {
              delete fragmentByStart[g.start];
              var fg = g === f ? f : f.concat(g);
              fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
          } else if (f = fragmentByStart[end4]) {
            delete fragmentByStart[f.start];
            f.unshift(i);
            f.start = start3;
            if (g = fragmentByEnd[start3]) {
              delete fragmentByEnd[g.end];
              var gf = g === f ? f : g.concat(f);
              fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
            } else {
              fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
            }
          } else {
            f = [i];
            fragmentByStart[f.start = start3] = fragmentByEnd[f.end = end4] = f;
          }
        });
        function ends(i) {
          var arc2 = topology.arcs[i < 0 ? ~i : i], p0 = arc2[0], p1;
          if (topology.transform)
            p1 = [0, 0], arc2.forEach(function(dp) {
              p1[0] += dp[0], p1[1] += dp[1];
            });
          else
            p1 = arc2[arc2.length - 1];
          return i < 0 ? [p1, p0] : [p0, p1];
        }
        function flush3(fragmentByEnd2, fragmentByStart2) {
          for (var k in fragmentByEnd2) {
            var f = fragmentByEnd2[k];
            delete fragmentByStart2[f.start];
            delete f.start;
            delete f.end;
            f.forEach(function(i) {
              stitchedArcs[i < 0 ? ~i : i] = 1;
            });
            fragments.push(f);
          }
        }
        flush3(fragmentByEnd, fragmentByStart);
        flush3(fragmentByStart, fragmentByEnd);
        arcs.forEach(function(i) {
          if (!stitchedArcs[i < 0 ? ~i : i])
            fragments.push([i]);
        });
        return fragments;
      }
      function mesh(topology) {
        return object(topology, meshArcs.apply(this, arguments));
      }
      function meshArcs(topology, object2, filter2) {
        var arcs, i, n2;
        if (arguments.length > 1)
          arcs = extractArcs(topology, object2, filter2);
        else
          for (i = 0, arcs = new Array(n2 = topology.arcs.length); i < n2; ++i)
            arcs[i] = i;
        return { type: "MultiLineString", arcs: stitch(topology, arcs) };
      }
      function extractArcs(topology, object2, filter2) {
        var arcs = [], geomsByArc = [], geom;
        function extract0(i) {
          var j = i < 0 ? ~i : i;
          (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
        }
        function extract1(arcs2) {
          arcs2.forEach(extract0);
        }
        function extract2(arcs2) {
          arcs2.forEach(extract1);
        }
        function extract3(arcs2) {
          arcs2.forEach(extract2);
        }
        function geometry(o) {
          switch (geom = o, o.type) {
            case "GeometryCollection":
              o.geometries.forEach(geometry);
              break;
            case "LineString":
              extract1(o.arcs);
              break;
            case "MultiLineString":
            case "Polygon":
              extract2(o.arcs);
              break;
            case "MultiPolygon":
              extract3(o.arcs);
              break;
          }
        }
        geometry(object2);
        geomsByArc.forEach(filter2 == null ? function(geoms) {
          arcs.push(geoms[0].i);
        } : function(geoms) {
          if (filter2(geoms[0].g, geoms[geoms.length - 1].g))
            arcs.push(geoms[0].i);
        });
        return arcs;
      }
      function planarRingArea(ring) {
        var i = -1, n2 = ring.length, a, b = ring[n2 - 1], area = 0;
        while (++i < n2)
          a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
        return Math.abs(area);
      }
      function merge3(topology) {
        return object(topology, mergeArcs.apply(this, arguments));
      }
      function mergeArcs(topology, objects) {
        var polygonsByArc = {}, polygons = [], groups = [];
        objects.forEach(geometry);
        function geometry(o) {
          switch (o.type) {
            case "GeometryCollection":
              o.geometries.forEach(geometry);
              break;
            case "Polygon":
              extract(o.arcs);
              break;
            case "MultiPolygon":
              o.arcs.forEach(extract);
              break;
          }
        }
        function extract(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc2) {
              (polygonsByArc[arc2 = arc2 < 0 ? ~arc2 : arc2] || (polygonsByArc[arc2] = [])).push(polygon);
            });
          });
          polygons.push(polygon);
        }
        function area(ring) {
          return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
        }
        polygons.forEach(function(polygon) {
          if (!polygon._) {
            var group = [], neighbors2 = [polygon];
            polygon._ = 1;
            groups.push(group);
            while (polygon = neighbors2.pop()) {
              group.push(polygon);
              polygon.forEach(function(ring) {
                ring.forEach(function(arc2) {
                  polygonsByArc[arc2 < 0 ? ~arc2 : arc2].forEach(function(polygon2) {
                    if (!polygon2._) {
                      polygon2._ = 1;
                      neighbors2.push(polygon2);
                    }
                  });
                });
              });
            }
          }
        });
        polygons.forEach(function(polygon) {
          delete polygon._;
        });
        return {
          type: "MultiPolygon",
          arcs: groups.map(function(polygons2) {
            var arcs = [], n2;
            polygons2.forEach(function(polygon) {
              polygon.forEach(function(ring) {
                ring.forEach(function(arc2) {
                  if (polygonsByArc[arc2 < 0 ? ~arc2 : arc2].length < 2) {
                    arcs.push(arc2);
                  }
                });
              });
            });
            arcs = stitch(topology, arcs);
            if ((n2 = arcs.length) > 1) {
              for (var i = 1, k = area(arcs[0]), ki, t2; i < n2; ++i) {
                if ((ki = area(arcs[i])) > k) {
                  t2 = arcs[0], arcs[0] = arcs[i], arcs[i] = t2, k = ki;
                }
              }
            }
            return arcs;
          }).filter(function(arcs) {
            return arcs.length > 0;
          })
        };
      }
      function bisect(a, x) {
        var lo = 0, hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (a[mid] < x)
            lo = mid + 1;
          else
            hi = mid;
        }
        return lo;
      }
      function neighbors(objects) {
        var indexesByArc = {}, neighbors2 = objects.map(function() {
          return [];
        });
        function line(arcs, i2) {
          arcs.forEach(function(a) {
            if (a < 0)
              a = ~a;
            var o = indexesByArc[a];
            if (o)
              o.push(i2);
            else
              indexesByArc[a] = [i2];
          });
        }
        function polygon(arcs, i2) {
          arcs.forEach(function(arc2) {
            line(arc2, i2);
          });
        }
        function geometry(o, i2) {
          if (o.type === "GeometryCollection")
            o.geometries.forEach(function(o2) {
              geometry(o2, i2);
            });
          else if (o.type in geometryType)
            geometryType[o.type](o.arcs, i2);
        }
        var geometryType = {
          LineString: line,
          MultiLineString: polygon,
          Polygon: polygon,
          MultiPolygon: function(arcs, i2) {
            arcs.forEach(function(arc2) {
              polygon(arc2, i2);
            });
          }
        };
        objects.forEach(geometry);
        for (var i in indexesByArc) {
          for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
            for (var k = j + 1; k < m; ++k) {
              var ij = indexes[j], ik = indexes[k], n2;
              if ((n2 = neighbors2[ij])[i = bisect(n2, ik)] !== ik)
                n2.splice(i, 0, ik);
              if ((n2 = neighbors2[ik])[i = bisect(n2, ij)] !== ij)
                n2.splice(i, 0, ij);
            }
          }
        }
        return neighbors2;
      }
      function untransform(transform2) {
        if (transform2 == null)
          return identity;
        var x0, y0, kx = transform2.scale[0], ky = transform2.scale[1], dx = transform2.translate[0], dy = transform2.translate[1];
        return function(input, i) {
          if (!i)
            x0 = y0 = 0;
          var j = 2, n2 = input.length, output = new Array(n2), x1 = Math.round((input[0] - dx) / kx), y1 = Math.round((input[1] - dy) / ky);
          output[0] = x1 - x0, x0 = x1;
          output[1] = y1 - y0, y0 = y1;
          while (j < n2)
            output[j] = input[j], ++j;
          return output;
        };
      }
      function quantize(topology, transform2) {
        if (topology.transform)
          throw new Error("already quantized");
        if (!transform2 || !transform2.scale) {
          if (!((n2 = Math.floor(transform2)) >= 2))
            throw new Error("n must be \u22652");
          box = topology.bbox || bbox(topology);
          var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n2;
          transform2 = { scale: [x1 - x0 ? (x1 - x0) / (n2 - 1) : 1, y1 - y0 ? (y1 - y0) / (n2 - 1) : 1], translate: [x0, y0] };
        } else {
          box = topology.bbox;
        }
        var t2 = untransform(transform2), box, key, inputs = topology.objects, outputs = {};
        function quantizePoint(point5) {
          return t2(point5);
        }
        function quantizeGeometry(input) {
          var output;
          switch (input.type) {
            case "GeometryCollection":
              output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
              break;
            case "Point":
              output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
              break;
            case "MultiPoint":
              output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
              break;
            default:
              return input;
          }
          if (input.id != null)
            output.id = input.id;
          if (input.bbox != null)
            output.bbox = input.bbox;
          if (input.properties != null)
            output.properties = input.properties;
          return output;
        }
        function quantizeArc(input) {
          var i = 0, j = 1, n3 = input.length, p2, output = new Array(n3);
          output[0] = t2(input[0], 0);
          while (++i < n3)
            if ((p2 = t2(input[i], i))[0] || p2[1])
              output[j++] = p2;
          if (j === 1)
            output[j++] = [0, 0];
          output.length = j;
          return output;
        }
        for (key in inputs)
          outputs[key] = quantizeGeometry(inputs[key]);
        return {
          type: "Topology",
          bbox: box,
          transform: transform2,
          objects: outputs,
          arcs: topology.arcs.map(quantizeArc)
        };
      }
      exports2.bbox = bbox;
      exports2.feature = feature;
      exports2.merge = merge3;
      exports2.mergeArcs = mergeArcs;
      exports2.mesh = mesh;
      exports2.meshArcs = meshArcs;
      exports2.neighbors = neighbors;
      exports2.quantize = quantize;
      exports2.transform = transform;
      exports2.untransform = untransform;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-dispatch/dist/d3-dispatch.js
var require_d3_dispatch = __commonJS({
  "node_modules/d3-dispatch/dist/d3-dispatch.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
    })(exports, function(exports2) {
      "use strict";
      var noop8 = { value: () => {
      } };
      function dispatch() {
        for (var i = 0, n2 = arguments.length, _2 = {}, t2; i < n2; ++i) {
          if (!(t2 = arguments[i] + "") || t2 in _2 || /[\s.]/.test(t2))
            throw new Error("illegal type: " + t2);
          _2[t2] = [];
        }
        return new Dispatch(_2);
      }
      function Dispatch(_2) {
        this._ = _2;
      }
      function parseTypenames(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function(t2) {
          var name = "", i = t2.indexOf(".");
          if (i >= 0)
            name = t2.slice(i + 1), t2 = t2.slice(0, i);
          if (t2 && !types.hasOwnProperty(t2))
            throw new Error("unknown type: " + t2);
          return { type: t2, name };
        });
      }
      Dispatch.prototype = dispatch.prototype = {
        constructor: Dispatch,
        on: function(typename, callback) {
          var _2 = this._, T = parseTypenames(typename + "", _2), t2, i = -1, n2 = T.length;
          if (arguments.length < 2) {
            while (++i < n2)
              if ((t2 = (typename = T[i]).type) && (t2 = get4(_2[t2], typename.name)))
                return t2;
            return;
          }
          if (callback != null && typeof callback !== "function")
            throw new Error("invalid callback: " + callback);
          while (++i < n2) {
            if (t2 = (typename = T[i]).type)
              _2[t2] = set2(_2[t2], typename.name, callback);
            else if (callback == null)
              for (t2 in _2)
                _2[t2] = set2(_2[t2], typename.name, null);
          }
          return this;
        },
        copy: function() {
          var copy2 = {}, _2 = this._;
          for (var t2 in _2)
            copy2[t2] = _2[t2].slice();
          return new Dispatch(copy2);
        },
        call: function(type2, that) {
          if ((n2 = arguments.length - 2) > 0)
            for (var args = new Array(n2), i = 0, n2, t2; i < n2; ++i)
              args[i] = arguments[i + 2];
          if (!this._.hasOwnProperty(type2))
            throw new Error("unknown type: " + type2);
          for (t2 = this._[type2], i = 0, n2 = t2.length; i < n2; ++i)
            t2[i].value.apply(that, args);
        },
        apply: function(type2, that, args) {
          if (!this._.hasOwnProperty(type2))
            throw new Error("unknown type: " + type2);
          for (var t2 = this._[type2], i = 0, n2 = t2.length; i < n2; ++i)
            t2[i].value.apply(that, args);
        }
      };
      function get4(type2, name) {
        for (var i = 0, n2 = type2.length, c; i < n2; ++i) {
          if ((c = type2[i]).name === name) {
            return c.value;
          }
        }
      }
      function set2(type2, name, callback) {
        for (var i = 0, n2 = type2.length; i < n2; ++i) {
          if (type2[i].name === name) {
            type2[i] = noop8, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
            break;
          }
        }
        if (callback != null)
          type2.push({ name, value: callback });
        return type2;
      }
      exports2.dispatch = dispatch;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-selection/dist/d3-selection.js
var require_d3_selection = __commonJS({
  "node_modules/d3-selection/dist/d3-selection.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
    })(exports, function(exports2) {
      "use strict";
      var xhtml = "http://www.w3.org/1999/xhtml";
      var namespaces = {
        svg: "http://www.w3.org/2000/svg",
        xhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      function namespace2(name) {
        var prefix3 = name += "", i = prefix3.indexOf(":");
        if (i >= 0 && (prefix3 = name.slice(0, i)) !== "xmlns")
          name = name.slice(i + 1);
        return namespaces.hasOwnProperty(prefix3) ? { space: namespaces[prefix3], local: name } : name;
      }
      function creatorInherit(name) {
        return function() {
          var document4 = this.ownerDocument, uri = this.namespaceURI;
          return uri === xhtml && document4.documentElement.namespaceURI === xhtml ? document4.createElement(name) : document4.createElementNS(uri, name);
        };
      }
      function creatorFixed(fullname) {
        return function() {
          return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
      }
      function creator(name) {
        var fullname = namespace2(name);
        return (fullname.local ? creatorFixed : creatorInherit)(fullname);
      }
      function none() {
      }
      function selector(selector2) {
        return selector2 == null ? none : function() {
          return this.querySelector(selector2);
        };
      }
      function selection_select(select2) {
        if (typeof select2 !== "function")
          select2 = selector(select2);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node2, subnode, i = 0; i < n2; ++i) {
            if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
              if ("__data__" in node2)
                subnode.__data__ = node2.__data__;
              subgroup[i] = subnode;
            }
          }
        }
        return new Selection(subgroups, this._parents);
      }
      function array(x) {
        return typeof x === "object" && "length" in x ? x : Array.from(x);
      }
      function empty2() {
        return [];
      }
      function selectorAll(selector2) {
        return selector2 == null ? empty2 : function() {
          return this.querySelectorAll(selector2);
        };
      }
      function arrayAll(select2) {
        return function() {
          var group = select2.apply(this, arguments);
          return group == null ? [] : array(group);
        };
      }
      function selection_selectAll(select2) {
        if (typeof select2 === "function")
          select2 = arrayAll(select2);
        else
          select2 = selectorAll(select2);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, node2, i = 0; i < n2; ++i) {
            if (node2 = group[i]) {
              subgroups.push(select2.call(node2, node2.__data__, i, group));
              parents.push(node2);
            }
          }
        }
        return new Selection(subgroups, parents);
      }
      function matcher(selector2) {
        return function() {
          return this.matches(selector2);
        };
      }
      function childMatcher(selector2) {
        return function(node2) {
          return node2.matches(selector2);
        };
      }
      var find3 = Array.prototype.find;
      function childFind(match3) {
        return function() {
          return find3.call(this.children, match3);
        };
      }
      function childFirst() {
        return this.firstElementChild;
      }
      function selection_selectChild(match3) {
        return this.select(match3 == null ? childFirst : childFind(typeof match3 === "function" ? match3 : childMatcher(match3)));
      }
      var filter2 = Array.prototype.filter;
      function children() {
        return this.children;
      }
      function childrenFilter(match3) {
        return function() {
          return filter2.call(this.children, match3);
        };
      }
      function selection_selectChildren(match3) {
        return this.selectAll(match3 == null ? children : childrenFilter(typeof match3 === "function" ? match3 : childMatcher(match3)));
      }
      function selection_filter(match3) {
        if (typeof match3 !== "function")
          match3 = matcher(match3);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n2; ++i) {
            if ((node2 = group[i]) && match3.call(node2, node2.__data__, i, group)) {
              subgroup.push(node2);
            }
          }
        }
        return new Selection(subgroups, this._parents);
      }
      function sparse(update2) {
        return new Array(update2.length);
      }
      function selection_enter() {
        return new Selection(this._enter || this._groups.map(sparse), this._parents);
      }
      function EnterNode(parent, datum2) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum2;
      }
      EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: function(child) {
          return this._parent.insertBefore(child, this._next);
        },
        insertBefore: function(child, next) {
          return this._parent.insertBefore(child, next);
        },
        querySelector: function(selector2) {
          return this._parent.querySelector(selector2);
        },
        querySelectorAll: function(selector2) {
          return this._parent.querySelectorAll(selector2);
        }
      };
      function constant(x) {
        return function() {
          return x;
        };
      }
      function bindIndex(parent, group, enter2, update2, exit2, data) {
        var i = 0, node2, groupLength = group.length, dataLength = data.length;
        for (; i < dataLength; ++i) {
          if (node2 = group[i]) {
            node2.__data__ = data[i];
            update2[i] = node2;
          } else {
            enter2[i] = new EnterNode(parent, data[i]);
          }
        }
        for (; i < groupLength; ++i) {
          if (node2 = group[i]) {
            exit2[i] = node2;
          }
        }
      }
      function bindKey(parent, group, enter2, update2, exit2, data, key) {
        var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
        for (i = 0; i < groupLength; ++i) {
          if (node2 = group[i]) {
            keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group) + "";
            if (nodeByKeyValue.has(keyValue)) {
              exit2[i] = node2;
            } else {
              nodeByKeyValue.set(keyValue, node2);
            }
          }
        }
        for (i = 0; i < dataLength; ++i) {
          keyValue = key.call(parent, data[i], i, data) + "";
          if (node2 = nodeByKeyValue.get(keyValue)) {
            update2[i] = node2;
            node2.__data__ = data[i];
            nodeByKeyValue.delete(keyValue);
          } else {
            enter2[i] = new EnterNode(parent, data[i]);
          }
        }
        for (i = 0; i < groupLength; ++i) {
          if ((node2 = group[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
            exit2[i] = node2;
          }
        }
      }
      function datum(node2) {
        return node2.__data__;
      }
      function selection_data(value, key) {
        if (!arguments.length)
          return Array.from(this, datum);
        var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
        if (typeof value !== "function")
          value = constant(value);
        for (var m = groups.length, update2 = new Array(m), enter2 = new Array(m), exit2 = new Array(m), j = 0; j < m; ++j) {
          var parent = parents[j], group = groups[j], groupLength = group.length, data = array(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter2[j] = new Array(dataLength), updateGroup = update2[j] = new Array(dataLength), exitGroup = exit2[j] = new Array(groupLength);
          bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
          for (var i0 = 0, i1 = 0, previous2, next; i0 < dataLength; ++i0) {
            if (previous2 = enterGroup[i0]) {
              if (i0 >= i1)
                i1 = i0 + 1;
              while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                ;
              previous2._next = next || null;
            }
          }
        }
        update2 = new Selection(update2, parents);
        update2._enter = enter2;
        update2._exit = exit2;
        return update2;
      }
      function selection_exit() {
        return new Selection(this._exit || this._groups.map(sparse), this._parents);
      }
      function selection_join(onenter, onupdate, onexit) {
        var enter2 = this.enter(), update2 = this, exit2 = this.exit();
        enter2 = typeof onenter === "function" ? onenter(enter2) : enter2.append(onenter + "");
        if (onupdate != null)
          update2 = onupdate(update2);
        if (onexit == null)
          exit2.remove();
        else
          onexit(exit2);
        return enter2 && update2 ? enter2.merge(update2).order() : update2;
      }
      function selection_merge(selection2) {
        if (!(selection2 instanceof Selection))
          throw new Error("invalid merge");
        for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
          for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge3 = merges[j] = new Array(n2), node2, i = 0; i < n2; ++i) {
            if (node2 = group0[i] || group1[i]) {
              merge3[i] = node2;
            }
          }
        }
        for (; j < m0; ++j) {
          merges[j] = groups0[j];
        }
        return new Selection(merges, this._parents);
      }
      function selection_order() {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
          for (var group = groups[j], i = group.length - 1, next = group[i], node2; --i >= 0; ) {
            if (node2 = group[i]) {
              if (next && node2.compareDocumentPosition(next) ^ 4)
                next.parentNode.insertBefore(node2, next);
              next = node2;
            }
          }
        }
        return this;
      }
      function selection_sort(compare) {
        if (!compare)
          compare = ascending;
        function compareNode(a, b) {
          return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, sortgroup = sortgroups[j] = new Array(n2), node2, i = 0; i < n2; ++i) {
            if (node2 = group[i]) {
              sortgroup[i] = node2;
            }
          }
          sortgroup.sort(compareNode);
        }
        return new Selection(sortgroups, this._parents).order();
      }
      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      function selection_call() {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
      }
      function selection_nodes() {
        return Array.from(this);
      }
      function selection_node() {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
          for (var group = groups[j], i = 0, n2 = group.length; i < n2; ++i) {
            var node2 = group[i];
            if (node2)
              return node2;
          }
        }
        return null;
      }
      function selection_size() {
        let size = 0;
        for (const node2 of this)
          ++size;
        return size;
      }
      function selection_empty() {
        return !this.node();
      }
      function selection_each(callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
          for (var group = groups[j], i = 0, n2 = group.length, node2; i < n2; ++i) {
            if (node2 = group[i])
              callback.call(node2, node2.__data__, i, group);
          }
        }
        return this;
      }
      function attrRemove(name) {
        return function() {
          this.removeAttribute(name);
        };
      }
      function attrRemoveNS(fullname) {
        return function() {
          this.removeAttributeNS(fullname.space, fullname.local);
        };
      }
      function attrConstant(name, value) {
        return function() {
          this.setAttribute(name, value);
        };
      }
      function attrConstantNS(fullname, value) {
        return function() {
          this.setAttributeNS(fullname.space, fullname.local, value);
        };
      }
      function attrFunction(name, value) {
        return function() {
          var v = value.apply(this, arguments);
          if (v == null)
            this.removeAttribute(name);
          else
            this.setAttribute(name, v);
        };
      }
      function attrFunctionNS(fullname, value) {
        return function() {
          var v = value.apply(this, arguments);
          if (v == null)
            this.removeAttributeNS(fullname.space, fullname.local);
          else
            this.setAttributeNS(fullname.space, fullname.local, v);
        };
      }
      function selection_attr(name, value) {
        var fullname = namespace2(name);
        if (arguments.length < 2) {
          var node2 = this.node();
          return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
        }
        return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
      }
      function defaultView(node2) {
        return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
      }
      function styleRemove(name) {
        return function() {
          this.style.removeProperty(name);
        };
      }
      function styleConstant(name, value, priority) {
        return function() {
          this.style.setProperty(name, value, priority);
        };
      }
      function styleFunction(name, value, priority) {
        return function() {
          var v = value.apply(this, arguments);
          if (v == null)
            this.style.removeProperty(name);
          else
            this.style.setProperty(name, v, priority);
        };
      }
      function selection_style(name, value, priority) {
        return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
      }
      function styleValue(node2, name) {
        return node2.style.getPropertyValue(name) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name);
      }
      function propertyRemove(name) {
        return function() {
          delete this[name];
        };
      }
      function propertyConstant(name, value) {
        return function() {
          this[name] = value;
        };
      }
      function propertyFunction(name, value) {
        return function() {
          var v = value.apply(this, arguments);
          if (v == null)
            delete this[name];
          else
            this[name] = v;
        };
      }
      function selection_property(name, value) {
        return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
      }
      function classArray2(string3) {
        return string3.trim().split(/^|\s+/);
      }
      function classList2(node2) {
        return node2.classList || new ClassList(node2);
      }
      function ClassList(node2) {
        this._node = node2;
        this._names = classArray2(node2.getAttribute("class") || "");
      }
      ClassList.prototype = {
        add: function(name) {
          var i = this._names.indexOf(name);
          if (i < 0) {
            this._names.push(name);
            this._node.setAttribute("class", this._names.join(" "));
          }
        },
        remove: function(name) {
          var i = this._names.indexOf(name);
          if (i >= 0) {
            this._names.splice(i, 1);
            this._node.setAttribute("class", this._names.join(" "));
          }
        },
        contains: function(name) {
          return this._names.indexOf(name) >= 0;
        }
      };
      function classedAdd(node2, names) {
        var list3 = classList2(node2), i = -1, n2 = names.length;
        while (++i < n2)
          list3.add(names[i]);
      }
      function classedRemove(node2, names) {
        var list3 = classList2(node2), i = -1, n2 = names.length;
        while (++i < n2)
          list3.remove(names[i]);
      }
      function classedTrue(names) {
        return function() {
          classedAdd(this, names);
        };
      }
      function classedFalse(names) {
        return function() {
          classedRemove(this, names);
        };
      }
      function classedFunction(names, value) {
        return function() {
          (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
        };
      }
      function selection_classed(name, value) {
        var names = classArray2(name + "");
        if (arguments.length < 2) {
          var list3 = classList2(this.node()), i = -1, n2 = names.length;
          while (++i < n2)
            if (!list3.contains(names[i]))
              return false;
          return true;
        }
        return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
      }
      function textRemove() {
        this.textContent = "";
      }
      function textConstant(value) {
        return function() {
          this.textContent = value;
        };
      }
      function textFunction(value) {
        return function() {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        };
      }
      function selection_text(value) {
        return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
      }
      function htmlRemove() {
        this.innerHTML = "";
      }
      function htmlConstant(value) {
        return function() {
          this.innerHTML = value;
        };
      }
      function htmlFunction(value) {
        return function() {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        };
      }
      function selection_html(value) {
        return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
      }
      function raise() {
        if (this.nextSibling)
          this.parentNode.appendChild(this);
      }
      function selection_raise() {
        return this.each(raise);
      }
      function lower() {
        if (this.previousSibling)
          this.parentNode.insertBefore(this, this.parentNode.firstChild);
      }
      function selection_lower() {
        return this.each(lower);
      }
      function selection_append(name) {
        var create5 = typeof name === "function" ? name : creator(name);
        return this.select(function() {
          return this.appendChild(create5.apply(this, arguments));
        });
      }
      function constantNull() {
        return null;
      }
      function selection_insert(name, before) {
        var create5 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
        return this.select(function() {
          return this.insertBefore(create5.apply(this, arguments), select2.apply(this, arguments) || null);
        });
      }
      function remove2() {
        var parent = this.parentNode;
        if (parent)
          parent.removeChild(this);
      }
      function selection_remove() {
        return this.each(remove2);
      }
      function selection_cloneShallow() {
        var clone3 = this.cloneNode(false), parent = this.parentNode;
        return parent ? parent.insertBefore(clone3, this.nextSibling) : clone3;
      }
      function selection_cloneDeep() {
        var clone3 = this.cloneNode(true), parent = this.parentNode;
        return parent ? parent.insertBefore(clone3, this.nextSibling) : clone3;
      }
      function selection_clone(deep) {
        return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
      }
      function selection_datum(value) {
        return arguments.length ? this.property("__data__", value) : this.node().__data__;
      }
      function contextListener(listener3) {
        return function(event) {
          listener3.call(this, event, this.__data__);
        };
      }
      function parseTypenames(typenames) {
        return typenames.trim().split(/^|\s+/).map(function(t2) {
          var name = "", i = t2.indexOf(".");
          if (i >= 0)
            name = t2.slice(i + 1), t2 = t2.slice(0, i);
          return { type: t2, name };
        });
      }
      function onRemove(typename) {
        return function() {
          var on = this.__on;
          if (!on)
            return;
          for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
            if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.options);
            } else {
              on[++i] = o;
            }
          }
          if (++i)
            on.length = i;
          else
            delete this.__on;
        };
      }
      function onAdd(typename, value, options) {
        return function() {
          var on = this.__on, o, listener3 = contextListener(value);
          if (on)
            for (var j = 0, m = on.length; j < m; ++j) {
              if ((o = on[j]).type === typename.type && o.name === typename.name) {
                this.removeEventListener(o.type, o.listener, o.options);
                this.addEventListener(o.type, o.listener = listener3, o.options = options);
                o.value = value;
                return;
              }
            }
          this.addEventListener(typename.type, listener3, options);
          o = { type: typename.type, name: typename.name, value, listener: listener3, options };
          if (!on)
            this.__on = [o];
          else
            on.push(o);
        };
      }
      function selection_on(typename, value, options) {
        var typenames = parseTypenames(typename + ""), i, n2 = typenames.length, t2;
        if (arguments.length < 2) {
          var on = this.node().__on;
          if (on)
            for (var j = 0, m = on.length, o; j < m; ++j) {
              for (i = 0, o = on[j]; i < n2; ++i) {
                if ((t2 = typenames[i]).type === o.type && t2.name === o.name) {
                  return o.value;
                }
              }
            }
          return;
        }
        on = value ? onAdd : onRemove;
        for (i = 0; i < n2; ++i)
          this.each(on(typenames[i], value, options));
        return this;
      }
      function dispatchEvent(node2, type2, params) {
        var window2 = defaultView(node2), event = window2.CustomEvent;
        if (typeof event === "function") {
          event = new event(type2, params);
        } else {
          event = window2.document.createEvent("Event");
          if (params)
            event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
          else
            event.initEvent(type2, false, false);
        }
        node2.dispatchEvent(event);
      }
      function dispatchConstant(type2, params) {
        return function() {
          return dispatchEvent(this, type2, params);
        };
      }
      function dispatchFunction(type2, params) {
        return function() {
          return dispatchEvent(this, type2, params.apply(this, arguments));
        };
      }
      function selection_dispatch(type2, params) {
        return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
      }
      function* selection_iterator() {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
          for (var group = groups[j], i = 0, n2 = group.length, node2; i < n2; ++i) {
            if (node2 = group[i])
              yield node2;
          }
        }
      }
      var root3 = [null];
      function Selection(groups, parents) {
        this._groups = groups;
        this._parents = parents;
      }
      function selection() {
        return new Selection([[document.documentElement]], root3);
      }
      function selection_selection() {
        return this;
      }
      Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: selection_select,
        selectAll: selection_selectAll,
        selectChild: selection_selectChild,
        selectChildren: selection_selectChildren,
        filter: selection_filter,
        data: selection_data,
        enter: selection_enter,
        exit: selection_exit,
        join: selection_join,
        merge: selection_merge,
        selection: selection_selection,
        order: selection_order,
        sort: selection_sort,
        call: selection_call,
        nodes: selection_nodes,
        node: selection_node,
        size: selection_size,
        empty: selection_empty,
        each: selection_each,
        attr: selection_attr,
        style: selection_style,
        property: selection_property,
        classed: selection_classed,
        text: selection_text,
        html: selection_html,
        raise: selection_raise,
        lower: selection_lower,
        append: selection_append,
        insert: selection_insert,
        remove: selection_remove,
        clone: selection_clone,
        datum: selection_datum,
        on: selection_on,
        dispatch: selection_dispatch,
        [Symbol.iterator]: selection_iterator
      };
      function select(selector2) {
        return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root3);
      }
      function create4(name) {
        return select(creator(name).call(document.documentElement));
      }
      var nextId = 0;
      function local() {
        return new Local();
      }
      function Local() {
        this._ = "@" + (++nextId).toString(36);
      }
      Local.prototype = local.prototype = {
        constructor: Local,
        get: function(node2) {
          var id = this._;
          while (!(id in node2))
            if (!(node2 = node2.parentNode))
              return;
          return node2[id];
        },
        set: function(node2, value) {
          return node2[this._] = value;
        },
        remove: function(node2) {
          return this._ in node2 && delete node2[this._];
        },
        toString: function() {
          return this._;
        }
      };
      function sourceEvent(event) {
        let sourceEvent2;
        while (sourceEvent2 = event.sourceEvent)
          event = sourceEvent2;
        return event;
      }
      function pointer(event, node2) {
        event = sourceEvent(event);
        if (node2 === void 0)
          node2 = event.currentTarget;
        if (node2) {
          var svg3 = node2.ownerSVGElement || node2;
          if (svg3.createSVGPoint) {
            var point5 = svg3.createSVGPoint();
            point5.x = event.clientX, point5.y = event.clientY;
            point5 = point5.matrixTransform(node2.getScreenCTM().inverse());
            return [point5.x, point5.y];
          }
          if (node2.getBoundingClientRect) {
            var rect = node2.getBoundingClientRect();
            return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
          }
        }
        return [event.pageX, event.pageY];
      }
      function pointers(events, node2) {
        if (events.target) {
          events = sourceEvent(events);
          if (node2 === void 0)
            node2 = events.currentTarget;
          events = events.touches || [events];
        }
        return Array.from(events, (event) => pointer(event, node2));
      }
      function selectAll(selector2) {
        return typeof selector2 === "string" ? new Selection([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection([selector2 == null ? [] : array(selector2)], root3);
      }
      exports2.create = create4;
      exports2.creator = creator;
      exports2.local = local;
      exports2.matcher = matcher;
      exports2.namespace = namespace2;
      exports2.namespaces = namespaces;
      exports2.pointer = pointer;
      exports2.pointers = pointers;
      exports2.select = select;
      exports2.selectAll = selectAll;
      exports2.selection = selection;
      exports2.selector = selector;
      exports2.selectorAll = selectorAll;
      exports2.style = styleValue;
      exports2.window = defaultView;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-drag/dist/d3-drag.js
var require_d3_drag = __commonJS({
  "node_modules/d3-drag/dist/d3-drag.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_d3_dispatch(), require_d3_selection()) : typeof define === "function" && define.amd ? define(["exports", "d3-dispatch", "d3-selection"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3));
    })(exports, function(exports2, d3Dispatch, d3Selection) {
      "use strict";
      function nopropagation(event) {
        event.stopImmediatePropagation();
      }
      function noevent(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
      function nodrag(view) {
        var root3 = view.document.documentElement, selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
        if ("onselectstart" in root3) {
          selection.on("selectstart.drag", noevent, true);
        } else {
          root3.__noselect = root3.style.MozUserSelect;
          root3.style.MozUserSelect = "none";
        }
      }
      function yesdrag(view, noclick) {
        var root3 = view.document.documentElement, selection = d3Selection.select(view).on("dragstart.drag", null);
        if (noclick) {
          selection.on("click.drag", noevent, true);
          setTimeout(function() {
            selection.on("click.drag", null);
          }, 0);
        }
        if ("onselectstart" in root3) {
          selection.on("selectstart.drag", null);
        } else {
          root3.style.MozUserSelect = root3.__noselect;
          delete root3.__noselect;
        }
      }
      var constant = (x) => () => x;
      function DragEvent(type2, {
        sourceEvent,
        subject,
        target,
        identifier,
        active,
        x,
        y,
        dx,
        dy,
        dispatch
      }) {
        Object.defineProperties(this, {
          type: { value: type2, enumerable: true, configurable: true },
          sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
          subject: { value: subject, enumerable: true, configurable: true },
          target: { value: target, enumerable: true, configurable: true },
          identifier: { value: identifier, enumerable: true, configurable: true },
          active: { value: active, enumerable: true, configurable: true },
          x: { value: x, enumerable: true, configurable: true },
          y: { value: y, enumerable: true, configurable: true },
          dx: { value: dx, enumerable: true, configurable: true },
          dy: { value: dy, enumerable: true, configurable: true },
          _: { value: dispatch }
        });
      }
      DragEvent.prototype.on = function() {
        var value = this._.on.apply(this._, arguments);
        return value === this._ ? this : value;
      };
      function defaultFilter(event) {
        return !event.ctrlKey && !event.button;
      }
      function defaultContainer() {
        return this.parentNode;
      }
      function defaultSubject(event, d2) {
        return d2 == null ? { x: event.x, y: event.y } : d2;
      }
      function defaultTouchable() {
        return navigator.maxTouchPoints || "ontouchstart" in this;
      }
      function drag() {
        var filter2 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = d3Dispatch.dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
        function drag2(selection) {
          selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
        }
        function mousedowned(event, d2) {
          if (touchending || !filter2.call(this, event, d2))
            return;
          var gesture = beforestart(this, container.call(this, event, d2), event, d2, "mouse");
          if (!gesture)
            return;
          d3Selection.select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
          nodrag(event.view);
          nopropagation(event);
          mousemoving = false;
          mousedownx = event.clientX;
          mousedowny = event.clientY;
          gesture("start", event);
        }
        function mousemoved(event) {
          noevent(event);
          if (!mousemoving) {
            var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
            mousemoving = dx * dx + dy * dy > clickDistance2;
          }
          gestures.mouse("drag", event);
        }
        function mouseupped(event) {
          d3Selection.select(event.view).on("mousemove.drag mouseup.drag", null);
          yesdrag(event.view, mousemoving);
          noevent(event);
          gestures.mouse("end", event);
        }
        function touchstarted(event, d2) {
          if (!filter2.call(this, event, d2))
            return;
          var touches = event.changedTouches, c = container.call(this, event, d2), n2 = touches.length, i, gesture;
          for (i = 0; i < n2; ++i) {
            if (gesture = beforestart(this, c, event, d2, touches[i].identifier, touches[i])) {
              nopropagation(event);
              gesture("start", event, touches[i]);
            }
          }
        }
        function touchmoved(event) {
          var touches = event.changedTouches, n2 = touches.length, i, gesture;
          for (i = 0; i < n2; ++i) {
            if (gesture = gestures[touches[i].identifier]) {
              noevent(event);
              gesture("drag", event, touches[i]);
            }
          }
        }
        function touchended(event) {
          var touches = event.changedTouches, n2 = touches.length, i, gesture;
          if (touchending)
            clearTimeout(touchending);
          touchending = setTimeout(function() {
            touchending = null;
          }, 500);
          for (i = 0; i < n2; ++i) {
            if (gesture = gestures[touches[i].identifier]) {
              nopropagation(event);
              gesture("end", event, touches[i]);
            }
          }
        }
        function beforestart(that, container2, event, d2, identifier, touch) {
          var dispatch = listeners.copy(), p2 = d3Selection.pointer(touch || event, container2), dx, dy, s3;
          if ((s3 = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag2,
            identifier,
            active,
            x: p2[0],
            y: p2[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d2)) == null)
            return;
          dx = s3.x - p2[0] || 0;
          dy = s3.y - p2[1] || 0;
          return function gesture(type2, event2, touch2) {
            var p0 = p2, n2;
            switch (type2) {
              case "start":
                gestures[identifier] = gesture, n2 = active++;
                break;
              case "end":
                delete gestures[identifier], --active;
              case "drag":
                p2 = d3Selection.pointer(touch2 || event2, container2), n2 = active;
                break;
            }
            dispatch.call(type2, that, new DragEvent(type2, {
              sourceEvent: event2,
              subject: s3,
              target: drag2,
              identifier,
              active: n2,
              x: p2[0] + dx,
              y: p2[1] + dy,
              dx: p2[0] - p0[0],
              dy: p2[1] - p0[1],
              dispatch
            }), d2);
          };
        }
        drag2.filter = function(_2) {
          return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant(!!_2), drag2) : filter2;
        };
        drag2.container = function(_2) {
          return arguments.length ? (container = typeof _2 === "function" ? _2 : constant(_2), drag2) : container;
        };
        drag2.subject = function(_2) {
          return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant(_2), drag2) : subject;
        };
        drag2.touchable = function(_2) {
          return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant(!!_2), drag2) : touchable;
        };
        drag2.on = function() {
          var value = listeners.on.apply(listeners, arguments);
          return value === listeners ? drag2 : value;
        };
        drag2.clickDistance = function(_2) {
          return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag2) : Math.sqrt(clickDistance2);
        };
        return drag2;
      }
      exports2.drag = drag;
      exports2.dragDisable = nodrag;
      exports2.dragEnable = yesdrag;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-color/dist/d3-color.js
var require_d3_color = __commonJS({
  "node_modules/d3-color/dist/d3-color.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
    })(exports, function(exports2) {
      "use strict";
      function define2(constructor, factory, prototype3) {
        constructor.prototype = factory.prototype = prototype3;
        prototype3.constructor = constructor;
      }
      function extend3(parent, definition2) {
        var prototype3 = Object.create(parent.prototype);
        for (var key in definition2)
          prototype3[key] = definition2[key];
        return prototype3;
      }
      function Color() {
      }
      var darker = 0.7;
      var brighter = 1 / darker;
      var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
      var named = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      };
      define2(Color, color2, {
        copy: function(channels) {
          return Object.assign(new this.constructor(), this, channels);
        },
        displayable: function() {
          return this.rgb().displayable();
        },
        hex: color_formatHex,
        formatHex: color_formatHex,
        formatHsl: color_formatHsl,
        formatRgb: color_formatRgb,
        toString: color_formatRgb
      });
      function color_formatHex() {
        return this.rgb().formatHex();
      }
      function color_formatHsl() {
        return hslConvert(this).formatHsl();
      }
      function color_formatRgb() {
        return this.rgb().formatRgb();
      }
      function color2(format) {
        var m, l2;
        format = (format + "").trim().toLowerCase();
        return (m = reHex.exec(format)) ? (l2 = m[1].length, m = parseInt(m[1], 16), l2 === 6 ? rgbn(m) : l2 === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l2 === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l2 === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
      }
      function rgbn(n2) {
        return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
      }
      function rgba(r, g, b, a) {
        if (a <= 0)
          r = g = b = NaN;
        return new Rgb(r, g, b, a);
      }
      function rgbConvert(o) {
        if (!(o instanceof Color))
          o = color2(o);
        if (!o)
          return new Rgb();
        o = o.rgb();
        return new Rgb(o.r, o.g, o.b, o.opacity);
      }
      function rgb(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
      }
      function Rgb(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
      }
      define2(Rgb, rgb, extend3(Color, {
        brighter: function(k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function(k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function() {
          return this;
        },
        displayable: function() {
          return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: rgb_formatHex,
        formatHex: rgb_formatHex,
        formatRgb: rgb_formatRgb,
        toString: rgb_formatRgb
      }));
      function rgb_formatHex() {
        return "#" + hex(this.r) + hex(this.g) + hex(this.b);
      }
      function rgb_formatRgb() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
      }
      function hex(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
      }
      function hsla(h2, s3, l2, a) {
        if (a <= 0)
          h2 = s3 = l2 = NaN;
        else if (l2 <= 0 || l2 >= 1)
          h2 = s3 = NaN;
        else if (s3 <= 0)
          h2 = NaN;
        return new Hsl(h2, s3, l2, a);
      }
      function hslConvert(o) {
        if (o instanceof Hsl)
          return new Hsl(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color))
          o = color2(o);
        if (!o)
          return new Hsl();
        if (o instanceof Hsl)
          return o;
        o = o.rgb();
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h2 = NaN, s3 = max - min, l2 = (max + min) / 2;
        if (s3) {
          if (r === max)
            h2 = (g - b) / s3 + (g < b) * 6;
          else if (g === max)
            h2 = (b - r) / s3 + 2;
          else
            h2 = (r - g) / s3 + 4;
          s3 /= l2 < 0.5 ? max + min : 2 - max - min;
          h2 *= 60;
        } else {
          s3 = l2 > 0 && l2 < 1 ? 0 : h2;
        }
        return new Hsl(h2, s3, l2, o.opacity);
      }
      function hsl(h2, s3, l2, opacity) {
        return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s3, l2, opacity == null ? 1 : opacity);
      }
      function Hsl(h2, s3, l2, opacity) {
        this.h = +h2;
        this.s = +s3;
        this.l = +l2;
        this.opacity = +opacity;
      }
      define2(Hsl, hsl, extend3(Color, {
        brighter: function(k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function(k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function() {
          var h2 = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s3, m1 = 2 * l2 - m2;
          return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb(h2, m1, m2), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
        },
        displayable: function() {
          return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
        },
        formatHsl: function() {
          var a = this.opacity;
          a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
          return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
        }
      }));
      function hsl2rgb(h2, m1, m2) {
        return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
      }
      const radians = Math.PI / 180;
      const degrees = 180 / Math.PI;
      const K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1;
      function labConvert(o) {
        if (o instanceof Lab)
          return new Lab(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl)
          return hcl2lab(o);
        if (!(o instanceof Rgb))
          o = rgbConvert(o);
        var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
        if (r === g && g === b)
          x = z = y;
        else {
          x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
          z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
        }
        return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
      }
      function gray(l2, opacity) {
        return new Lab(l2, 0, 0, opacity == null ? 1 : opacity);
      }
      function lab(l2, a, b, opacity) {
        return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a, b, opacity == null ? 1 : opacity);
      }
      function Lab(l2, a, b, opacity) {
        this.l = +l2;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
      }
      define2(Lab, lab, extend3(Color, {
        brighter: function(k) {
          return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function(k) {
          return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function() {
          var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
          x = Xn * lab2xyz(x);
          y = Yn * lab2xyz(y);
          z = Zn * lab2xyz(z);
          return new Rgb(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
        }
      }));
      function xyz2lab(t4) {
        return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0;
      }
      function lab2xyz(t4) {
        return t4 > t1 ? t4 * t4 * t4 : t2 * (t4 - t0);
      }
      function lrgb2rgb(x) {
        return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
      }
      function rgb2lrgb(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
      }
      function hclConvert(o) {
        if (o instanceof Hcl)
          return new Hcl(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab))
          o = labConvert(o);
        if (o.a === 0 && o.b === 0)
          return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
        var h2 = Math.atan2(o.b, o.a) * degrees;
        return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
      }
      function lch(l2, c, h2, opacity) {
        return arguments.length === 1 ? hclConvert(l2) : new Hcl(h2, c, l2, opacity == null ? 1 : opacity);
      }
      function hcl(h2, c, l2, opacity) {
        return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c, l2, opacity == null ? 1 : opacity);
      }
      function Hcl(h2, c, l2, opacity) {
        this.h = +h2;
        this.c = +c;
        this.l = +l2;
        this.opacity = +opacity;
      }
      function hcl2lab(o) {
        if (isNaN(o.h))
          return new Lab(o.l, 0, 0, o.opacity);
        var h2 = o.h * radians;
        return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
      }
      define2(Hcl, hcl, extend3(Color, {
        brighter: function(k) {
          return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
        },
        darker: function(k) {
          return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
        },
        rgb: function() {
          return hcl2lab(this).rgb();
        }
      }));
      var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
      function cubehelixConvert(o) {
        if (o instanceof Cubehelix)
          return new Cubehelix(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb))
          o = rgbConvert(o);
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, l2 = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l2, k = (E * (g - l2) - C * bl) / D, s3 = Math.sqrt(k * k + bl * bl) / (E * l2 * (1 - l2)), h2 = s3 ? Math.atan2(k, bl) * degrees - 120 : NaN;
        return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s3, l2, o.opacity);
      }
      function cubehelix(h2, s3, l2, opacity) {
        return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s3, l2, opacity == null ? 1 : opacity);
      }
      function Cubehelix(h2, s3, l2, opacity) {
        this.h = +h2;
        this.s = +s3;
        this.l = +l2;
        this.opacity = +opacity;
      }
      define2(Cubehelix, cubehelix, extend3(Color, {
        brighter: function(k) {
          k = k == null ? brighter : Math.pow(brighter, k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function(k) {
          k = k == null ? darker : Math.pow(darker, k);
          return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function() {
          var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh = Math.cos(h2), sinh = Math.sin(h2);
          return new Rgb(255 * (l2 + a * (A * cosh + B * sinh)), 255 * (l2 + a * (C * cosh + D * sinh)), 255 * (l2 + a * (E * cosh)), this.opacity);
        }
      }));
      exports2.color = color2;
      exports2.cubehelix = cubehelix;
      exports2.gray = gray;
      exports2.hcl = hcl;
      exports2.hsl = hsl;
      exports2.lab = lab;
      exports2.lch = lch;
      exports2.rgb = rgb;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-interpolate/dist/d3-interpolate.js
var require_d3_interpolate = __commonJS({
  "node_modules/d3-interpolate/dist/d3-interpolate.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_d3_color()) : typeof define === "function" && define.amd ? define(["exports", "d3-color"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
    })(exports, function(exports2, d3Color) {
      "use strict";
      function basis(t1, v0, v1, v2, v3) {
        var t2 = t1 * t1, t3 = t2 * t1;
        return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
      }
      function basis$1(values2) {
        var n2 = values2.length - 1;
        return function(t2) {
          var i = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n2 - 1) : Math.floor(t2 * n2), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n2 - 1 ? values2[i + 2] : 2 * v2 - v1;
          return basis((t2 - i / n2) * n2, v0, v1, v2, v3);
        };
      }
      function basisClosed(values2) {
        var n2 = values2.length;
        return function(t2) {
          var i = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n2), v0 = values2[(i + n2 - 1) % n2], v1 = values2[i % n2], v2 = values2[(i + 1) % n2], v3 = values2[(i + 2) % n2];
          return basis((t2 - i / n2) * n2, v0, v1, v2, v3);
        };
      }
      var constant = (x) => () => x;
      function linear(a, d2) {
        return function(t2) {
          return a + t2 * d2;
        };
      }
      function exponential(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t2) {
          return Math.pow(a + t2 * b, y);
        };
      }
      function hue(a, b) {
        var d2 = b - a;
        return d2 ? linear(a, d2 > 180 || d2 < -180 ? d2 - 360 * Math.round(d2 / 360) : d2) : constant(isNaN(a) ? b : a);
      }
      function gamma(y) {
        return (y = +y) === 1 ? nogamma : function(a, b) {
          return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
        };
      }
      function nogamma(a, b) {
        var d2 = b - a;
        return d2 ? linear(a, d2) : constant(isNaN(a) ? b : a);
      }
      var rgb = function rgbGamma(y) {
        var color2 = gamma(y);
        function rgb2(start3, end4) {
          var r = color2((start3 = d3Color.rgb(start3)).r, (end4 = d3Color.rgb(end4)).r), g = color2(start3.g, end4.g), b = color2(start3.b, end4.b), opacity = nogamma(start3.opacity, end4.opacity);
          return function(t2) {
            start3.r = r(t2);
            start3.g = g(t2);
            start3.b = b(t2);
            start3.opacity = opacity(t2);
            return start3 + "";
          };
        }
        rgb2.gamma = rgbGamma;
        return rgb2;
      }(1);
      function rgbSpline(spline) {
        return function(colors) {
          var n2 = colors.length, r = new Array(n2), g = new Array(n2), b = new Array(n2), i, color2;
          for (i = 0; i < n2; ++i) {
            color2 = d3Color.rgb(colors[i]);
            r[i] = color2.r || 0;
            g[i] = color2.g || 0;
            b[i] = color2.b || 0;
          }
          r = spline(r);
          g = spline(g);
          b = spline(b);
          color2.opacity = 1;
          return function(t2) {
            color2.r = r(t2);
            color2.g = g(t2);
            color2.b = b(t2);
            return color2 + "";
          };
        };
      }
      var rgbBasis = rgbSpline(basis$1);
      var rgbBasisClosed = rgbSpline(basisClosed);
      function numberArray(a, b) {
        if (!b)
          b = [];
        var n2 = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
        return function(t2) {
          for (i = 0; i < n2; ++i)
            c[i] = a[i] * (1 - t2) + b[i] * t2;
          return c;
        };
      }
      function isNumberArray(x) {
        return ArrayBuffer.isView(x) && !(x instanceof DataView);
      }
      function array(a, b) {
        return (isNumberArray(b) ? numberArray : genericArray)(a, b);
      }
      function genericArray(a, b) {
        var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
        for (i = 0; i < na; ++i)
          x[i] = value(a[i], b[i]);
        for (; i < nb; ++i)
          c[i] = b[i];
        return function(t2) {
          for (i = 0; i < na; ++i)
            c[i] = x[i](t2);
          return c;
        };
      }
      function date2(a, b) {
        var d2 = new Date();
        return a = +a, b = +b, function(t2) {
          return d2.setTime(a * (1 - t2) + b * t2), d2;
        };
      }
      function number2(a, b) {
        return a = +a, b = +b, function(t2) {
          return a * (1 - t2) + b * t2;
        };
      }
      function object(a, b) {
        var i = {}, c = {}, k;
        if (a === null || typeof a !== "object")
          a = {};
        if (b === null || typeof b !== "object")
          b = {};
        for (k in b) {
          if (k in a) {
            i[k] = value(a[k], b[k]);
          } else {
            c[k] = b[k];
          }
        }
        return function(t2) {
          for (k in i)
            c[k] = i[k](t2);
          return c;
        };
      }
      var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
      function zero(b) {
        return function() {
          return b;
        };
      }
      function one5(b) {
        return function(t2) {
          return b(t2) + "";
        };
      }
      function string3(a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s3 = [], q = [];
        a = a + "", b = b + "";
        while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s3[i])
              s3[i] += bs;
            else
              s3[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s3[i])
              s3[i] += bm;
            else
              s3[++i] = bm;
          } else {
            s3[++i] = null;
            q.push({ i, x: number2(am, bm) });
          }
          bi = reB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s3[i])
            s3[i] += bs;
          else
            s3[++i] = bs;
        }
        return s3.length < 2 ? q[0] ? one5(q[0].x) : zero(b) : (b = q.length, function(t2) {
          for (var i2 = 0, o; i2 < b; ++i2)
            s3[(o = q[i2]).i] = o.x(t2);
          return s3.join("");
        });
      }
      function value(a, b) {
        var t2 = typeof b, c;
        return b == null || t2 === "boolean" ? constant(b) : (t2 === "number" ? number2 : t2 === "string" ? (c = d3Color.color(b)) ? (b = c, rgb) : string3 : b instanceof d3Color.color ? rgb : b instanceof Date ? date2 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : number2)(a, b);
      }
      function discrete(range) {
        var n2 = range.length;
        return function(t2) {
          return range[Math.max(0, Math.min(n2 - 1, Math.floor(t2 * n2)))];
        };
      }
      function hue$1(a, b) {
        var i = hue(+a, +b);
        return function(t2) {
          var x = i(t2);
          return x - 360 * Math.floor(x / 360);
        };
      }
      function round(a, b) {
        return a = +a, b = +b, function(t2) {
          return Math.round(a * (1 - t2) + b * t2);
        };
      }
      var degrees = 180 / Math.PI;
      var identity = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
      };
      function decompose(a, b, c, d2, e2, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b))
          a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d2)
          c -= a * skewX, d2 -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d2 * d2))
          c /= scaleY, d2 /= scaleY, skewX /= scaleY;
        if (a * d2 < b * c)
          a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
          translateX: e2,
          translateY: f,
          rotate: Math.atan2(b, a) * degrees,
          skewX: Math.atan(skewX) * degrees,
          scaleX,
          scaleY
        };
      }
      var svgNode;
      function parseCss(value2) {
        const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
        return m.isIdentity ? identity : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
      }
      function parseSvg(value2) {
        if (value2 == null)
          return identity;
        if (!svgNode)
          svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode.setAttribute("transform", value2);
        if (!(value2 = svgNode.transform.baseVal.consolidate()))
          return identity;
        value2 = value2.matrix;
        return decompose(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
      }
      function interpolateTransform(parse8, pxComma, pxParen, degParen) {
        function pop(s3) {
          return s3.length ? s3.pop() + " " : "";
        }
        function translate(xa, ya, xb, yb, s3, q) {
          if (xa !== xb || ya !== yb) {
            var i = s3.push("translate(", null, pxComma, null, pxParen);
            q.push({ i: i - 4, x: number2(xa, xb) }, { i: i - 2, x: number2(ya, yb) });
          } else if (xb || yb) {
            s3.push("translate(" + xb + pxComma + yb + pxParen);
          }
        }
        function rotate(a, b, s3, q) {
          if (a !== b) {
            if (a - b > 180)
              b += 360;
            else if (b - a > 180)
              a += 360;
            q.push({ i: s3.push(pop(s3) + "rotate(", null, degParen) - 2, x: number2(a, b) });
          } else if (b) {
            s3.push(pop(s3) + "rotate(" + b + degParen);
          }
        }
        function skewX(a, b, s3, q) {
          if (a !== b) {
            q.push({ i: s3.push(pop(s3) + "skewX(", null, degParen) - 2, x: number2(a, b) });
          } else if (b) {
            s3.push(pop(s3) + "skewX(" + b + degParen);
          }
        }
        function scale(xa, ya, xb, yb, s3, q) {
          if (xa !== xb || ya !== yb) {
            var i = s3.push(pop(s3) + "scale(", null, ",", null, ")");
            q.push({ i: i - 4, x: number2(xa, xb) }, { i: i - 2, x: number2(ya, yb) });
          } else if (xb !== 1 || yb !== 1) {
            s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
          }
        }
        return function(a, b) {
          var s3 = [], q = [];
          a = parse8(a), b = parse8(b);
          translate(a.translateX, a.translateY, b.translateX, b.translateY, s3, q);
          rotate(a.rotate, b.rotate, s3, q);
          skewX(a.skewX, b.skewX, s3, q);
          scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s3, q);
          a = b = null;
          return function(t2) {
            var i = -1, n2 = q.length, o;
            while (++i < n2)
              s3[(o = q[i]).i] = o.x(t2);
            return s3.join("");
          };
        };
      }
      var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
      var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
      var epsilon2 = 1e-12;
      function cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      var zoom = function zoomRho(rho, rho2, rho4) {
        function zoom2(p0, p1) {
          var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
          if (d2 < epsilon2) {
            S = Math.log(w1 / w0) / rho;
            i = function(t2) {
              return [
                ux0 + t2 * dx,
                uy0 + t2 * dy,
                w0 * Math.exp(rho * t2 * S)
              ];
            };
          } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / rho;
            i = function(t2) {
              var s3 = t2 * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s3 + r0) - sinh(r0));
              return [
                ux0 + u * dx,
                uy0 + u * dy,
                w0 * coshr0 / cosh(rho * s3 + r0)
              ];
            };
          }
          i.duration = S * 1e3 * rho / Math.SQRT2;
          return i;
        }
        zoom2.rho = function(_2) {
          var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
          return zoomRho(_1, _22, _4);
        };
        return zoom2;
      }(Math.SQRT2, 2, 4);
      function hsl(hue2) {
        return function(start3, end4) {
          var h2 = hue2((start3 = d3Color.hsl(start3)).h, (end4 = d3Color.hsl(end4)).h), s3 = nogamma(start3.s, end4.s), l2 = nogamma(start3.l, end4.l), opacity = nogamma(start3.opacity, end4.opacity);
          return function(t2) {
            start3.h = h2(t2);
            start3.s = s3(t2);
            start3.l = l2(t2);
            start3.opacity = opacity(t2);
            return start3 + "";
          };
        };
      }
      var hsl$1 = hsl(hue);
      var hslLong = hsl(nogamma);
      function lab(start3, end4) {
        var l2 = nogamma((start3 = d3Color.lab(start3)).l, (end4 = d3Color.lab(end4)).l), a = nogamma(start3.a, end4.a), b = nogamma(start3.b, end4.b), opacity = nogamma(start3.opacity, end4.opacity);
        return function(t2) {
          start3.l = l2(t2);
          start3.a = a(t2);
          start3.b = b(t2);
          start3.opacity = opacity(t2);
          return start3 + "";
        };
      }
      function hcl(hue2) {
        return function(start3, end4) {
          var h2 = hue2((start3 = d3Color.hcl(start3)).h, (end4 = d3Color.hcl(end4)).h), c = nogamma(start3.c, end4.c), l2 = nogamma(start3.l, end4.l), opacity = nogamma(start3.opacity, end4.opacity);
          return function(t2) {
            start3.h = h2(t2);
            start3.c = c(t2);
            start3.l = l2(t2);
            start3.opacity = opacity(t2);
            return start3 + "";
          };
        };
      }
      var hcl$1 = hcl(hue);
      var hclLong = hcl(nogamma);
      function cubehelix(hue2) {
        return function cubehelixGamma(y) {
          y = +y;
          function cubehelix2(start3, end4) {
            var h2 = hue2((start3 = d3Color.cubehelix(start3)).h, (end4 = d3Color.cubehelix(end4)).h), s3 = nogamma(start3.s, end4.s), l2 = nogamma(start3.l, end4.l), opacity = nogamma(start3.opacity, end4.opacity);
            return function(t2) {
              start3.h = h2(t2);
              start3.s = s3(t2);
              start3.l = l2(Math.pow(t2, y));
              start3.opacity = opacity(t2);
              return start3 + "";
            };
          }
          cubehelix2.gamma = cubehelixGamma;
          return cubehelix2;
        }(1);
      }
      var cubehelix$1 = cubehelix(hue);
      var cubehelixLong = cubehelix(nogamma);
      function piecewise(interpolate, values2) {
        if (values2 === void 0)
          values2 = interpolate, interpolate = value;
        var i = 0, n2 = values2.length - 1, v = values2[0], I = new Array(n2 < 0 ? 0 : n2);
        while (i < n2)
          I[i] = interpolate(v, v = values2[++i]);
        return function(t2) {
          var i2 = Math.max(0, Math.min(n2 - 1, Math.floor(t2 *= n2)));
          return I[i2](t2 - i2);
        };
      }
      function quantize(interpolator, n2) {
        var samples = new Array(n2);
        for (var i = 0; i < n2; ++i)
          samples[i] = interpolator(i / (n2 - 1));
        return samples;
      }
      exports2.interpolate = value;
      exports2.interpolateArray = array;
      exports2.interpolateBasis = basis$1;
      exports2.interpolateBasisClosed = basisClosed;
      exports2.interpolateCubehelix = cubehelix$1;
      exports2.interpolateCubehelixLong = cubehelixLong;
      exports2.interpolateDate = date2;
      exports2.interpolateDiscrete = discrete;
      exports2.interpolateHcl = hcl$1;
      exports2.interpolateHclLong = hclLong;
      exports2.interpolateHsl = hsl$1;
      exports2.interpolateHslLong = hslLong;
      exports2.interpolateHue = hue$1;
      exports2.interpolateLab = lab;
      exports2.interpolateNumber = number2;
      exports2.interpolateNumberArray = numberArray;
      exports2.interpolateObject = object;
      exports2.interpolateRgb = rgb;
      exports2.interpolateRgbBasis = rgbBasis;
      exports2.interpolateRgbBasisClosed = rgbBasisClosed;
      exports2.interpolateRound = round;
      exports2.interpolateString = string3;
      exports2.interpolateTransformCss = interpolateTransformCss;
      exports2.interpolateTransformSvg = interpolateTransformSvg;
      exports2.interpolateZoom = zoom;
      exports2.piecewise = piecewise;
      exports2.quantize = quantize;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-timer/dist/d3-timer.js
var require_d3_timer = __commonJS({
  "node_modules/d3-timer/dist/d3-timer.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
    })(exports, function(exports2) {
      "use strict";
      var frame = 0, timeout = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
        setTimeout(f, 17);
      };
      function now2() {
        return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
      }
      function clearNow() {
        clockNow = 0;
      }
      function Timer() {
        this._call = this._time = this._next = null;
      }
      Timer.prototype = timer.prototype = {
        constructor: Timer,
        restart: function(callback, delay, time) {
          if (typeof callback !== "function")
            throw new TypeError("callback is not a function");
          time = (time == null ? now2() : +time) + (delay == null ? 0 : +delay);
          if (!this._next && taskTail !== this) {
            if (taskTail)
              taskTail._next = this;
            else
              taskHead = this;
            taskTail = this;
          }
          this._call = callback;
          this._time = time;
          sleep();
        },
        stop: function() {
          if (this._call) {
            this._call = null;
            this._time = Infinity;
            sleep();
          }
        }
      };
      function timer(callback, delay, time) {
        var t2 = new Timer();
        t2.restart(callback, delay, time);
        return t2;
      }
      function timerFlush() {
        now2();
        ++frame;
        var t2 = taskHead, e2;
        while (t2) {
          if ((e2 = clockNow - t2._time) >= 0)
            t2._call.call(null, e2);
          t2 = t2._next;
        }
        --frame;
      }
      function wake() {
        clockNow = (clockLast = clock.now()) + clockSkew;
        frame = timeout = 0;
        try {
          timerFlush();
        } finally {
          frame = 0;
          nap();
          clockNow = 0;
        }
      }
      function poke() {
        var now3 = clock.now(), delay = now3 - clockLast;
        if (delay > pokeDelay)
          clockSkew -= delay, clockLast = now3;
      }
      function nap() {
        var t0, t1 = taskHead, t2, time = Infinity;
        while (t1) {
          if (t1._call) {
            if (time > t1._time)
              time = t1._time;
            t0 = t1, t1 = t1._next;
          } else {
            t2 = t1._next, t1._next = null;
            t1 = t0 ? t0._next = t2 : taskHead = t2;
          }
        }
        taskTail = t0;
        sleep(time);
      }
      function sleep(time) {
        if (frame)
          return;
        if (timeout)
          timeout = clearTimeout(timeout);
        var delay = time - clockNow;
        if (delay > 24) {
          if (time < Infinity)
            timeout = setTimeout(wake, time - clock.now() - clockSkew);
          if (interval)
            interval = clearInterval(interval);
        } else {
          if (!interval)
            clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
          frame = 1, setFrame(wake);
        }
      }
      function timeout$1(callback, delay, time) {
        var t2 = new Timer();
        delay = delay == null ? 0 : +delay;
        t2.restart((elapsed) => {
          t2.stop();
          callback(elapsed + delay);
        }, delay, time);
        return t2;
      }
      function interval$1(callback, delay, time) {
        var t2 = new Timer(), total = delay;
        if (delay == null)
          return t2.restart(callback, delay, time), t2;
        t2._restart = t2.restart;
        t2.restart = function(callback2, delay2, time2) {
          delay2 = +delay2, time2 = time2 == null ? now2() : +time2;
          t2._restart(function tick(elapsed) {
            elapsed += total;
            t2._restart(tick, total += delay2, time2);
            callback2(elapsed);
          }, delay2, time2);
        };
        t2.restart(callback, delay, time);
        return t2;
      }
      exports2.interval = interval$1;
      exports2.now = now2;
      exports2.timeout = timeout$1;
      exports2.timer = timer;
      exports2.timerFlush = timerFlush;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-ease/dist/d3-ease.js
var require_d3_ease = __commonJS({
  "node_modules/d3-ease/dist/d3-ease.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
    })(exports, function(exports2) {
      "use strict";
      const linear = (t2) => +t2;
      function quadIn(t2) {
        return t2 * t2;
      }
      function quadOut(t2) {
        return t2 * (2 - t2);
      }
      function quadInOut(t2) {
        return ((t2 *= 2) <= 1 ? t2 * t2 : --t2 * (2 - t2) + 1) / 2;
      }
      function cubicIn(t2) {
        return t2 * t2 * t2;
      }
      function cubicOut(t2) {
        return --t2 * t2 * t2 + 1;
      }
      function cubicInOut(t2) {
        return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
      }
      var exponent = 3;
      var polyIn = function custom(e2) {
        e2 = +e2;
        function polyIn2(t2) {
          return Math.pow(t2, e2);
        }
        polyIn2.exponent = custom;
        return polyIn2;
      }(exponent);
      var polyOut = function custom(e2) {
        e2 = +e2;
        function polyOut2(t2) {
          return 1 - Math.pow(1 - t2, e2);
        }
        polyOut2.exponent = custom;
        return polyOut2;
      }(exponent);
      var polyInOut = function custom(e2) {
        e2 = +e2;
        function polyInOut2(t2) {
          return ((t2 *= 2) <= 1 ? Math.pow(t2, e2) : 2 - Math.pow(2 - t2, e2)) / 2;
        }
        polyInOut2.exponent = custom;
        return polyInOut2;
      }(exponent);
      var pi = Math.PI, halfPi = pi / 2;
      function sinIn(t2) {
        return +t2 === 1 ? 1 : 1 - Math.cos(t2 * halfPi);
      }
      function sinOut(t2) {
        return Math.sin(t2 * halfPi);
      }
      function sinInOut(t2) {
        return (1 - Math.cos(pi * t2)) / 2;
      }
      function tpmt(x) {
        return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
      }
      function expIn(t2) {
        return tpmt(1 - +t2);
      }
      function expOut(t2) {
        return 1 - tpmt(t2);
      }
      function expInOut(t2) {
        return ((t2 *= 2) <= 1 ? tpmt(1 - t2) : 2 - tpmt(t2 - 1)) / 2;
      }
      function circleIn(t2) {
        return 1 - Math.sqrt(1 - t2 * t2);
      }
      function circleOut(t2) {
        return Math.sqrt(1 - --t2 * t2);
      }
      function circleInOut(t2) {
        return ((t2 *= 2) <= 1 ? 1 - Math.sqrt(1 - t2 * t2) : Math.sqrt(1 - (t2 -= 2) * t2) + 1) / 2;
      }
      var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
      function bounceIn(t2) {
        return 1 - bounceOut(1 - t2);
      }
      function bounceOut(t2) {
        return (t2 = +t2) < b1 ? b0 * t2 * t2 : t2 < b3 ? b0 * (t2 -= b2) * t2 + b4 : t2 < b6 ? b0 * (t2 -= b5) * t2 + b7 : b0 * (t2 -= b8) * t2 + b9;
      }
      function bounceInOut(t2) {
        return ((t2 *= 2) <= 1 ? 1 - bounceOut(1 - t2) : bounceOut(t2 - 1) + 1) / 2;
      }
      var overshoot = 1.70158;
      var backIn = function custom(s3) {
        s3 = +s3;
        function backIn2(t2) {
          return (t2 = +t2) * t2 * (s3 * (t2 - 1) + t2);
        }
        backIn2.overshoot = custom;
        return backIn2;
      }(overshoot);
      var backOut = function custom(s3) {
        s3 = +s3;
        function backOut2(t2) {
          return --t2 * t2 * ((t2 + 1) * s3 + t2) + 1;
        }
        backOut2.overshoot = custom;
        return backOut2;
      }(overshoot);
      var backInOut = function custom(s3) {
        s3 = +s3;
        function backInOut2(t2) {
          return ((t2 *= 2) < 1 ? t2 * t2 * ((s3 + 1) * t2 - s3) : (t2 -= 2) * t2 * ((s3 + 1) * t2 + s3) + 2) / 2;
        }
        backInOut2.overshoot = custom;
        return backInOut2;
      }(overshoot);
      var tau = 2 * Math.PI, amplitude = 1, period = 0.3;
      var elasticIn = function custom(a, p2) {
        var s3 = Math.asin(1 / (a = Math.max(1, a))) * (p2 /= tau);
        function elasticIn2(t2) {
          return a * tpmt(- --t2) * Math.sin((s3 - t2) / p2);
        }
        elasticIn2.amplitude = function(a2) {
          return custom(a2, p2 * tau);
        };
        elasticIn2.period = function(p3) {
          return custom(a, p3);
        };
        return elasticIn2;
      }(amplitude, period);
      var elasticOut = function custom(a, p2) {
        var s3 = Math.asin(1 / (a = Math.max(1, a))) * (p2 /= tau);
        function elasticOut2(t2) {
          return 1 - a * tpmt(t2 = +t2) * Math.sin((t2 + s3) / p2);
        }
        elasticOut2.amplitude = function(a2) {
          return custom(a2, p2 * tau);
        };
        elasticOut2.period = function(p3) {
          return custom(a, p3);
        };
        return elasticOut2;
      }(amplitude, period);
      var elasticInOut = function custom(a, p2) {
        var s3 = Math.asin(1 / (a = Math.max(1, a))) * (p2 /= tau);
        function elasticInOut2(t2) {
          return ((t2 = t2 * 2 - 1) < 0 ? a * tpmt(-t2) * Math.sin((s3 - t2) / p2) : 2 - a * tpmt(t2) * Math.sin((s3 + t2) / p2)) / 2;
        }
        elasticInOut2.amplitude = function(a2) {
          return custom(a2, p2 * tau);
        };
        elasticInOut2.period = function(p3) {
          return custom(a, p3);
        };
        return elasticInOut2;
      }(amplitude, period);
      exports2.easeBack = backInOut;
      exports2.easeBackIn = backIn;
      exports2.easeBackInOut = backInOut;
      exports2.easeBackOut = backOut;
      exports2.easeBounce = bounceOut;
      exports2.easeBounceIn = bounceIn;
      exports2.easeBounceInOut = bounceInOut;
      exports2.easeBounceOut = bounceOut;
      exports2.easeCircle = circleInOut;
      exports2.easeCircleIn = circleIn;
      exports2.easeCircleInOut = circleInOut;
      exports2.easeCircleOut = circleOut;
      exports2.easeCubic = cubicInOut;
      exports2.easeCubicIn = cubicIn;
      exports2.easeCubicInOut = cubicInOut;
      exports2.easeCubicOut = cubicOut;
      exports2.easeElastic = elasticOut;
      exports2.easeElasticIn = elasticIn;
      exports2.easeElasticInOut = elasticInOut;
      exports2.easeElasticOut = elasticOut;
      exports2.easeExp = expInOut;
      exports2.easeExpIn = expIn;
      exports2.easeExpInOut = expInOut;
      exports2.easeExpOut = expOut;
      exports2.easeLinear = linear;
      exports2.easePoly = polyInOut;
      exports2.easePolyIn = polyIn;
      exports2.easePolyInOut = polyInOut;
      exports2.easePolyOut = polyOut;
      exports2.easeQuad = quadInOut;
      exports2.easeQuadIn = quadIn;
      exports2.easeQuadInOut = quadInOut;
      exports2.easeQuadOut = quadOut;
      exports2.easeSin = sinInOut;
      exports2.easeSinIn = sinIn;
      exports2.easeSinInOut = sinInOut;
      exports2.easeSinOut = sinOut;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-transition/dist/d3-transition.js
var require_d3_transition = __commonJS({
  "node_modules/d3-transition/dist/d3-transition.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_d3_selection(), require_d3_dispatch(), require_d3_timer(), require_d3_interpolate(), require_d3_color(), require_d3_ease()) : typeof define === "function" && define.amd ? define(["exports", "d3-selection", "d3-dispatch", "d3-timer", "d3-interpolate", "d3-color", "d3-ease"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3));
    })(exports, function(exports2, d3Selection, d3Dispatch, d3Timer, d3Interpolate, d3Color, d3Ease) {
      "use strict";
      var emptyOn = d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
      var emptyTween = [];
      var CREATED = 0;
      var SCHEDULED = 1;
      var STARTING = 2;
      var STARTED = 3;
      var RUNNING = 4;
      var ENDING = 5;
      var ENDED = 6;
      function schedule(node2, name, id2, index2, group, timing) {
        var schedules = node2.__transition;
        if (!schedules)
          node2.__transition = {};
        else if (id2 in schedules)
          return;
        create4(node2, id2, {
          name,
          index: index2,
          group,
          on: emptyOn,
          tween: emptyTween,
          time: timing.time,
          delay: timing.delay,
          duration: timing.duration,
          ease: timing.ease,
          timer: null,
          state: CREATED
        });
      }
      function init2(node2, id2) {
        var schedule2 = get4(node2, id2);
        if (schedule2.state > CREATED)
          throw new Error("too late; already scheduled");
        return schedule2;
      }
      function set2(node2, id2) {
        var schedule2 = get4(node2, id2);
        if (schedule2.state > STARTED)
          throw new Error("too late; already running");
        return schedule2;
      }
      function get4(node2, id2) {
        var schedule2 = node2.__transition;
        if (!schedule2 || !(schedule2 = schedule2[id2]))
          throw new Error("transition not found");
        return schedule2;
      }
      function create4(node2, id2, self2) {
        var schedules = node2.__transition, tween;
        schedules[id2] = self2;
        self2.timer = d3Timer.timer(schedule2, 0, self2.time);
        function schedule2(elapsed) {
          self2.state = SCHEDULED;
          self2.timer.restart(start4, self2.delay, self2.time);
          if (self2.delay <= elapsed)
            start4(elapsed - self2.delay);
        }
        function start4(elapsed) {
          var i, j, n2, o;
          if (self2.state !== SCHEDULED)
            return stop();
          for (i in schedules) {
            o = schedules[i];
            if (o.name !== self2.name)
              continue;
            if (o.state === STARTED)
              return d3Timer.timeout(start4);
            if (o.state === RUNNING) {
              o.state = ENDED;
              o.timer.stop();
              o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
              delete schedules[i];
            } else if (+i < id2) {
              o.state = ENDED;
              o.timer.stop();
              o.on.call("cancel", node2, node2.__data__, o.index, o.group);
              delete schedules[i];
            }
          }
          d3Timer.timeout(function() {
            if (self2.state === STARTED) {
              self2.state = RUNNING;
              self2.timer.restart(tick, self2.delay, self2.time);
              tick(elapsed);
            }
          });
          self2.state = STARTING;
          self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
          if (self2.state !== STARTING)
            return;
          self2.state = STARTED;
          tween = new Array(n2 = self2.tween.length);
          for (i = 0, j = -1; i < n2; ++i) {
            if (o = self2.tween[i].value.call(node2, node2.__data__, self2.index, self2.group)) {
              tween[++j] = o;
            }
          }
          tween.length = j + 1;
        }
        function tick(elapsed) {
          var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n2 = tween.length;
          while (++i < n2) {
            tween[i].call(node2, t2);
          }
          if (self2.state === ENDING) {
            self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
            stop();
          }
        }
        function stop() {
          self2.state = ENDED;
          self2.timer.stop();
          delete schedules[id2];
          for (var i in schedules)
            return;
          delete node2.__transition;
        }
      }
      function interrupt(node2, name) {
        var schedules = node2.__transition, schedule2, active2, empty2 = true, i;
        if (!schedules)
          return;
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule2 = schedules[i]).name !== name) {
            empty2 = false;
            continue;
          }
          active2 = schedule2.state > STARTING && schedule2.state < ENDING;
          schedule2.state = ENDED;
          schedule2.timer.stop();
          schedule2.on.call(active2 ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
          delete schedules[i];
        }
        if (empty2)
          delete node2.__transition;
      }
      function selection_interrupt(name) {
        return this.each(function() {
          interrupt(this, name);
        });
      }
      function tweenRemove(id2, name) {
        var tween0, tween1;
        return function() {
          var schedule2 = set2(this, id2), tween = schedule2.tween;
          if (tween !== tween0) {
            tween1 = tween0 = tween;
            for (var i = 0, n2 = tween1.length; i < n2; ++i) {
              if (tween1[i].name === name) {
                tween1 = tween1.slice();
                tween1.splice(i, 1);
                break;
              }
            }
          }
          schedule2.tween = tween1;
        };
      }
      function tweenFunction(id2, name, value) {
        var tween0, tween1;
        if (typeof value !== "function")
          throw new Error();
        return function() {
          var schedule2 = set2(this, id2), tween = schedule2.tween;
          if (tween !== tween0) {
            tween1 = (tween0 = tween).slice();
            for (var t2 = { name, value }, i = 0, n2 = tween1.length; i < n2; ++i) {
              if (tween1[i].name === name) {
                tween1[i] = t2;
                break;
              }
            }
            if (i === n2)
              tween1.push(t2);
          }
          schedule2.tween = tween1;
        };
      }
      function transition_tween(name, value) {
        var id2 = this._id;
        name += "";
        if (arguments.length < 2) {
          var tween = get4(this.node(), id2).tween;
          for (var i = 0, n2 = tween.length, t2; i < n2; ++i) {
            if ((t2 = tween[i]).name === name) {
              return t2.value;
            }
          }
          return null;
        }
        return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
      }
      function tweenValue(transition2, name, value) {
        var id2 = transition2._id;
        transition2.each(function() {
          var schedule2 = set2(this, id2);
          (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
        });
        return function(node2) {
          return get4(node2, id2).value[name];
        };
      }
      function interpolate(a, b) {
        var c;
        return (typeof b === "number" ? d3Interpolate.interpolateNumber : b instanceof d3Color.color ? d3Interpolate.interpolateRgb : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb) : d3Interpolate.interpolateString)(a, b);
      }
      function attrRemove(name) {
        return function() {
          this.removeAttribute(name);
        };
      }
      function attrRemoveNS(fullname) {
        return function() {
          this.removeAttributeNS(fullname.space, fullname.local);
        };
      }
      function attrConstant(name, interpolate2, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function() {
          var string0 = this.getAttribute(name);
          return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
        };
      }
      function attrConstantNS(fullname, interpolate2, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function() {
          var string0 = this.getAttributeNS(fullname.space, fullname.local);
          return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
        };
      }
      function attrFunction(name, interpolate2, value) {
        var string00, string10, interpolate0;
        return function() {
          var string0, value1 = value(this), string1;
          if (value1 == null)
            return void this.removeAttribute(name);
          string0 = this.getAttribute(name);
          string1 = value1 + "";
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
        };
      }
      function attrFunctionNS(fullname, interpolate2, value) {
        var string00, string10, interpolate0;
        return function() {
          var string0, value1 = value(this), string1;
          if (value1 == null)
            return void this.removeAttributeNS(fullname.space, fullname.local);
          string0 = this.getAttributeNS(fullname.space, fullname.local);
          string1 = value1 + "";
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
        };
      }
      function transition_attr(name, value) {
        var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
        return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
      }
      function attrInterpolate(name, i) {
        return function(t2) {
          this.setAttribute(name, i.call(this, t2));
        };
      }
      function attrInterpolateNS(fullname, i) {
        return function(t2) {
          this.setAttributeNS(fullname.space, fullname.local, i.call(this, t2));
        };
      }
      function attrTweenNS(fullname, value) {
        var t0, i0;
        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0)
            t0 = (i0 = i) && attrInterpolateNS(fullname, i);
          return t0;
        }
        tween._value = value;
        return tween;
      }
      function attrTween(name, value) {
        var t0, i0;
        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0)
            t0 = (i0 = i) && attrInterpolate(name, i);
          return t0;
        }
        tween._value = value;
        return tween;
      }
      function transition_attrTween(name, value) {
        var key = "attr." + name;
        if (arguments.length < 2)
          return (key = this.tween(key)) && key._value;
        if (value == null)
          return this.tween(key, null);
        if (typeof value !== "function")
          throw new Error();
        var fullname = d3Selection.namespace(name);
        return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
      }
      function delayFunction(id2, value) {
        return function() {
          init2(this, id2).delay = +value.apply(this, arguments);
        };
      }
      function delayConstant(id2, value) {
        return value = +value, function() {
          init2(this, id2).delay = value;
        };
      }
      function transition_delay(value) {
        var id2 = this._id;
        return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get4(this.node(), id2).delay;
      }
      function durationFunction(id2, value) {
        return function() {
          set2(this, id2).duration = +value.apply(this, arguments);
        };
      }
      function durationConstant(id2, value) {
        return value = +value, function() {
          set2(this, id2).duration = value;
        };
      }
      function transition_duration(value) {
        var id2 = this._id;
        return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get4(this.node(), id2).duration;
      }
      function easeConstant(id2, value) {
        if (typeof value !== "function")
          throw new Error();
        return function() {
          set2(this, id2).ease = value;
        };
      }
      function transition_ease(value) {
        var id2 = this._id;
        return arguments.length ? this.each(easeConstant(id2, value)) : get4(this.node(), id2).ease;
      }
      function easeVarying(id2, value) {
        return function() {
          var v = value.apply(this, arguments);
          if (typeof v !== "function")
            throw new Error();
          set2(this, id2).ease = v;
        };
      }
      function transition_easeVarying(value) {
        if (typeof value !== "function")
          throw new Error();
        return this.each(easeVarying(this._id, value));
      }
      function transition_filter(match3) {
        if (typeof match3 !== "function")
          match3 = d3Selection.matcher(match3);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n2; ++i) {
            if ((node2 = group[i]) && match3.call(node2, node2.__data__, i, group)) {
              subgroup.push(node2);
            }
          }
        }
        return new Transition(subgroups, this._parents, this._name, this._id);
      }
      function transition_merge(transition2) {
        if (transition2._id !== this._id)
          throw new Error();
        for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
          for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge3 = merges[j] = new Array(n2), node2, i = 0; i < n2; ++i) {
            if (node2 = group0[i] || group1[i]) {
              merge3[i] = node2;
            }
          }
        }
        for (; j < m0; ++j) {
          merges[j] = groups0[j];
        }
        return new Transition(merges, this._parents, this._name, this._id);
      }
      function start3(name) {
        return (name + "").trim().split(/^|\s+/).every(function(t2) {
          var i = t2.indexOf(".");
          if (i >= 0)
            t2 = t2.slice(0, i);
          return !t2 || t2 === "start";
        });
      }
      function onFunction(id2, name, listener3) {
        var on0, on1, sit = start3(name) ? init2 : set2;
        return function() {
          var schedule2 = sit(this, id2), on = schedule2.on;
          if (on !== on0)
            (on1 = (on0 = on).copy()).on(name, listener3);
          schedule2.on = on1;
        };
      }
      function transition_on(name, listener3) {
        var id2 = this._id;
        return arguments.length < 2 ? get4(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener3));
      }
      function removeFunction(id2) {
        return function() {
          var parent = this.parentNode;
          for (var i in this.__transition)
            if (+i !== id2)
              return;
          if (parent)
            parent.removeChild(this);
        };
      }
      function transition_remove() {
        return this.on("end.remove", removeFunction(this._id));
      }
      function transition_select(select) {
        var name = this._name, id2 = this._id;
        if (typeof select !== "function")
          select = d3Selection.selector(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node2, subnode, i = 0; i < n2; ++i) {
            if ((node2 = group[i]) && (subnode = select.call(node2, node2.__data__, i, group))) {
              if ("__data__" in node2)
                subnode.__data__ = node2.__data__;
              subgroup[i] = subnode;
              schedule(subgroup[i], name, id2, i, subgroup, get4(node2, id2));
            }
          }
        }
        return new Transition(subgroups, this._parents, name, id2);
      }
      function transition_selectAll(select) {
        var name = this._name, id2 = this._id;
        if (typeof select !== "function")
          select = d3Selection.selectorAll(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, node2, i = 0; i < n2; ++i) {
            if (node2 = group[i]) {
              for (var children = select.call(node2, node2.__data__, i, group), child, inherit2 = get4(node2, id2), k = 0, l2 = children.length; k < l2; ++k) {
                if (child = children[k]) {
                  schedule(child, name, id2, k, children, inherit2);
                }
              }
              subgroups.push(children);
              parents.push(node2);
            }
          }
        }
        return new Transition(subgroups, parents, name, id2);
      }
      var Selection = d3Selection.selection.prototype.constructor;
      function transition_selection() {
        return new Selection(this._groups, this._parents);
      }
      function styleNull(name, interpolate2) {
        var string00, string10, interpolate0;
        return function() {
          var string0 = d3Selection.style(this, name), string1 = (this.style.removeProperty(name), d3Selection.style(this, name));
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
        };
      }
      function styleRemove(name) {
        return function() {
          this.style.removeProperty(name);
        };
      }
      function styleConstant(name, interpolate2, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function() {
          var string0 = d3Selection.style(this, name);
          return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
        };
      }
      function styleFunction(name, interpolate2, value) {
        var string00, string10, interpolate0;
        return function() {
          var string0 = d3Selection.style(this, name), value1 = value(this), string1 = value1 + "";
          if (value1 == null)
            string1 = value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
          return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
        };
      }
      function styleMaybeRemove(id2, name) {
        var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
        return function() {
          var schedule2 = set2(this, id2), on = schedule2.on, listener3 = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
          if (on !== on0 || listener0 !== listener3)
            (on1 = (on0 = on).copy()).on(event, listener0 = listener3);
          schedule2.on = on1;
        };
      }
      function transition_style(name, value, priority) {
        var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
        return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
      }
      function styleInterpolate(name, i, priority) {
        return function(t2) {
          this.style.setProperty(name, i.call(this, t2), priority);
        };
      }
      function styleTween(name, value, priority) {
        var t2, i0;
        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0)
            t2 = (i0 = i) && styleInterpolate(name, i, priority);
          return t2;
        }
        tween._value = value;
        return tween;
      }
      function transition_styleTween(name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2)
          return (key = this.tween(key)) && key._value;
        if (value == null)
          return this.tween(key, null);
        if (typeof value !== "function")
          throw new Error();
        return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
      }
      function textConstant(value) {
        return function() {
          this.textContent = value;
        };
      }
      function textFunction(value) {
        return function() {
          var value1 = value(this);
          this.textContent = value1 == null ? "" : value1;
        };
      }
      function transition_text(value) {
        return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
      }
      function textInterpolate(i) {
        return function(t2) {
          this.textContent = i.call(this, t2);
        };
      }
      function textTween(value) {
        var t0, i0;
        function tween() {
          var i = value.apply(this, arguments);
          if (i !== i0)
            t0 = (i0 = i) && textInterpolate(i);
          return t0;
        }
        tween._value = value;
        return tween;
      }
      function transition_textTween(value) {
        var key = "text";
        if (arguments.length < 1)
          return (key = this.tween(key)) && key._value;
        if (value == null)
          return this.tween(key, null);
        if (typeof value !== "function")
          throw new Error();
        return this.tween(key, textTween(value));
      }
      function transition_transition() {
        var name = this._name, id0 = this._id, id1 = newId();
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, node2, i = 0; i < n2; ++i) {
            if (node2 = group[i]) {
              var inherit2 = get4(node2, id0);
              schedule(node2, name, id1, i, group, {
                time: inherit2.time + inherit2.delay + inherit2.duration,
                delay: 0,
                duration: inherit2.duration,
                ease: inherit2.ease
              });
            }
          }
        }
        return new Transition(groups, this._parents, name, id1);
      }
      function transition_end() {
        var on0, on1, that = this, id2 = that._id, size = that.size();
        return new Promise(function(resolve, reject) {
          var cancel = { value: reject }, end4 = { value: function() {
            if (--size === 0)
              resolve();
          } };
          that.each(function() {
            var schedule2 = set2(this, id2), on = schedule2.on;
            if (on !== on0) {
              on1 = (on0 = on).copy();
              on1._.cancel.push(cancel);
              on1._.interrupt.push(cancel);
              on1._.end.push(end4);
            }
            schedule2.on = on1;
          });
          if (size === 0)
            resolve();
        });
      }
      var id = 0;
      function Transition(groups, parents, name, id2) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id2;
      }
      function transition(name) {
        return d3Selection.selection().transition(name);
      }
      function newId() {
        return ++id;
      }
      var selection_prototype = d3Selection.selection.prototype;
      Transition.prototype = transition.prototype = {
        constructor: Transition,
        select: transition_select,
        selectAll: transition_selectAll,
        filter: transition_filter,
        merge: transition_merge,
        selection: transition_selection,
        transition: transition_transition,
        call: selection_prototype.call,
        nodes: selection_prototype.nodes,
        node: selection_prototype.node,
        size: selection_prototype.size,
        empty: selection_prototype.empty,
        each: selection_prototype.each,
        on: transition_on,
        attr: transition_attr,
        attrTween: transition_attrTween,
        style: transition_style,
        styleTween: transition_styleTween,
        text: transition_text,
        textTween: transition_textTween,
        remove: transition_remove,
        tween: transition_tween,
        delay: transition_delay,
        duration: transition_duration,
        ease: transition_ease,
        easeVarying: transition_easeVarying,
        end: transition_end,
        [Symbol.iterator]: selection_prototype[Symbol.iterator]
      };
      var defaultTiming = {
        time: null,
        delay: 0,
        duration: 250,
        ease: d3Ease.easeCubicInOut
      };
      function inherit(node2, id2) {
        var timing;
        while (!(timing = node2.__transition) || !(timing = timing[id2])) {
          if (!(node2 = node2.parentNode)) {
            throw new Error(`transition ${id2} not found`);
          }
        }
        return timing;
      }
      function selection_transition(name) {
        var id2, timing;
        if (name instanceof Transition) {
          id2 = name._id, name = name._name;
        } else {
          id2 = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
        }
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
          for (var group = groups[j], n2 = group.length, node2, i = 0; i < n2; ++i) {
            if (node2 = group[i]) {
              schedule(node2, name, id2, i, group, timing || inherit(node2, id2));
            }
          }
        }
        return new Transition(groups, this._parents, name, id2);
      }
      d3Selection.selection.prototype.interrupt = selection_interrupt;
      d3Selection.selection.prototype.transition = selection_transition;
      var root3 = [null];
      function active(node2, name) {
        var schedules = node2.__transition, schedule2, i;
        if (schedules) {
          name = name == null ? null : name + "";
          for (i in schedules) {
            if ((schedule2 = schedules[i]).state > SCHEDULED && schedule2.name === name) {
              return new Transition([[node2]], root3, name, +i);
            }
          }
        }
        return null;
      }
      exports2.active = active;
      exports2.interrupt = interrupt;
      exports2.transition = transition;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/d3-zoom/dist/d3-zoom.js
var require_d3_zoom = __commonJS({
  "node_modules/d3-zoom/dist/d3-zoom.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_d3_dispatch(), require_d3_drag(), require_d3_interpolate(), require_d3_selection(), require_d3_transition()) : typeof define === "function" && define.amd ? define(["exports", "d3-dispatch", "d3-drag", "d3-interpolate", "d3-selection", "d3-transition"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3, global2.d3, global2.d3, global2.d3, global2.d3));
    })(exports, function(exports2, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) {
      "use strict";
      var constant = (x) => () => x;
      function ZoomEvent(type2, {
        sourceEvent,
        target,
        transform: transform2,
        dispatch
      }) {
        Object.defineProperties(this, {
          type: { value: type2, enumerable: true, configurable: true },
          sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
          target: { value: target, enumerable: true, configurable: true },
          transform: { value: transform2, enumerable: true, configurable: true },
          _: { value: dispatch }
        });
      }
      function Transform(k, x, y) {
        this.k = k;
        this.x = x;
        this.y = y;
      }
      Transform.prototype = {
        constructor: Transform,
        scale: function(k) {
          return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
        },
        translate: function(x, y) {
          return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
        },
        apply: function(point5) {
          return [point5[0] * this.k + this.x, point5[1] * this.k + this.y];
        },
        applyX: function(x) {
          return x * this.k + this.x;
        },
        applyY: function(y) {
          return y * this.k + this.y;
        },
        invert: function(location3) {
          return [(location3[0] - this.x) / this.k, (location3[1] - this.y) / this.k];
        },
        invertX: function(x) {
          return (x - this.x) / this.k;
        },
        invertY: function(y) {
          return (y - this.y) / this.k;
        },
        rescaleX: function(x) {
          return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
        },
        rescaleY: function(y) {
          return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
        },
        toString: function() {
          return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
        }
      };
      var identity = new Transform(1, 0, 0);
      transform.prototype = Transform.prototype;
      function transform(node2) {
        while (!node2.__zoom)
          if (!(node2 = node2.parentNode))
            return identity;
        return node2.__zoom;
      }
      function nopropagation(event) {
        event.stopImmediatePropagation();
      }
      function noevent(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
      function defaultFilter(event) {
        return (!event.ctrlKey || event.type === "wheel") && !event.button;
      }
      function defaultExtent() {
        var e2 = this;
        if (e2 instanceof SVGElement) {
          e2 = e2.ownerSVGElement || e2;
          if (e2.hasAttribute("viewBox")) {
            e2 = e2.viewBox.baseVal;
            return [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]];
          }
          return [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]];
        }
        return [[0, 0], [e2.clientWidth, e2.clientHeight]];
      }
      function defaultTransform() {
        return this.__zoom || identity;
      }
      function defaultWheelDelta(event) {
        return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
      }
      function defaultTouchable() {
        return navigator.maxTouchPoints || "ontouchstart" in this;
      }
      function defaultConstrain(transform2, extent, translateExtent) {
        var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
        return transform2.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
      }
      function zoom() {
        var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration2 = 250, interpolate = d3Interpolate.interpolateZoom, listeners = d3Dispatch.dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
        function zoom2(selection) {
          selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
        }
        zoom2.transform = function(collection, transform2, point5, event) {
          var selection = collection.selection ? collection.selection() : collection;
          selection.property("__zoom", defaultTransform);
          if (collection !== selection) {
            schedule(collection, transform2, point5, event);
          } else {
            selection.interrupt().each(function() {
              gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
            });
          }
        };
        zoom2.scaleBy = function(selection, k, p2, event) {
          zoom2.scaleTo(selection, function() {
            var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return k0 * k1;
          }, p2, event);
        };
        zoom2.scaleTo = function(selection, k, p2, event) {
          zoom2.transform(selection, function() {
            var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
            return constrain(translate(scale(t0, k1), p0, p1), e2, translateExtent);
          }, p2, event);
        };
        zoom2.translateBy = function(selection, x, y, event) {
          zoom2.transform(selection, function() {
            return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
          }, null, event);
        };
        zoom2.translateTo = function(selection, x, y, p2, event) {
          zoom2.transform(selection, function() {
            var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
            return constrain(identity.translate(p0[0], p0[1]).scale(t2.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e2, translateExtent);
          }, p2, event);
        };
        function scale(transform2, k) {
          k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
          return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
        }
        function translate(transform2, p0, p1) {
          var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
          return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
        }
        function centroid(extent2) {
          return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
        }
        function schedule(transition, transform2, point5, event) {
          transition.on("start.zoom", function() {
            gesture(this, arguments).event(event).start();
          }).on("interrupt.zoom end.zoom", function() {
            gesture(this, arguments).event(event).end();
          }).tween("zoom", function() {
            var that = this, args = arguments, g = gesture(that, args).event(event), e2 = extent.apply(that, args), p2 = point5 == null ? centroid(e2) : typeof point5 === "function" ? point5.apply(that, args) : point5, w2 = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p2).concat(w2 / a.k), b.invert(p2).concat(w2 / b.k));
            return function(t2) {
              if (t2 === 1)
                t2 = b;
              else {
                var l2 = i(t2), k = w2 / l2[2];
                t2 = new Transform(k, p2[0] - l2[0] * k, p2[1] - l2[1] * k);
              }
              g.zoom(null, t2);
            };
          });
        }
        function gesture(that, args, clean5) {
          return !clean5 && that.__zooming || new Gesture(that, args);
        }
        function Gesture(that, args) {
          this.that = that;
          this.args = args;
          this.active = 0;
          this.sourceEvent = null;
          this.extent = extent.apply(that, args);
          this.taps = 0;
        }
        Gesture.prototype = {
          event: function(event) {
            if (event)
              this.sourceEvent = event;
            return this;
          },
          start: function() {
            if (++this.active === 1) {
              this.that.__zooming = this;
              this.emit("start");
            }
            return this;
          },
          zoom: function(key, transform2) {
            if (this.mouse && key !== "mouse")
              this.mouse[1] = transform2.invert(this.mouse[0]);
            if (this.touch0 && key !== "touch")
              this.touch0[1] = transform2.invert(this.touch0[0]);
            if (this.touch1 && key !== "touch")
              this.touch1[1] = transform2.invert(this.touch1[0]);
            this.that.__zoom = transform2;
            this.emit("zoom");
            return this;
          },
          end: function() {
            if (--this.active === 0) {
              delete this.that.__zooming;
              this.emit("end");
            }
            return this;
          },
          emit: function(type2) {
            var d2 = d3Selection.select(this.that).datum();
            listeners.call(type2, this.that, new ZoomEvent(type2, {
              sourceEvent: this.sourceEvent,
              target: zoom2,
              type: type2,
              transform: this.that.__zoom,
              dispatch: listeners
            }), d2);
          }
        };
        function wheeled(event, ...args) {
          if (!filter2.apply(this, arguments))
            return;
          var g = gesture(this, args).event(event), t2 = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = d3Selection.pointer(event);
          if (g.wheel) {
            if (g.mouse[0][0] !== p2[0] || g.mouse[0][1] !== p2[1]) {
              g.mouse[1] = t2.invert(g.mouse[0] = p2);
            }
            clearTimeout(g.wheel);
          } else if (t2.k === k)
            return;
          else {
            g.mouse = [p2, t2.invert(p2)];
            d3Transition.interrupt(this);
            g.start();
          }
          noevent(event);
          g.wheel = setTimeout(wheelidled, wheelDelay);
          g.zoom("mouse", constrain(translate(scale(t2, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
          function wheelidled() {
            g.wheel = null;
            g.end();
          }
        }
        function mousedowned(event, ...args) {
          if (touchending || !filter2.apply(this, arguments))
            return;
          var g = gesture(this, args, true).event(event), v = d3Selection.select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = d3Selection.pointer(event, currentTarget), currentTarget = event.currentTarget, x0 = event.clientX, y0 = event.clientY;
          d3Drag.dragDisable(event.view);
          nopropagation(event);
          g.mouse = [p2, this.__zoom.invert(p2)];
          d3Transition.interrupt(this);
          g.start();
          function mousemoved(event2) {
            noevent(event2);
            if (!g.moved) {
              var dx = event2.clientX - x0, dy = event2.clientY - y0;
              g.moved = dx * dx + dy * dy > clickDistance2;
            }
            g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
          }
          function mouseupped(event2) {
            v.on("mousemove.zoom mouseup.zoom", null);
            d3Drag.dragEnable(event2.view, g.moved);
            noevent(event2);
            g.event(event2).end();
          }
        }
        function dblclicked(event, ...args) {
          if (!filter2.apply(this, arguments))
            return;
          var t0 = this.__zoom, p0 = d3Selection.pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
          noevent(event);
          if (duration2 > 0)
            d3Selection.select(this).transition().duration(duration2).call(schedule, t1, p0, event);
          else
            d3Selection.select(this).call(zoom2.transform, t1, p0, event);
        }
        function touchstarted(event, ...args) {
          if (!filter2.apply(this, arguments))
            return;
          var touches = event.touches, n2 = touches.length, g = gesture(this, args, event.changedTouches.length === n2).event(event), started, i, t2, p2;
          nopropagation(event);
          for (i = 0; i < n2; ++i) {
            t2 = touches[i], p2 = d3Selection.pointer(t2, this);
            p2 = [p2, this.__zoom.invert(p2), t2.identifier];
            if (!g.touch0)
              g.touch0 = p2, started = true, g.taps = 1 + !!touchstarting;
            else if (!g.touch1 && g.touch0[2] !== p2[2])
              g.touch1 = p2, g.taps = 0;
          }
          if (touchstarting)
            touchstarting = clearTimeout(touchstarting);
          if (started) {
            if (g.taps < 2)
              touchfirst = p2[0], touchstarting = setTimeout(function() {
                touchstarting = null;
              }, touchDelay);
            d3Transition.interrupt(this);
            g.start();
          }
        }
        function touchmoved(event, ...args) {
          if (!this.__zooming)
            return;
          var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i, t2, p2, l2;
          noevent(event);
          for (i = 0; i < n2; ++i) {
            t2 = touches[i], p2 = d3Selection.pointer(t2, this);
            if (g.touch0 && g.touch0[2] === t2.identifier)
              g.touch0[0] = p2;
            else if (g.touch1 && g.touch1[2] === t2.identifier)
              g.touch1[0] = p2;
          }
          t2 = g.that.__zoom;
          if (g.touch1) {
            var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
            t2 = scale(t2, Math.sqrt(dp / dl));
            p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
            l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
          } else if (g.touch0)
            p2 = g.touch0[0], l2 = g.touch0[1];
          else
            return;
          g.zoom("touch", constrain(translate(t2, p2, l2), g.extent, translateExtent));
        }
        function touchended(event, ...args) {
          if (!this.__zooming)
            return;
          var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i, t2;
          nopropagation(event);
          if (touchending)
            clearTimeout(touchending);
          touchending = setTimeout(function() {
            touchending = null;
          }, touchDelay);
          for (i = 0; i < n2; ++i) {
            t2 = touches[i];
            if (g.touch0 && g.touch0[2] === t2.identifier)
              delete g.touch0;
            else if (g.touch1 && g.touch1[2] === t2.identifier)
              delete g.touch1;
          }
          if (g.touch1 && !g.touch0)
            g.touch0 = g.touch1, delete g.touch1;
          if (g.touch0)
            g.touch0[1] = this.__zoom.invert(g.touch0[0]);
          else {
            g.end();
            if (g.taps === 2) {
              t2 = d3Selection.pointer(t2, this);
              if (Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance) {
                var p2 = d3Selection.select(this).on("dblclick.zoom");
                if (p2)
                  p2.apply(this, arguments);
              }
            }
          }
        }
        zoom2.wheelDelta = function(_2) {
          return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant(+_2), zoom2) : wheelDelta;
        };
        zoom2.filter = function(_2) {
          return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : filter2;
        };
        zoom2.touchable = function(_2) {
          return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : touchable;
        };
        zoom2.extent = function(_2) {
          return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent;
        };
        zoom2.scaleExtent = function(_2) {
          return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
        };
        zoom2.translateExtent = function(_2) {
          return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
        };
        zoom2.constrain = function(_2) {
          return arguments.length ? (constrain = _2, zoom2) : constrain;
        };
        zoom2.duration = function(_2) {
          return arguments.length ? (duration2 = +_2, zoom2) : duration2;
        };
        zoom2.interpolate = function(_2) {
          return arguments.length ? (interpolate = _2, zoom2) : interpolate;
        };
        zoom2.on = function() {
          var value = listeners.on.apply(listeners, arguments);
          return value === listeners ? zoom2 : value;
        };
        zoom2.clickDistance = function(_2) {
          return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
        };
        zoom2.tapDistance = function(_2) {
          return arguments.length ? (tapDistance = +_2, zoom2) : tapDistance;
        };
        return zoom2;
      }
      exports2.zoom = zoom;
      exports2.zoomIdentity = identity;
      exports2.zoomTransform = transform;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/react-simple-maps/dist/index.umd.js
var require_index_umd = __commonJS({
  "node_modules/react-simple-maps/dist/index.umd.js"(exports, module2) {
    !function(e2, t2) {
      typeof exports == "object" && typeof module2 != "undefined" ? t2(exports, require_react(), require_prop_types(), require_d3_geo(), require_topojson_client(), require_d3_zoom(), require_d3_selection()) : typeof define == "function" && define.amd ? define(["exports", "react", "prop-types", "d3-geo", "topojson-client", "d3-zoom", "d3-selection"], t2) : t2((e2 = typeof globalThis != "undefined" ? globalThis : e2 || self).reactSimpleMaps = e2.reactSimpleMaps || {}, e2.React, e2.PropTypes, e2.d3, e2.topojson, e2.d3, e2.d3);
    }(exports, function(e2, t2, r, o, n2, a, u) {
      "use strict";
      function s3(e3) {
        return e3 && typeof e3 == "object" && "default" in e3 ? e3 : { default: e3 };
      }
      function l2(e3) {
        if (e3 && e3.__esModule)
          return e3;
        var t3 = /* @__PURE__ */ Object.create(null);
        return e3 && Object.keys(e3).forEach(function(r2) {
          if (r2 !== "default") {
            var o2 = Object.getOwnPropertyDescriptor(e3, r2);
            Object.defineProperty(t3, r2, o2.get ? o2 : { enumerable: true, get: function() {
              return e3[r2];
            } });
          }
        }), t3.default = e3, Object.freeze(t3);
      }
      var i = s3(t2), c = s3(r), f = l2(o);
      function d2(e3, t3) {
        var r2 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e3);
          t3 && (o2 = o2.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), r2.push.apply(r2, o2);
        }
        return r2;
      }
      function p2(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r2 = arguments[t3] != null ? arguments[t3] : {};
          t3 % 2 ? d2(Object(r2), true).forEach(function(t4) {
            y(e3, t4, r2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : d2(Object(r2)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r2, t4));
          });
        }
        return e3;
      }
      function m(e3) {
        return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, m(e3);
      }
      function y(e3, t3, r2) {
        return t3 in e3 ? Object.defineProperty(e3, t3, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t3] = r2, e3;
      }
      function g() {
        return g = Object.assign ? Object.assign.bind() : function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r2 = arguments[t3];
            for (var o2 in r2)
              Object.prototype.hasOwnProperty.call(r2, o2) && (e3[o2] = r2[o2]);
          }
          return e3;
        }, g.apply(this, arguments);
      }
      function v(e3, t3) {
        if (e3 == null)
          return {};
        var r2, o2, n3 = function(e4, t4) {
          if (e4 == null)
            return {};
          var r3, o3, n4 = {}, a3 = Object.keys(e4);
          for (o3 = 0; o3 < a3.length; o3++)
            r3 = a3[o3], t4.indexOf(r3) >= 0 || (n4[r3] = e4[r3]);
          return n4;
        }(e3, t3);
        if (Object.getOwnPropertySymbols) {
          var a2 = Object.getOwnPropertySymbols(e3);
          for (o2 = 0; o2 < a2.length; o2++)
            r2 = a2[o2], t3.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, r2) && (n3[r2] = e3[r2]);
        }
        return n3;
      }
      function h2(e3, t3) {
        return function(e4) {
          if (Array.isArray(e4))
            return e4;
        }(e3) || function(e4, t4) {
          var r2 = e4 == null ? null : typeof Symbol != "undefined" && e4[Symbol.iterator] || e4["@@iterator"];
          if (r2 == null)
            return;
          var o2, n3, a2 = [], u2 = true, s4 = false;
          try {
            for (r2 = r2.call(e4); !(u2 = (o2 = r2.next()).done) && (a2.push(o2.value), !t4 || a2.length !== t4); u2 = true)
              ;
          } catch (e5) {
            s4 = true, n3 = e5;
          } finally {
            try {
              u2 || r2.return == null || r2.return();
            } finally {
              if (s4)
                throw n3;
            }
          }
          return a2;
        }(e3, t3) || function(e4, t4) {
          if (!e4)
            return;
          if (typeof e4 == "string")
            return b(e4, t4);
          var r2 = Object.prototype.toString.call(e4).slice(8, -1);
          r2 === "Object" && e4.constructor && (r2 = e4.constructor.name);
          if (r2 === "Map" || r2 === "Set")
            return Array.from(e4);
          if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
            return b(e4, t4);
        }(e3, t3) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function b(e3, t3) {
        (t3 == null || t3 > e3.length) && (t3 = e3.length);
        for (var r2 = 0, o2 = new Array(t3); r2 < t3; r2++)
          o2[r2] = e3[r2];
        return o2;
      }
      var j = ["width", "height", "projection", "projectionConfig"], M = f.geoPath, E = v(f, ["geoPath"]), x = t2.createContext(), k = function(e3) {
        var r2 = e3.width, o2 = e3.height, n3 = e3.projection, a2 = e3.projectionConfig, u2 = v(e3, j), s4 = h2(a2.center || [], 2), l3 = s4[0], c2 = s4[1], f2 = h2(a2.rotate || [], 3), d3 = f2[0], p3 = f2[1], m2 = f2[2], y2 = h2(a2.parallels || [], 2), b2 = y2[0], k2 = y2[1], w3 = a2.scale || null, O2 = t2.useMemo(function() {
          return function(e4) {
            var t3 = e4.projectionConfig, r3 = t3 === void 0 ? {} : t3, o3 = e4.projection, n4 = o3 === void 0 ? "geoEqualEarth" : o3, a3 = e4.width, u3 = a3 === void 0 ? 800 : a3, s5 = e4.height, l4 = s5 === void 0 ? 600 : s5;
            if (typeof n4 == "function")
              return n4;
            var i2 = E[n4]().translate([u3 / 2, l4 / 2]);
            return [i2.center ? "center" : null, i2.rotate ? "rotate" : null, i2.scale ? "scale" : null, i2.parallels ? "parallels" : null].forEach(function(e5) {
              e5 && (i2 = i2[e5](r3[e5] || i2[e5]()));
            }), i2;
          }({ projectionConfig: { center: l3 || l3 === 0 || c2 || c2 === 0 ? [l3, c2] : null, rotate: d3 || d3 === 0 || p3 || p3 === 0 ? [d3, p3, m2] : null, parallels: b2 || b2 === 0 || k2 || k2 === 0 ? [b2, k2] : null, scale: w3 }, projection: n3, width: r2, height: o2 });
        }, [r2, o2, n3, l3, c2, d3, p3, m2, b2, k2, w3]), N2 = t2.useCallback(O2, [O2]), S2 = t2.useMemo(function() {
          return { width: r2, height: o2, projection: N2, path: M().projection(N2) };
        }, [r2, o2, N2]);
        return i.default.createElement(x.Provider, g({ value: S2 }, u2));
      };
      k.propTypes = { width: c.default.number, height: c.default.number, projection: c.default.oneOfType([c.default.string, c.default.func]), projectionConfig: c.default.object };
      var w2 = ["width", "height", "projection", "projectionConfig", "className"], O = t2.forwardRef(function(e3, t3) {
        var r2 = e3.width, o2 = r2 === void 0 ? 800 : r2, n3 = e3.height, a2 = n3 === void 0 ? 600 : n3, u2 = e3.projection, s4 = u2 === void 0 ? "geoEqualEarth" : u2, l3 = e3.projectionConfig, c2 = l3 === void 0 ? {} : l3, f2 = e3.className, d3 = f2 === void 0 ? "" : f2, p3 = v(e3, w2);
        return i.default.createElement(k, { width: o2, height: a2, projection: s4, projectionConfig: c2 }, i.default.createElement("svg", g({ ref: t3, viewBox: "0 0 ".concat(o2, " ").concat(a2), className: "rsm-svg ".concat(d3) }, p3)));
      });
      function N(e3, t3, r2) {
        var o2 = (e3 * r2.k - e3) / 2, n3 = (t3 * r2.k - t3) / 2;
        return [e3 / 2 - (o2 + r2.x) / r2.k, t3 / 2 - (n3 + r2.y) / r2.k];
      }
      function S(e3, t3) {
        if (!(e3.type === "Topology"))
          return t3 ? t3(e3.features || e3) : e3.features || e3;
        var r2 = n2.feature(e3, e3.objects[Object.keys(e3.objects)[0]]).features;
        return t3 ? t3(r2) : r2;
      }
      function P(e3) {
        return e3.type === "Topology" ? { outline: n2.mesh(e3, e3.objects[Object.keys(e3.objects)[0]], function(e4, t3) {
          return e4 === t3;
        }), borders: n2.mesh(e3, e3.objects[Object.keys(e3.objects)[0]], function(e4, t3) {
          return e4 !== t3;
        }) } : null;
      }
      function C(e3, t3) {
        return e3 ? e3.map(function(e4, r2) {
          return p2(p2({}, e4), {}, { rsmKey: "geo-".concat(r2), svgPath: t3(e4) });
        }) : [];
      }
      function T(e3) {
        var r2 = e3.geography, o2 = e3.parseGeographies, n3 = t2.useContext(x).path, a2 = h2(t2.useState({}), 2), u2 = a2[0], s4 = a2[1];
        t2.useEffect(function() {
          var e4;
          (typeof window == "undefined" ? "undefined" : m(window)) !== "undefined" && (r2 && (typeof r2 == "string" ? (e4 = r2, fetch(e4).then(function(e5) {
            if (!e5.ok)
              throw Error(e5.statusText);
            return e5.json();
          }).catch(function(e5) {
            console.log("There was a problem when fetching the data: ", e5);
          })).then(function(e5) {
            e5 && s4({ geographies: S(e5, o2), mesh: P(e5) });
          }) : s4({ geographies: S(r2, o2), mesh: P(r2) })));
        }, [r2, o2]);
        var l3 = t2.useMemo(function() {
          var e4 = u2.mesh || {}, t3 = function(e5, t4, r3) {
            return e5 && t4 ? { outline: p2(p2({}, e5), {}, { rsmKey: "outline", svgPath: r3(e5) }), borders: p2(p2({}, t4), {}, { rsmKey: "borders", svgPath: r3(t4) }) } : {};
          }(e4.outline, e4.borders, n3);
          return { geographies: C(u2.geographies, n3), outline: t3.outline, borders: t3.borders };
        }, [u2, n3]);
        return { geographies: l3.geographies, outline: l3.outline, borders: l3.borders };
      }
      O.displayName = "ComposableMap", O.propTypes = { width: c.default.number, height: c.default.number, projection: c.default.oneOfType([c.default.string, c.default.func]), projectionConfig: c.default.object, className: c.default.string };
      var R = ["geography", "children", "parseGeographies", "className"], Z = t2.forwardRef(function(e3, r2) {
        var o2 = e3.geography, n3 = e3.children, a2 = e3.parseGeographies, u2 = e3.className, s4 = u2 === void 0 ? "" : u2, l3 = v(e3, R), c2 = t2.useContext(x), f2 = c2.path, d3 = c2.projection, p3 = T({ geography: o2, parseGeographies: a2 }), m2 = p3.geographies, y2 = p3.outline, h3 = p3.borders;
        return i.default.createElement("g", g({ ref: r2, className: "rsm-geographies ".concat(s4) }, l3), m2 && m2.length > 0 && n3({ geographies: m2, outline: y2, borders: h3, path: f2, projection: d3 }));
      });
      Z.displayName = "Geographies", Z.propTypes = { geography: c.default.oneOfType([c.default.string, c.default.object, c.default.array]), children: c.default.func, parseGeographies: c.default.func, className: c.default.string };
      var z = ["geography", "onMouseEnter", "onMouseLeave", "onMouseDown", "onMouseUp", "onFocus", "onBlur", "style", "className"], G = t2.forwardRef(function(e3, r2) {
        var o2 = e3.geography, n3 = e3.onMouseEnter, a2 = e3.onMouseLeave, u2 = e3.onMouseDown, s4 = e3.onMouseUp, l3 = e3.onFocus, c2 = e3.onBlur, f2 = e3.style, d3 = f2 === void 0 ? {} : f2, p3 = e3.className, m2 = p3 === void 0 ? "" : p3, y2 = v(e3, z), b2 = h2(t2.useState(false), 2), j2 = b2[0], M2 = b2[1], E2 = h2(t2.useState(false), 2), x2 = E2[0], k2 = E2[1];
        return i.default.createElement("path", g({ ref: r2, tabIndex: "0", className: "rsm-geography ".concat(m2), d: o2.svgPath, onMouseEnter: function(e4) {
          k2(true), n3 && n3(e4);
        }, onMouseLeave: function(e4) {
          k2(false), j2 && M2(false), a2 && a2(e4);
        }, onFocus: function(e4) {
          k2(true), l3 && l3(e4);
        }, onBlur: function(e4) {
          k2(false), j2 && M2(false), c2 && c2(e4);
        }, onMouseDown: function(e4) {
          M2(true), u2 && u2(e4);
        }, onMouseUp: function(e4) {
          M2(false), s4 && s4(e4);
        }, style: d3[j2 || x2 ? j2 ? "pressed" : "hover" : "default"] }, y2));
      });
      G.displayName = "Geography", G.propTypes = { geography: c.default.object, onMouseEnter: c.default.func, onMouseLeave: c.default.func, onMouseDown: c.default.func, onMouseUp: c.default.func, onFocus: c.default.func, onBlur: c.default.func, style: c.default.object, className: c.default.string };
      var D = t2.memo(G), L = ["fill", "stroke", "step", "className"], A = t2.forwardRef(function(e3, r2) {
        var n3 = e3.fill, a2 = n3 === void 0 ? "transparent" : n3, u2 = e3.stroke, s4 = u2 === void 0 ? "currentcolor" : u2, l3 = e3.step, c2 = l3 === void 0 ? [10, 10] : l3, f2 = e3.className, d3 = f2 === void 0 ? "" : f2, p3 = v(e3, L), m2 = t2.useContext(x).path;
        return i.default.createElement("path", g({ ref: r2, d: m2(o.geoGraticule().step(c2)()), fill: a2, stroke: s4, className: "rsm-graticule ".concat(d3) }, p3));
      });
      A.displayName = "Graticule", A.propTypes = { fill: c.default.string, stroke: c.default.string, step: c.default.array, className: c.default.string };
      var B = t2.memo(A), F = ["value"], U = t2.createContext(), q = { x: 0, y: 0, k: 1, transformString: "translate(0 0) scale(1)" }, W = function(e3) {
        var t3 = e3.value, r2 = t3 === void 0 ? q : t3, o2 = v(e3, F);
        return i.default.createElement(U.Provider, g({ value: r2 }, o2));
      };
      W.propTypes = { x: c.default.number, y: c.default.number, k: c.default.number, transformString: c.default.string };
      function I(e3) {
        var r2 = e3.center, o2 = e3.filterZoomEvent, n3 = e3.onMoveStart, s4 = e3.onMoveEnd, l3 = e3.onMove, i2 = e3.translateExtent, c2 = i2 === void 0 ? [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]] : i2, f2 = e3.scaleExtent, d3 = f2 === void 0 ? [1, 8] : f2, p3 = e3.zoom, m2 = p3 === void 0 ? 1 : p3, y2 = t2.useContext(x), g2 = y2.width, v2 = y2.height, b2 = y2.projection, j2 = h2(r2, 2), M2 = j2[0], E2 = j2[1], k2 = h2(t2.useState({ x: 0, y: 0, k: 1 }), 2), w3 = k2[0], O2 = k2[1], S2 = t2.useRef({ x: 0, y: 0, k: 1 }), P2 = t2.useRef(), C2 = t2.useRef(), T2 = t2.useRef(false), R2 = h2(c2, 2), Z2 = R2[0], z2 = R2[1], G2 = h2(Z2, 2), D2 = G2[0], L2 = G2[1], A2 = h2(z2, 2), B2 = A2[0], F2 = A2[1], U2 = h2(d3, 2), q2 = U2[0], W2 = U2[1];
        return t2.useEffect(function() {
          var e4 = u.select(P2.current);
          var t3 = a.zoom().filter(function(e5) {
            return o2 ? o2(e5) : !!e5 && (!e5.ctrlKey && !e5.button);
          }).scaleExtent([q2, W2]).translateExtent([[D2, L2], [B2, F2]]).on("start", function(e5) {
            n3 && !T2.current && n3({ coordinates: b2.invert(N(g2, v2, e5.transform)), zoom: e5.transform.k }, e5);
          }).on("zoom", function(e5) {
            if (!T2.current) {
              var t4 = e5.transform, r3 = e5.sourceEvent;
              O2({ x: t4.x, y: t4.y, k: t4.k, dragging: r3 }), l3 && l3({ x: t4.x, y: t4.y, zoom: t4.k, dragging: r3 }, e5);
            }
          }).on("end", function(e5) {
            if (T2.current)
              T2.current = false;
            else {
              var t4 = h2(b2.invert(N(g2, v2, e5.transform)), 2), r3 = t4[0], o3 = t4[1];
              S2.current = { x: r3, y: o3, k: e5.transform.k }, s4 && s4({ coordinates: [r3, o3], zoom: e5.transform.k }, e5);
            }
          });
          C2.current = t3, e4.call(t3);
        }, [g2, v2, D2, L2, B2, F2, q2, W2, b2, n3, l3, s4, o2]), t2.useEffect(function() {
          if (M2 !== S2.current.x || E2 !== S2.current.y || m2 !== S2.current.k) {
            var e4 = b2([M2, E2]), t3 = e4[0] * m2, r3 = e4[1] * m2, o3 = u.select(P2.current);
            T2.current = true, o3.call(C2.current.transform, a.zoomIdentity.translate(g2 / 2 - t3, v2 / 2 - r3).scale(m2)), O2({ x: g2 / 2 - t3, y: v2 / 2 - r3, k: m2 }), S2.current = { x: M2, y: E2, k: m2 };
          }
        }, [M2, E2, m2, g2, v2, b2]), { mapRef: P2, position: w3, transformString: "translate(".concat(w3.x, " ").concat(w3.y, ") scale(").concat(w3.k, ")") };
      }
      var K = ["center", "zoom", "minZoom", "maxZoom", "translateExtent", "filterZoomEvent", "onMoveStart", "onMove", "onMoveEnd", "className"], _2 = t2.forwardRef(function(e3, r2) {
        var o2 = e3.center, n3 = o2 === void 0 ? [0, 0] : o2, a2 = e3.zoom, u2 = a2 === void 0 ? 1 : a2, s4 = e3.minZoom, l3 = s4 === void 0 ? 1 : s4, c2 = e3.maxZoom, f2 = c2 === void 0 ? 8 : c2, d3 = e3.translateExtent, p3 = e3.filterZoomEvent, m2 = e3.onMoveStart, y2 = e3.onMove, h3 = e3.onMoveEnd, b2 = e3.className, j2 = v(e3, K), M2 = t2.useContext(x), E2 = M2.width, k2 = M2.height, w3 = I({ center: n3, filterZoomEvent: p3, onMoveStart: m2, onMove: y2, onMoveEnd: h3, scaleExtent: [l3, f2], translateExtent: d3, zoom: u2 }), O2 = w3.mapRef, N2 = w3.transformString, S2 = w3.position;
        return i.default.createElement(W, { value: { x: S2.x, y: S2.y, k: S2.k, transformString: N2 } }, i.default.createElement("g", { ref: O2 }, i.default.createElement("rect", { width: E2, height: k2, fill: "transparent" }), i.default.createElement("g", g({ ref: r2, transform: N2, className: "rsm-zoomable-group ".concat(b2) }, j2))));
      });
      _2.displayName = "ZoomableGroup", _2.propTypes = { center: c.default.array, zoom: c.default.number, minZoom: c.default.number, maxZoom: c.default.number, translateExtent: c.default.arrayOf(c.default.array), onMoveStart: c.default.func, onMove: c.default.func, onMoveEnd: c.default.func, className: c.default.string };
      var Q = ["id", "fill", "stroke", "strokeWidth", "className"], $ = t2.forwardRef(function(e3, r2) {
        var o2 = e3.id, n3 = o2 === void 0 ? "rsm-sphere" : o2, a2 = e3.fill, u2 = a2 === void 0 ? "transparent" : a2, s4 = e3.stroke, l3 = s4 === void 0 ? "currentcolor" : s4, c2 = e3.strokeWidth, f2 = c2 === void 0 ? 0.5 : c2, d3 = e3.className, p3 = d3 === void 0 ? "" : d3, m2 = v(e3, Q), y2 = t2.useContext(x).path, h3 = t2.useMemo(function() {
          return y2({ type: "Sphere" });
        }, [y2]);
        return i.default.createElement(t2.Fragment, null, i.default.createElement("defs", null, i.default.createElement("clipPath", { id: n3 }, i.default.createElement("path", { d: h3 }))), i.default.createElement("path", g({ ref: r2, d: h3, fill: u2, stroke: l3, strokeWidth: f2, style: { pointerEvents: "none" }, className: "rsm-sphere ".concat(p3) }, m2)));
      });
      $.displayName = "Sphere", $.propTypes = { id: c.default.string, fill: c.default.string, stroke: c.default.string, strokeWidth: c.default.number, className: c.default.string };
      var H = t2.memo($), J = ["coordinates", "children", "onMouseEnter", "onMouseLeave", "onMouseDown", "onMouseUp", "onFocus", "onBlur", "style", "className"], V = t2.forwardRef(function(e3, r2) {
        var o2 = e3.coordinates, n3 = e3.children, a2 = e3.onMouseEnter, u2 = e3.onMouseLeave, s4 = e3.onMouseDown, l3 = e3.onMouseUp, c2 = e3.onFocus, f2 = e3.onBlur, d3 = e3.style, p3 = d3 === void 0 ? {} : d3, m2 = e3.className, y2 = m2 === void 0 ? "" : m2, b2 = v(e3, J), j2 = t2.useContext(x).projection, M2 = h2(t2.useState(false), 2), E2 = M2[0], k2 = M2[1], w3 = h2(t2.useState(false), 2), O2 = w3[0], N2 = w3[1], S2 = h2(j2(o2), 2), P2 = S2[0], C2 = S2[1];
        return i.default.createElement("g", g({ ref: r2, transform: "translate(".concat(P2, ", ").concat(C2, ")"), className: "rsm-marker ".concat(y2), onMouseEnter: function(e4) {
          N2(true), a2 && a2(e4);
        }, onMouseLeave: function(e4) {
          N2(false), E2 && k2(false), u2 && u2(e4);
        }, onFocus: function(e4) {
          N2(true), c2 && c2(e4);
        }, onBlur: function(e4) {
          N2(false), E2 && k2(false), f2 && f2(e4);
        }, onMouseDown: function(e4) {
          k2(true), s4 && s4(e4);
        }, onMouseUp: function(e4) {
          k2(false), l3 && l3(e4);
        }, style: p3[E2 || O2 ? E2 ? "pressed" : "hover" : "default"] }, b2), n3);
      });
      V.displayName = "Marker", V.propTypes = { coordinates: c.default.array, children: c.default.oneOfType([c.default.node, c.default.arrayOf(c.default.node)]), onMouseEnter: c.default.func, onMouseLeave: c.default.func, onMouseDown: c.default.func, onMouseUp: c.default.func, onFocus: c.default.func, onBlur: c.default.func, style: c.default.object, className: c.default.string };
      var X = ["from", "to", "coordinates", "stroke", "strokeWidth", "fill", "className"], Y = t2.forwardRef(function(e3, r2) {
        var o2 = e3.from, n3 = o2 === void 0 ? [0, 0] : o2, a2 = e3.to, u2 = a2 === void 0 ? [0, 0] : a2, s4 = e3.coordinates, l3 = e3.stroke, c2 = l3 === void 0 ? "currentcolor" : l3, f2 = e3.strokeWidth, d3 = f2 === void 0 ? 3 : f2, p3 = e3.fill, m2 = p3 === void 0 ? "transparent" : p3, y2 = e3.className, h3 = y2 === void 0 ? "" : y2, b2 = v(e3, X), j2 = t2.useContext(x).path, M2 = { type: "LineString", coordinates: s4 || [n3, u2] };
        return i.default.createElement("path", g({ ref: r2, d: j2(M2), className: "rsm-line ".concat(h3), stroke: c2, strokeWidth: d3, fill: m2 }, b2));
      });
      Y.displayName = "Line", Y.propTypes = { from: c.default.array, to: c.default.array, coordinates: c.default.array, stroke: c.default.string, strokeWidth: c.default.number, fill: c.default.string, className: c.default.string };
      var ee = ["subject", "children", "connectorProps", "dx", "dy", "curve", "className"], te = t2.forwardRef(function(e3, r2) {
        var o2 = e3.subject, n3 = e3.children, a2 = e3.connectorProps, u2 = e3.dx, s4 = u2 === void 0 ? 30 : u2, l3 = e3.dy, c2 = l3 === void 0 ? 30 : l3, f2 = e3.curve, d3 = f2 === void 0 ? 0 : f2, p3 = e3.className, m2 = p3 === void 0 ? "" : p3, y2 = v(e3, ee), b2 = h2((0, t2.useContext(x).projection)(o2), 2), j2 = b2[0], M2 = b2[1], E2 = function() {
          var e4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30, t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30, r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.5, o3 = Array.isArray(r3) ? r3 : [r3, r3], n4 = e4 / 2 * o3[0], a3 = t3 / 2 * o3[1];
          return "M".concat(0, ",", 0, " Q", -e4 / 2 - n4, ",").concat(-t3 / 2 + a3, " ").concat(-e4, ",").concat(-t3);
        }(s4, c2, d3);
        return i.default.createElement("g", g({ ref: r2, transform: "translate(".concat(j2 + s4, ", ").concat(M2 + c2, ")"), className: "rsm-annotation ".concat(m2) }, y2), i.default.createElement("path", g({ d: E2, fill: "transparent", stroke: "#000" }, a2)), n3);
      });
      te.displayName = "Annotation", te.propTypes = { subject: c.default.array, children: c.default.oneOfType([c.default.node, c.default.arrayOf(c.default.node)]), dx: c.default.number, dy: c.default.number, curve: c.default.number, connectorProps: c.default.object, className: c.default.string }, e2.Annotation = te, e2.ComposableMap = O, e2.Geographies = Z, e2.Geography = D, e2.Graticule = B, e2.Line = Y, e2.MapContext = x, e2.MapProvider = k, e2.Marker = V, e2.Sphere = H, e2.ZoomPanContext = U, e2.ZoomPanProvider = W, e2.ZoomableGroup = _2, e2.useGeographies = T, e2.useMapContext = function() {
        return t2.useContext(x);
      }, e2.useZoomPan = I, e2.useZoomPanContext = function() {
        return t2.useContext(U);
      }, Object.defineProperty(e2, "__esModule", { value: true });
    });
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development3 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType2(type2) {
          return typeof type2 === "string" || typeof type2 === "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element3 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment65 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer2(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element3;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment65;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer2;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is3 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development3();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module2) {
    "use strict";
    var reactIs = require_react_is3();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf2 = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf2(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys2.length; ++i) {
          var key = keys2[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e2) {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development4 = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType2(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_DEBUG_TRACING_MODE_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || type2 === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_BLOCK_TYPE || type2[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element3 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment65 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer2(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element3;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment65;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer2;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is4 = __commonJS({
  "node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development4();
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RpgManager
});
module.exports = __toCommonJS(main_exports);
var import_obsidian16 = require("obsidian");

// src/data/enums/ElementType.ts
var ElementType = /* @__PURE__ */ ((ElementType2) => {
  ElementType2["Campaign"] = "campaign";
  ElementType2["Adventure"] = "adventure";
  ElementType2["Scene"] = "scene";
  ElementType2["Session"] = "session";
  ElementType2["PlayerCharacter"] = "playercharacter";
  ElementType2["NonPlayerCharacter"] = "nonplayercharacter";
  ElementType2["Location"] = "location";
  ElementType2["Event"] = "event";
  ElementType2["Clue"] = "clue";
  ElementType2["Faction"] = "faction";
  ElementType2["Subplot"] = "subplot";
  ElementType2["Chapter"] = "chapter";
  ElementType2["Object"] = "object";
  ElementType2["Monster"] = "monster";
  return ElementType2;
})(ElementType || {});

// src/services/RpgManagerCodeblockService.ts
var import_obsidian = require("obsidian");

// src/data/enums/RelationshipType.ts
var RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {
  RelationshipType2["Reversed"] = "reverse";
  RelationshipType2["Bidirectional"] = "bidirectional";
  RelationshipType2["Unidirectional"] = "unidirectional";
  RelationshipType2["Parent"] = "parent";
  RelationshipType2["Child"] = "child";
  return RelationshipType2;
})(RelationshipType || {});

// src/factories/RelationshipFactory.ts
var RelationshipFactory = class {
  static createFromRpgManagerBlock(relationshipDefinition) {
    const relationshipName = relationshipDefinition.type.charAt(0).toUpperCase() + relationshipDefinition.type.slice(1);
    const relationshipType = RelationshipType[relationshipName];
    if (relationshipType === void 0)
      return void 0;
    const response = {
      type: relationshipType,
      path: relationshipDefinition.path,
      isInContent: false
    };
    if (relationshipDefinition.description !== void 0)
      response.description = relationshipDefinition.description;
    return response;
  }
  static createFromElement(type2, element4) {
    return {
      type: type2,
      path: element4.path,
      isInContent: false
    };
  }
  static createFromCodeblock(type2, path4) {
    return {
      type: type2,
      path: path4,
      isInContent: false
    };
  }
  static createFromContent(type2, path4) {
    return {
      type: type2,
      path: path4,
      isInContent: true
    };
  }
  static createFromReverse(relationship, element4) {
    if (relationship.type === "unidirectional" /* Unidirectional */)
      return void 0;
    let reverseRelationshipType = "bidirectional" /* Bidirectional */;
    switch (relationship.type) {
      case "child" /* Child */:
        reverseRelationshipType = "parent" /* Parent */;
        break;
      case "parent" /* Parent */:
        reverseRelationshipType = "child" /* Child */;
        break;
      case "bidirectional" /* Bidirectional */:
        reverseRelationshipType = "reverse" /* Reversed */;
        break;
    }
    return {
      type: reverseRelationshipType,
      path: element4.path,
      component: element4,
      isInContent: relationship.isInContent,
      isAlsoInContent: relationship.isAlsoInContent
    };
  }
};

// src/data/classes/YamlService.ts
var YamlService = class {
  stringify(yaml) {
    let response = "";
    response = this._stringify(yaml, 0).join("\n") + "\n";
    return response;
  }
  _stringify(yaml, indent, isArray2 = false) {
    const response = [];
    if (isArray2) {
      for (let index2 = 0; index2 < yaml.length; index2++) {
        const value = yaml[index2];
        if (value == null) {
          response.push("");
        } else {
          switch (typeof value) {
            case "object":
              response.push(...this._stringify(value, indent + 1));
              break;
            case "number":
            case "boolean":
              response.push(value.toString());
              break;
            case "undefined":
              break;
            default:
              response.push('"' + value.replaceAll("\n", "\\n").replaceAll('"', '\\"') + '"');
              break;
          }
        }
      }
    } else {
      Object.entries(yaml).forEach(([key, value], index2) => {
        const yamlKey = "  ".repeat(indent) + key + ": ";
        if (value == null) {
          response.push(yamlKey);
        } else if (Array.isArray(value)) {
          const yamlDataType = this._dataType(value);
          switch (yamlDataType) {
            case 0 /* Basic */:
              response.push(yamlKey + "[" + this._stringify(value, 0, true).join(",") + "]");
              break;
            case 2 /* Object */:
              response.push(yamlKey);
              for (let index3 = 0; index3 < value.length; index3++) {
                const arrayReponse = this._stringify(value[index3], 0, false);
                for (let responseIndex = 0; responseIndex < arrayReponse.length; responseIndex++) {
                  if (responseIndex === 0) {
                    arrayReponse[responseIndex] = "  ".repeat(indent + 1) + "- " + arrayReponse[responseIndex];
                  } else {
                    arrayReponse[responseIndex] = "  ".repeat(indent + 2) + arrayReponse[responseIndex];
                  }
                }
                response.push(...arrayReponse);
              }
              break;
          }
        } else {
          switch (typeof value) {
            case "object":
              response.push(yamlKey);
              response.push(...this._stringify(value, indent + 1));
              break;
            case "number":
            case "boolean":
              response.push(yamlKey + value);
              break;
            default:
              response.push(yamlKey + '"' + value.replaceAll("\n", "\\n").replaceAll('"', '\\"') + '"');
              break;
          }
        }
      });
    }
    return response;
  }
  _dataType(values2) {
    for (let index2 = 0; index2 < values2.length; index2++) {
      if (typeof values2[index2] === "object") {
        if (Array.isArray(values2[index2]))
          return 1 /* Array */;
        return 2 /* Object */;
      }
    }
    return 0 /* Basic */;
  }
};

// src/services/EditorPositionService.ts
var _EditorPositionService = class {
  static setEditorPosition(path4, editor, cursorPosition, scrollInfo) {
    return __async(this, null, function* () {
      _EditorPositionService._editorPositions[path4] = { editor, cursorPosition, scrollInfo };
    });
  }
  static getEditorPositions(path4) {
    return _EditorPositionService._editorPositions[path4];
  }
  static clearEditorPosition(path4) {
    _EditorPositionService._editorPositions[path4] = void 0;
  }
};
var EditorPositionService = _EditorPositionService;
__publicField(EditorPositionService, "_editorPositions", {});

// src/services/RpgManagerCodeblockService.ts
var RpgManagerCodeblockService = class {
  constructor(_app, _api, _file) {
    this._app = _app;
    this._api = _api;
    this._file = _file;
    __publicField(this, "_fileContent");
    __publicField(this, "_fileContentLines");
    __publicField(this, "_metadata");
    __publicField(this, "_codeblockContent");
  }
  _readMetadata() {
    return __async(this, null, function* () {
      if (this._metadata !== void 0)
        return;
      this._fileContent = yield this._app.vault.read(this._file);
      this._fileContentLines = this._fileContent.split("\n");
      this._metadata = this._app.metadataCache.getFileCache(this._file);
    });
  }
  get metadata() {
    var _a;
    return (_a = this._metadata) != null ? _a : void 0;
  }
  _modifyFileContent(content3) {
    return __async(this, null, function* () {
      let activeLeaf;
      for (const leaf of this._app.workspace.getLeavesOfType("markdown")) {
        if (leaf.view.file === this._file) {
          activeLeaf = leaf;
        }
      }
      if (activeLeaf) {
        const markdownView = activeLeaf.view;
        const editor = markdownView.editor;
        const cursorPosition = editor.getCursor();
        const scrollInfo = editor.getScrollInfo();
        EditorPositionService.setEditorPosition(this._file.path, editor, cursorPosition, scrollInfo);
      }
      this._app.vault.modify(this._file, content3);
    });
  }
  update(values2) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock === void 0)
        return;
      if (codeblock.data == void 0)
        codeblock.data = {};
      if (codeblock.relationships == void 0)
        codeblock.relationships = [];
      if (codeblock.images == void 0)
        codeblock.images = [];
      if (codeblock.tasks == void 0)
        codeblock.tasks = [];
      if (values2.data !== void 0) {
        Object.keys(values2.data).forEach((key) => {
          codeblock.data[key] = values2.data[key];
        });
      }
      if (values2.relationships !== void 0) {
        values2.relationships.forEach((relationship) => {
          const existingRelationship = codeblock.relationships.find((existingRelationship2) => existingRelationship2.path === relationship.path);
          if (existingRelationship === void 0) {
            codeblock.relationships.push({
              type: relationship.type,
              path: relationship.path
            });
          } else {
            existingRelationship.type = relationship.type;
          }
        });
      }
      if (values2.images !== void 0) {
        values2.images.forEach((image2) => {
          const existingImage = codeblock.images.find((existingImage2) => existingImage2.path === image2.path);
          if (existingImage === void 0) {
            codeblock.images.push({
              path: image2.path,
              caption: image2.caption
            });
          } else {
            existingImage.caption = image2.caption;
          }
        });
      }
      if (values2.tasks !== void 0) {
        values2.tasks.forEach((task) => {
          const existingTask = codeblock.tasks.find((existingTask2) => existingTask2.id === task.id);
          if (existingTask === void 0) {
            codeblock.tasks.push({
              id: task.id,
              priority: task.priority,
              name: task.name,
              description: task.description,
              complete: task.complete
            });
          } else {
            existingTask.priority = task.priority;
            existingTask.name = task.name;
            existingTask.description = task.description;
            existingTask.complete = task.complete;
          }
        });
      }
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  updateRelationshipInContent(relationships) {
    return __async(this, null, function* () {
      yield this._readMetadata();
      if (this._metadata === null)
        return void 0;
      const element4 = this._api.get(this._file.path);
      if (element4.type === "campaign" /* Campaign */)
        return;
      const relationshipsNotInContent = relationships.filter((relationship) => relationship.component !== void 0 || relationship.isInContent === false && relationship.isAlsoInContent !== true);
      if (relationshipsNotInContent.length === 0)
        return;
      const relationshipsToAdd = relationshipsNotInContent.map((relationship) => {
        if (relationship.component === void 0)
          return void 0;
        return "[[" + relationship.component.path + "|]]";
      });
      relationshipsToAdd.filter((relationship) => relationship !== void 0);
      const toAdd = relationshipsToAdd.join("\n");
      const relationshipsAddedToContent = this._fileContentLines.filter((line) => line.startsWith("[[") && line.endsWith("|]]"));
      const toRemove = relationshipsAddedToContent.join("\n");
      if (toRemove === toAdd)
        return;
      const fileContent = this._fileContentLines.join("\n");
      if (toRemove === "") {
        this._fileContentLines.push(...relationshipsToAdd);
        this._fileContent = this._fileContentLines.join("\n");
      } else {
        this._fileContent = this._fileContent.replace(toRemove, toAdd);
      }
      if (fileContent !== this._fileContent)
        this._modifyFileContent(this._fileContent);
    });
  }
  readCodeblock() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      yield this._readMetadata();
      if (this._metadata === null)
        return void 0;
      let codeblockContent = void 0;
      let codeblockData = void 0;
      for (let index2 = 0; index2 < ((_c = (_b = (_a = this._metadata) == null ? void 0 : _a.sections) == null ? void 0 : _b.length) != null ? _c : 0); index2++) {
        codeblockData = ((_d = this._metadata) == null ? void 0 : _d.sections) !== void 0 ? this._metadata.sections[index2] : void 0;
        if (codeblockData !== void 0 && this._fileContentLines[codeblockData.position.start.line] === "```RpgManager4") {
          codeblockContent = "";
          for (let lineIndex = codeblockData.position.start.line + 1; lineIndex < codeblockData.position.end.line; lineIndex++) {
            codeblockContent += this._fileContentLines[lineIndex] + "\n";
          }
          if (codeblockContent === void 0)
            return void 0;
          this._codeblockContent = codeblockContent;
          return (_e = yield (0, import_obsidian.parseYaml)(codeblockContent)) != null ? _e : {};
        }
      }
      return void 0;
    });
  }
  addCodeBlock(rpgManagerCodeblock) {
    return __async(this, null, function* () {
      yield this._readMetadata();
      if (this._metadata === null)
        return void 0;
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(rpgManagerCodeblock);
      const codeblockContentLines = codeblockContent.split("\n");
      codeblockContentLines.pop();
      let newContent = [];
      if (this._metadata.frontmatter === void 0) {
        newContent = ["", "```RpgManager4", ...codeblockContentLines, "```", "", ...this._fileContentLines];
      } else {
        let frontmatterStarted = false;
        let frontmatterEnded = false;
        let codeblockAdded = false;
        this._fileContentLines.forEach((line) => {
          if (line === "---") {
            if (frontmatterStarted) {
              frontmatterEnded = true;
            } else {
              frontmatterStarted = true;
            }
          }
          newContent.push(line);
          if (frontmatterStarted && frontmatterEnded && !codeblockAdded) {
            newContent.push("", "```RpgManager4", ...codeblockContentLines, "```", "");
            codeblockAdded = true;
          }
        });
      }
      this._modifyFileContent(newContent.join("\n"));
      return this._file;
    });
  }
  updateImage(path4, caption) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock === void 0 || codeblock.images === void 0)
        return;
      const image2 = codeblock.images.find((image3) => image3.path === path4);
      image2.caption = caption;
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  deleteAttributes() {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock.attributes !== void 0) {
        delete codeblock.attributes;
        const yamlService = new YamlService();
        const codeblockContent = yamlService.stringify(codeblock);
        this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
      }
    });
  }
  addOrUpdateAttribute(attribute) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      let existingAttribute = void 0;
      if (codeblock.attributes == void 0) {
        codeblock.attributes = [];
      } else {
        existingAttribute = codeblock.attributes.find((att) => att.id === attribute.id);
      }
      if (existingAttribute === void 0) {
        existingAttribute = attribute;
        codeblock.attributes.push(existingAttribute);
      } else {
        existingAttribute.customName = attribute.customName;
        existingAttribute.type = attribute.type;
        existingAttribute.customTypes = attribute.customTypes;
        if (attribute.options)
          existingAttribute.options = attribute.options;
      }
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  updateRelationship(relationship) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      let existingRelationship = void 0;
      if (codeblock.relationships == void 0) {
        codeblock.relationships = [];
      } else {
        existingRelationship = codeblock.relationships.find((rel) => rel.path === relationship.path);
      }
      if (existingRelationship === void 0) {
        existingRelationship = {
          type: relationship.type,
          path: relationship.path,
          description: relationship.description
        };
        codeblock.relationships.push(existingRelationship);
      } else {
        existingRelationship.type = relationship.type;
        existingRelationship.description = relationship.description;
      }
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  updateCodeblockDataList(attributes3) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock === void 0)
        return;
      if (codeblock.data == void 0)
        codeblock.data = {};
      attributes3.forEach((attribute) => {
        if (attribute.value !== void 0) {
          codeblock.data[attribute.name] = attribute.value;
        } else {
          delete codeblock.data[attribute.name];
        }
      });
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  updateCodeblockSubData(names, value) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock === void 0)
        return;
      if (codeblock.data == void 0)
        codeblock.data = {};
      let subData = codeblock.data;
      names.forEach((name, index2) => {
        if (index2 === names.length - 1) {
          if (value !== void 0) {
            subData[name] = value;
          } else {
            delete subData[name];
          }
        } else {
          if (subData[name] === void 0)
            subData[name] = {};
          subData = subData[name];
        }
      });
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  updateCodeblockData(name, value) {
    return __async(this, null, function* () {
      return this.updateCodeblockDataList([{ name, value }]);
    });
  }
  updateCodeblockId(name, value) {
    return __async(this, null, function* () {
      return this.updateCodeblockIdList([{ name, value }]);
    });
  }
  updateCodeblockIdList(ids) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock === void 0)
        return;
      ids.forEach((id) => {
        if (id.value !== void 0) {
          codeblock.id[id.name] = id.value;
        } else {
          delete codeblock.data[id.name];
        }
      });
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  updateRelationshipsPaths(toFile, oldPath) {
    return __async(this, null, function* () {
      yield this.readCodeblock();
      if (this._codeblockContent.indexOf(oldPath) === -1)
        return;
      const oldBaseName = oldPath.split("/").pop().substring(0, oldPath.split("/").pop().lastIndexOf("."));
      let newCodeblockContent = this._codeblockContent.replaceAll(oldPath, toFile.path);
      if (oldBaseName !== toFile.basename && newCodeblockContent.indexOf("|" + oldBaseName) !== -1)
        newCodeblockContent = newCodeblockContent.replaceAll("|" + oldBaseName, "|" + toFile.basename);
      const content3 = this._fileContent.replace(this._codeblockContent, newCodeblockContent);
      this._modifyFileContent(content3);
    });
  }
  addImage(path4, caption) {
    return __async(this, null, function* () {
      return this.addImages([{ path: path4, caption }]);
    });
  }
  addImages(images) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock.images == void 0)
        codeblock.images = [];
      images.forEach((image2) => {
        codeblock.images.push(image2);
      });
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  addRelationship(relationship) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock.relationships == void 0)
        codeblock.relationships = [];
      const minimalRelationship = {
        type: relationship.type,
        path: relationship.path
      };
      codeblock.relationships.push(minimalRelationship);
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  addOrUpdateTask(task) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock.tasks == void 0)
        codeblock.tasks = [];
      const existingTaskIndex = codeblock.tasks.findIndex((existingTask) => existingTask.id === task.id);
      if (existingTaskIndex !== -1) {
        codeblock.tasks[existingTaskIndex] = task.prepare();
      } else {
        codeblock.tasks.push(task.prepare());
      }
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  deleteTask(task) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock.tasks == void 0 || codeblock.tasks.length === 0)
        return;
      const existingTaskIndex = codeblock.tasks.findIndex((existingTask) => existingTask.id === task.id);
      if (existingTaskIndex !== -1) {
        codeblock.tasks.splice(existingTaskIndex, 1);
      }
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  addRelationships(relationships) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock.relationships == void 0)
        codeblock.relationships = [];
      relationships.forEach((relationship) => {
        const foundRelationship = codeblock.relationships.find((foundRelationship2) => foundRelationship2.path === relationship.path);
        if (foundRelationship !== void 0)
          return;
        const minimalRelationship = {
          type: relationship.type,
          path: relationship.path
        };
        codeblock.relationships.push(minimalRelationship);
      });
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  removeRelationship(element4, relatedElement) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock.relationships === void 0 || codeblock.relationships.length === 0)
        return;
      codeblock.relationships = codeblock.relationships.filter((minimalRelationship) => minimalRelationship.path !== relatedElement.file.path);
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      relatedElement.relationships = relatedElement.relationships.filter((relationship) => relationship.path !== element4.file.path);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  removeImage(path4) {
    return __async(this, null, function* () {
      const codeblock = yield this.readCodeblock();
      if (codeblock === void 0 || codeblock.images === void 0)
        return;
      codeblock.images = codeblock.images.filter((image2) => image2.path !== path4);
      const yamlService = new YamlService();
      const codeblockContent = yamlService.stringify(codeblock);
      this._modifyFileContent(this._fileContent.replace(this._codeblockContent, codeblockContent));
    });
  }
  readInContentRelationships() {
    return __async(this, null, function* () {
      yield this.readCodeblock();
      const response = [];
      const yamlService = new YamlService();
      const codeblockStringWithoutRelationships = (0, import_obsidian.parseYaml)(this._codeblockContent);
      codeblockStringWithoutRelationships.relationships = [];
      const codeblockWithoutRelationships = yamlService.stringify(codeblockStringWithoutRelationships);
      response.push(...this._getRelationshipsFromContent(codeblockWithoutRelationships, true));
      const additionalRelationships = this._getRelationshipsFromContent(this._fileContent.replace(this._codeblockContent, ""), false);
      additionalRelationships.forEach((relationship) => {
        const existingRelationship = response.find((existingRelationship2) => existingRelationship2.path === relationship.path);
        if (existingRelationship === void 0) {
          response.push(relationship);
        } else {
          if (!existingRelationship.isAlsoInContent)
            existingRelationship.isAlsoInContent = true;
        }
      });
      return response;
    });
  }
  _getRelationshipsFromContent(content3, isInCodeblock) {
    const response = [];
    if (isInCodeblock) {
      const regex = /"([^"]+\.md)"/g;
      let match3;
      while ((match3 = regex.exec(content3)) !== null) {
        response.push(RelationshipFactory.createFromCodeblock("bidirectional" /* Bidirectional */, match3[1]));
      }
    }
    let indexOfRelationship = content3.indexOf("[[");
    while (indexOfRelationship !== -1) {
      content3 = content3.substring(content3.indexOf("[[") + 2);
      const endLinkIndex = content3.indexOf("]]");
      if (endLinkIndex === -1)
        break;
      const nameAndAlias = content3.substring(0, endLinkIndex);
      const aliasIndex = nameAndAlias.indexOf("|");
      let basename2 = void 0;
      let skipHiddenLink = false;
      if (aliasIndex === -1) {
        basename2 = nameAndAlias;
      } else {
        if (nameAndAlias.substring(aliasIndex) === "|") {
          skipHiddenLink = true;
        } else {
          basename2 = nameAndAlias.substring(0, aliasIndex);
        }
      }
      if (!skipHiddenLink && basename2 !== void 0) {
        const matchingFile = this._app.vault.getFiles().find((file) => file.basename === basename2 || file.path === basename2);
        if (matchingFile !== void 0 && response.find((relationship) => relationship.path === matchingFile.path) === void 0) {
          if (isInCodeblock) {
            response.push(RelationshipFactory.createFromCodeblock("bidirectional" /* Bidirectional */, matchingFile.path));
          } else {
            response.push(RelationshipFactory.createFromContent("bidirectional" /* Bidirectional */, matchingFile.path));
          }
        }
      }
      indexOfRelationship = content3.indexOf("[[");
    }
    return response;
  }
};

// src/data/attributes/attributes.ts
var description = { id: "description" /* Description */, type: "Description" /* Description */ };
var ghost = { id: "ghost" /* Ghost */, type: "LongText" /* LongText */ };
var lie = { id: "lie" /* Lie */, type: "LongText" /* LongText */ };
var arc = { id: "arc" /* Arc */, type: "Arc" /* Arc */ };
var beliefs = { id: "beliefs" /* Beliefs */, type: "LongText" /* LongText */ };
var need = { id: "need" /* Need */, type: "LongText" /* LongText */ };
var behaviour = { id: "behaviour" /* Behaviour */, type: "LongText" /* LongText */ };
var want = { id: "want" /* Want */, type: "LongText" /* LongText */ };
var opposition = { id: "opposition" /* Opposition */, type: "LongText" /* LongText */ };
var strengths = { id: "strengths" /* Strengths */, type: "Strengths" /* Strengths */ };
var weaknesses = { id: "weaknesses" /* Weaknesses */, type: "Weaknesses" /* Weaknesses */ };
var storycircle = { id: "storycircle" /* StoryCircle */, type: "StoryCircle" /* StoryCircle */ };
var type = { id: "scenetype" /* SceneType */, type: "SceneType" /* SceneType */ };
var dob = { id: "dob" /* Dob */, type: "Date" /* Date */ };
var dod = { id: "dod" /* Dod */, type: "Date" /* Date */ };
var occupation = { id: "occupation" /* Occupation */, type: "Text" /* Text */ };
var sceneaction = { id: "sceneaction" /* SceneAction */, type: "LongText" /* LongText */ };
var date = { id: "date" /* Date */, type: "Date" /* Date */ };
var sessiondate = { id: "sessiondate" /* SessionDate */, type: "Date" /* Date */ };
var storycirclestage = { id: "storycirclestage" /* StoryCircleStage */, type: "StoryCircleStage" /* StoryCircleStage */ };
var abtstage = { id: "abtstage" /* AbtStage */, type: "AbtStage" /* AbtStage */ };
var externalactions = { id: "externalactions" /* ExternalActions */, type: "Boolean" /* Boolean */ };
var address = { id: "address" /* Address */, type: "LongText" /* LongText */ };
var location = { id: "location" /* Location */, type: "Map" /* Map */ };
var duration = { id: "duration" /* Duration */, type: "Duration" /* Duration */ };
var philosophy = { id: "philosophy" /* Philosophy */, type: "LongText" /* LongText */ };
var majorclues = { id: "majorclues" /* MajorClues */, type: "MajorClues" /* MajorClues */ };
var factionstructure = { id: "factionstructure" /* FactionStructure */, type: "LongText" /* LongText */ };
var nonplayercharactertype = {
  id: "nonplayercharactertype" /* NonPlayerCharacterType */,
  type: "NonPlayerCharacterType" /* NonPlayerCharacterType */
};
var sensoryimprint = { id: "sensoryimprint" /* SensoryImprint */, type: "SensoryImprint" /* SensoryImprint */ };
var stake = { id: "stake" /* Stake */, type: "Scale" /* Scale */ };
var kishotenketsu = { id: "kishotenketsu" /* Kishotenketsu */, type: "Kishotenketsu" /* Kishotenketsu */ };
var conflict = { id: "conflict" /* Conflict */, type: "Conflict" /* Conflict */ };
var pronoun = { id: "pronoun" /* Pronoun */, type: "Pronoun" /* Pronoun */ };
var attributes = /* @__PURE__ */ new Map([
  ["campaign" /* Campaign */, [description, storycircle]],
  ["adventure" /* Adventure */, [description, storycircle, majorclues, kishotenketsu, conflict]],
  ["chapter" /* Chapter */, [description, abtstage, storycircle, majorclues, kishotenketsu, conflict]],
  ["session" /* Session */, [description, storycircle, abtstage, sessiondate, kishotenketsu, conflict]],
  [
    "scene" /* Scene */,
    [description, sensoryimprint, storycirclestage, sceneaction, type, date, externalactions, duration]
  ],
  [
    "nonplayercharacter" /* NonPlayerCharacter */,
    [
      description,
      sensoryimprint,
      nonplayercharactertype,
      occupation,
      ghost,
      lie,
      arc,
      beliefs,
      need,
      behaviour,
      want,
      stake,
      opposition,
      strengths,
      weaknesses,
      dob,
      dod,
      pronoun
    ]
  ],
  ["event" /* Event */, [description, date]],
  ["location" /* Location */, [sensoryimprint, description, address, location]],
  ["faction" /* Faction */, [description, philosophy, factionstructure]],
  ["clue" /* Clue */, [description]],
  [
    "playercharacter" /* PlayerCharacter */,
    [description, occupation, ghost, lie, beliefs, need, behaviour, want, strengths, weaknesses, dob, pronoun]
  ],
  ["subplot" /* Subplot */, [description, storycircle]],
  ["object" /* Object */, [sensoryimprint, description]],
  ["monster" /* Monster */, [sensoryimprint, description]]
]);

// src/data/classes/Element.ts
var import_lodash = __toESM(require_lodash());

// src/data/classes/Image.ts
var Image = class {
  constructor(path4, src) {
    __publicField(this, "_caption");
    __publicField(this, "_src");
    __publicField(this, "_path");
    this._path = path4;
    this._src = src;
    this._caption = "";
  }
  get path() {
    return this._path;
  }
  get caption() {
    return this._caption;
  }
  set caption(caption) {
    this._caption = caption;
  }
  get src() {
    return this._src;
  }
};

// src/services/ImageService.ts
var ImageService = class {
  static createImage(app, api2, imageData) {
    const imageLocation = this._getImageLocation(app, api2, imageData.path);
    if (imageLocation === void 0)
      return void 0;
    const response = new Image(imageData.path, imageLocation);
    if (imageData.caption !== void 0)
      response.caption = imageData.caption;
    return response;
  }
  static _getImageLocation(app, api2, path4) {
    if (path4.trim().toLowerCase().startsWith("http"))
      return path4;
    const file = app.vault.getAbstractFileByPath("/");
    let root3 = app.vault.getResourcePath(file);
    if (root3.includes("?"))
      root3 = root3.substring(0, root3.lastIndexOf("?"));
    if (!root3.endsWith("/"))
      root3 += "/";
    if (app.vault.getAbstractFileByPath(path4) === void 0)
      return void 0;
    let response = root3;
    if (api2.settings.assetsFolder)
      response += api2.settings.assetsFolder + "/";
    response += path4;
    return response;
  }
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr2, offset4 = 0) {
  return (byteToHex[arr2[offset4 + 0]] + byteToHex[arr2[offset4 + 1]] + byteToHex[arr2[offset4 + 2]] + byteToHex[arr2[offset4 + 3]] + "-" + byteToHex[arr2[offset4 + 4]] + byteToHex[arr2[offset4 + 5]] + "-" + byteToHex[arr2[offset4 + 6]] + byteToHex[arr2[offset4 + 7]] + "-" + byteToHex[arr2[offset4 + 8]] + byteToHex[arr2[offset4 + 9]] + "-" + byteToHex[arr2[offset4 + 10]] + byteToHex[arr2[offset4 + 11]] + byteToHex[arr2[offset4 + 12]] + byteToHex[arr2[offset4 + 13]] + byteToHex[arr2[offset4 + 14]] + byteToHex[arr2[offset4 + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset4) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset4 = offset4 || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset4 + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/services/taskService/enums/PriorityType.ts
var PriorityType = /* @__PURE__ */ ((PriorityType2) => {
  PriorityType2["High"] = "high";
  PriorityType2["Medium"] = "medium";
  PriorityType2["Low"] = "low";
  return PriorityType2;
})(PriorityType || {});

// src/services/taskService/Task.ts
var Task = class {
  constructor(api2, _element, task) {
    this._element = _element;
    __publicField(this, "_id");
    __publicField(this, "_priority");
    __publicField(this, "_name");
    __publicField(this, "_description");
    __publicField(this, "_status");
    __publicField(this, "_completedIn");
    __publicField(this, "_mentionedIn");
    __publicField(this, "_completionDate");
    __publicField(this, "_type", "custom" /* Custom */);
    if (task !== void 0) {
      this._id = task.id;
      switch (task.priority) {
        case 2:
          this._priority = "medium" /* Medium */;
          break;
        case 3:
          this._priority = "high" /* High */;
          break;
        default:
          this._priority = "low" /* Low */;
          break;
      }
      this._status = task.status;
      this._name = task.name;
      this._description = task.description;
      this._type = task.type || "custom" /* Custom */;
      if (task.completedIn !== void 0)
        this._completedIn = api2.get(task.completedIn);
      if (task.mentionedIn !== void 0)
        this._mentionedIn = task.mentionedIn;
      if (task.completionDate !== void 0)
        this._completionDate = new Date(task.completionDate);
    } else {
      this._id = v4_default();
      this._priority = "low" /* Low */;
      this._status = "incomplete" /* Incomplete */;
      this._type = "custom" /* Custom */;
    }
  }
  get id() {
    return this._id;
  }
  prepare() {
    const response = {
      id: this._id,
      priority: 1,
      name: this._name,
      description: this._description,
      status: this._status,
      type: this._type
    };
    if (this._priority === "medium" /* Medium */)
      response.priority = 2;
    if (this._priority === "high" /* High */)
      response.priority = 3;
    if (this._completedIn !== void 0)
      response.completedIn = this._completedIn.path;
    if (this._completionDate !== void 0)
      response.completionDate = this._completionDate.toISOString();
    if (this._mentionedIn !== void 0)
      response.mentionedIn = this._mentionedIn;
    return response;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
  }
  get status() {
    return this._status;
  }
  set status(value) {
    this._status = value;
  }
  get element() {
    return this._element;
  }
  get priority() {
    return this._priority;
  }
  set priority(value) {
    this._priority = value;
  }
  get description() {
    return this._description;
  }
  set description(value) {
    this._description = value;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get completedIn() {
    return this._completedIn;
  }
  set completedIn(value) {
    this._completedIn = value;
  }
  get mentionedIn() {
    return this._mentionedIn || [];
  }
  set mentionedIn(value) {
    this._mentionedIn = value;
  }
  get completionDate() {
    return this._completionDate;
  }
  click() {
    if (this.status === "complete" /* Complete */) {
      this._status = "incomplete" /* Incomplete */;
      this._completionDate = void 0;
    } else {
      this._status = "complete" /* Complete */;
      this._completionDate = new Date();
    }
  }
};

// src/data/enums/SystemType.ts
var SystemType = /* @__PURE__ */ ((SystemType2) => {
  SystemType2[SystemType2["Agnostic"] = 0] = "Agnostic";
  return SystemType2;
})(SystemType || {});

// src/data/classes/Element.ts
var Element2 = class {
  constructor(_app, _api, _file, _rpgManagerBlock) {
    this._app = _app;
    this._api = _api;
    this._file = _file;
    this._rpgManagerBlock = _rpgManagerBlock;
    __publicField(this, "_relationships", []);
    __publicField(this, "_campaign");
    __publicField(this, "_parent");
    __publicField(this, "_version", Date.now());
    __publicField(this, "_metadata");
    __publicField(this, "_runningStart", 0);
    if (this._rpgManagerBlock.id.type === "campaign" /* Campaign */ || this._rpgManagerBlock.id.type === "adventure" /* Adventure */ || this._rpgManagerBlock.id.type === "session" /* Session */ || this._rpgManagerBlock.id.type === "scene" /* Scene */)
      this.touch();
  }
  get attributes() {
    var _a;
    const response = [];
    const customAttributes = this._api.settings.customAttributes.filter((customAttribute) => customAttribute.customTypes !== void 0 && customAttribute.customTypes.contains(this.type));
    const elementAttributes = [];
    switch (this.system) {
      case 0 /* Agnostic */:
        elementAttributes.push(...(_a = attributes.get(this.type)) != null ? _a : []);
        break;
    }
    elementAttributes.forEach((elementAttribute) => {
      var _a2;
      const deepClone = JSON.parse(JSON.stringify(elementAttribute));
      deepClone.value = (_a2 = this._rpgManagerBlock.data) == null ? void 0 : _a2[elementAttribute.id];
      deepClone.isSet = deepClone.value !== void 0;
      response.push(deepClone);
    });
    customAttributes.forEach((customAttribute) => {
      var _a2;
      const deepClone = JSON.parse(JSON.stringify(customAttribute));
      deepClone.value = (_a2 = this._rpgManagerBlock.data) == null ? void 0 : _a2[customAttribute.id];
      deepClone.isSet = deepClone.value !== void 0;
      response.push(deepClone);
    });
    return response;
  }
  attribute(id) {
    var _a, _b;
    let attribute = void 0;
    switch (this.system) {
      case 0 /* Agnostic */:
        attribute = (_a = attributes.get(this.type)) == null ? void 0 : _a.find((attribute2) => attribute2.id === id.toLowerCase());
        break;
    }
    if (attribute === void 0) {
      attribute = this._api.settings.customAttributes.find((customAttribute) => customAttribute.customTypes !== void 0 && customAttribute.customTypes.contains(this.type) && customAttribute.id === id.toLowerCase());
    }
    if (attribute === void 0)
      return void 0;
    const response = JSON.parse(JSON.stringify(attribute));
    response.value = (_b = this._rpgManagerBlock.data) == null ? void 0 : _b[attribute.id];
    response.isSet = response.value !== void 0;
    return response;
  }
  touch() {
    this._version = Date.now();
  }
  get aliases() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this._metadata) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.aliases) != null ? _c : [];
  }
  set metadata(metadata) {
    this._metadata = metadata;
  }
  get images() {
    const response = [];
    if (this._rpgManagerBlock.images == void 0)
      return response;
    this._rpgManagerBlock.images.forEach((imageData) => {
      const image2 = ImageService.createImage(this._app, this._api, imageData);
      if (image2)
        response.push(image2);
    });
    return response;
  }
  set codeblock(rpgManagerBlock) {
    if (import_lodash.default.isEqual(this._rpgManagerBlock, rpgManagerBlock))
      return;
    this.touch();
    this._rpgManagerBlock = rpgManagerBlock;
  }
  get version() {
    return this._version;
  }
  get file() {
    return this._file;
  }
  get type() {
    return this._rpgManagerBlock.id.type;
  }
  get system() {
    return this._rpgManagerBlock.id.system ? SystemType[this._rpgManagerBlock.id.system] : 0 /* Agnostic */;
  }
  get relationships() {
    return this._relationships;
  }
  set relationships(value) {
    this._version++;
    this._relationships = value;
  }
  get campaignPath() {
    return this._rpgManagerBlock.id.campaign;
  }
  get campaign() {
    return this._campaign;
  }
  set campaign(value) {
    this._campaign = value;
  }
  get parentPath() {
    return this._rpgManagerBlock.id.parent;
  }
  get parent() {
    return this._parent;
  }
  set parent(value) {
    this._parent = value;
  }
  get positionInParent() {
    return this._rpgManagerBlock.id.positionInParent;
  }
  get path() {
    return this._file.path;
  }
  get name() {
    return this._file.basename;
  }
  get tasks() {
    if (this._rpgManagerBlock.tasks === void 0 || this._rpgManagerBlock.tasks.length === 0)
      return [];
    return this._rpgManagerBlock.tasks.map((task) => {
      return new Task(this._api, this, task);
    });
  }
};

// src/factories/ElementFactory.ts
var ElementFactory = class {
  static createElement(app, api2, file) {
    return __async(this, null, function* () {
      const codeblockService = new RpgManagerCodeblockService(app, api2, file);
      let rpgManagerBlock = void 0;
      try {
        rpgManagerBlock = yield codeblockService.readCodeblock();
      } catch (e2) {
        throw Error("Error reading the RPG Manager YAML in file " + file.path);
      }
      if (rpgManagerBlock === void 0 || rpgManagerBlock.id === void 0 || rpgManagerBlock.id.type === void 0)
        return void 0;
      const response = new Element2(app, api2, file, rpgManagerBlock);
      response.metadata = codeblockService.metadata;
      if (rpgManagerBlock.relationships != void 0 && rpgManagerBlock.relationships.length > 0) {
        rpgManagerBlock.relationships.forEach((relationshipDefinition) => {
          const newRelationship = RelationshipFactory.createFromRpgManagerBlock(relationshipDefinition);
          if (newRelationship !== void 0)
            response.relationships.push(newRelationship);
        });
      }
      const relationships = yield codeblockService.readInContentRelationships();
      relationships.forEach((relationship) => {
        if (relationship.path === response.path)
          return;
        const existingRelationship = response.relationships.find((existingRelationship2) => existingRelationship2.path === relationship.path);
        if (existingRelationship === void 0) {
          response.relationships.push(relationship);
        } else {
          existingRelationship.isAlsoInContent = true;
        }
      });
      return response;
    });
  }
  static updateElement(app, api2, element4) {
    return __async(this, null, function* () {
      const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
      const rpgManagerBlock = yield codeblockService.readCodeblock();
      if (rpgManagerBlock === void 0 || rpgManagerBlock.id === void 0 || rpgManagerBlock.id.type === void 0)
        return void 0;
      element4.codeblock = rpgManagerBlock;
      element4.metadata = codeblockService.metadata;
      let areRelationshipChanged = false;
      if (rpgManagerBlock.relationships != void 0 && rpgManagerBlock.relationships.length > 0) {
        rpgManagerBlock.relationships.forEach((relationshipDefinition) => {
          const foundRelationship = element4.relationships.find((relationship) => relationship.path === relationshipDefinition.path);
          if (foundRelationship === void 0) {
            const newRelationship = RelationshipFactory.createFromRpgManagerBlock(relationshipDefinition);
            if (newRelationship !== void 0) {
              element4.relationships.push(newRelationship);
              areRelationshipChanged = true;
            }
          } else {
            if (foundRelationship.description !== relationshipDefinition.description)
              areRelationshipChanged = true;
          }
        });
      }
      const relationships = yield codeblockService.readInContentRelationships();
      relationships.forEach((relationship) => {
        const existingRelationship = element4.relationships.find((existingRelationship2) => existingRelationship2.path === relationship.path);
        if (existingRelationship === void 0) {
          areRelationshipChanged = true;
          element4.relationships.push(relationship);
        } else {
          if (!existingRelationship.isAlsoInContent) {
            areRelationshipChanged = true;
            existingRelationship.isAlsoInContent = true;
          }
        }
      });
      const existingRelationships = element4.relationships.filter((existingRelationship) => existingRelationship.isInContent);
      const inContentRelationshipPaths = new Set(relationships.filter((relationship) => relationship.isInContent).map((r) => r.path));
      const pathsToRemove = new Set(existingRelationships.filter((r) => !inContentRelationshipPaths.has(r.path)).map((r) => r.path));
      element4.relationships = element4.relationships.filter((relationship) => relationship.type === "reverse" /* Reversed */ || !pathsToRemove.has(relationship.path));
      const allExistingRelationships = new Set(relationships.map((r) => r.path));
      if (rpgManagerBlock.relationships !== void 0 && rpgManagerBlock.relationships.length > 0) {
        rpgManagerBlock.relationships.forEach((relationshipDefinition) => allExistingRelationships.add(relationshipDefinition.path));
      }
      const relationshipsToBeRemoved = element4.relationships.filter((relationship) => relationship.type !== "reverse" /* Reversed */ && !allExistingRelationships.has(relationship.path));
      if (relationshipsToBeRemoved.length !== 0) {
        element4.relationships = element4.relationships.filter((relationship) => allExistingRelationships.has(relationship.path));
        areRelationshipChanged = true;
      }
      if (areRelationshipChanged)
        element4.touch();
    });
  }
  static initialiseRelationships(element4, elements) {
    if (element4.campaign === void 0 && element4.campaignPath !== void 0)
      element4.campaign = elements.find((elementInList) => elementInList.path === element4.campaignPath);
    if (element4.parent === void 0 || element4.parentPath !== void 0 && element4.parent.file.path !== element4.parentPath)
      element4.parent = elements.find((elementInList) => elementInList.path === element4.parentPath);
    element4.relationships.forEach((relationship) => {
      const targetElement = elements.find((element5) => element5.path === relationship.path);
      if (targetElement !== void 0 && targetElement.path !== element4.path) {
        relationship.component = targetElement;
        const reverseRelationship = targetElement.relationships.find((relationship2) => relationship2.path === element4.path);
        if (reverseRelationship === void 0) {
          const reverseRelationship2 = RelationshipFactory.createFromReverse(relationship, element4);
          if (reverseRelationship2 !== void 0)
            targetElement.relationships.push(reverseRelationship2);
        } else if (relationship.type === "parent" /* Parent */ && reverseRelationship.type !== "child" /* Child */) {
          reverseRelationship.type = "child" /* Child */;
        }
      }
    });
  }
  static updateRelationships(element4, elements, updateReverseRelationships) {
    ElementFactory.initialiseRelationships(element4, elements);
    let touch = false;
    elements.forEach((elementInList) => {
      const reverseRelationship = elementInList.relationships.find((relationship) => relationship.path === element4.path);
      const existingRelationship = element4.relationships.find((relationship) => relationship.path === elementInList.path);
      if (reverseRelationship !== void 0 && existingRelationship === void 0) {
        const newRelationship = RelationshipFactory.createFromReverse(reverseRelationship, elementInList);
        if (newRelationship !== void 0) {
          element4.relationships.push(newRelationship);
          touch = true;
        }
      }
    });
    if (touch)
      element4.touch();
    if (updateReverseRelationships)
      elements.forEach((relatedElement) => {
        if (relatedElement.relationships.some((relationship) => relationship.path === element4.path))
          relatedElement.touch();
      });
  }
  static updateFileRelationships(app, api2, file, elements) {
    return __async(this, null, function* () {
      const element4 = elements.find((element5) => element5.path === file.path);
      if (!element4 || !element4.relationships || element4.relationships.length === 0)
        return;
      const codeblockService = new RpgManagerCodeblockService(app, api2, file);
      codeblockService.updateRelationshipInContent(element4.relationships);
    });
  }
};

// src/factories/DatabaseFactory.ts
var DatabaseFactory = class {
  static create(app, api2) {
    return __async(this, null, function* () {
      const response = [];
      const elementPromises = app.vault.getMarkdownFiles().map((file) => ElementFactory.createElement(app, api2, file).then((element4) => {
        return element4;
      }).catch((error2) => {
        console.warn(error2);
        return void 0;
      }));
      const elements = yield Promise.all(elementPromises);
      elements.filter((element4) => element4 !== void 0).forEach((element4) => response.push(element4));
      response.map((element4) => ElementFactory.initialiseRelationships(element4, response));
      return response;
    });
  }
  static add(app, api2, elements, file) {
    return __async(this, null, function* () {
      const element4 = yield ElementFactory.createElement(app, api2, file);
      if (element4 === void 0)
        return elements;
      elements.push(element4);
      ElementFactory.initialiseRelationships(element4, elements);
      return elements;
    });
  }
  static update(app, api2, elements, element4) {
    return __async(this, null, function* () {
      const previousVersion = element4.version;
      yield ElementFactory.updateElement(app, api2, element4);
      ElementFactory.updateRelationships(element4, elements, previousVersion !== element4.version);
    });
  }
  static rename(app, api2, elements, element4, oldPath) {
    return __async(this, null, function* () {
      const elementPromises = elements.map((existingElement) => {
        let isElementToBeRenamed = false;
        if (existingElement.parentPath === oldPath || existingElement.campaignPath === oldPath)
          isElementToBeRenamed = true;
        const relationshipToRenamedElement = existingElement.relationships.find((relationship) => relationship.path === oldPath);
        if (relationshipToRenamedElement !== void 0) {
          relationshipToRenamedElement.path = element4.path;
          isElementToBeRenamed = true;
        }
        if (!isElementToBeRenamed)
          return void 0;
        return existingElement;
      });
      const allElements = yield Promise.all(elementPromises);
      const elementsToUpdate = allElements.filter((element5) => element5 !== void 0);
      const updatedElements = elementsToUpdate.map((elementToUpdate) => {
        const codeblockService = new RpgManagerCodeblockService(app, api2, elementToUpdate.file);
        return codeblockService.updateRelationshipsPaths(element4.file, oldPath);
      });
      yield Promise.all(updatedElements);
    });
  }
};

// src/data/enums/SceneType.ts
var SceneType = /* @__PURE__ */ ((SceneType2) => {
  SceneType2["Action"] = "action";
  SceneType2["Combat"] = "combat";
  SceneType2["Decision"] = "decision";
  SceneType2["Encounter"] = "encounter";
  SceneType2["Exposition"] = "exposition";
  SceneType2["Investigation"] = "investigation";
  SceneType2["Preparation"] = "preparation";
  SceneType2["Recap"] = "recap";
  SceneType2["SocialCombat"] = "socialcombat";
  return SceneType2;
})(SceneType || {});
function isSceneActive(type2) {
  switch (type2) {
    case "action" /* Action */:
    case "combat" /* Combat */:
    case "investigation" /* Investigation */:
    case "socialcombat" /* SocialCombat */:
      return true;
    default:
      return false;
  }
}

// src/data/enums/AbtStage.ts
var AbtStage = /* @__PURE__ */ ((AbtStage2) => {
  AbtStage2["Need"] = "need";
  AbtStage2["And"] = "and";
  AbtStage2["But"] = "but";
  AbtStage2["Therefore"] = "therefore";
  return AbtStage2;
})(AbtStage || {});

// src/services/sceneAnalyserService/SceneAnalysis.ts
var SceneAnalysis = class {
  constructor(_abtStage, _durationGoal) {
    this._abtStage = _abtStage;
    this._durationGoal = _durationGoal;
    __publicField(this, "_activity", 0);
    __publicField(this, "_excitement", 0);
    __publicField(this, "_interest", 0);
    __publicField(this, "_variety", 0);
    __publicField(this, "_expectedDuration", 0);
    __publicField(this, "_excitingDuration", 0);
    __publicField(this, "_activeDuration", 0);
    __publicField(this, "_sceneTypeUsed", []);
    __publicField(this, "_sceneCount", 0);
    __publicField(this, "_duplicatedSuccessiveSceneType", 0);
  }
  get score() {
    var _a;
    let response = 0;
    if (this._durationGoal !== void 0) {
      response += (_a = this.duration) != null ? _a : 0;
    }
    response += 100 - Math.abs(this.activity);
    response += 100 - Math.abs(this.excitement);
    response += 100 + this.interest;
    response += 100 + this.variety;
    return Math.round(this._durationGoal === void 0 ? response / 4 : response / 5);
  }
  get activity() {
    const goalLookup = {
      ["need" /* Need */]: 0.35,
      ["and" /* And */]: 0.75,
      ["but" /* But */]: 0.5,
      ["therefore" /* Therefore */]: 0.75
    };
    const goal = (goalLookup[this._abtStage] || 0.5) * this._expectedDuration;
    let response = Math.round((this._activeDuration - goal) / goal * 100);
    if (response > 100) {
      response = 100;
    } else if (response < -100) {
      response = -100;
    }
    return response;
  }
  get excitement() {
    const goalLookup = {
      ["need" /* Need */]: 0.35,
      ["and" /* And */]: 0.75,
      ["but" /* But */]: 0.5,
      ["therefore" /* Therefore */]: 0.75
    };
    const goal = (goalLookup[this._abtStage] || 0.5) * this._expectedDuration;
    if (this._excitingDuration === goal) {
      return 0;
    } else if (this._excitingDuration >= 2 * goal) {
      return 100;
    } else if (this._excitingDuration < goal) {
      return -Math.round((goal - this._excitingDuration) / goal * 100);
    } else if (this._excitingDuration > goal) {
      return Math.round((this._excitingDuration - goal) / goal * 100);
    }
  }
  get interest() {
    const maxSceneType = Object.keys(SceneType).filter((key) => isNaN(Number(key))).length;
    const interestGoal = Math.round((this._sceneCount > maxSceneType ? maxSceneType : this._sceneCount) * 0.75);
    if (this._sceneTypeUsed.length >= interestGoal)
      return 0;
    const response = Math.round(this._sceneTypeUsed.length * 100 / interestGoal);
    if (response > 100)
      return 0;
    return -(100 - response);
  }
  get variety() {
    if (this._duplicatedSuccessiveSceneType === 0)
      return 0;
    return -Math.round(this._duplicatedSuccessiveSceneType / this._sceneCount * 100);
  }
  get duration() {
    if (this._durationGoal === void 0)
      return void 0;
    return 100 + (this._expectedDuration - this._durationGoal) / this._durationGoal * 100;
  }
  get expectedDuration() {
    return this._expectedDuration;
  }
  addExpectedDuration(duration2) {
    this._expectedDuration += duration2;
  }
  addExcitingDuration(duration2) {
    this._excitingDuration += duration2;
  }
  addActiveDuration(duration2) {
    this._activeDuration += duration2;
  }
  addSceneType(sceneType) {
    this._sceneCount++;
    if (this._sceneTypeUsed.includes(sceneType))
      return;
    this._sceneTypeUsed.push(sceneType);
  }
  addDuplicatedSuccessiveSceenType() {
    this._duplicatedSuccessiveSceneType++;
  }
};

// src/services/sceneAnalyserService/SceneAnalyserService.ts
var SceneAnalyserService = class {
  constructor(_api) {
    this._api = _api;
    __publicField(this, "_defaultDuration", /* @__PURE__ */ new Map([
      ["action" /* Action */, 15 * 60],
      ["combat" /* Combat */, 15 * 60],
      ["encounter" /* Encounter */, 15 * 60],
      ["exposition" /* Exposition */, 5 * 60],
      ["investigation" /* Investigation */, 15 * 60],
      ["decision" /* Decision */, 10 * 60],
      ["preparation" /* Preparation */, 10 * 60],
      ["recap" /* Recap */, 5 * 60],
      ["socialcombat" /* SocialCombat */, 15 * 60]
    ]));
  }
  analyseSession(session) {
    var _a, _b, _c, _d;
    const scenes = this._api.get(void 0, session.campaign, "scene" /* Scene */, session);
    if (scenes.length === 0)
      return void 0;
    scenes.sort((a, b) => b.positionInParent - a.positionInParent);
    const medianDurations = this._analyseMedianDuration(session.campaign);
    const response = new SceneAnalysis((_a = session.attribute("abtstage" /* AbtStage */)) == null ? void 0 : _a.value, (_b = session.attribute("expected")) == null ? void 0 : _b.value);
    let previousSceneType = void 0;
    for (let i = 0; i < scenes.length; i++) {
      const scene = scenes[i];
      const sceneType = scene.attribute("scenetype" /* SceneType */).value;
      if (sceneType === void 0)
        continue;
      let duration2 = medianDurations.get(sceneType);
      if (duration2 === void 0)
        duration2 = this._defaultDuration.get(sceneType);
      const isExciting = (_d = (_c = scene.attribute("externalactions" /* ExternalActions */)) == null ? void 0 : _c.value) != null ? _d : false;
      const isActive = isSceneActive(sceneType);
      response.addSceneType(sceneType);
      response.addExpectedDuration(duration2);
      if (previousSceneType === sceneType)
        response.addDuplicatedSuccessiveSceenType();
      if (isExciting)
        response.addExcitingDuration(duration2);
      if (isActive)
        response.addActiveDuration(duration2);
      previousSceneType = sceneType;
    }
    return response;
  }
  _analyseMedianDuration(campaing) {
    const allScenes = this._api.get(void 0, campaing, "scene" /* Scene */);
    const durations = /* @__PURE__ */ new Map();
    allScenes.forEach((scene) => {
      var _a, _b, _c;
      const sceneType = (_a = scene.attribute("scenetype" /* SceneType */)) == null ? void 0 : _a.value;
      const duration2 = (_b = scene.attribute("duration" /* Duration */)) == null ? void 0 : _b.value;
      if (sceneType === void 0 || duration2 == void 0)
        return;
      if (durations.has(sceneType)) {
        (_c = durations.get(sceneType)) == null ? void 0 : _c.push(duration2);
      } else {
        durations.set(sceneType, [duration2]);
      }
    });
    const medianDurations = /* @__PURE__ */ new Map();
    durations.forEach((durationArray, sceneType) => {
      const sortedArray = durationArray.sort((a, b) => a - b);
      const medianIndex = Math.floor(sortedArray.length / 2);
      medianDurations.set(sceneType, sortedArray[medianIndex]);
    });
    return medianDurations;
  }
  getExpectedDuration(campaign, sceneType) {
    var _a;
    if (sceneType === void 0)
      return 0;
    const allScenes = this._api.get(void 0, campaign, "scene" /* Scene */).filter((scene) => {
      var _a2;
      return ((_a2 = scene.attribute("scenetype" /* SceneType */)) == null ? void 0 : _a2.value) === sceneType;
    });
    let response = 0;
    allScenes.forEach((scene) => {
      var _a2, _b;
      response += (_b = (_a2 = scene.attribute("duration" /* Duration */)) == null ? void 0 : _a2.value) != null ? _b : 0;
    });
    if (response === 0)
      return (_a = this._defaultDuration.get(sceneType)) != null ? _a : 0;
    return response;
  }
};

// src/factories/ServiceFactory.ts
var _ServiceFactory = class {
  static initialise(app, api2) {
    _ServiceFactory._app = app;
    _ServiceFactory._api = api2;
  }
  static createSceneAnalyserService() {
    return new SceneAnalyserService(_ServiceFactory._api);
  }
};
var ServiceFactory = _ServiceFactory;
__publicField(ServiceFactory, "_app");
__publicField(ServiceFactory, "_api");

// src/i18n/it.ts
var i18nIt = {
  elements: {
    campaign_one: "Campagna",
    campaign_other: "Campagne",
    campaing_inside: "Dentro la Campagna",
    campaign_contains: "Contiene Campagne",
    adventure_one: "Avventura",
    adventure_other: "Avventure",
    adventure_inside: "Dentro l'Avventura",
    adventure_contains: "Contiene Avventure",
    session_one: "Sessione",
    session_other: "Sessioni",
    session_inside: "Dentro la Sessione",
    session_contains: "Contiene Sessioni",
    chapter_one: "Capitolo",
    chapter_other: "Capitoli",
    chapter_inside: "Dentro il Capitolo",
    chapter_contains: "Contiene Capitoli",
    scene_one: "Scena",
    scene_other: "Scene",
    scene_inside: "Dentro la Scena",
    scene_contains: "Contiene Scene",
    playercharacter_one: "Personaggio Giocante",
    playercharacter_other: "Personaggi Giocanti",
    playercharacter_inside: "Dentro il Personaggio Giocante",
    playercharacter_contains: "Contiene Personaggi Giocanti",
    nonplayercharacter_one: "Personaggio Non Giocante",
    nonplayercharacter_other: "Personaggi Non Giocanti",
    nonplayercharacter_inside: "Dentro il Personaggio Non Giocante",
    nonplayercharacter_contains: "Contiene Personaggi Non Giocanti",
    location_one: "Luogo",
    location_other: "Luoghi",
    location_inside: "Dentro il Luogo",
    location_contains: "Contiene Luoghi",
    faction_one: "Fazione",
    faction_other: "Fazioni",
    faction_inside: "Dentro la Fazione",
    faction_contains: "Contiene Fazioni",
    event_one: "Evento",
    event_other: "Eventi",
    event_inside: "Dentro l'Evento",
    event_contains: "Contiene Eventi",
    clue_one: "Indizio",
    clue_other: "Indizi",
    clue_inside: "Dentro l'Indizio",
    clue_contains: "Contiene Indizi",
    subplot_one: "Sottotrama",
    subplot_other: "Sottotrame",
    subplot_inside: "Dentro la Sottotrama",
    subplot_contains: "Contiene Sottotrame",
    object_one: "Oggetto",
    object_other: "Oggetti",
    object_inside: "Dentro l'Oggetto",
    object_contains: "Contiene Oggetti",
    monster_one: "Mostro",
    monster_other: "Mostri",
    monster_inside: "Dentro il Mostro",
    monster_contains: "Contiene Mostri",
    element_one: "Elemento",
    element_other: "Elementi"
  },
  tasks: {
    task_one: "Compito",
    task_other: "Compiti",
    owned: "Compiti di {{variable}}",
    name: "Nome",
    priority: "Priorit\xE0",
    mentionedin: "Menzionato in",
    description: "Descrizione",
    assignedto: "Assegnato a",
    all: "Tutti i Compiti",
    complete_campaign: "Completa Campagna",
    complete_adventure: "Completa Avventura",
    complete_session: "Completa Sessione",
    complete_chapter: "Completa Capitolo",
    complete_scene: "Completa Scena",
    complete_playercharacter: "Completa Personaggio Giocante",
    complete_nonplayercharacter: "Completa Personaggio Non Giocante",
    complete_location: "Completa Luogo",
    complete_faction: "Completa Fazione",
    complete_event: "Completa Evento",
    complete_clue: "Completa Indizio",
    complete_subplot: "Completa Sottotrama",
    complete_object: "Completa Oggetto",
    complete_monster: "Completa Mostro",
    complete_element: "Completa Elemento"
  },
  customattributes: {
    name: "Nome",
    type: "Tipo",
    text: "Testo",
    number: "Numero",
    option: "Opzione",
    checkbox: "Checkbox",
    longtext: "Testo Lungo",
    link: "Link",
    date: "Data",
    availableon: "Disponibile su",
    your: "I Tuoi Attributi Personalizzati",
    describe: `Puoi personalizzare gli attributi da utilizzare nei tuoi elementi.
	
	A sinistra puoi vedere gli attributi che hai gi\xE0 creato, e puoi modificarli.
	
	Se desideri crearne di nuovi, basta cliccare sul pulsante e definire il nome e il tipo dell'attributo e in quali elementi sar\xE0 disponibile.`,
    cantdelete: "Non puoi eliminare questo attributo perch\xE9 \xE8 utilizzato in uno o pi\xF9 elementi."
  },
  attributes: {
    attribute_one: "Attributo",
    attribute_other: "Attributi",
    description: "Descrizione",
    ghost: "Fantasma",
    lie: "Menzongna",
    arc: "Arco del Personaggio",
    beliefs: "Credenze",
    need: "Necessit\xE0",
    behaviour: "Comportamento",
    want: "Desiderio",
    opposition: "Opposizione",
    strengths: "Punti di Forza",
    weaknesses: "Debolezze",
    storycircle: "Cerchio Narrativo",
    scenetype: "Tipo",
    dob: "Data di Nascita",
    dod: "Data di Morte",
    sceneaction: "Azione",
    date: "Data",
    sessiondate: "Data della Sessione",
    storycirclestage: "Fase del Cerchio Narrativo",
    abtstage: "Fase ABT",
    externalactions: "Eccitante",
    address: "Indirizzo",
    location: "Luogo",
    duration: "Durata",
    philosophy: "Filosofia",
    majorclues: "Indizi Principali",
    factionstructure: "Struttura della Fazione",
    nonplayercharactertype: "Tipo di PNG",
    sensoryimprint: "Impronta Sensoriale",
    custom: "Attributi Personalizzati",
    stage: "Fase",
    coordinates: "Coordinate",
    sensoryimprints: "Impronte Sensoriali",
    active: " (Attivo)",
    occupation: "Occupazione",
    stake: "Posta in gioco",
    goals: "Obiettivi (Desiderio)",
    attitude: "Atteggiamento (Comportamento)",
    kishotenketsu: "Kish\u014Dtenketsu",
    conflict: "Conflitto",
    pronoun: "Pronome"
  },
  npctype: {
    npctype_main: "Principale",
    npctype_supporting: "Di Supporto",
    npctype_extra: "Extra",
    description_main: "Un personaggio non giocante completo, con dettagli sulla loro personalit\xE0, desideri e bisogni.",
    description_supporting: "Un personaggio non giocante ricorrente che non \xE8 un personaggio principale.",
    description_extra: "Un personaggio non giocante con dettagli minimi, sufficienti solo per essere utilizzato come personaggio di sfondo."
  },
  arc: {
    arc_1: "Arco Positivo",
    arc_2: "Arco della Disillusione",
    arc_3: "Arco della Caduta",
    arc_4: "Arco della Corruzione",
    arc_5: "Arco Piatto",
    description_1: "Il personaggio inizia **credendo in una bugia**, poi incontra la verit\xE0 e supera la bugia per **accettare la verit\xE0**.",
    description_2: "Il personaggio inizia **credendo in una bugia**, poi incontra la verit\xE0 e supera la bugia, ma **la verit\xE0 porta a un esito peggiore** rispetto a credere nella bugia.",
    description_3: "Il personaggio inizia **credendo in una bugia**, poi incontra la verit\xE0 ma la rifiuta e **crede in una bugia pi\xF9 forte o peggiore**.",
    description_4: "Il personaggio inizia **conoscendo la verit\xE0**, ma poi la rifiuta, **abbracciando una bugia**.",
    description_5: "Il personaggio inizia **conoscendo la verit\xE0**, ma poi le loro convinzioni sono messe alla prova, ma continuano a **abbracciare la verit\xE0**."
  },
  options: {
    option_one: "Opzione",
    option_other: "Opzioni",
    wizard: "Wizard"
  },
  search: {
    entertocreate: "Premi Invio per creare"
  },
  parents: {
    parent_campaign: "Parte della Campagna",
    parent_adventure: "Parte dell'Avventura",
    parent_session: "Parte della Sessione"
  },
  relationships: {
    relationship_other: "Relazioni",
    relationship_one: "Relazione",
    relationshiptype: "Tipo di Relazione",
    relationshiptype_reverse: "Invertita",
    relationshiptype_bidirectional: "Bidirezionale",
    relationshiptype_unidirectional: "Unidirezionale",
    relationshiptype_parent: "Genitore",
    relationshiptype_child: "Figlio"
  },
  gallery: {
    title: "Galleria Immagini",
    drag: "Trascina una nuova immagine",
    dragdrop: "Trascina e rilascia l'immagine qui",
    upload: "Carica una nuova immagine",
    link: "Collega una nuova immagine",
    browse: "Sfoglia le immagini",
    browselocal: "Sfoglia le immagini locali",
    caption: "Didascalia",
    carousel: "Carosello Immagini"
  },
  analyser: {
    expectedduration: "Durata Prevista",
    activity: "Attivit\xE0",
    excitement: "Eccitazione",
    interest: "Interesse",
    variety: "Variet\xE0",
    sceneanalyser: "Analizzatore di Scene",
    saactivity_positiveerror: "Troppe scene attive",
    saactivity_positivewarning: "Il numero di scene attive potrebbe essere pi\xF9 del necessario.",
    saactivity_negativeerror: "Non abbastanza scene attive",
    saactivity_negativewarning: "Il numero di scene attive potrebbe non essere sufficiente.",
    saexcitement_positiveerror: "Troppe scene eccitanti",
    saexcitement_positivewarning: "Il numero di scene eccitanti potrebbe essere pi\xF9 del necessario.",
    saexcitement_negativeerror: "Non abbastanza scene eccitanti",
    saexcitement_negativewarning: "Il numero di scene eccitanti potrebbe non essere sufficiente.",
    sainterest_negativeerror: "Non abbastanza variet\xE0 nel tipo di scene",
    sainterest_negativewarning: "Il numero di tipi di scene potrebbe non essere sufficiente.",
    savariety_negativeerror: "Troppi tipi di scene ripetuti",
    savariety_negativewarning: "Il numero di tipi di scene ripetuti potrebbe essere troppo alto."
  },
  clues: {
    description: "Descrizione",
    destination: "Destinazione"
  },
  buttons: {
    save: "Salva",
    edit: "Modifica",
    delete: "Elimina",
    cancel: "Annulla",
    create: "Crea",
    replace: "Sostituisci",
    adddestination: "Aggiungi Destinazione",
    newattribute: "Nuovo Attributo",
    assign: "Assegna",
    unassign: "Dissocia",
    launchwizard: "Lancia il Wizard di Creazione",
    previous: "< Precedente",
    next: "Successivo >"
  },
  create: {
    title: "Crea Nuovo...",
    in_title: "Converti in...",
    new_campaign: "Crea una nuova Campagna",
    new_adventure: "Crea una nuova Avventura",
    new_session: "Crea una nuova Sessione",
    new_chapter: "Crea un nuovo Capitolo",
    new_scene: "Crea una nuova Scena",
    new_element: "Crea un nuovo Elemento di Rpg Manager",
    new_task: "Crea un nuovo Compito",
    new_playercharacter: "Crea un nuovo Personaggio Giocante",
    new_nonplayercharacter: "Crea un nuovo Personaggio Non Giocante",
    new_location: "Crea un nuovo Luogo",
    new_faction: "Crea una nuova Fazione",
    new_event: "Crea un nuovo Evento",
    new_clue: "Crea un nuovo Indizio",
    new_subplot: "Crea una nuova Sottotrama",
    new_object: "Crea un nuovo Oggetto",
    new_monster: "Crea un nuovo Mostro",
    in_element: "Aggiungi un nuovo Elemento di Rpg Manager alla nota corrente",
    in_campaign: "Aggiungi una nuova Campagna alla nota corrente",
    in_adventure: "Aggiungi una nuova Avventura alla nota corrente",
    in_session: "Aggiungi una nuova Sessione alla nota corrente",
    in_chapter: "Aggiungi un nuovo Capitolo alla nota corrente",
    in_scene: "Aggiungi una nuova Scena alla nota corrente",
    in_playercharacter: "Aggiungi un nuovo Personaggio Giocante alla nota corrente",
    in_nonplayercharacter: "Aggiungi un nuovo Personaggio Non Giocante alla nota corrente",
    in_location: "Aggiungi un nuovo Luogo alla nota corrente",
    in_faction: "Aggiungi una nuova Fazione alla nota corrente",
    in_event: "Aggiungi un nuovo Evento alla nota corrente",
    in_clue: "Aggiungi un nuovo Indizio alla nota corrente",
    in_subplot: "Aggiungi una nuova Sottotrama alla nota corrente",
    in_object: "Agginungi un nuovo Oggetto alla nota corrente",
    in_monster: "Aggiungi un nuovo Mostro alla nota corrente",
    add_session: "Aggiungi una nuova Sessione",
    add_scene: "Aggiungi una nuova Scena",
    add_chapter: "Aggiungi un nuovo Capitolo",
    add_task: "Aggiungi un nuovo Compito",
    add_clue: "Aggiungi Indizio",
    add_relationship: "Aggiungi Relazione",
    add_attribute: "Aggiungi Attributo",
    select_campaign: "Seleziona Campagna",
    select_adventure: "Seleziona Avventura",
    select_session: "Seleziona Sessione",
    select_type: "Seleziona il tipo di elemento che vuoi creare",
    select_template: "Seleziona il modello per il tuo elemento"
  },
  chatgpt: {
    overlaytitle_nonplayercharacter: "Generazione automatica del tuo Personaggio",
    overlaytitle_chapter: "Generazione automatica del tuo Capitolo",
    overlaydescription: "Potrebbe richiedere del tempo, per favore sii paziente e attendi il completamento del processo.",
    generate: "Genera con ChatGPT",
    messages: [
      "Recupero suggerimenti da ChatGPT...",
      "In attesa che ChatGPT pensi...",
      "Mi faccio un caff\xE8 mentre aspetto...",
      "Il piccione che trasportava il tuo suggerimento potrebbe essere stato mangiato da un drago rosso...",
      "Parliamo di Call of Cthulhu mentre aspettiamo?",
      "S\xEC, sto ANCORA aspettando!",
      "S\xEC, sto ANCORA aspettando! (Non sono un bot molto paziente)",
      "Sapevi che la prima partita di D&D \xE8 stata giocata da Gary Gygax e Dave Arneson nel 1974?",
      "Ti capita spesso di sbadigliare mentre aspetti ChatGPT?",
      "Il creatore di questa estensione \xE8 il MIGLIORE narratore che conosco! (anche se \xE8 l'unico che conosco...)",
      "ChatGPT \xE8 in ritardo, tira d'iniziativa!",
      "Perch\xE9 l'NPC ha attraversato la strada? Per sfuggire ai pessimi giochi di parole del bardo!",
      "Se hai dei dadi a 20 facce di scorta, ora sarebbe un buon momento per tirare per la pazienza.",
      "Chiederei aiuto a uno stregone, ma sono noti per rispondere in ritardo.",
      "Sto evocando un'entit\xE0 di chat amichevole... Non lanciare 'Dissolvi Magie'!",
      "Ancora in attesa che il bardo finisca il suo assolo...",
      "I draghi usano ChatGPT? Chiedo per un amico.",
      "Quanti elfi ci vogliono per ottenere una risposta? Solo uno, ma racconter\xE0 una lunga storia a riguardo.",
      "Scusa per il ritardo. Un ladro ha cercato di borseggiare il mio codice.",
      "Il mago ha maledetto di nuovo la mia connessione?",
      "In una terra lontana, lontana... ChatGPT sta ancora pensando.",
      "Un mago non \xE8 n\xE9 in ritardo n\xE9 in anticipo. Ma ChatGPT... a volte si prende il suo tempo.",
      "Affrontando un cubo gelatinoso. Potrebbe richiedere un po'...",
      "Ho detto al barbaro di 'aspettare qui'. Sta ancora l\xEC fermo..."
    ]
  },
  wizards: {
    errors: "Sono stati riscontrati i seguenti errori:",
    chapter: {
      errors: {
        missingtargettype: "Seleziona un tipo di destinazione",
        missingtargetname: "Inserisci un nome destinazione o seleziona uno esistente",
        missingdestination: "Seleziona una destinazione valida o inserisci il nome della nuova destinazione"
      },
      cluename: "Nome dell'Indizio",
      cluesdescription: "Descrizione dell'indizio/i",
      title: "Wizard Capitolo",
      description: `Un capitolo \xE8 un modo per organizzare avventure pi\xF9 grandi in porzioni pi\xF9 gestibili, come per un libro o un film. 
		  
		  Descrivi *{{name}}*.`,
      destinationtitle: "Destinazione",
      destination: "Dove porta questo capitolo?",
      destinationelementtype: "Tipo di destinazione",
      destinationtype_adventure: "Il passo successivo da qui dovrebbe essere un'altra avventura",
      destinationtype_chapter: "Questo capitolo dovrebbe portare a un altro capitolo",
      destinationelementtype_existing: "Esistente",
      destinationelementtypedescription_existing: "Seleziona un'avventura o un capitolo esistente per seguirlo.",
      destinationelementtype_new: "Nuovo",
      destinationelementtypedescription_new: "L'avventura o il capitolo a cui seguir\xE0 questo \xE8 nuovo.",
      destinationelement_existing: "Avventura o capitolo di destinazione esistente",
      destinationelement_new: "Nome nuovo avventura o capitolo di destinazione",
      targettitle: "Obiettivo",
      target: "Il capitolo punta a un evento o a una posizione per far progredire la trama?",
      targetdescription: "Prima di descrivere l'obiettivo, seleziona il tipo di obiettivo che vuoi utilizzare.",
      targettitle_event: "Descrizione dell'evento chiave",
      targetdescription_event: "Scrivi una descrizione per l'evento chiave nel capitolo *{{name}}*",
      targettitle_location: "Descrizione della posizione chiave",
      targetdescription_location: "Scrivi una descrizione per la posizione chiave nel capitolo *{{name}}*",
      targetelementtype: "Tipo di obiettivo",
      targettype_event: "La trama si sviluppa attraverso un evento",
      targettype_location: "Il capitolo ruota attorno a una posizione",
      targetelementtype_existing: "Esistente",
      targetelementtypedescription_existing: "Seleziona un evento o una posizione esistenti su cui far pivot il capitolo.",
      targetelementtype_new: "Nuovo",
      targetelementtypedescription_new: "L'evento o la posizione \xE8 nuovo.",
      targetelement_existing: "Evento o posizione di destinazione esistente",
      targetelement_new: "Nome nuovo evento o posizione di destinazione",
      targetelementdescription: "Descrizione dell'evento o della posizione",
      removeexistingclue: "Rimuovi",
      selectexistingclue: "Seleziona indizio esistente"
    },
    npc: {
      title: "Wizard Personaggio Non Giocante",
      create: "Crea automaticamente",
      description_arc: `L'arco del personaggio descrive il modo in cui un personaggio cresce ed evolve durante la storia.
				
		  Seleziona **l'arco** che identifica meglio l'evoluzione di *{{name}}*.`,
      description_behaviour: `Il comportamento \xE8 il modo normale in cui un personaggio fa le cose, il modo in cui i personaggi giocatori li vedono.
		  
		  Qual \xE8 il comportamento di *{{name}}*?`,
      description_beliefs: `Le Credenze sono ci\xF2 che i personaggi accettano come vero nel mondo, anche se non lo \xE8.
		  
		  Quali sono le credenze di *{{name}}*?`,
      description_description: `La descrizione \xE8 un'introduzione a un personaggio, fornendo
			  una breve informazione di sfondo per aiutare il narratore a identificarli chiaramente. Questa parte \xE8 particolarmente importante se desideri utilizzare la generazione automatica dei personaggi tramite la funzione IA.

			  Descrivi *{{name}}*.`,
      description_occupation: `L'occupazione definisce cosa fa un personaggio per vivere. Sebbene questo non definisca chi sono,
			  aggiunge uno strato di profondit\xE0 al personaggio e suggerisce un insieme di abilit\xE0 che possiedono.
			  
			  Qual \xE8 l'occupazione di *{{name}}*?`,
      description_ghost: `Il Fantasma \xE8 un evento importante nel passato del personaggio che definisce le loro credenze.
			  Il fantasma \xE8 molto probabilmente un punto di svolta, molto positivo o molto negativo, e potrebbe aver plasmato la loro visione del mondo come una menzogna.
			  
			  Qual \xE8 l'evento che ha plasmato *{{name}}*?`,
      description_lie: `La Menzogna \xE8 ci\xF2 che un personaggio crede essere vero nel mondo, ma non lo \xE8.
			  
			  In cosa crede la menzogna di *{{name}}*?`,
      description_need: `Il Bisogno \xE8 ci\xF2 di cui un personaggio ha veramente bisogno, anche se \xE8 sconosciuto a loro.
			  
			  Di cosa ha disperatamente bisogno *{{name}}*?`,
      description_opposition: `Le Forze Ostili sono forze che impediscono al personaggio di ottenere ci\xF2 che desidera.
					
			  Cosa sta ostacolando *{{name}}* nel raggiungere ci\xF2 che vuole?`,
      description_strengths: `I Punti di Forza sono gli attributi positivi di un personaggio.
			  
			  Seleziona quelli di *{{name}}*.`,
      description_weaknesses: `I Punti Deboli sono gli attributi negativi di un personaggio.
			  
			  Seleziona quelli di *{{name}}*.`,
      description_type: `Il tipo di personaggio definisce la loro importanza nella campagna e la quantit\xE0 di attributi che hanno di default.
				  
			  Chi \xE8 *{{name}}*?`,
      description_want: `Il Desiderio \xE8 ci\xF2 che i personaggi pensano di volere raggiungere, anche se non \xE8 ci\xF2 di cui hanno veramente bisogno. Questo \xE8 pubblicamente noto e determina il loro comportamento.

Cosa vuole *{{name}}*?`,
      description_stake: `La Posta in gioco definisce il valore di quanto il personaggio \xE8 **investito** nella sua occupazione, desideri e comportamenti.
Ci\xF2 aiuta a definire quanto sforzo metteranno nel raggiungerli.

Qual \xE8 la Posta in gioco di *{{name}}*?`
    }
  },
  errors: {
    must_campaign: "Devi creare prima una campagna",
    must_adventure: "Devi creare prima un'avventura",
    must_session: "Devi creare prima una sessione"
  },
  kishotenketsu: {
    ki: "Ki<br/><small>(Introduzione)</small>",
    sho: "Sh\u014D<br/><small>(Sviluppo)</small>",
    ten: "Ten<br/><small>(Svolta)</small>",
    ketsu: "Ketsu<br/><small>(Conclusione)</small>",
    description_ki: "**Introduzione**: un'introduzione ai personaggi, all'epoca e ad altre informazioni necessarie per capire la trama",
    description_sho: "**Sviluppo**: segue i lead verso la svolta nella storia. Nessun cambiamento significativo finora.",
    description_ten: "**Svolta**: la storia si orienta verso uno sviluppo inaspettato. Questo \xE8 il nucleo della storia, il yama (\u30E4\u30DE) o climax. Se la narrazione prende diverse svolte, questa \xE8 la pi\xF9 grande.",
    description_ketsu: "**Conclusione**: chiamata anche ochi (\u843D\u3061) o finale, conclude la storia."
  },
  storycircle: {
    you: "Tu/Loro",
    need: "Bisogno",
    go: "Vai",
    search: "Cerca",
    find: "Trova",
    take: "Prendi",
    return: "Torna",
    change: "Cambia",
    description_you: "Inizia stabilendo la situazione attuale dei personaggi giocanti all'inizio di questo particolare intreccio. Cosa stanno facendo attualmente? Dove si trovano? Qual \xE8 il loro obiettivo immediato?",
    description_need: "Fai in modo che i personaggi giocanti sentano un bisogno. Non chiamarlo *gancio*, assicurati che i personaggi giocanti siano coinvolti e sentano un bisogno disperato di fare qualcosa.",
    description_go: "I personaggi giocanti entrano in una nuova situazione. Escono dalla loro zona di comfort e entrano in un nuovo mondo. Questo \xE8 il punto di non ritorno.",
    description_search: "Questa \xE8 la fase delle sfide. I personaggi giocanti sono testati e affrontano le loro paure. Sono costretti ad adattarsi alla nuova situazione.",
    description_find: "I personaggi giocanti molto probabilmente devono raggiungere ci\xF2 per cui sono partiti, ma devono pagare un prezzo: ci\xF2 che ottengono \xE8 ci\xF2 che vogliono, ma non ci\xF2 di cui hanno bisogno.",
    description_take: "\xC8 il momento di creare una situazione in cui i personaggi giocanti possono passare da ci\xF2 che vogliono a ci\xF2 di cui hanno bisogno. Questo \xE8 il momento della realizzazione.",
    description_return: "I personaggi giocanti lottano per ottenere ci\xF2 di cui hanno bisogno, e nel farlo tornano nel mondo che conoscono.",
    description_change: "I personaggi giocanti sono cambiati, e dovrebbero vedere gli effetti delle loro azioni nel mondo che conoscono."
  },
  conflict: {
    title: "Titolo",
    description_title: "Questo \xE8 un nome descrittivo per il conflitto, che dovrebbe aiutare il Narratore a ricordare di cosa si tratta.",
    description: "Descrizione",
    description_description: "Una descrizione del conflitto, inclusi i modi in cui i personaggi giocanti sono coinvolti.",
    outcome: "Esito",
    description_outcome: "Questo descrive l'esito finale del conflitto, dopo che il conflitto si \xE8 svolto.",
    category: "Categoria",
    description_category: `Questa \xE8 una categoria ampia che aiuta a descrivere la natura del conflitto e aiuta il Narratore a capire di cosa tratta il conflitto.
      
- **Ambizione**: I personaggi coinvolti vogliono raggiungere qualcosa.
- **Tradimento**: Il conflitto riguarda un tradimento.
- **Sopravvivenza**: \xC8 una questione di vita o di morte.
- **Vendetta**: Il conflitto riguarda la vendetta dei personaggi.
- **Ideologia**: Tutto ruota attorno a un'ideologia.
- **Amore**: Conflitto personale che si concentra sulle relazioni.
- **Culpa**: Il conflitto riguarda la colpa.
- **Paura**: Ruota attorno alla paura.`,
    category_ambition: "Ambizione",
    category_betrayal: "Tradimento",
    category_survival: "Sopravvivenza",
    category_revenge: "Vendetta",
    category_ideology: "Ideologia",
    category_love: "Amore",
    category_guilt: "Culpa",
    category_fear: "Paura",
    involvement: "Coinvolgimento",
    involvement_active: "Attivo",
    involvement_passive: "Passivo",
    involvement_unaware: "Ignaro",
    involvement_forced: "Forzato",
    involvement_opportunistic: "Opportunistico",
    description_involvement: `Questo descrive come i personaggi giocanti sono coinvolti nel conflitto e aiuta il Narratore a capire come possono essere collegati al conflitto.
      
- **Attivo**: I personaggi giocanti sono attivamente coinvolti nel conflitto.
- **Passivo**: I personaggi giocanti non sono attivamente coinvolti nel conflitto, ma ne sono comunque influenzati.
- **Ignaro**: I personaggi giocanti non sono consapevoli del conflitto, ma ne sono comunque influenzati.
- **Forzato**: I personaggi giocanti sono costretti a essere coinvolti nel conflitto.
- **Opportunistico**: I personaggi giocanti non sono coinvolti nel conflitto, ma possono trarne vantaggio.`,
    opposingforces: "Forze Opposte",
    description_opposingforces: "Elenco dei personaggi non giocanti o delle fazioni coinvolte nel conflitto. Aiuta il Narratore a capire chi sta combattendo contro chi.",
    events: "Eventi",
    description_events: "Elenco degli eventi che fanno parte del conflitto.",
    status: "Stato",
    description_status: `Questo descrive lo stato attuale del conflitto e aiuta il Narratore a capire come si sta sviluppando il conflitto.
      
- **Pianificato**: Il conflitto \xE8 pianificato, ma non \xE8 ancora iniziato.
- **In corso**: Il conflitto sta attualmente accadendo.
- **Risolto**: Il conflitto \xE8 stato risolto.`,
    status_planned: "Pianificato",
    status_inprogress: "In Corso",
    status_resolved: "Risolto",
    stakes: "Posta in gioco",
    description_stakes: `Questo descrive cosa \xE8 in gioco nel conflitto e cosa succeder\xE0 se un lato vince sull'altro.
      
- **Vita e Morte**: Minaccia la vita di qualcuno.
- **Amore e Relazioni**: Coinvolge relazioni personali.
- **Potere e Controllo**: Coinvolge il potere e il controllo sugli altri.
- **Reputazione e Onore**: Sfida l'onore di un personaggio.
- **Ricchezza e Risorse**: Riguarda tutto il denaro.
- **Libert\xE0 e Giustizia**: Simile a Morale ed Etica, ma dal punto di vista della giustizia.
- **Conoscenza e Informazioni**: Le informazioni sono potere.
- **Morale ed Etica**: \xC8 una questione di ci\xF2 che \xE8 giusto e ci\xF2 che \xE8 sbagliato.
- **Credenze e Valori**: Sfida le credenze di un personaggio.
- **Futuro e Eredit\xE0**: Ci\xF2 che sar\xE0 lasciato dietro di s\xE9.`,
    stake: {
      lifeanddeath: "Vita e Morte",
      loveandrelationships: "Amore e Relazioni",
      powerandcontrol: "Potere e Controllo",
      reputationandhonor: "Reputazione e Onore",
      wealthandresources: "Ricchezza e Risorse",
      freedomandjustice: "Libert\xE0 e Giustizia",
      knowledgeandinformation: "Conoscenza e Informazioni",
      moralityandethics: "Morale ed Etica",
      beliefsandvalues: "Credenze e Valori",
      futureandlegacy: "Futuro ed Eredit\xE0"
    }
  },
  name: "Nome",
  documentation: "Documentazione",
  global: "Risorsa Globale",
  global_description: "Rendi questo elemento disponibile in tutte le campagne"
};

// node_modules/i18next/dist/esm/i18next.js
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type2, args) {
    if (console && console[type2])
      console[type2].apply(console, args);
  }
};
var Logger = class {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix3, debugOnly) {
    if (debugOnly && !this.debug)
      return null;
    if (typeof args[0] === "string")
      args[0] = `${prefix3}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, __spreadValues(__spreadValues({}, {
      prefix: `${this.prefix}:${moduleName}:`
    }), this.options));
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events, listener3) {
    events.split(" ").forEach((event) => {
      this.observers[event] = this.observers[event] || [];
      this.observers[event].push(listener3);
    });
    return this;
  }
  off(event, listener3) {
    if (!this.observers[event])
      return;
    if (!listener3) {
      delete this.observers[event];
      return;
    }
    this.observers[event] = this.observers[event].filter((l2) => l2 !== listener3);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = [].concat(this.observers[event]);
      cloned.forEach((observer) => {
        observer(...args);
      });
    }
    if (this.observers["*"]) {
      const cloned = [].concat(this.observers["*"]);
      cloned.forEach((observer) => {
        observer.apply(observer, [event, ...args]);
      });
    }
  }
};
function defer() {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a, s3, t2) {
  a.forEach((m) => {
    if (s3[m])
      t2[m] = s3[m];
  });
}
function getLastOfPath(object, path4, Empty) {
  function cleanKey(key) {
    return key && key.indexOf("###") > -1 ? key.replace(/###/g, ".") : key;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  const stack = typeof path4 !== "string" ? [].concat(path4) : path4.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    const key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path4, newValue) {
  const {
    obj,
    k
  } = getLastOfPath(object, path4, Object);
  obj[k] = newValue;
}
function pushPath(object, path4, newValue, concat) {
  const {
    obj,
    k
  } = getLastOfPath(object, path4, Object);
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath(object, path4) {
  const {
    obj,
    k
  } = getLastOfPath(object, path4);
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, (s3) => _entityMap[s3]);
  }
  return data;
}
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0)
    return true;
  const r = new RegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path4) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path4])
    return obj[path4];
  const paths = path4.split(keySeparator);
  let current = obj;
  for (let i = 0; i < paths.length; ++i) {
    if (!current)
      return void 0;
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      let j = 2;
      let p2 = paths.slice(i, i + j).join(keySeparator);
      let mix = current[p2];
      while (mix === void 0 && paths.length > i + j) {
        j++;
        p2 = paths.slice(i, i + j).join(keySeparator);
        mix = current[p2];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path4.endsWith(p2)) {
        if (typeof mix === "string")
          return mix;
        if (p2 && typeof mix[p2] === "string")
          return mix[p2];
      }
      const joinedPath = paths.slice(i + j).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
function getCleanedCode(code2) {
  if (code2 && code2.indexOf("_") > 0)
    return code2.replace("_", "-");
  return code2;
}
var ResourceStore = class extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path4 = [lng, ns];
    if (key && typeof key !== "string")
      path4 = path4.concat(key);
    if (key && typeof key === "string")
      path4 = path4.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path4 = lng.split(".");
    }
    const result = getPath(this.data, path4);
    if (result || !ignoreJSONStructure || typeof key !== "string")
      return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path4 = [lng, ns];
    if (key)
      path4 = path4.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path4 = lng.split(".");
      value = ns;
      ns = path4[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path4, value);
    if (!options.silent)
      this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
        this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
    }
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false
    };
    let path4 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path4 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path4[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path4) || {};
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = __spreadValues(__spreadValues({}, pack), resources);
    }
    setPath(this.data, path4, pack);
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns)
      ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1")
      return __spreadValues(__spreadValues({}, {}), this.getResource(lng, ns));
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor])
        value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = class extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng)
      this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0)
      nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
        namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys2, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object")
      options = __spreadValues({}, options);
    if (!options)
      options = {};
    if (keys2 === void 0 || keys2 === null)
      return "";
    if (!Array.isArray(keys2))
      keys2 = [String(keys2)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys2[keys2.length - 1], options);
    const namespace2 = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace2}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace2
          };
        }
        return `${namespace2}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace2
        };
      }
      return key;
    }
    const resolved = this.resolve(keys2, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, __spreadProps(__spreadValues({}, options), {
          ns: namespaces
        })) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = resType === "[object Array]";
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, __spreadValues(__spreadValues({}, options), {
              joinArrays: false,
              ns: namespaces
            }));
            if (copy2[m] === deepKey)
              copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
      res = res.join(joinArrays);
      if (res)
        res = this.extendTranslation(res, keys2, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace2, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, __spreadProps(__spreadValues({}, options), {
            keySeparator: false
          }));
          if (fk && fk.res)
            this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l2, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace2, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace2, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l2, namespace2, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              this.pluralResolver.getSuffixes(language, options).forEach((suffix2) => {
                send([language], key + suffix2, options[`defaultValue${suffix2}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys2, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
        res = `${namespace2}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace2}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, __spreadValues(__spreadValues({}, this.options.interpolation.defaultVariables), options), options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation)
        this.interpolator.init(__spreadValues(__spreadValues({}, options), {
          interpolation: __spreadValues(__spreadValues({}, this.options.interpolation), options.interpolation)
        }));
      const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables)
        data = __spreadValues(__spreadValues({}, this.options.interpolation.defaultVariables), data);
      res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft)
          options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
        options.lng = resolved.usedLng;
      if (options.nest !== false)
        res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
            return null;
          }
          return _this.translate(...args, key);
        }, options);
      if (options.interpolation)
        this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? __spreadValues({
        i18nResolved: resolved
      }, options) : options, this);
    }
    return res;
  }
  resolve(keys2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (typeof keys2 === "string")
      keys2 = [keys2];
    keys2.forEach((k) => {
      if (this.isValidLookup(found))
        return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS)
        namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found))
          return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code2) => {
          if (this.isValidLookup(found))
            return;
          usedLng = code2;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling)
              pluralSuffix = this.pluralResolver.getSuffix(code2, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code2, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code2, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource)
      return this.i18nFormat.getResource(code2, ns, key, options);
    return this.resourceStore.getResource(code2, ns, key, options);
  }
  static hasDefaultValue(options) {
    const prefix3 = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix3 === option.substring(0, prefix3.length) && options[option] !== void 0) {
        return true;
      }
    }
    return false;
  }
};
function capitalize(string3) {
  return string3.charAt(0).toUpperCase() + string3.slice(1);
}
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code2) {
    code2 = getCleanedCode(code2);
    if (!code2 || code2.indexOf("-") < 0)
      return null;
    const p2 = code2.split("-");
    if (p2.length === 2)
      return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x")
      return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code2) {
    code2 = getCleanedCode(code2);
    if (!code2 || code2.indexOf("-") < 0)
      return code2;
    const p2 = code2.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code2) {
    if (typeof code2 === "string" && code2.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p2 = code2.split("-");
      if (this.options.lowerCaseLng) {
        p2 = p2.map((part) => part.toLowerCase());
      } else if (p2.length === 2) {
        p2[0] = p2[0].toLowerCase();
        p2[1] = p2[1].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
          p2[1] = capitalize(p2[1].toLowerCase());
      } else if (p2.length === 3) {
        p2[0] = p2[0].toLowerCase();
        if (p2[1].length === 2)
          p2[1] = p2[1].toUpperCase();
        if (p2[0] !== "sgn" && p2[2].length === 2)
          p2[2] = p2[2].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
          p2[1] = capitalize(p2[1].toLowerCase());
        if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
          p2[2] = capitalize(p2[2].toLowerCase());
      }
      return p2.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
  }
  isSupportedCode(code2) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code2 = this.getLanguagePartFromCode(code2);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes)
      return null;
    let found;
    codes.forEach((code2) => {
      if (found)
        return;
      const cleanedLng = this.formatLanguageCode(code2);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
        found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code2) => {
        if (found)
          return;
        const lngOnly = this.getLanguagePartFromCode(code2);
        if (this.isSupportedCode(lngOnly))
          return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
            return;
          if (supportedLng.indexOf(lngOnly) === 0)
            return supportedLng;
        });
      });
    }
    if (!found)
      found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code2) {
    if (!fallbacks)
      return [];
    if (typeof fallbacks === "function")
      fallbacks = fallbacks(code2);
    if (typeof fallbacks === "string")
      fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
      return fallbacks;
    if (!code2)
      return fallbacks.default || [];
    let found = fallbacks[code2];
    if (!found)
      found = fallbacks[this.getScriptPartFromCode(code2)];
    if (!found)
      found = fallbacks[this.formatLanguageCode(code2)];
    if (!found)
      found = fallbacks[this.getLanguagePartFromCode(code2)];
    if (!found)
      found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code2, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
    const codes = [];
    const addCode = (c) => {
      if (!c)
        return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (typeof code2 === "string" && (code2.indexOf("-") > -1 || code2.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly")
        addCode(this.formatLanguageCode(code2));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
        addCode(this.getScriptPartFromCode(code2));
      if (this.options.load !== "currentOnly")
        addCode(this.getLanguagePartFromCode(code2));
    } else if (typeof code2 === "string") {
      addCode(this.formatLanguageCode(code2));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0)
        addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function(n2) {
    return Number(n2 > 1);
  },
  2: function(n2) {
    return Number(n2 != 1);
  },
  3: function(n2) {
    return 0;
  },
  4: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function(n2) {
    return Number(n2 >= 2);
  },
  10: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function(n2) {
    return Number(n2 !== 0);
  },
  14: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var nonIntlVersions = ["v1", "v2", "v3"];
var intlVersions = ["v4"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  const rules = {};
  sets.forEach((set2) => {
    set2.lngs.forEach((l2) => {
      rules[l2] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = class {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  getRule(code2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        return new Intl.PluralRules(getCleanedCode(code2), {
          type: options.ordinal ? "ordinal" : "cardinal"
        });
      } catch (e2) {
        return;
      }
    }
    return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
  }
  needsPlural(code2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code2, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code2, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code2, options).map((suffix2) => `${key}${suffix2}`);
  }
  getSuffixes(code2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code2, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number2) => this.getSuffix(code2, number2, options));
  }
  getSuffix(code2, count2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code2, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count2)}`;
      }
      return this.getSuffixRetroCompatible(rule, count2);
    }
    this.logger.warn(`no plural rule found for: ${code2}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count2) {
    const idx = rule.noAbs ? rule.plurals(count2) : rule.plurals(Math.abs(count2));
    let suffix2 = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix2 === 2) {
        suffix2 = "plural";
      } else if (suffix2 === 1) {
        suffix2 = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix2.toString() ? this.options.prepend + suffix2.toString() : suffix2.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix2 === 1)
        return "";
      if (typeof suffix2 === "number")
        return `_plural_${suffix2.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
function deepFindWithDefaults(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path4 = getPathWithDefaults(data, defaultData, key);
  if (!path4 && ignoreJSONStructure && typeof key === "string") {
    path4 = deepFind(data, key, keySeparator);
    if (path4 === void 0)
      path4 = deepFind(defaultData, key, keySeparator);
  }
  return path4;
}
var Interpolator = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation)
      options.interpolation = {
        escapeValue: true
      };
    const iOpts = options.interpolation;
    this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
    this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
    this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
    this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
    this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
    this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
    this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options)
      this.init(this.options);
  }
  resetRegExp() {
    const regexpStr = `${this.prefix}(.+?)${this.suffix}`;
    this.regexp = new RegExp(regexpStr, "g");
    const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
    this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
    const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
    this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
  }
  interpolate(str, data, lng, options) {
    let match3;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function regexSafe(val) {
      return val.replace(/\$/g, "$$$$");
    }
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path4 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path4, void 0, lng, __spreadProps(__spreadValues(__spreadValues({}, options), data), {
          interpolationkey: key
        })) : path4;
      }
      const p2 = key.split(this.formatSeparator);
      const k = p2.shift().trim();
      const f = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, __spreadProps(__spreadValues(__spreadValues({}, options), data), {
        interpolationkey: k
      }));
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match3 = todo.regex.exec(str)) {
        const matchedVar = match3[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match3, options);
            value = typeof temp === "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match3[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match3[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match3[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match3;
    let value;
    let clonedOptions;
    function handleHasOptions(key, inheritedOptions) {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0)
        return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions)
          clonedOptions = __spreadValues(__spreadValues({}, inheritedOptions), clonedOptions);
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep}${optionsString}`;
      }
      delete clonedOptions.defaultValue;
      return key;
    }
    while (match3 = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = __spreadValues({}, options);
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match3[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match3[1])) {
        const r = match3[1].split(this.formatSeparator).map((elem) => elem.trim());
        match3[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match3[1].trim(), clonedOptions), clonedOptions);
      if (value && match3[0] === str && typeof value !== "string")
        return value;
      if (typeof value !== "string")
        value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match3[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, __spreadProps(__spreadValues({}, options), {
          interpolationkey: match3[1].trim()
        })), value.trim());
      }
      str = str.replace(match3[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
function parseFormatStr(formatStr) {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (!opt)
          return;
        const [key, ...rest] = opt.split(":");
        const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  const cache = {};
  return function invokeFormatter(val, lng, options) {
    const key = lng + JSON.stringify(options);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, __spreadValues({}, opt));
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, __spreadProps(__spreadValues({}, opt), {
          style: "currency"
        }));
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, __spreadValues({}, opt));
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, __spreadValues({}, opt));
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, __spreadValues({}, opt));
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    const iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, __spreadValues(__spreadValues(__spreadValues({}, formatOptions), options), valOptions));
        } catch (error2) {
          this.logger.warn(error2);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
function removePending(q, name) {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}
var Connector = class extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0)
          ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0)
            pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0)
            pending[name] = true;
          if (toLoad[name] === void 0)
            toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0)
            toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces)
        toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s3 = name.split("|");
    const lng = s3[0];
    const ns = s3[1];
    if (err)
      this.emit("failedLoading", lng, ns, err);
    if (data) {
      this.store.addResourceBundle(lng, ns, data);
    }
    this.state[name] = err ? -1 : 2;
    const loaded2 = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err)
        q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l2) => {
          if (!loaded2[l2])
            loaded2[l2] = {};
          const loadedKeys = q.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded2[l2][n2] === void 0)
                loaded2[l2][n2] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded2);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length)
      return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver2 = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver2(null, data)).catch(resolver2);
        } else {
          resolver2(null, r);
        }
      } catch (err) {
        resolver2(err);
      }
      return;
    }
    return fc(lng, ns, resolver2);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (typeof languages === "string")
      languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length)
        callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s3 = name.split("|");
    const lng = s3[0];
    const ns = s3[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err)
        this.logger.warn(`${prefix3}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data)
        this.logger.log(`${prefix3}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace2, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace2)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace2}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "")
      return;
    if (this.backend && this.backend.create) {
      const opts = __spreadProps(__spreadValues({}, options), {
        isUpdate
      });
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace2, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace2, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace2, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0])
      return;
    this.store.addResource(languages[0], namespace2, key, fallbackValue);
  }
};
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      let ret = {};
      if (typeof args[1] === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key) => {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value, format, lng, options) => value,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function noop() {
}
function bindMemberFunctions(inst) {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = class extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === "string") {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = __spreadValues(__spreadValues(__spreadValues({}, defOpts), this.options), transformOptions(options));
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = __spreadValues(__spreadValues({}, defOpts.interpolation), this.options.interpolation);
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject)
        return null;
      if (typeof ClassOrObject === "function")
        return new ClassOrObject();
      return ClassOrObject;
    }
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s3 = this.services;
      s3.logger = baseLogger;
      s3.resourceStore = this.store;
      s3.languageUtils = lu;
      s3.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s3.formatter = createClassOnDemand(formatter);
        s3.formatter.init(s3, this.options);
        this.options.interpolation.format = s3.formatter.format.bind(s3.formatter);
      }
      s3.interpolator = new Interpolator(this.options);
      s3.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s3.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s3.resourceStore, s3, this.options);
      s3.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s3.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s3.languageDetector.init)
          s3.languageDetector.init(s3, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s3.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s3.i18nFormat.init)
          s3.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init)
          m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback)
      callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev")
        this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish3 = (err, t2) => {
        if (this.isInitialized && !this.initializedStoreOnce)
          this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone)
          this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return finish3(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish3);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = typeof language === "string" ? language : this.language;
    if (typeof language === "function")
      usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode")
        return usedCallback();
      const toLoad = [];
      const append2 = (lng) => {
        if (!lng)
          return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (toLoad.indexOf(l2) < 0)
            toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append2(l2));
      } else {
        append2(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l2) => append2(l2));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language)
          this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (!lngs)
      lngs = this.languages;
    if (!ns)
      ns = this.options.ns;
    if (!callback)
      callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module2) {
    if (!module2)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module2.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module2.type === "backend") {
      this.modules.backend = module2;
    }
    if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
      this.modules.logger = module2;
    }
    if (module2.type === "languageDetector") {
      this.modules.languageDetector = module2;
    }
    if (module2.type === "i18nFormat") {
      this.modules.i18nFormat = module2;
    }
    if (module2.type === "postProcessor") {
      postProcessor.addPostProcessor(module2);
    }
    if (module2.type === "formatter") {
      this.modules.formatter = module2;
    }
    if (module2.type === "3rdParty") {
      this.modules.external.push(module2);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages)
      return;
    if (["cimode", "dev"].indexOf(l2) > -1)
      return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1)
        continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        setLngProps(l2);
        this.translator.changeLanguage(l2);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l2);
        this.logger.log("languageChanged", l2);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback)
        callback(err, function() {
          return _this2.t(...arguments);
        });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector)
        lngs = [];
      const l2 = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language)
          this.translator.changeLanguage(l2);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
          this.services.languageDetector.cacheUserLanguage(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = __spreadValues({}, opts);
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (typeof lng === "string") {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode")
      return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0)
        return preResult;
    }
    if (this.hasResourceBundle(lng, ns))
      return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
      return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
      return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    if (typeof ns === "string")
      ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0)
        this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (typeof lngs === "string")
      lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0);
    if (!newLngs.length) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng)
      lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng)
      return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore)
      delete options.forkResourceStore;
    const mergedOptions = __spreadValues(__spreadValues(__spreadValues({}, this.options), options), {
      isClone: true
    });
    const clone3 = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone3.logger = clone3.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone3[m] = this[m];
    });
    clone3.services = __spreadValues({}, this.services);
    clone3.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    if (forkResourceStore) {
      clone3.store = new ResourceStore(this.store.data, mergedOptions);
      clone3.services.resourceStore = clone3.store;
    }
    clone3.translator = new Translator(clone3.services, mergedOptions);
    clone3.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone3.emit(event, ...args);
    });
    clone3.init(mergedOptions, callback);
    clone3.translator.options = mergedOptions;
    clone3.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
    };
    return clone3;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0)
          obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var serializeCookie = function serializeCookie2(name, val, options) {
  var opt = options || {};
  opt.path = opt.path || "/";
  var value = encodeURIComponent(val);
  var str = "".concat(name, "=").concat(value);
  if (opt.maxAge > 0) {
    var maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge))
      throw new Error("maxAge should be a Number");
    str += "; Max-Age=".concat(Math.floor(maxAge));
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=".concat(opt.domain);
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=".concat(opt.path);
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=".concat(opt.expires.toUTCString());
  }
  if (opt.httpOnly)
    str += "; HttpOnly";
  if (opt.secure)
    str += "; Secure";
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var cookie = {
  create: function create(name, value, minutes, domain) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain)
      cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read: function read(name) {
    var nameEQ = "".concat(name, "=");
    var ca = document.cookie.split(";");
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0)
        return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove: function remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup(options) {
    var found;
    if (options.lookupCookie && typeof document !== "undefined") {
      var c = cookie.read(options.lookupCookie);
      if (c)
        found = c;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options) {
    if (options.lookupCookie && typeof document !== "undefined") {
      cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup2(options) {
    var found;
    if (typeof window !== "undefined") {
      var search3 = window.location.search;
      if (!window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1) {
        search3 = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      var query = search3.substring(1);
      var params = query.split("&");
      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf("=");
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport = null;
var localStorageAvailable = function localStorageAvailable2() {
  if (hasLocalStorageSupport !== null)
    return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    var testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e2) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage = {
  name: "localStorage",
  lookup: function lookup3(options) {
    var found;
    if (options.lookupLocalStorage && localStorageAvailable()) {
      var lng = window.localStorage.getItem(options.lookupLocalStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options) {
    if (options.lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(options.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport = null;
var sessionStorageAvailable = function sessionStorageAvailable2() {
  if (hasSessionStorageSupport !== null)
    return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    var testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e2) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup: function lookup4(options) {
    var found;
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options) {
    if (options.lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(options.lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options) {
    var found;
    var htmlTag2 = options.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup7(options) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options.lookupFromPathIndex === "number") {
          if (typeof language[options.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options) {
    var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === "number" ? options.lookupFromSubdomainIndex + 1 : 1;
    var language = typeof window !== "undefined" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language)
      return void 0;
    return language[lookupFromSubdomainIndex];
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    convertDetectedLanguage: function convertDetectedLanguage(l2) {
      return l2;
    }
  };
}
var Browser = /* @__PURE__ */ function() {
  function Browser2(services) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  _createClass(Browser2, [{
    key: "init",
    value: function init2(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services || {
        languageUtils: {}
      };
      this.options = defaults(options, this.options || {}, getDefaults());
      if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
        this.options.convertDetectedLanguage = function(l2) {
          return l2.replace("-", "_");
        };
      }
      if (this.options.lookupFromUrlIndex)
        this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder)
        detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string")
            lookup9 = [lookup9];
          if (lookup9)
            detected = detected.concat(lookup9);
        }
      });
      detected = detected.map(function(d2) {
        return _this.options.convertDetectedLanguage(d2);
      });
      if (this.services.languageUtils.getBestMatchFromCodes)
        return detected;
      return detected.length > 0 ? detected[0] : null;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage4(lng, caches) {
      var _this2 = this;
      if (!caches)
        caches = this.options.caches;
      if (!caches)
        return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1)
        return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName])
          _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }]);
  return Browser2;
}();
Browser.type = "languageDetector";

// node_modules/react-i18next/dist/es/Trans.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/react-i18next/dist/es/TransWithoutContext.js
var import_react = __toESM(require_react(), 1);

// node_modules/html-parse-stringify/dist/html-parse-stringify.module.js
var import_void_elements = __toESM(require_void_elements());

// node_modules/react-i18next/dist/es/utils.js
function warn() {
  if (console && console.warn) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = `react-i18next:: ${args[0]}`;
    console.warn(...args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = new Date();
  warn(...args);
}
var loadedClb = (i18n, cb) => () => {
  if (i18n.isInitialized) {
    cb();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb();
    };
    i18n.on("initialized", initialized);
  }
};
function loadNamespaces2(i18n, ns, cb) {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb));
}
function loadLanguages2(i18n, lng, ns, cb) {
  if (typeof ns === "string")
    ns = [ns];
  ns.forEach((n2) => {
    if (i18n.options.ns.indexOf(n2) < 0)
      i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb));
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const lng = i18n.languages[0];
  const fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  const lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  const loadNotPending = (l2, n2) => {
    const loadState = i18n.services.backendConnector.state[`${l2}|${n2}`];
    return loadState === -1 || loadState === 2;
  };
  if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
    return false;
  if (i18n.hasResourceBundle(lng, ns))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
    return true;
  return false;
}
function hasLoadedNamespace2(ns, i18n) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  const isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns, i18n, options);
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: (i18nInstance2, loadNotPending) => {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
        return false;
    }
  });
}

// node_modules/react-i18next/dist/es/unescape.js
var matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
var htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "\xA9",
  "&#169;": "\xA9",
  "&reg;": "\xAE",
  "&#174;": "\xAE",
  "&hellip;": "\u2026",
  "&#8230;": "\u2026",
  "&#x2F;": "/",
  "&#47;": "/"
};
var unescapeHtmlEntity = (m) => htmlEntities[m];
var unescape2 = (text6) => text6.replace(matchHtmlEntity, unescapeHtmlEntity);

// node_modules/react-i18next/dist/es/defaults.js
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape: unescape2
};
function setDefaults() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = __spreadValues(__spreadValues({}, defaultOptions), options);
}
function getDefaults2() {
  return defaultOptions;
}

// node_modules/react-i18next/dist/es/i18nInstance.js
var i18nInstance;
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}

// node_modules/react-i18next/dist/es/context.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/initReactI18next.js
var initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};

// node_modules/react-i18next/dist/es/context.js
var I18nContext = (0, import_react2.createContext)();
var ReportNamespaces = class {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns) => {
      if (!this.usedNamespaces[ns])
        this.usedNamespaces[ns] = true;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
};

// node_modules/react-i18next/dist/es/useTranslation.js
var import_react4 = __toESM(require_react(), 1);
var usePrevious = (value, ignore2) => {
  const ref2 = (0, import_react4.useRef)();
  (0, import_react4.useEffect)(() => {
    ref2.current = ignore2 ? ref2.current : value;
  }, [value, ignore2]);
  return ref2.current;
};
function useTranslation(ns) {
  let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = (0, import_react4.useContext)(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k, optsOrDefaultValue) => {
      if (typeof optsOrDefaultValue === "string")
        return optsOrDefaultValue;
      if (optsOrDefaultValue && typeof optsOrDefaultValue === "object" && typeof optsOrDefaultValue.defaultValue === "string")
        return optsOrDefaultValue.defaultValue;
      return Array.isArray(k) ? k[k.length - 1] : k;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = __spreadValues(__spreadValues(__spreadValues({}, getDefaults2()), i18n.options.react), props);
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace2(n2, i18n, i18nOptions));
  function getT() {
    return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  const [t2, setT] = (0, import_react4.useState)(getT);
  let joinedNS = namespaces.join();
  if (props.lng)
    joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious(joinedNS);
  const isMounted = (0, import_react4.useRef)(true);
  (0, import_react4.useEffect)(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages2(i18n, props.lng, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      } else {
        loadNamespaces2(i18n, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getT);
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach((e2) => i18n.off(e2, boundReset));
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
    };
  }, [i18n, joinedNS]);
  const isInitial = (0, import_react4.useRef)(true);
  (0, import_react4.useEffect)(() => {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n, keyPrefix]);
  const ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise((resolve) => {
    if (props.lng) {
      loadLanguages2(i18n, props.lng, namespaces, () => resolve());
    } else {
      loadNamespaces2(i18n, namespaces, () => resolve());
    }
  });
}

// node_modules/react-i18next/dist/es/withTranslation.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/I18nextProvider.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/withSSR.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/react-i18next/dist/es/useSSR.js
var import_react7 = __toESM(require_react(), 1);

// src/i18n/en.ts
var i18nEn = {
  elements: {
    campaign_one: "Campaign",
    campaign_other: "Campaigns",
    campaing_inside: "Inside Campaign",
    campaign_contains: "Contains Campaigns",
    adventure_one: "Adventure",
    adventure_other: "Adventures",
    adventure_inside: "Inside Adventure",
    adventure_contains: "Contains Adventures",
    session_one: "Session",
    session_other: "Sessions",
    session_inside: "Inside Session",
    session_contains: "Contains Sessions",
    chapter_one: "Chapter",
    chapter_other: "Chapters",
    chapter_inside: "Inside Chapter",
    chapter_contains: "Contains Chapters",
    scene_one: "Scene",
    scene_other: "Scenes",
    scene_inside: "Inside Scene",
    scene_contains: "Contains Scenes",
    playercharacter_one: "Player character",
    playercharacter_other: "Player characters",
    playercharacter_inside: "Inside Player Character",
    playercharacter_contains: "Contains Player Characters",
    nonplayercharacter_one: "Non-player character",
    nonplayercharacter_other: "Non-player characters",
    nonplayercharacter_inside: "Inside Non-Player Character",
    nonplayercharacter_contains: "Contains Non-Player Characters",
    location_one: "Location",
    location_other: "Locations",
    location_inside: "Inside Location",
    location_contains: "Contains Locations",
    faction_one: "Faction",
    faction_other: "Factions",
    faction_inside: "Inside Faction",
    faction_contains: "Contains Factions",
    event_one: "Event",
    event_other: "Events",
    event_inside: "Inside Event",
    event_contains: "Contains Events",
    clue_one: "Clue",
    clue_other: "Clues",
    clue_inside: "Inside Clue",
    clue_contains: "Contains Clues",
    subplot_one: "Subplot",
    subplot_other: "Subplots",
    subplot_inside: "Inside Subplot",
    subplot_contains: "Contains Subplots",
    object_one: "Object",
    object_other: "Objects",
    object_inside: "Inside Object",
    object_contains: "Contains Objects",
    monster_one: "Monster",
    monster_other: "Monsters",
    monster_inside: "Inside Monster",
    monster_contains: "Contains Monsters",
    element_one: "Element",
    element_other: "Elements"
  },
  tasks: {
    task_one: "Task",
    task_other: "Tasks",
    owned: "{{variable}}'s tasks",
    name: "Name",
    priority: "Priority",
    mentionedin: "Mentioned in",
    description: "Description",
    assignedto: "Assigned to",
    all: "All tasks",
    complete_campaign: "Complete Campaign",
    complete_adventure: "Complete Adventure",
    complete_session: "Complete Session",
    complete_chapter: "Complete Chapter",
    complete_scene: "Complete Scene",
    complete_playercharacter: "Complete Player Character",
    complete_nonplayercharacter: "Complete Non-Player Character",
    complete_location: "Complete Location",
    complete_faction: "Complete Faction",
    complete_event: "Complete Event",
    complete_clue: "Complete Clue",
    complete_subplot: "Complete Subplot",
    complete_object: "Complete Object",
    complete_monster: "Complete Monster",
    complete_element: "Complete Element"
  },
  customattributes: {
    name: "Name",
    type: "Type",
    text: "Text",
    number: "Number",
    option: "Option",
    checkbox: "Checkbox",
    longtext: "Long Text",
    link: "Link",
    date: "Date",
    availableon: "Available on",
    your: "Your Custom Attributes",
    describe: `You can customise the attributes to use in your elements.

On the left you can see the attributes you have already created, and you can edit them.

If you want to create new ones, just click on the button and define the name and type of the attribute and in which elements it is goign to be available.`,
    cantdelete: "You can't delete this attribute because it is used in one or more elements."
  },
  attributes: {
    attribute_one: "Attribute",
    attribute_other: "Attributes",
    description: "Description",
    ghost: "Ghost",
    lie: "Lie",
    arc: "Character Arc",
    beliefs: "Beliefs",
    need: "Need",
    behaviour: "Behaviour",
    want: "Want",
    opposition: "Opposition",
    strengths: "Strengths",
    weaknesses: "Weaknesses",
    storycircle: "Story Circle",
    scenetype: "Type",
    dob: "Date of Birth",
    dod: "Date of Death",
    sceneaction: "Action",
    date: "Date",
    sessiondate: "Session Date",
    storycirclestage: "Story Circle Stage",
    abtstage: "ABT Stage",
    externalactions: "Exciting",
    address: "Address",
    location: "Location",
    duration: "Duration",
    philosophy: "Philosophy",
    majorclues: "Major Clues",
    factionstructure: "Faction Structure",
    nonplayercharactertype: "NPC Type",
    sensoryimprint: "Sensory Imprint",
    custom: "Custom Attributes",
    stage: "Stage",
    coordinates: "Coordinates",
    sensoryimprints: "Sensory Imprints",
    active: " (Active)",
    occupation: "Occupation",
    stake: "Stake",
    goals: "Goals (Want)",
    attitude: "Attitude (Behaviour)",
    kishotenketsu: "Kish\u014Dtenketsu",
    conflict: "Conflict",
    pronoun: "Pronoun"
  },
  npctype: {
    npctype_main: "Main",
    npctype_supporting: "Supporting",
    npctype_extra: "Extra",
    description_main: "A fully fledged non-player character, with details about their personality, wants and needs.",
    description_supporting: "A recurring non-player character that is not a main character.",
    description_extra: "A non-player character with minimal details, just enough to be used as a background character."
  },
  arc: {
    arc_1: "Positive Arc",
    arc_2: "Disillusionment Arc",
    arc_3: "Fall Arc",
    arc_4: "Corruption Arc",
    arc_5: "Flat Arc",
    description_1: "The character starts **believing a lie**, they then encounter the truth and overcome the lie and **accept the truth**.",
    description_2: "The character starts **believing a lie**, they then encounter the truth and overcome the lie, but **the truth leads to worse outcome** than in believing the lie.",
    description_3: "The character starts **believing a lie**, they then encounter the truth but reject it and **believing a stronger or worse lie**.",
    description_4: "The character starts **knowing the truth**, but then they reject the truth, **embracing a lie**.",
    description_5: "The character starts **knowing the truth**, but then their beliefs are tested, but they keep **embracing the truth**."
  },
  options: {
    option_one: "Option",
    option_other: "Options",
    wizard: "Wizard"
  },
  search: {
    entertocreate: "Enter to create"
  },
  parents: {
    parent_campaign: "Part of Campaign",
    parent_adventure: "Part of Adventure",
    parent_session: "Part of Session"
  },
  relationships: {
    relationship_other: "Relationships",
    relationship_one: "Relationship",
    relationshiptype: "Relationship Type",
    relationshiptype_reverse: "Reversed",
    relationshiptype_bidirectional: "Bidirectional",
    relationshiptype_unidirectional: "Unidirectional",
    relationshiptype_parent: "Parent",
    relationshiptype_child: "Child"
  },
  gallery: {
    title: "Image Gallery",
    drag: "Drag a new image",
    dragdrop: "Drag and drop image here",
    upload: "Upload a new image",
    link: "Link a new image",
    browse: "Browse images",
    browselocal: "Browse local images",
    caption: "Caption",
    carousel: "Image Carousel"
  },
  analyser: {
    expectedduration: "Expected Duration",
    activity: "Activity",
    excitement: "Excitement",
    interest: "Interest",
    variety: "Variety",
    sceneanalyser: "Scene Analyser",
    saactivity_positiveerror: "Too many active scenes",
    saactivity_positivewarnign: "The number of active scenes might be more than needed.",
    saactivity_negativeerror: "Not enough active scenes",
    saactivity_negativewarning: "The number of active scenes could not be enough.",
    saexcitement_positiveerror: "Too many exciting scenes",
    saexcitement_positivewarnign: "The number of exciting scenes might be more than needed.",
    saexcitement_negativeerror: "Not enough exciting scenes",
    saexcitement_negativewarning: "The number of exciting scenes could not be enough.",
    sainterest_negativeerror: "Not enough variety in the type of scenes",
    sainterest_negativewarning: "The number of scene types could not be enough.",
    savariety_negativeerror: "Too many repeated scene types",
    savariety_negativewarning: "The number of repeated scene types could be too high."
  },
  clues: {
    description: "Description",
    destination: "Destination"
  },
  buttons: {
    save: "Save",
    edit: "Edit",
    delete: "Delete",
    cancel: "Cancel",
    create: "Create",
    replace: "Replace",
    adddestination: "Add Destination",
    newattribute: "New Attribute",
    assign: "Assign",
    unassign: "Unassign",
    launchwizard: "Launch Creation Wizard",
    previous: "< Previous",
    next: "Next >"
  },
  create: {
    title: "Create New...",
    in_title: "Convert to...",
    new_campaign: "Create new Campaign",
    new_adventure: "Create new Adventure",
    new_session: "Create new Session",
    new_chapter: "Create new chapter",
    new_scene: "Create new Scene",
    new_element: "Create new Rpg Manager Element",
    new_task: "Create new Task",
    new_playercharacter: "Create new Player Character",
    new_nonplayercharacter: "Create new Non-Player Character",
    new_location: "Create new Location",
    new_faction: "Create new Faction",
    new_event: "Create new Event",
    new_clue: "Create new Clue",
    new_subplot: "Create new Subplot",
    new_object: "Create new Object",
    new_monster: "Create new Monster",
    in_element: "Add a new Rpg Manager Element to the current note",
    in_campaign: "Add a new Campaign to the current note",
    in_adventure: "Add a new Adventure to the current note",
    in_session: "Add a new Session to the current note",
    in_chapter: "Add a new Chapter to the current note",
    in_scene: "Add a new Scene to the current note",
    in_playercharacter: "Add a new Player Character to the current note",
    in_nonplayercharacter: "Add a new Non-Player Character to the current note",
    in_location: "Add a new Location to the current note",
    in_faction: "Add a new Faction to the current note",
    in_event: "Add a new Event to the current note",
    in_clue: "Add a new Clue to the current note",
    in_subplot: "Add a new Subplot to the current note",
    in_object: "Add a new Object to the current note",
    in_monster: "Add a new Monster to the current note",
    add_session: "Add new Session",
    add_scene: "Add new Scene",
    add_chapter: "Add new Chapter",
    add_task: "Add new Task",
    add_clue: "Add Clue",
    add_relationship: "Add Relationship",
    add_attribute: "Add Attribute",
    select_campaign: "Select Campaign",
    select_adventure: "Select Adventure",
    select_session: "Select Session",
    select_type: "Select the type of element you want to create",
    select_template: "Select the template for your element"
  },
  chatgpt: {
    overlaytitle_nonplayercharacter: "Automatically Generating your Character",
    overlaytitle_chapter: "Automatically Generating your Chapter",
    overlaydescription: "This may take a while, please be patient and wait for the process to complete.",
    generate: "Generate with ChatGPT",
    messages: [
      "Retrieving suggestions from ChatGPT...",
      "Waiting for ChatGPT to think...",
      "Having a coffee while I wait...",
      "The pidgeon carrying your suggestion might have been eaten by a red dragon...",
      "Shall we talk about Call of Cthulhu while we wait?",
      "Yes, I am STILL waiting!",
      "Yes, I am STILL waiting! (I am not a very patient bot)",
      "Did you know that the first ever game of D&D was played by Gary Gygax and Dave Arneson in 1974?",
      "Do you often yawn while waiting for ChatGPT?",
      "The creator of this plugin is the BEST storyteller I know! (yet it is the only one I know...)",
      "ChatGPT is late, roll initiative!",
      "Why did the NPC cross the road? To escape the bard's bad puns!",
      "If you have any spare 20-sided dice, now would be a good time to roll for patience.",
      "I'd ask a wizard for help, but they're notorious for their late replies.",
      "Summoning a friendly chat entity... Do not cast 'Dispel Magic'!",
      "Still waiting for the bard to finish their solo...",
      "Do dragons even use ChatGPT? Asking for a friend.",
      "How many elves does it take to get a response? Just one, but they'll tell a long tale about it.",
      "Sorry for the delay. A rogue tried to pickpocket my code.",
      "Did the sorcerer hex my connection again?",
      "In a land far, far away... ChatGPT is still thinking.",
      "A wizard is never late, nor is he early. But ChatGPT... sometimes takes its sweet time.",
      "Facing off with a gelatinous cube. Might take a while...",
      "I told the barbarian to 'wait here'. He's still standing there..."
    ]
  },
  wizards: {
    errors: "The following errors have been found:",
    chapter: {
      errors: {
        missingtargettype: "Please select a target type",
        missingtargetname: "Please enter a target name or select an existing one",
        missingdestination: "Please select either a valid destination or type the new destination name"
      },
      cluename: "Clue name",
      cluesdescription: "Description of the clue(s)",
      title: "Chapter Wizard",
      description: `A chapter is a way to organise bigger adventures in more manageable chunks, like for a book or a film. 

Describe *{{name}}*.`,
      destinationtitle: "Destination",
      destination: "Where does this chapter lead to?",
      destinationelementtype: "Destination type",
      destinationtype_adventure: "The next step from here should be another adventure",
      destinationtype_chapter: "This chapter should lead to another chapter",
      destinationelementtype_existing: "Existing",
      destinationelementtypedescription_existing: "Select an existing adventure or chapter to follow this one.",
      destinationelementtype_new: "New",
      destinationelementtypedescription_new: "The adventure or chapter to follow this one is a new one.",
      destinationelement_existing: "Existing destination adventure or chapter",
      destinationelement_new: "New destination adventure or chapter name",
      targettitle: "Target",
      target: "Is the chapter targeting an event or a location to move the plot forward?",
      targetdescription: "Before describing the target, please select the type of target you want to use.",
      targettitle_event: "Description of the key event",
      targetdescription_event: "Write a description for the key event in chapter *{{name}}*",
      targettitle_location: "Description of the key location",
      targetdescription_location: "Write a description for the key location in chapter *{{name}}*",
      targetelementtype: "Target type",
      targettype_event: "The plot is moved forward by an event",
      targettype_location: "The chapter revolves around a location",
      targetelementtype_existing: "Existing",
      targetelementtypedescription_existing: "Select an existing event or location where to pivot the chapter.",
      targetelementtype_new: "New",
      targetelementtypedescription_new: "The event or location is a new one.",
      targetelement_existing: "Existing target event or location",
      targetelement_new: "New target event or location name",
      targetelementdescription: "Description of the event or the location",
      removeexistingclue: "Remove",
      selectexistingclue: "Select existing clue"
    },
    npc: {
      title: "Non-Player Character Wizard",
      create: "Create automatically",
      description_arc: `The character arc describe the way a character grow and evolve during the story.
			
Please **select the arc** that better identifies *{{name}}*'s evolution.`,
      description_behaviour: `The behaviour is the normal way a character does things, the way the player characters see them.

What is the Behaviour of *{{name}}*?`,
      description_beliefs: `The Beliefs is what characters accept to be true in the world, even if they are not.

What are the beliefs of *{{name}}*?`,
      description_description: `The description is an introduction to a character, giving a blurb of background information to help the
storyteller to clearly identify them. This part is particularly importan if you wish to use the automatic character generation via the AI feature.

Describe *{{name}}*.`,
      description_occupation: `The occupation defines what a character does for living. While this does not define who they are,
it adds a layer of depth to the character and suggests a set of skill they possess.

What's *{{name}}* occupation?`,
      description_ghost: `The Ghost is an important event in the character's past that defines their beliefs.
The ghost is highly likely a turning point, highly positive or highly negative and may have shaped their view of the world as a lie.

What is the event that shaped *{{name}}*?`,
      description_lie: `The Lie is what a character believes about the world to be true that is not.

What is the lie *{{name}}* believs in?`,
      description_need: `The Need is what a charater truly need, even it it is unknown to them.

What does *{{name}}* desperately needs?`,
      description_opposition: `The Oppositon are forces that stops the character to get what they want.
			
What is opposing *{{name}}* from reaching what they want?`,
      description_strengths: `Strengths are the positive traits of a character.

Select *{{name}}*'s.`,
      description_weaknesses: `Weaknesses are the negative traits of a character.

Select *{{name}}*'s.`,
      description_type: `The type of character defines their importance in the campaign and the amount of attributes they have by default.
			
Who is *{{name}}*?`,
      description_want: `The Want is what characters think they want to achieve, even if it is not what they really need. This is pulicly known and determines their behaviour.

What does *{{name}}* wants?`,
      description_stake: `The Stake defines a value of how much the character is **invested** in their occupation, wants and behaviours.
This helps defining how much effort they will put into achieving them.

What's *{{name}}* stake?`
    }
  },
  errors: {
    must_campaign: "You must create a campaign first",
    must_adventure: "You must create an adventure first",
    must_session: "You must create a session first"
  },
  kishotenketsu: {
    ki: "Ki<br/><small>(Introduction)</small>",
    sho: "Sh\u014D<br/><small>(Development)</small>",
    ten: "Ten<br/><small>(Twist)</small>",
    ketsu: "Ketsu<br/><small>(Conclusion)</small>",
    description_ki: "**Introduction**: an introduction to the characters, era, and other information required to understand the plot",
    description_sho: "**Development**: follows leads towards the twist in the story. No major changes so far.",
    description_ten: "**Twist**: the story turns toward an unexpected development. This is the crux of the story, the yama (\u30E4\u30DE) or climax. If the narrative takes several turns, this is the biggest one.",
    description_ketsu: "**Conclusion**: also called ochi (\u843D\u3061) or ending, wraps up the story."
  },
  storycircle: {
    you: "You/They",
    need: "Need",
    go: "Go",
    search: "Search",
    find: "Find",
    take: "Take",
    return: "Return",
    change: "Change",
    description_you: "Start by establishing the current situation of the player characters at the beginning of this particular plot. What are they currently doing? Where are they? What is their immediate goal?",
    description_need: "Make the player characters feel a need. Don't call it *hook*, make sure the player characters are invested and feel a desperate need to do something.",
    description_go: "The player characters enter a new situation. They leave their comfort zone and enter a new world. This is the point of no return.",
    description_search: "This is the stage of the challenges. The player characters are tested and they face their fears. They are forced to adapt to the new situation.",
    description_find: "The player characters highly likely have to achieve what they set off for, but they have to pay a price: what they get is what the want, but not what they need.",
    description_take: "Time to create a situation in which the player characters can switch from what they want to what they need. This is the moment of realisation.",
    description_return: "The player characters fight to get what they need, and in doing so they return to the world they know.",
    description_change: "The player characters have changed, and they should see the effect of their actions in the world they know."
  },
  conflict: {
    title: "Title",
    description_title: "This is a descriptive name for the conflict, which should help the storyteller remember what it's about.",
    description: "Description",
    description_description: "A description of the conflict, including how the player characters are involved.",
    outcome: "Outcome",
    description_outcome: "This describes the ultimate outcome of the conflict, after the conflict is played out.",
    category: "Category",
    description_category: `This is a broad category that helps to describe the nature of the conflict and helps the storyteller to understand what the conflict is about.
			
- **Ambition**: The characters involved want to achieve something.
- **Betrayal**: The conflict is about a betrayal.
- **Survival**: It's a matter of life and death.
- **Revenge**: The conflict is about characters' revenge.
- **Ideology**: Everything revolves around an ideology.
- **Love**: Personal conflict focusing on relationships.
- **Guilt**: The conflict is about guilt.
- **Fear**: It revolves around fear.`,
    category_ambition: "Ambition",
    category_betrayal: "Betrayal",
    category_survival: "Survival",
    category_revenge: "Revenge",
    category_ideology: "Ideology",
    category_love: "Love",
    category_guilt: "Guilt",
    category_fear: "Fear",
    involvement: "Involvement",
    involvement_active: "Active",
    involvement_passive: "Passive",
    involvement_unaware: "Unaware",
    involvement_forced: "Forced",
    involvement_opportunistic: "Opportunistic",
    description_involvement: `This describes how the player characters are involved in the conflict, and helps the storyteller to understand how they can be linked to the conflict.
			
- **Active**: The player characters are actively involved in the conflict.
- **Passive**: The player characters are not actively involved in the conflict, but they are affected by it.
- **Unaware**: The player characters are not aware of the conflict, but they are affected by it.
- **Forced**: The player characters are forced to be involved in the conflict.
- **Opportunistic**: The player characters are not involved in the conflict, but they can take advantage of it.`,
    opposingforces: "Opposing Forces",
    description_opposingforces: "List of non-player characters or factions in the conflict. It helps the storyteller to understand who is fighting who.",
    events: "Events",
    description_events: "List of events that are part of the conflict.",
    status: "Status",
    description_status: `This describes the current status of the conflict, and helps the storyteller to understand how the conflict is developing.
			
- **Planned**: The conflict is planned, but it has not started yet.
- **In Progress**: The conflict is currently happening.
- **Resolved**: The conflict has been resolved.`,
    status_planned: "Planned",
    status_inprogress: "In Progress",
    status_resolved: "Resolved",
    stakes: "Stakes",
    description_stakes: `This describes what's at stake in the conflict, and what will happen if one side wins over the other.
			
- **Life and Death**: Threathening someone's life.
- **Love and Relationships**: Involving personal relationships.
- **Power and Control**: Involving power and control over others.
- **Reputation and Honor**: Challenging a character's honour.
- **Wealth and Resources**: All about Money.
- **Freedom and Justice**: Similar to Morality and Ethics, but from a justice perspective.
- **Knowledge and Information**: Information is power.
- **Morality and Ethics**: It's a matter of what's right and what's wrong.
- **Beliefs and Values**: Challenging a character's beliefs.
- **Future and Legacy**: What will be left behind.`,
    stake: {
      lifeanddeath: "Life and Death",
      loveandrelationships: "Love and Relationships",
      powerandcontrol: "Power and Control",
      reputationandhonor: "Reputation and Honor",
      wealthandresources: "Wealth and Resources",
      freedomandjustice: "Freedom and Justice",
      knowledgeandinformation: "Knowledge and Information",
      moralityandethics: "Morality and Ethics",
      beliefsandvalues: "Beliefs and Values",
      futureandlegacy: "Future and Legacy"
    }
  },
  name: "Name",
  documentation: "Documentation",
  global: "Global Asset",
  global_description: "Make this element available in all campaigns"
};

// src/services/InternationalisationService.ts
var InternationalisationService = class {
  static loadSettings() {
    return __async(this, null, function* () {
      var _a;
      instance.use(initReactI18next).use(Browser).init({
        initImmediate: false,
        lng: (_a = window.localStorage.getItem("language")) != null ? _a : "en",
        fallbackLng: "en",
        debug: false,
        interpolation: {
          escapeValue: false
        },
        ns: ["common"],
        defaultNS: "common",
        resources: {}
      });
      instance.addResourceBundle("en", "common", i18nEn);
      instance.addResourceBundle("it", "common", i18nIt);
    });
  }
};

// src/services/PluginServices.ts
var import_obsidian7 = require("obsidian");

// src/contexts/AppContext.tsx
var React2 = __toESM(require_react());
var AppContext = React2.createContext(void 0);

// src/controllers/Controller.ts
var import_obsidian5 = require("obsidian");
var import_react24 = __toESM(require_react());
var import_client2 = __toESM(require_client());

// src/contexts/ApiContext.tsx
var React3 = __toESM(require_react());
var ApiContext = React3.createContext(void 0);

// src/components/elements/ChapterComponent.tsx
var React59 = __toESM(require_react());

// src/components/attributes/AttributeListComponent.tsx
var React34 = __toESM(require_react());

// src/hooks/useApp.ts
var import_react9 = __toESM(require_react());
var useApp = () => {
  return import_react9.default.useContext(AppContext);
};

// src/components/attributes/types/AbtStageAttributeComponent.tsx
var React7 = __toESM(require_react());

// src/hooks/useApi.ts
var import_react10 = __toESM(require_react());
var useApi = () => {
  return import_react10.default.useContext(ApiContext);
};

// src/components/attributes/AttributeTitleComponent.tsx
var React6 = __toESM(require_react());
function AttributeTitleComponent({ attribute }) {
  var _a;
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React6.createElement("div", {
    className: "!font-bold"
  }, attribute.isCustom === true ? (_a = attribute.customName) != null ? _a : attribute.id.substring(1) : t2("attributes." + attribute.id));
}

// src/components/attributes/types/AbtStageAttributeComponent.tsx
function AbtStageAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  if (!attribute.isSet)
    return null;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  const saveAttribute = (newValue) => {
    if (newValue === "") {
      codeblockService.updateCodeblockData(attribute.id, void 0);
      return;
    }
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  const handleDelete = () => {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React7.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React7.createElement("div", null, /* @__PURE__ */ React7.createElement("select", {
      defaultValue: attribute.value,
      onChange: (e2) => saveAttribute(e2.target.value),
      className: "!pl-2 !pr-4"
    }, /* @__PURE__ */ React7.createElement("option", {
      value: ""
    }), Object.entries(AbtStage).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React7.createElement("option", {
      key,
      value: index2
    }, key)))), /* @__PURE__ */ React7.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React7.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: handleDelete
    }, t2("buttons.delete"))));
  } else {
    content3 = /* @__PURE__ */ React7.createElement("div", null, Object.keys(AbtStage).find((key) => AbtStage[key] === attribute.value));
  }
  return /* @__PURE__ */ React7.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React7.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React7.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/ArcAttributeComponent.tsx
var React11 = __toESM(require_react());

// src/components/markdowns/MarkdownComponent.tsx
var React10 = __toESM(require_react());

// node_modules/react-markdown/lib/react-markdown.js
var import_react12 = __toESM(require_react(), 1);

// node_modules/vfile/lib/index.js
var import_is_buffer = __toESM(require_is_buffer(), 1);

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point5) {
  return index(point5 && point5.line) + ":" + index(point5 && point5.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  constructor(reason, place, origin2) {
    const parts = [null, null];
    let position6 = {
      start: { line: null, column: null },
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin2 = place;
      place = void 0;
    }
    if (typeof origin2 === "string") {
      const index2 = origin2.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin2;
      } else {
        parts[0] = origin2.slice(0, index2);
        parts[1] = origin2.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position6 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position6 = place;
      } else if ("line" in place || "column" in place) {
        position6.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position6.start.line;
    this.column = position6.start.column;
    this.position = position6;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// node_modules/vfile/lib/minpath.browser.js
var path2 = { basename, dirname, extname, join, sep: "/" };
function basename(path4, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path4);
  let start3 = 0;
  let end4 = -1;
  let index2 = path4.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path4.length) {
    while (index2--) {
      if (path4.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start3 = index2 + 1;
          break;
        }
      } else if (end4 < 0) {
        seenNonSlash = true;
        end4 = index2 + 1;
      }
    }
    return end4 < 0 ? "" : path4.slice(start3, end4);
  }
  if (ext === path4) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path4.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start3 = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path4.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end4 = index2;
          }
        } else {
          extIndex = -1;
          end4 = firstNonSlashEnd;
        }
      }
    }
  }
  if (start3 === end4) {
    end4 = firstNonSlashEnd;
  } else if (end4 < 0) {
    end4 = path4.length;
  }
  return path4.slice(start3, end4);
}
function dirname(path4) {
  assertPath(path4);
  if (path4.length === 0) {
    return ".";
  }
  let end4 = -1;
  let index2 = path4.length;
  let unmatchedSlash;
  while (--index2) {
    if (path4.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end4 = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end4 < 0 ? path4.charCodeAt(0) === 47 ? "/" : "." : end4 === 1 && path4.charCodeAt(0) === 47 ? "//" : path4.slice(0, end4);
}
function extname(path4) {
  assertPath(path4);
  let index2 = path4.length;
  let end4 = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path4.charCodeAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end4 < 0) {
      unmatchedSlash = true;
      end4 = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end4 < 0 || preDotState === 0 || preDotState === 1 && startDot === end4 - 1 && startDot === startPart + 1) {
    return "";
  }
  return path4.slice(startDot, end4);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path4) {
  assertPath(path4);
  const absolute = path4.charCodeAt(0) === 47;
  let value = normalizeString(path4, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path4.charCodeAt(path4.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path4, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path4.length) {
    if (index2 < path4.length) {
      code2 = path4.charCodeAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path4.slice(lastSlash + 1, index2);
        } else {
          result = path4.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path4) {
  if (typeof path4 !== "string") {
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path4));
  }
}

// node_modules/vfile/lib/minproc.browser.js
var proc = { cwd };
function cwd() {
  return "/";
}

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && fileUrlOrPath.href && fileUrlOrPath.origin;
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path4) {
  if (typeof path4 === "string") {
    path4 = new URL(path4);
  } else if (!isUrl(path4)) {
    const error2 = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + path4 + "`");
    error2.code = "ERR_INVALID_ARG_TYPE";
    throw error2;
  }
  if (path4.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    error2.code = "ERR_INVALID_URL_SCHEME";
    throw error2;
  }
  return getPathFromURLPosix(path4);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError('File URL host must be "localhost" or empty on darwin');
    error2.code = "ERR_INVALID_FILE_URL_HOST";
    throw error2;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError("File URL path must not include encoded / characters");
        error2.code = "ERR_INVALID_FILE_URL_PATH";
        throw error2;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
var VFile = class {
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || buffer(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path4) {
    if (isUrl(path4)) {
      path4 = urlToPath(path4);
    }
    assertNonEmpty(path4, "path");
    if (this.path !== path4) {
      this.history.push(path4);
    }
  }
  get dirname() {
    return typeof this.path === "string" ? path2.dirname(this.path) : void 0;
  }
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = path2.join(dirname2 || "", this.basename);
  }
  get basename() {
    return typeof this.path === "string" ? path2.basename(this.path) : void 0;
  }
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path2.join(this.dirname || "", basename2);
  }
  get extname() {
    return typeof this.path === "string" ? path2.extname(this.path) : void 0;
  }
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path2.join(this.dirname, this.stem + (extname2 || ""));
  }
  get stem() {
    return typeof this.path === "string" ? path2.basename(this.path, this.extname) : void 0;
  }
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path2.join(this.dirname || "", stem + (this.extname || ""));
  }
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  message(reason, place, origin2) {
    const message = new VFileMessage(reason, place, origin2);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  info(reason, place, origin2) {
    const message = this.message(reason, place, origin2);
    message.fatal = null;
    return message;
  }
  fail(reason, place, origin2) {
    const message = this.message(reason, place, origin2);
    message.fatal = true;
    throw message;
  }
};
function assertPart(part, name) {
  if (part && part.includes(path2.sep)) {
    throw new Error("`" + name + "` cannot be a path: did not expect `" + path2.sep + "`");
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path4, name) {
  if (!path4) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function buffer(value) {
  return (0, import_is_buffer.default)(value);
}

// node_modules/bail/index.js
function bail(error2) {
  if (error2) {
    throw error2;
  }
}

// node_modules/unified/lib/index.js
var import_is_buffer2 = __toESM(require_is_buffer(), 1);
var import_extend = __toESM(require_extend(), 1);

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype3 = Object.getPrototypeOf(value);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use: use2 };
  return pipeline;
  function run(...values2) {
    let middlewareIndex = -1;
    const callback = values2.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values2);
    function next(error2, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      while (++index2 < values2.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values2[index2];
        }
      }
      values2 = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use2(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError("Expected `middelware` to be a function, not " + middelware);
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error2) {
      const exception = error2;
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error2, ...output) {
    if (!called) {
      called = true;
      callback(error2, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// node_modules/unified/lib/index.js
var unified = base().freeze();
var own = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace2 = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use2;
  processor.parse = parse8;
  processor.stringify = stringify3;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace2));
    return destination;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace2[key] = value;
        return processor;
      }
      return own.call(namespace2, key) && namespace2[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace2 = key;
      return processor;
    }
    return namespace2;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use2(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace2.settings = Object.assign(namespace2.settings || {}, settings);
    }
    return processor;
    function add3(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins2) {
      let index2 = -1;
      if (plugins2 === null || plugins2 === void 0) {
      } else if (Array.isArray(plugins2)) {
        while (++index2 < plugins2.length) {
          const thing = plugins2[index2];
          add3(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins2 + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
          value2 = (0, import_extend.default)(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse8(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser2 = processor.Parser;
    assertParser("parse", Parser2);
    if (newable(Parser2, "parse")) {
      return new Parser2(String(file), file).parse();
    }
    return Parser2(String(file), file);
  }
  function stringify3(node2, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function run(node2, doc, callback) {
    assertNode(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(doc), done);
      function done(error2, tree, file) {
        tree = tree || node2;
        if (error2) {
          reject(error2);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error2, tree) {
      bail(error2);
      result = tree;
      complete = true;
    }
  }
  function process2(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error2, tree, file2) => {
        if (error2 || !tree || !file2) {
          done(error2);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error2, file2);
        }
      });
      function done(error2, file2) {
        if (error2 || !file2) {
          reject(error2);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error2) {
      complete = true;
      bail(error2);
    }
  }
}
function newable(value, name) {
  return typeof value === "function" && value.prototype && (keys(value.prototype) || name in value.prototype);
}
function keys(value) {
  let key;
  for (key in value) {
    if (own.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `Compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error("Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(value && typeof value === "object" && "message" in value && "messages" in value);
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || (0, import_is_buffer2.default)(value);
}

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/micromark-util-chunked/index.js
function splice(list3, start3, remove2, items) {
  const end4 = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start3 < 0) {
    start3 = -start3 > end4 ? 0 : end4 + start3;
  } else {
    start3 = start3 > end4 ? end4 : start3;
  }
  remove2 = remove2 > 0 ? remove2 : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start3, remove2);
    list3.splice(...parameters);
  } else {
    if (remove2)
      list3.splice(start3, remove2);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start3, 0);
      list3.splice(...parameters);
      chunkStart += 1e4;
      start3 += 1e4;
    }
  }
}
function push(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all7 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all7, extensions[index2]);
  }
  return all7;
}
function syntaxExtension(all7, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all7, hook) ? all7[hook] : void 0;
    const left = maybe || (all7[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2))
          left[code2] = [];
        const value = right[code2];
        constructs(left[code2], Array.isArray(value) ? value : value ? [value] : []);
      }
    }
  }
}
function constructs(existing, list3) {
  let index2 = -1;
  const before = [];
  while (++index2 < list3.length) {
    ;
    (list3[index2].add === "after" ? existing : before).push(list3[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < 32 || code2 === 127);
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok2, type2, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start3;
  function start3(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type2);
      return prefix3(code2);
    }
    return ok2(code2);
  }
  function prefix3(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix3;
    }
    effects.exit(type2);
    return ok2(code2);
  }
}

// node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start3;
  function start3(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point5 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point5);
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start3(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
    }
    self2.containerState = {};
    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start3;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point5 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point5);
        index2++;
      }
      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}

// node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text6;
  let openingSequence;
  let closingSequence;
  let use2;
  let nextEvents;
  let offset4;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use2 = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start3 = Object.assign({}, events[open][1].end);
          const end4 = Object.assign({}, events[index2][1].start);
          movePoint(start3, -use2);
          movePoint(end4, use2);
          openingSequence = {
            type: use2 > 1 ? "strongSequence" : "emphasisSequence",
            start: start3,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use2 > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end: end4
          };
          text6 = {
            type: use2 > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use2 > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text6, context]
          ]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [
            ["exit", text6, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset4 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset4 = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset4 - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start3;
  function start3(code2) {
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point5, offset4) {
  point5.column += offset4;
  point5.offset += offset4;
  point5._bufferIndex += offset4;
}

// node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start3;
  function start3(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      const next = code2 === 45 ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start3;
  function start3(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start3;
  function start3(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}

// node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start3;
  function start3(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start3;
  function start3(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start3;
  function start3(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return start4;
    }
    function start4(code2) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code2) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start3;
  function start3(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start3;
  function start3(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter2;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter2 === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter2 = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter2][1].type = "codeTextData";
      if (index2 !== enter2 + 2) {
        events[enter2][1].end = events[index2 - 1][1].end;
        events.splice(enter2 + 2, index2 - enter2 - 2);
        tailExitIndex -= index2 - enter2 - 2;
        index2 = enter2 + 2;
      }
      enter2 = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start3;
  function start3(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between(code2);
  }
  function between(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return between;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}

// node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start3 = 0;
  const breaks = [start3];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      start3 = index2 + 1;
      breaks.push(start3);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start4 = startPositions.pop();
    jumps.unshift([start4, start4 + slice2.length - 1]);
    splice(events, start4, 2, slice2);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}

// node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok2, nok, type2, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start3;
  function start3(code2) {
    if (code2 === 60) {
      effects.enter(type2);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type2);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw2(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type2);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw2(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type2);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw2;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw2;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw2;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw2;
    }
    return raw2(code2);
  }
}

// node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok2, nok, type2, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start3;
  function start3(code2) {
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen)
      seen = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}

// node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok2, nok, type2, markerType, stringType) {
  let marker;
  return start3;
  function start3(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type2);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin3;
    }
    return nok(code2);
  }
  function begin3(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin3(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape3 : inside;
  }
  function escape3(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}

// node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok2) {
  let seen;
  return start3;
  function start3(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start3;
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, start3, seen ? "linePrefix" : "lineSuffix")(code2);
    }
    return ok2(code2);
  }
}

// node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier;
  return start3;
  function start3(code2) {
    effects.enter("definition");
    return before(code2);
  }
  function before(code2) {
    return factoryLabel.call(self2, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(effects, destinationAfter, nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start3;
  function start3(code2) {
    effects.enter("hardBreakEscape");
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text6;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text6 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text6, context],
      ["exit", text6, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start3;
  function start3(code2) {
    effects.enter("atxHeading");
    return before(code2);
  }
  function before(code2) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer2;
  let index2;
  let markerB;
  return start3;
  function start3(code2) {
    return before(code2);
  }
  function before(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      marker = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      marker = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47;
      const name = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && marker === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && marker === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && marker === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && marker === 5) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
  }
  function continuationStartNonLazy(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name = buffer2.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer2.length < 8) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start3;
  function start3(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start3;
  function start3(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}

// node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start3;
  function start3(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment2;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment2;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment2(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end4(code2) : code2 === 45 ? commentClose(code2) : comment2(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end4(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end4(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end4(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end4(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end4;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end4(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end4(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
var referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset4 = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset4 = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text6 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset4 + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset4 + 3));
  media = push(media, [["enter", text6, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset4 + 4, close - 3), context));
  media = push(media, [
    ["exit", text6, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start3;
  function start3(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start3;
  function start3(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start3;
  function start3(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start3;
  function start3(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}

// node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start3;
  function start3(code2) {
    effects.enter("thematicBreak");
    return before(code2);
  }
  function before(code2) {
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
      effects.exit("thematicBreak");
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start3;
  function start3(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(blankLine, self2.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self2.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list, ok2, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text6;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text6 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text6][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text6][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text6, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start3;
  function start3(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter("setextHeadingLineSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial2 = effects.attempt(blankLine, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix")));
  return initial2;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial2;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial2;
  }
}

// node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text6 = effects.attempt(constructs2, start3, notText);
    return start3;
    function start3(code2) {
      return atBreak(code2) ? text6(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text6(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list3 = constructs2[code2];
      let index2 = -1;
      if (list3) {
        while (++index2 < list3.length) {
          const item = list3[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter2;
    while (++index2 <= events.length) {
      if (enter2 === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter2 = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter2 + 2) {
          events[enter2][1].end = events[index2 - 1][1].end;
          events.splice(enter2 + 2, index2 - enter2 - 2);
          index2 = enter2 + 2;
        }
        enter2 = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point5 = Object.assign(from ? Object.assign({}, from) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter: enter2,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now: now2,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now2() {
    const { line, column, offset: offset4, _index, _bufferIndex } = point5;
    return {
      line,
      column,
      offset: offset4,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point5._index < chunks.length) {
      const chunk = chunks[point5._index];
      if (typeof chunk === "string") {
        chunkIndex = point5._index;
        if (point5._bufferIndex < 0) {
          point5._bufferIndex = 0;
        }
        while (point5._index === chunkIndex && point5._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point5._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    consumed = void 0;
    expectedCode = code2;
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point5.line++;
      point5.column = 1;
      point5.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point5.column++;
      point5.offset++;
    }
    if (point5._bufferIndex < 0) {
      point5._index++;
    } else {
      point5._bufferIndex++;
      if (point5._bufferIndex === chunks[point5._index].length) {
        point5._bufferIndex = -1;
        point5._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter2(type2, fields) {
    const token = fields || {};
    token.type = type2;
    token.start = now2();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type2) {
    const token = stack.pop();
    token.end = now2();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start3;
        function start3(code2) {
          const def = code2 !== null && map[code2];
          const all7 = code2 !== null && map.null;
          const list3 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all7) ? all7 : all7 ? [all7] : []
          ];
          return handleListOfConstructs(list3)(code2);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct) {
        return start3;
        function start3(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(fields ? Object.assign(Object.create(context), fields) : context, effects, ok2, nok)(code2);
        }
      }
      function ok2(code2) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now2();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point5 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point5.line in columnStart && point5.column < 2) {
      point5.column = columnStart[point5.line];
      point5.offset += columnStart[point5.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// node_modules/micromark/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = combineExtensions([constructs_exports, ...settings.extensions || []]);
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create4(content),
    document: create4(document2),
    flow: create4(flow),
    string: create4(string),
    text: create4(text)
  };
  return parser;
  function create4(initial2) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial2, from);
    }
  }
}

// node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer2 = "";
  let start3 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end4) {
    const chunks = [];
    let match3;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer2 + value.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start3) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start3 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match3 = search.exec(value);
      endPosition = match3 && match3.index !== void 0 ? match3.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match3) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end4) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer2)
        chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}

// node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value, base2) {
  const code2 = Number.parseInt(value, base2);
  if (code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || code2 > 126 && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return "\uFFFD";
  }
  return String.fromCharCode(code2);
}

// node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/mdast-util-from-markdown/lib/index.js
var own2 = {}.hasOwnProperty;
var fromMarkdown = function(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
};
function compiler(options) {
  const config3 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html4, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html4, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config3, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config: config3,
      enter: enter2,
      exit: exit2,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config3[events[index2][0]];
      if (own2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config3.transforms.length) {
      tree = config3.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start3, length) {
    let index2 = start3 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            end: void 0
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start3][1]._spread = listSpread;
    return length;
  }
  function setData(key, value) {
    data[key] = value;
  }
  function getData(key) {
    return data[key];
  }
  function opener(create4, and) {
    return open;
    function open(token) {
      enter2.call(this, create4(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter2(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point2(token.start)
    };
    return node2;
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): it\u2019s not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node2.position.end = point2(token.end);
    return node2;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    let tail = node2.children[node2.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text6();
      tail.position = {
        start: point2(token.start)
      };
      node2.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config3.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment2 = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node2.type === "link") {
      const children = fragment2.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type2 = getData("characterReferenceType");
    let value;
    if (type2) {
      value = decodeNumericCharacterReference(data2, type2 === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html4() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list3(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text6() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak3() {
    return {
      type: "thematicBreak"
    };
  }
}
function point2(d2) {
  return {
    line: d2.line,
    column: d2.column,
    offset: d2.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const parser = (doc) => {
    const settings = this.data("settings");
    return fromMarkdown(doc, Object.assign({}, settings, options, {
      extensions: this.data("micromarkExtensions") || [],
      mdastExtensions: this.data("fromMarkdownExtensions") || []
    }));
  };
  Object.assign(this, { Parser: parser });
}

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}

// node_modules/mdast-util-to-hast/lib/handlers/code.js
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const lang = node2.lang ? node2.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
  const properties = {};
  if (lang) {
    properties.className = ["language-" + lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/micromark-util-sanitize-uri/index.js
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start3 = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace3 = "";
    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace3 = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next > 56319 && next < 57344) {
        replace3 = String.fromCharCode(code2, next);
        skip = 1;
      } else {
        replace3 = "\uFFFD";
      }
    } else {
      replace3 = String.fromCharCode(code2);
    }
    if (replace3) {
      result.push(value.slice(start3, index2), encodeURIComponent(replace3));
      start3 = index2 + skip + 1;
      replace3 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start3);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id);
  let counter2;
  if (index2 === -1) {
    state.footnoteOrder.push(id);
    state.footnoteCounts[id] = 1;
    counter2 = state.footnoteOrder.length;
  } else {
    state.footnoteCounts[id]++;
    counter2 = index2 + 1;
  }
  const reuseCounter = state.footnoteCounts[id];
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + state.clobberPrefix + "fn-" + safeId,
      id: state.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter2) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote.js
function footnote(state, node2) {
  const footnoteById = state.footnoteById;
  let no = 1;
  while (no in footnoteById)
    no++;
  const identifier = String(no);
  footnoteById[identifier] = {
    type: "footnoteDefinition",
    identifier,
    children: [{ type: "paragraph", children: node2.children }],
    position: node2.position
  };
  return footnoteReference(state, {
    type: "footnoteReference",
    identifier,
    position: node2.position
  });
}

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/html.js
function html(state, node2) {
  if (state.dangerous) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return null;
}

// node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix2 = "]";
  if (subtype === "collapsed") {
    suffix2 += "[]";
  } else if (subtype === "full") {
    suffix2 += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return { type: "text", value: "![" + node2.alt + suffix2 };
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix2;
  } else {
    contents.push({ type: "text", value: suffix2 });
  }
  return contents;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode(state, node2) {
  const text6 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text6);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text6]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread3 = node2.spread;
  return spread3 === void 0 || spread3 === null ? node2.children.length > 1 : spread3;
}

// node_modules/mdast-util-to-hast/lib/handlers/list.js
function list2(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/root.js
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/unist-util-position/lib/index.js
var pointStart = point3("start");
var pointEnd = point3("end");
function position2(node2) {
  return { start: pointStart(node2), end: pointEnd(node2) };
}
function point3(type2) {
  return point5;
  function point5(node2) {
    const point6 = node2 && node2.position && node2.position[type2] || {};
    return {
      line: point6.line || null,
      column: point6.column || null,
      offset: point6.offset > -1 ? point6.offset : null
    };
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start3 = pointStart(node2.children[1]);
    const end4 = pointEnd(node2.children[node2.children.length - 1]);
    if (start3.line && end4.line)
      body.position = { start: start3, end: end4 };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(node2, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/trim-lines/index.js
var tab = 9;
var space = 32;
function trimLines(value) {
  const source = String(value);
  const search3 = /\r?\n|\r/g;
  let match3 = search3.exec(source);
  let last = 0;
  const lines = [];
  while (match3) {
    lines.push(trimLine(source.slice(last, match3.index), last > 0, true), match3[0]);
    last = match3.index + match3[0].length;
    match3 = search3.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start3, end4) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start3) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end4) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text3(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak2(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  footnote,
  heading,
  html,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list: list2,
  paragraph,
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text: text3,
  thematicBreak: thematicBreak2,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}

// node_modules/unist-util-is/lib/index.js
var convert = function(test) {
  if (test === void 0 || test === null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
  }
  if (typeof test === "function") {
    return castFactory(test);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all7);
  function all7(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type2);
  function type2(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(node2 && typeof node2 === "object" && "type" in node2 && Boolean(check.call(this, node2, ...parameters)));
  }
}
function ok() {
  return true;
}

// node_modules/unist-util-visit-parents/lib/color.browser.js
function color(d2) {
  return d2;
}

// node_modules/unist-util-visit-parents/lib/index.js
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
var visitParents = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  const is3 = convert(test);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = node2 && typeof node2 === "object" ? node2 : {};
    if (typeof value.type === "string") {
      const name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = [];
      let subresult;
      let offset4;
      let grandparents;
      if (!test || is3(node2, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if (node2.children && result[0] !== SKIP) {
        offset4 = (reverse ? node2.children.length : -1) + step;
        grandparents = parents.concat(node2);
        while (offset4 > -1 && offset4 < node2.children.length) {
          subresult = factory(node2.children[offset4], offset4, grandparents)();
          if (subresult[0] === EXIT) {
            return subresult;
          }
          offset4 = typeof subresult[1] === "number" ? subresult[1] : offset4 + step;
        }
      }
      return result;
    }
  }
};
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}

// node_modules/unist-util-visit/lib/index.js
var visit = function(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    return visitor(node2, parent ? parent.children.indexOf(node2) : null, parent);
  }
};

// node_modules/unist-util-generated/lib/index.js
function generated(node2) {
  return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
}

// node_modules/mdast-util-definitions/lib/index.js
var own3 = {}.hasOwnProperty;
function definitions(tree) {
  const cache = /* @__PURE__ */ Object.create(null);
  if (!tree || !tree.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit(tree, "definition", (definition3) => {
    const id = clean(definition3.identifier);
    if (id && !own3.call(cache, id)) {
      cache[id] = definition3;
    }
  });
  return definition2;
  function definition2(identifier) {
    const id = clean(identifier);
    return id && own3.call(cache, id) ? cache[id] : null;
  }
}
function clean(value) {
  return String(value || "").toUpperCase();
}

// node_modules/mdast-util-to-hast/lib/state.js
var own4 = {}.hasOwnProperty;
function createState(tree, options) {
  const settings = options || {};
  const dangerous = settings.allowDangerousHtml || false;
  const footnoteById = {};
  state.dangerous = dangerous;
  state.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
  state.footnoteLabel = settings.footnoteLabel || "Footnotes";
  state.footnoteLabelTagName = settings.footnoteLabelTagName || "h2";
  state.footnoteLabelProperties = settings.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  state.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
  state.unknownHandler = settings.unknownHandler;
  state.passThrough = settings.passThrough;
  state.handlers = __spreadValues(__spreadValues({}, handlers), settings.handlers);
  state.definition = definitions(tree);
  state.footnoteById = footnoteById;
  state.footnoteOrder = [];
  state.footnoteCounts = {};
  state.patch = patch;
  state.applyData = applyData;
  state.one = oneBound;
  state.all = allBound;
  state.wrap = wrap2;
  state.augment = augment;
  visit(tree, "footnoteDefinition", (definition2) => {
    const id = String(definition2.identifier).toUpperCase();
    if (!own4.call(footnoteById, id)) {
      footnoteById[id] = definition2;
    }
  });
  return state;
  function augment(left, right) {
    if (left && "data" in left && left.data) {
      const data = left.data;
      if (data.hName) {
        if (right.type !== "element") {
          right = {
            type: "element",
            tagName: "",
            properties: {},
            children: []
          };
        }
        right.tagName = data.hName;
      }
      if (right.type === "element" && data.hProperties) {
        right.properties = __spreadValues(__spreadValues({}, right.properties), data.hProperties);
      }
      if ("children" in right && right.children && data.hChildren) {
        right.children = data.hChildren;
      }
    }
    if (left) {
      const ctx = "type" in left ? left : { position: left };
      if (!generated(ctx)) {
        right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
      }
    }
    return right;
  }
  function state(node2, tagName, props, children) {
    if (Array.isArray(props)) {
      children = props;
      props = {};
    }
    return augment(node2, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function oneBound(node2, parent) {
    return one2(state, node2, parent);
  }
  function allBound(parent) {
    return all2(state, parent);
  }
}
function patch(from, to) {
  if (from.position)
    to.position = position2(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        result = {
          type: "element",
          tagName: hName,
          properties: {},
          children: []
        };
      }
    }
    if (result.type === "element" && hProperties) {
      result.properties = __spreadValues(__spreadValues({}, result.properties), hProperties);
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function one2(state, node2, parent) {
  const type2 = node2 && node2.type;
  if (!type2) {
    throw new Error("Expected node, got `" + node2 + "`");
  }
  if (own4.call(state.handlers, type2)) {
    return state.handlers[type2](state, node2, parent);
  }
  if (state.passThrough && state.passThrough.includes(type2)) {
    return "children" in node2 ? __spreadProps(__spreadValues({}, node2), { children: all2(state, node2) }) : node2;
  }
  if (state.unknownHandler) {
    return state.unknownHandler(state, node2, parent);
  }
  return defaultUnknownHandler(state, node2);
}
function all2(state, parent) {
  const values2 = [];
  if ("children" in parent) {
    const nodes = parent.children;
    let index2 = -1;
    while (++index2 < nodes.length) {
      const result = one2(state, nodes[index2], parent);
      if (result) {
        if (index2 && nodes[index2 - 1].type === "break") {
          if (!Array.isArray(result) && result.type === "text") {
            result.value = result.value.replace(/^\s+/, "");
          }
          if (!Array.isArray(result) && result.type === "element") {
            const head = result.children[0];
            if (head && head.type === "text") {
              head.value = head.value.replace(/^\s+/, "");
            }
          }
        }
        if (Array.isArray(result)) {
          values2.push(...result);
        } else {
          values2.push(result);
        }
      }
    }
  }
  return values2;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own4.call(data, "hProperties") || own4.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: all2(state, node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap2(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2)
      result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}

// node_modules/mdast-util-to-hast/lib/footer.js
function footer(state) {
  const listItems = [];
  let index2 = -1;
  while (++index2 < state.footnoteOrder.length) {
    const def = state.footnoteById[state.footnoteOrder[index2]];
    if (!def) {
      continue;
    }
    const content3 = state.all(def);
    const id = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let referenceIndex = 0;
    const backReferences = [];
    while (++referenceIndex <= state.footnoteCounts[id]) {
      const backReference = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + state.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
          dataFootnoteBackref: true,
          className: ["data-footnote-backref"],
          ariaLabel: state.footnoteBackLabel
        },
        children: [{ type: "text", value: "\u21A9" }]
      };
      if (referenceIndex > 1) {
        backReference.children.push({
          type: "element",
          tagName: "sup",
          children: [{ type: "text", value: String(referenceIndex) }]
        });
      }
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      backReferences.push(backReference);
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: state.clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(def, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: state.footnoteLabelTagName,
        properties: __spreadProps(__spreadValues({}, JSON.parse(JSON.stringify(state.footnoteLabelProperties))), {
          id: "footnote-label"
        }),
        children: [{ type: "text", value: state.footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, null);
  const foot = footer(state);
  if (foot) {
    node2.children.push({ type: "text", value: "\n" }, foot);
  }
  return Array.isArray(node2) ? { type: "root", children: node2 } : node2;
}

// node_modules/remark-rehype/lib/index.js
var remarkRehype = function(destination, options) {
  return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
};
var lib_default = remarkRehype;
function bridge(destination, options) {
  return (node2, file, next) => {
    destination.run(toHast(node2, options), file, (error2) => {
      next(error2);
    });
  };
}
function mutate(options) {
  return (node2) => toHast(node2, options);
}

// node_modules/react-markdown/lib/react-markdown.js
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/property-information/lib/util/schema.js
var Schema = class {
  constructor(property, normal, space3) {
    this.property = property;
    this.normal = normal;
    if (space3) {
      this.space = space3;
    }
  }
};
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;

// node_modules/property-information/lib/util/merge.js
function merge(definitions2, space3) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions2.length) {
    Object.assign(property, definitions2[index2].property);
    Object.assign(normal, definitions2[index2].normal);
  }
  return new Schema(property, normal, space3);
}

// node_modules/property-information/lib/normalize.js
function normalize2(value) {
  return value.toLowerCase();
}

// node_modules/property-information/lib/util/info.js
var Info = class {
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
};
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = Object.keys(types_exports);
var DefinedInfo = class extends Info {
  constructor(property, attribute, mask, space3) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space3);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values2, key, value) {
  if (value) {
    values2[key] = value;
  }
}

// node_modules/property-information/lib/util/create.js
var own5 = {}.hasOwnProperty;
function create2(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own5.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(prop, definition2.transform(definition2.attributes || {}, prop), value, definition2.space);
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize2(prop)] = prop;
      normal[normalize2(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition2.space);
}

// node_modules/property-information/lib/xlink.js
var xlink = create2({
  space: "xlink",
  transform(_2, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});

// node_modules/property-information/lib/xml.js
var xml = create2({
  space: "xml",
  transform(_2, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes3, attribute) {
  return attribute in attributes3 ? attributes3[attribute] : attribute;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes3, property) {
  return caseSensitiveTransform(attributes3, property.toLowerCase());
}

// node_modules/property-information/lib/xmlns.js
var xmlns = create2({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});

// node_modules/property-information/lib/aria.js
var aria = create2({
  transform(_2, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});

// node_modules/property-information/lib/html.js
var html2 = create2({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    align: null,
    aLink: null,
    archive: spaceSeparated,
    axis: null,
    background: null,
    bgColor: null,
    border: number,
    borderColor: null,
    bottomMargin: number,
    cellPadding: null,
    cellSpacing: null,
    char: null,
    charOff: null,
    classId: null,
    clear: null,
    code: null,
    codeBase: null,
    codeType: null,
    color: null,
    compact: boolean,
    declare: boolean,
    event: null,
    face: null,
    frame: null,
    frameBorder: null,
    hSpace: number,
    leftMargin: number,
    link: null,
    longDesc: null,
    lowSrc: null,
    marginHeight: number,
    marginWidth: number,
    noResize: boolean,
    noHref: boolean,
    noShade: boolean,
    noWrap: boolean,
    object: null,
    profile: null,
    prompt: null,
    rev: null,
    rightMargin: number,
    rules: null,
    scheme: null,
    scrolling: booleanish,
    standby: null,
    summary: null,
    text: null,
    topMargin: number,
    valueType: null,
    version: null,
    vAlign: null,
    vLink: null,
    vSpace: number,
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});

// node_modules/property-information/lib/svg.js
var svg = create2({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    keySplines: null,
    keyTimes: null,
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});

// node_modules/property-information/lib/find.js
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize2(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/lib/hast-to-react.js
var hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};

// node_modules/property-information/index.js
var html3 = merge([xml, xlink, xmlns, aria, html2], "html");
var svg2 = merge([xml, xlink, xmlns, aria, svg], "svg");

// node_modules/react-markdown/lib/rehype-filter.js
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError("Only one of `allowedElements` and `disallowedElements` should be defined");
  }
  if (options.allowedElements || options.disallowedElements || options.allowElement) {
    return (tree) => {
      visit(tree, "element", (node2, index2, parent_) => {
        const parent = parent_;
        let remove2;
        if (options.allowedElements) {
          remove2 = !options.allowedElements.includes(node2.tagName);
        } else if (options.disallowedElements) {
          remove2 = options.disallowedElements.includes(node2.tagName);
        }
        if (!remove2 && options.allowElement && typeof index2 === "number") {
          remove2 = !options.allowElement(node2, index2, parent);
        }
        if (remove2 && typeof index2 === "number") {
          if (options.unwrapDisallowed && node2.children) {
            parent.children.splice(index2, 1, ...node2.children);
          } else {
            parent.children.splice(index2, 1);
          }
          return index2;
        }
        return void 0;
      });
    };
  }
}

// node_modules/react-markdown/lib/ast-to-react.js
var import_react11 = __toESM(require_react(), 1);
var import_react_is = __toESM(require_react_is2(), 1);

// node_modules/hast-util-whitespace/index.js
function whitespace(thing) {
  const value = thing && typeof thing === "object" && thing.type === "text" ? thing.value || "" : thing;
  return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}

// node_modules/space-separated-tokens/index.js
function parse2(value) {
  const input = String(value || "").trim();
  return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify(values2) {
  return values2.join(" ").trim();
}

// node_modules/comma-separated-tokens/index.js
function parse3(value) {
  const tokens = [];
  const input = String(value || "");
  let index2 = input.indexOf(",");
  let start3 = 0;
  let end4 = false;
  while (!end4) {
    if (index2 === -1) {
      index2 = input.length;
      end4 = true;
    }
    const token = input.slice(start3, index2).trim();
    if (token || !end4) {
      tokens.push(token);
    }
    start3 = index2 + 1;
    index2 = input.indexOf(",", start3);
  }
  return tokens;
}
function stringify2(values2, options) {
  const settings = options || {};
  const input = values2[values2.length - 1] === "" ? [...values2, ""] : values2;
  return input.join((settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")).trim();
}

// node_modules/style-to-object/index.mjs
var import_index = __toESM(require_style_to_object(), 1);
var style_to_object_default = import_index.default;

// node_modules/react-markdown/lib/uri-transformer.js
var protocols = ["http", "https", "mailto", "tel"];
function uriTransformer(uri) {
  const url = (uri || "").trim();
  const first = url.charAt(0);
  if (first === "#" || first === "/") {
    return url;
  }
  const colon = url.indexOf(":");
  if (colon === -1) {
    return url;
  }
  let index2 = -1;
  while (++index2 < protocols.length) {
    const protocol = protocols[index2];
    if (colon === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) {
      return url;
    }
  }
  index2 = url.indexOf("?");
  if (index2 !== -1 && colon > index2) {
    return url;
  }
  index2 = url.indexOf("#");
  if (index2 !== -1 && colon > index2) {
    return url;
  }
  return "javascript:void(0)";
}

// node_modules/react-markdown/lib/ast-to-react.js
var own6 = {}.hasOwnProperty;
var tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function childrenToReact(context, node2) {
  const children = [];
  let childIndex = -1;
  let child;
  while (++childIndex < node2.children.length) {
    child = node2.children[childIndex];
    if (child.type === "element") {
      children.push(toReact(context, child, childIndex, node2));
    } else if (child.type === "text") {
      if (node2.type !== "element" || !tableElements.has(node2.tagName) || !whitespace(child)) {
        children.push(child.value);
      }
    } else if (child.type === "raw" && !context.options.skipHtml) {
      children.push(child.value);
    }
  }
  return children;
}
function toReact(context, node2, index2, parent) {
  const options = context.options;
  const transform = options.transformLinkUri === void 0 ? uriTransformer : options.transformLinkUri;
  const parentSchema = context.schema;
  const name = node2.tagName;
  const properties = {};
  let schema = parentSchema;
  let property;
  if (parentSchema.space === "html" && name === "svg") {
    schema = svg2;
    context.schema = schema;
  }
  if (node2.properties) {
    for (property in node2.properties) {
      if (own6.call(node2.properties, property)) {
        addProperty(properties, property, node2.properties[property], context);
      }
    }
  }
  if (name === "ol" || name === "ul") {
    context.listDepth++;
  }
  const children = childrenToReact(context, node2);
  if (name === "ol" || name === "ul") {
    context.listDepth--;
  }
  context.schema = parentSchema;
  const position6 = node2.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  };
  const component = options.components && own6.call(options.components, name) ? options.components[name] : name;
  const basic = typeof component === "string" || component === import_react11.default.Fragment;
  if (!import_react_is.default.isValidElementType(component)) {
    throw new TypeError(`Component for name \`${name}\` not defined or is not renderable`);
  }
  properties.key = index2;
  if (name === "a" && options.linkTarget) {
    properties.target = typeof options.linkTarget === "function" ? options.linkTarget(String(properties.href || ""), node2.children, typeof properties.title === "string" ? properties.title : null) : options.linkTarget;
  }
  if (name === "a" && transform) {
    properties.href = transform(String(properties.href || ""), node2.children, typeof properties.title === "string" ? properties.title : null);
  }
  if (!basic && name === "code" && parent.type === "element" && parent.tagName !== "pre") {
    properties.inline = true;
  }
  if (!basic && (name === "h1" || name === "h2" || name === "h3" || name === "h4" || name === "h5" || name === "h6")) {
    properties.level = Number.parseInt(name.charAt(1), 10);
  }
  if (name === "img" && options.transformImageUri) {
    properties.src = options.transformImageUri(String(properties.src || ""), String(properties.alt || ""), typeof properties.title === "string" ? properties.title : null);
  }
  if (!basic && name === "li" && parent.type === "element") {
    const input = getInputElement(node2);
    properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;
    properties.index = getElementsBeforeCount(parent, node2);
    properties.ordered = parent.tagName === "ol";
  }
  if (!basic && (name === "ol" || name === "ul")) {
    properties.ordered = name === "ol";
    properties.depth = context.listDepth;
  }
  if (name === "td" || name === "th") {
    if (properties.align) {
      if (!properties.style)
        properties.style = {};
      properties.style.textAlign = properties.align;
      delete properties.align;
    }
    if (!basic) {
      properties.isHeader = name === "th";
    }
  }
  if (!basic && name === "tr" && parent.type === "element") {
    properties.isHeader = Boolean(parent.tagName === "thead");
  }
  if (options.sourcePos) {
    properties["data-sourcepos"] = flattenPosition(position6);
  }
  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node2.position;
  }
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node2);
    properties.siblingCount = getElementsBeforeCount(parent);
  }
  if (!basic) {
    properties.node = node2;
  }
  return children.length > 0 ? import_react11.default.createElement(component, properties, children) : import_react11.default.createElement(component, properties);
}
function getInputElement(node2) {
  let index2 = -1;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    if (child.type === "element" && child.tagName === "input") {
      return child;
    }
  }
  return null;
}
function getElementsBeforeCount(parent, node2) {
  let index2 = -1;
  let count2 = 0;
  while (++index2 < parent.children.length) {
    if (parent.children[index2] === node2)
      break;
    if (parent.children[index2].type === "element")
      count2++;
  }
  return count2;
}
function addProperty(props, prop, value, ctx) {
  const info = find(ctx.schema, prop);
  let result = value;
  if (result === null || result === void 0 || result !== result) {
    return;
  }
  if (Array.isArray(result)) {
    result = info.commaSeparated ? stringify2(result) : stringify(result);
  }
  if (info.property === "style" && typeof result === "string") {
    result = parseStyle(result);
  }
  if (info.space && info.property) {
    props[own6.call(hastToReact, info.property) ? hastToReact[info.property] : info.property] = result;
  } else if (info.attribute) {
    props[info.attribute] = result;
  }
}
function parseStyle(value) {
  const result = {};
  try {
    style_to_object_default(value, iterator);
  } catch (e2) {
  }
  return result;
  function iterator(name, v) {
    const k = name.slice(0, 4) === "-ms-" ? `ms-${name.slice(4)}` : name;
    result[k.replace(/-([a-z])/g, styleReplacer)] = v;
  }
}
function styleReplacer(_2, $1) {
  return $1.toUpperCase();
}
function flattenPosition(pos) {
  return [
    pos.start.line,
    ":",
    pos.start.column,
    "-",
    pos.end.line,
    ":",
    pos.end.column
  ].map(String).join("");
}

// node_modules/react-markdown/lib/react-markdown.js
var own7 = {}.hasOwnProperty;
var changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var deprecated = {
  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own7.call(deprecated, key) && own7.call(options, key)) {
      const deprecation = deprecated[key];
      console.warn(`[react-markdown] Warning: please ${deprecation.to ? `use \`${deprecation.to}\` instead of` : "remove"} \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`);
      delete deprecated[key];
    }
  }
  const processor = unified().use(remarkParse).use(options.remarkPlugins || []).use(lib_default, __spreadProps(__spreadValues({}, options.remarkRehypeOptions), {
    allowDangerousHtml: true
  })).use(options.rehypePlugins || []).use(rehypeFilter, options);
  const file = new VFile();
  if (typeof options.children === "string") {
    file.value = options.children;
  } else if (options.children !== void 0 && options.children !== null) {
    console.warn(`[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`);
  }
  const hastNode = processor.runSync(processor.parse(file), file);
  if (hastNode.type !== "root") {
    throw new TypeError("Expected a `root` node");
  }
  let result = import_react12.default.createElement(import_react12.default.Fragment, {}, childrenToReact({ options, schema: html3, listDepth: 0 }, hastNode));
  if (options.className) {
    result = import_react12.default.createElement("div", { className: options.className }, result);
  }
  return result;
}
ReactMarkdown.propTypes = {
  children: import_prop_types.default.string,
  className: import_prop_types.default.string,
  allowElement: import_prop_types.default.func,
  allowedElements: import_prop_types.default.arrayOf(import_prop_types.default.string),
  disallowedElements: import_prop_types.default.arrayOf(import_prop_types.default.string),
  unwrapDisallowed: import_prop_types.default.bool,
  remarkPlugins: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([
    import_prop_types.default.object,
    import_prop_types.default.func,
    import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([
      import_prop_types.default.bool,
      import_prop_types.default.string,
      import_prop_types.default.object,
      import_prop_types.default.func,
      import_prop_types.default.arrayOf(import_prop_types.default.any)
    ]))
  ])),
  rehypePlugins: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([
    import_prop_types.default.object,
    import_prop_types.default.func,
    import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([
      import_prop_types.default.bool,
      import_prop_types.default.string,
      import_prop_types.default.object,
      import_prop_types.default.func,
      import_prop_types.default.arrayOf(import_prop_types.default.any)
    ]))
  ])),
  sourcePos: import_prop_types.default.bool,
  rawSourcePos: import_prop_types.default.bool,
  skipHtml: import_prop_types.default.bool,
  includeElementIndex: import_prop_types.default.bool,
  transformLinkUri: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.bool]),
  linkTarget: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.string]),
  transformImageUri: import_prop_types.default.func,
  components: import_prop_types.default.object
};

// node_modules/hast-util-raw/lib/index.js
var import_parser = __toESM(require_parser(), 1);

// node_modules/hast-util-parse-selector/lib/index.js
var search2 = /[#.]/g;
function parseSelector(selector, defaultTagName) {
  const value = selector || "";
  const props = {};
  let start3 = 0;
  let previous2;
  let tagName;
  while (start3 < value.length) {
    search2.lastIndex = start3;
    const match3 = search2.exec(value);
    const subvalue = value.slice(start3, match3 ? match3.index : value.length);
    if (subvalue) {
      if (!previous2) {
        tagName = subvalue;
      } else if (previous2 === "#") {
        props.id = subvalue;
      } else if (Array.isArray(props.className)) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start3 += subvalue.length;
    }
    if (match3) {
      previous2 = match3[0];
      start3++;
    }
  }
  return {
    type: "element",
    tagName: tagName || defaultTagName || "div",
    properties: props,
    children: []
  };
}

// node_modules/hastscript/lib/core.js
var buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
var own8 = {}.hasOwnProperty;
function core(schema, defaultTagName, caseSensitive) {
  const adjust = caseSensitive && createAdjustMap(caseSensitive);
  const h2 = function(selector, properties, ...children) {
    let index2 = -1;
    let node2;
    if (selector === void 0 || selector === null) {
      node2 = { type: "root", children: [] };
      children.unshift(properties);
    } else {
      node2 = parseSelector(selector, defaultTagName);
      node2.tagName = node2.tagName.toLowerCase();
      if (adjust && own8.call(adjust, node2.tagName)) {
        node2.tagName = adjust[node2.tagName];
      }
      if (isProperties(properties, node2.tagName)) {
        let key;
        for (key in properties) {
          if (own8.call(properties, key)) {
            addProperty2(schema, node2.properties, key, properties[key]);
          }
        }
      } else {
        children.unshift(properties);
      }
    }
    while (++index2 < children.length) {
      addChild(node2.children, children[index2]);
    }
    if (node2.type === "element" && node2.tagName === "template") {
      node2.content = { type: "root", children: node2.children };
      node2.children = [];
    }
    return node2;
  };
  return h2;
}
function isProperties(value, name) {
  if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
    return false;
  }
  if (name === "input" || !value.type || typeof value.type !== "string") {
    return true;
  }
  if ("children" in value && Array.isArray(value.children)) {
    return false;
  }
  if (name === "button") {
    return buttonTypes.has(value.type.toLowerCase());
  }
  return !("value" in value);
}
function addProperty2(schema, properties, key, value) {
  const info = find(schema, key);
  let index2 = -1;
  let result;
  if (value === void 0 || value === null)
    return;
  if (typeof value === "number") {
    if (Number.isNaN(value))
      return;
    result = value;
  } else if (typeof value === "boolean") {
    result = value;
  } else if (typeof value === "string") {
    if (info.spaceSeparated) {
      result = parse2(value);
    } else if (info.commaSeparated) {
      result = parse3(value);
    } else if (info.commaOrSpaceSeparated) {
      result = parse2(parse3(value).join(" "));
    } else {
      result = parsePrimitive(info, info.property, value);
    }
  } else if (Array.isArray(value)) {
    result = value.concat();
  } else {
    result = info.property === "style" ? style(value) : String(value);
  }
  if (Array.isArray(result)) {
    const finalResult = [];
    while (++index2 < result.length) {
      finalResult[index2] = parsePrimitive(info, info.property, result[index2]);
    }
    result = finalResult;
  }
  if (info.property === "className" && Array.isArray(properties.className)) {
    result = properties.className.concat(result);
  }
  properties[info.property] = result;
}
function addChild(nodes, value) {
  let index2 = -1;
  if (value === void 0 || value === null) {
  } else if (typeof value === "string" || typeof value === "number") {
    nodes.push({ type: "text", value: String(value) });
  } else if (Array.isArray(value)) {
    while (++index2 < value.length) {
      addChild(nodes, value[index2]);
    }
  } else if (typeof value === "object" && "type" in value) {
    if (value.type === "root") {
      addChild(nodes, value.children);
    } else {
      nodes.push(value);
    }
  } else {
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  }
}
function parsePrimitive(info, name, value) {
  if (typeof value === "string") {
    if (info.number && value && !Number.isNaN(Number(value))) {
      return Number(value);
    }
    if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize2(value) === normalize2(name))) {
      return true;
    }
  }
  return value;
}
function style(value) {
  const result = [];
  let key;
  for (key in value) {
    if (own8.call(value, key)) {
      result.push([key, value[key]].join(": "));
    }
  }
  return result.join("; ");
}
function createAdjustMap(values2) {
  const result = {};
  let index2 = -1;
  while (++index2 < values2.length) {
    result[values2[index2].toLowerCase()] = values2[index2];
  }
  return result;
}

// node_modules/hastscript/lib/html.js
var h = core(html3, "div");

// node_modules/hastscript/lib/svg-case-sensitive-tag-names.js
var svgCaseSensitiveTagNames = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];

// node_modules/hastscript/lib/svg.js
var s = core(svg2, "g", svgCaseSensitiveTagNames);

// node_modules/vfile-location/lib/index.js
function location2(file) {
  const value = String(file);
  const indices = [];
  const search3 = /\r?\n|\r/g;
  while (search3.test(value)) {
    indices.push(search3.lastIndex);
  }
  indices.push(value.length + 1);
  return { toPoint, toOffset };
  function toPoint(offset4) {
    let index2 = -1;
    if (typeof offset4 === "number" && offset4 > -1 && offset4 < indices[indices.length - 1]) {
      while (++index2 < indices.length) {
        if (indices[index2] > offset4) {
          return {
            line: index2 + 1,
            column: offset4 - (index2 > 0 ? indices[index2 - 1] : 0) + 1,
            offset: offset4
          };
        }
      }
    }
    return { line: void 0, column: void 0, offset: void 0 };
  }
  function toOffset(point5) {
    const line = point5 && point5.line;
    const column = point5 && point5.column;
    if (typeof line === "number" && typeof column === "number" && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {
      const offset4 = (indices[line - 2] || 0) + column - 1 || 0;
      if (offset4 > -1 && offset4 < indices[indices.length - 1]) {
        return offset4;
      }
    }
    return -1;
  }
}

// node_modules/web-namespaces/index.js
var webNamespaces = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/hast-util-from-parse5/lib/index.js
var own9 = {}.hasOwnProperty;
var proto = Object.prototype;
function fromParse5(tree, options) {
  const options_ = options || {};
  let settings;
  let file;
  if (isFile(options_)) {
    file = options_;
    settings = {};
  } else {
    file = options_.file || void 0;
    settings = options_;
  }
  return one3({
    schema: settings.space === "svg" ? svg2 : html3,
    file,
    verbose: settings.verbose,
    location: false
  }, tree);
}
function one3(state, node2) {
  let result;
  switch (node2.nodeName) {
    case "#comment": {
      const reference = node2;
      result = { type: "comment", value: reference.data };
      patch2(state, reference, result);
      return result;
    }
    case "#document":
    case "#document-fragment": {
      const reference = node2;
      const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
      result = {
        type: "root",
        children: all3(state, node2.childNodes),
        data: { quirksMode }
      };
      if (state.file && state.location) {
        const doc = String(state.file);
        const loc = location2(doc);
        const start3 = loc.toPoint(0);
        const end4 = loc.toPoint(doc.length);
        result.position = { start: start3, end: end4 };
      }
      return result;
    }
    case "#documentType": {
      const reference = node2;
      result = { type: "doctype" };
      patch2(state, reference, result);
      return result;
    }
    case "#text": {
      const reference = node2;
      result = { type: "text", value: reference.value };
      patch2(state, reference, result);
      return result;
    }
    default: {
      const reference = node2;
      result = element2(state, reference);
      return result;
    }
  }
}
function all3(state, nodes) {
  let index2 = -1;
  const result = [];
  while (++index2 < nodes.length) {
    result[index2] = one3(state, nodes[index2]);
  }
  return result;
}
function element2(state, node2) {
  const schema = state.schema;
  state.schema = node2.namespaceURI === webNamespaces.svg ? svg2 : html3;
  let index2 = -1;
  const props = {};
  while (++index2 < node2.attrs.length) {
    const attribute = node2.attrs[index2];
    const name = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
    if (!own9.call(proto, name)) {
      props[name] = attribute.value;
    }
  }
  const fn = state.schema.space === "svg" ? s : h;
  const result = fn(node2.tagName, props, all3(state, node2.childNodes));
  patch2(state, node2, result);
  if (result.tagName === "template") {
    const reference = node2;
    const pos = reference.sourceCodeLocation;
    const startTag2 = pos && pos.startTag && position3(pos.startTag);
    const endTag2 = pos && pos.endTag && position3(pos.endTag);
    const content3 = one3(state, reference.content);
    if (startTag2 && endTag2 && state.file) {
      content3.position = { start: startTag2.end, end: endTag2.start };
    }
    result.content = content3;
  }
  state.schema = schema;
  return result;
}
function patch2(state, from, to) {
  if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
    const position6 = createLocation(state, to, from.sourceCodeLocation);
    if (position6) {
      state.location = true;
      to.position = position6;
    }
  }
}
function createLocation(state, node2, location3) {
  const result = position3(location3);
  if (node2.type === "element") {
    const tail = node2.children[node2.children.length - 1];
    if (result && !location3.endTag && tail && tail.position && tail.position.end) {
      result.end = Object.assign({}, tail.position.end);
    }
    if (state.verbose) {
      const props = {};
      let key;
      if (location3.attrs) {
        for (key in location3.attrs) {
          if (own9.call(location3.attrs, key)) {
            props[find(state.schema, key).property] = position3(location3.attrs[key]);
          }
        }
      }
      node2.data = {
        position: {
          opening: position3(location3.startTag),
          closing: location3.endTag ? position3(location3.endTag) : null,
          properties: props
        }
      };
    }
  }
  return result;
}
function position3(loc) {
  const start3 = point4({
    line: loc.startLine,
    column: loc.startCol,
    offset: loc.startOffset
  });
  const end4 = point4({
    line: loc.endLine,
    column: loc.endCol,
    offset: loc.endOffset
  });
  return start3 || end4 ? { start: start3, end: end4 } : void 0;
}
function point4(point5) {
  return point5.line && point5.column ? point5 : void 0;
}
function isFile(value) {
  return "messages" in value;
}

// node_modules/zwitch/index.js
var own10 = {}.hasOwnProperty;
function zwitch(key, options) {
  const settings = options || {};
  function one5(value, ...parameters) {
    let fn = one5.invalid;
    const handlers2 = one5.handlers;
    if (value && own10.call(value, key)) {
      const id = String(value[key]);
      fn = own10.call(handlers2, id) ? handlers2[id] : one5.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one5.handlers = settings.handlers || {};
  one5.invalid = settings.invalid;
  one5.unknown = settings.unknown;
  return one5;
}

// node_modules/hast-util-to-parse5/lib/index.js
var own11 = {}.hasOwnProperty;
var one4 = zwitch("type", { handlers: { root: root2, element: element3, text: text4, comment, doctype } });
function toParse5(tree, options) {
  const space3 = options && typeof options === "object" ? options.space : options;
  return one4(tree, space3 === "svg" ? svg2 : html3);
}
function root2(node2, schema) {
  const result = {
    nodeName: "#document",
    mode: (node2.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  result.childNodes = all4(node2.children, result, schema);
  patch3(node2, result);
  return result;
}
function fragment(node2, schema) {
  const result = { nodeName: "#document-fragment", childNodes: [] };
  result.childNodes = all4(node2.children, result, schema);
  patch3(node2, result);
  return result;
}
function doctype(node2) {
  const result = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: void 0
  };
  patch3(node2, result);
  return result;
}
function text4(node2) {
  const result = {
    nodeName: "#text",
    value: node2.value,
    parentNode: void 0
  };
  patch3(node2, result);
  return result;
}
function comment(node2) {
  const result = {
    nodeName: "#comment",
    data: node2.value,
    parentNode: void 0
  };
  patch3(node2, result);
  return result;
}
function element3(node2, schema) {
  const parentSchema = schema;
  let currentSchema = parentSchema;
  if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    currentSchema = svg2;
  }
  const attrs = [];
  let prop;
  if (node2.properties) {
    for (prop in node2.properties) {
      if (prop !== "children" && own11.call(node2.properties, prop)) {
        const result2 = createProperty(currentSchema, prop, node2.properties[prop]);
        if (result2) {
          attrs.push(result2);
        }
      }
    }
  }
  const result = {
    nodeName: node2.tagName,
    tagName: node2.tagName,
    attrs,
    namespaceURI: webNamespaces[currentSchema.space],
    childNodes: [],
    parentNode: void 0
  };
  result.childNodes = all4(node2.children, result, currentSchema);
  patch3(node2, result);
  if (node2.tagName === "template" && node2.content) {
    result.content = fragment(node2.content, currentSchema);
  }
  return result;
}
function createProperty(schema, prop, value) {
  const info = find(schema, prop);
  if (value === void 0 || value === null || value === false || typeof value === "number" && Number.isNaN(value) || !value && info.boolean) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify2(value) : stringify(value);
  }
  const attribute = {
    name: info.attribute,
    value: value === true ? "" : String(value)
  };
  if (info.space && info.space !== "html" && info.space !== "svg") {
    const index2 = attribute.name.indexOf(":");
    if (index2 < 0) {
      attribute.prefix = "";
    } else {
      attribute.name = attribute.name.slice(index2 + 1);
      attribute.prefix = info.attribute.slice(0, index2);
    }
    attribute.namespace = webNamespaces[info.space];
  }
  return attribute;
}
function all4(children, parentNode, schema) {
  let index2 = -1;
  const results = [];
  if (children) {
    while (++index2 < children.length) {
      const child = one4(children[index2], schema);
      child.parentNode = parentNode;
      results.push(child);
    }
  }
  return results;
}
function patch3(from, to) {
  const position6 = from.position;
  if (position6 && position6.start && position6.end) {
    to.sourceCodeLocation = {
      startLine: position6.start.line,
      startCol: position6.start.column,
      startOffset: position6.start.offset,
      endLine: position6.end.line,
      endCol: position6.end.column,
      endOffset: position6.end.offset
    };
  }
}

// node_modules/html-void-elements/index.js
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
];

// node_modules/hast-util-raw/lib/index.js
var inTemplateMode = "IN_TEMPLATE_MODE";
var dataState = "DATA_STATE";
var characterToken = "CHARACTER_TOKEN";
var startTagToken = "START_TAG_TOKEN";
var endTagToken = "END_TAG_TOKEN";
var commentToken = "COMMENT_TOKEN";
var doctypeToken = "DOCTYPE_TOKEN";
var parseOptions = { sourceCodeLocationInfo: true, scriptingEnabled: false };
var raw = function(tree, file, options) {
  let index2 = -1;
  const parser = new import_parser.default(parseOptions);
  const one5 = zwitch("type", {
    handlers: { root: root3, element: element4, text: text6, comment: comment2, doctype: doctype2, raw: handleRaw },
    unknown
  });
  let stitches;
  let tokenizer;
  let preprocessor;
  let posTracker;
  let locationTracker;
  if (isOptions(file)) {
    options = file;
    file = void 0;
  }
  if (options && options.passThrough) {
    while (++index2 < options.passThrough.length) {
      one5.handlers[options.passThrough[index2]] = stitch;
    }
  }
  const result = fromParse5(documentMode(tree) ? document4() : fragment2(), file);
  if (stitches) {
    visit(result, "comment", (node2, index3, parent) => {
      const stitch2 = node2;
      if (stitch2.value.stitch && parent !== null && index3 !== null) {
        parent.children[index3] = stitch2.value.stitch;
        return index3;
      }
    });
  }
  if (tree.type !== "root" && result.type === "root" && result.children.length === 1) {
    return result.children[0];
  }
  return result;
  function fragment2() {
    const context = {
      nodeName: "template",
      tagName: "template",
      attrs: [],
      namespaceURI: webNamespaces.html,
      childNodes: []
    };
    const mock = {
      nodeName: "documentmock",
      tagName: "documentmock",
      attrs: [],
      namespaceURI: webNamespaces.html,
      childNodes: []
    };
    const doc = { nodeName: "#document-fragment", childNodes: [] };
    parser._bootstrap(mock, context);
    parser._pushTmplInsertionMode(inTemplateMode);
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    tokenizer = parser.tokenizer;
    if (!tokenizer)
      throw new Error("Expected `tokenizer`");
    preprocessor = tokenizer.preprocessor;
    locationTracker = tokenizer.__mixins[0];
    posTracker = locationTracker.posTracker;
    one5(tree);
    resetTokenizer();
    parser._adoptNodes(mock.childNodes[0], doc);
    return doc;
  }
  function document4() {
    const doc = parser.treeAdapter.createDocument();
    parser._bootstrap(doc, void 0);
    tokenizer = parser.tokenizer;
    if (!tokenizer)
      throw new Error("Expected `tokenizer`");
    preprocessor = tokenizer.preprocessor;
    locationTracker = tokenizer.__mixins[0];
    posTracker = locationTracker.posTracker;
    one5(tree);
    resetTokenizer();
    return doc;
  }
  function all7(nodes) {
    let index3 = -1;
    if (nodes) {
      while (++index3 < nodes.length) {
        one5(nodes[index3]);
      }
    }
  }
  function root3(node2) {
    all7(node2.children);
  }
  function element4(node2) {
    resetTokenizer();
    parser._processInputToken(startTag(node2));
    all7(node2.children);
    if (!htmlVoidElements.includes(node2.tagName)) {
      resetTokenizer();
      parser._processInputToken(endTag(node2));
    }
  }
  function text6(node2) {
    resetTokenizer();
    parser._processInputToken({
      type: characterToken,
      chars: node2.value,
      location: createParse5Location(node2)
    });
  }
  function doctype2(node2) {
    resetTokenizer();
    parser._processInputToken({
      type: doctypeToken,
      name: "html",
      forceQuirks: false,
      publicId: "",
      systemId: "",
      location: createParse5Location(node2)
    });
  }
  function comment2(node2) {
    resetTokenizer();
    parser._processInputToken({
      type: commentToken,
      data: node2.value,
      location: createParse5Location(node2)
    });
  }
  function handleRaw(node2) {
    const start3 = pointStart(node2);
    const line = start3.line || 1;
    const column = start3.column || 1;
    const offset4 = start3.offset || 0;
    if (!preprocessor)
      throw new Error("Expected `preprocessor`");
    if (!tokenizer)
      throw new Error("Expected `tokenizer`");
    if (!posTracker)
      throw new Error("Expected `posTracker`");
    if (!locationTracker)
      throw new Error("Expected `locationTracker`");
    preprocessor.html = void 0;
    preprocessor.pos = -1;
    preprocessor.lastGapPos = -1;
    preprocessor.lastCharPos = -1;
    preprocessor.gapStack = [];
    preprocessor.skipNextNewLine = false;
    preprocessor.lastChunkWritten = false;
    preprocessor.endOfChunkHit = false;
    posTracker.isEol = false;
    posTracker.lineStartPos = -column + 1;
    posTracker.droppedBufferSize = offset4;
    posTracker.offset = 0;
    posTracker.col = 1;
    posTracker.line = line;
    locationTracker.currentAttrLocation = void 0;
    locationTracker.ctLoc = createParse5Location(node2);
    tokenizer.write(node2.value);
    parser._runParsingLoop(null);
    if (tokenizer.state === "NAMED_CHARACTER_REFERENCE_STATE" || tokenizer.state === "NUMERIC_CHARACTER_REFERENCE_END_STATE") {
      preprocessor.lastChunkWritten = true;
      tokenizer[tokenizer.state](tokenizer._consume());
    }
  }
  function stitch(node2) {
    stitches = true;
    let clone3;
    if ("children" in node2) {
      clone3 = __spreadProps(__spreadValues({}, node2), {
        children: raw({ type: "root", children: node2.children }, file, options).children
      });
    } else {
      clone3 = __spreadValues({}, node2);
    }
    comment2({ type: "comment", value: { stitch: clone3 } });
  }
  function resetTokenizer() {
    if (!tokenizer)
      throw new Error("Expected `tokenizer`");
    if (!posTracker)
      throw new Error("Expected `posTracker`");
    const token = tokenizer.currentCharacterToken;
    if (token) {
      token.location.endLine = posTracker.line;
      token.location.endCol = posTracker.col + 1;
      token.location.endOffset = posTracker.offset + 1;
      parser._processInputToken(token);
    }
    tokenizer.tokenQueue = [];
    tokenizer.state = dataState;
    tokenizer.returnState = "";
    tokenizer.charRefCode = -1;
    tokenizer.tempBuff = [];
    tokenizer.lastStartTagName = "";
    tokenizer.consumedAfterSnapshot = -1;
    tokenizer.active = false;
    tokenizer.currentCharacterToken = void 0;
    tokenizer.currentToken = void 0;
    tokenizer.currentAttr = void 0;
  }
};
function startTag(node2) {
  const location3 = Object.assign(createParse5Location(node2));
  location3.startTag = Object.assign({}, location3);
  return {
    type: startTagToken,
    tagName: node2.tagName,
    selfClosing: false,
    attrs: attributes2(node2),
    location: location3
  };
}
function attributes2(node2) {
  return toParse5({
    tagName: node2.tagName,
    type: "element",
    properties: node2.properties,
    children: []
  }).attrs;
}
function endTag(node2) {
  const location3 = Object.assign(createParse5Location(node2));
  location3.startTag = Object.assign({}, location3);
  return {
    type: endTagToken,
    tagName: node2.tagName,
    attrs: [],
    location: location3
  };
}
function unknown(node2) {
  throw new Error("Cannot compile `" + node2.type + "` node");
}
function documentMode(node2) {
  const head = node2.type === "root" ? node2.children[0] : node2;
  return Boolean(head && (head.type === "doctype" || head.type === "element" && head.tagName === "html"));
}
function createParse5Location(node2) {
  const start3 = pointStart(node2);
  const end4 = pointEnd(node2);
  return {
    startLine: start3.line,
    startCol: start3.column,
    startOffset: start3.offset,
    endLine: end4.line,
    endCol: end4.column,
    endOffset: end4.offset
  };
}
function isOptions(value) {
  return Boolean(value && !("message" in value && "messages" in value));
}

// node_modules/rehype-raw/index.js
function rehypeRaw(options = {}) {
  return (tree, file) => {
    const result = raw(tree, file, options);
    return result;
  };
}

// src/components/markdowns/MarkdownComponent.tsx
var transformMarkdownLinks = (api2, markdown) => {
  return markdown.replace(/\[\[(.*?)(?:\|(.*?))?\]\]/g, (_2, link2, alias) => {
    return `<a href="${link2}" data-id="${link2}">${alias || link2}</a>`;
  });
};
function MarkdownComponent({
  value,
  specificComponent,
  className
}) {
  const api2 = useApi();
  const app = useApp();
  const transformedValue = transformMarkdownLinks(api2, value != null ? value : "");
  const handleLinkClick = (e2) => {
    e2.stopPropagation();
    if (e2.currentTarget.href) {
      app.workspace.openLinkText(e2.currentTarget.dataset.id, "", false);
    }
  };
  let components = {
    p: (_a) => {
      var props = __objRest(_a, []);
      return /* @__PURE__ */ React10.createElement("p", __spreadProps(__spreadValues({}, props), {
        className: "!mb-0 !mt-0  !bg-transparent"
      }));
    },
    a: (_b) => {
      var _c = _b, { node: node2 } = _c, props = __objRest(_c, ["node"]);
      return /* @__PURE__ */ React10.createElement("a", __spreadProps(__spreadValues({}, props), {
        className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]",
        onClick: handleLinkClick
      }));
    },
    ul: (_d) => {
      var _e = _d, { node: node2, ordered } = _e, props = __objRest(_e, ["node", "ordered"]);
      return /* @__PURE__ */ React10.createElement("ul", __spreadProps(__spreadValues({}, props), {
        className: "list-disc list-inside"
      }));
    },
    ol: (_f) => {
      var _g = _f, { node: node2, ordered } = _g, props = __objRest(_g, ["node", "ordered"]);
      return /* @__PURE__ */ React10.createElement("ol", __spreadProps(__spreadValues({}, props), {
        style: { listStyleType: "decimal" },
        className: " list-inside"
      }));
    },
    li: (_h) => {
      var _i = _h, { node: node2, ordered } = _i, props = __objRest(_i, ["node", "ordered"]);
      return /* @__PURE__ */ React10.createElement("li", __spreadProps(__spreadValues({}, props), {
        className: "!mb-0"
      }));
    },
    h2: (_j) => {
      var _k = _j, { node: node2 } = _k, props = __objRest(_k, ["node"]);
      return /* @__PURE__ */ React10.createElement("h2", __spreadProps(__spreadValues({}, props), {
        className: "!mt-3 !mb-6 !text-2xl !font-bold border-b border-b-[--background-modifier-border]"
      }));
    },
    h3: (_l) => {
      var _m = _l, { node: node2 } = _m, props = __objRest(_m, ["node"]);
      return /* @__PURE__ */ React10.createElement("h3", __spreadProps(__spreadValues({}, props), {
        className: "!mt-3 !mb-1 !text-xl !font-extralight"
      }));
    },
    small: (_n) => {
      var _o = _n, { node: node2 } = _o, props = __objRest(_o, ["node"]);
      return /* @__PURE__ */ React10.createElement("small", __spreadProps(__spreadValues({}, props), {
        className: "!text-xs text-[--text-muted]"
      }));
    }
  };
  if (specificComponent === "sensory") {
    components = {
      p: (_p) => {
        var props = __objRest(_p, []);
        return /* @__PURE__ */ React10.createElement("p", __spreadProps(__spreadValues({}, props), {
          className: "!mb-0 !mt-0  !bg-transparent"
        }));
      },
      a: (_q) => {
        var _r = _q, { node: node2 } = _r, props = __objRest(_r, ["node"]);
        return /* @__PURE__ */ React10.createElement("a", __spreadProps(__spreadValues({}, props), {
          className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]",
          onClick: handleLinkClick
        }));
      },
      ul: (_s) => {
        var _t = _s, { node: node2, ordered } = _t, props = __objRest(_t, ["node", "ordered"]);
        return /* @__PURE__ */ React10.createElement("ul", __spreadProps(__spreadValues({}, props), {
          className: "list-disc"
        }));
      },
      ol: (_u) => {
        var _v = _u, { node: node2, ordered } = _v, props = __objRest(_v, ["node", "ordered"]);
        return /* @__PURE__ */ React10.createElement("ol", __spreadProps(__spreadValues({}, props), {
          className: "list-none"
        }));
      },
      li: (_w) => {
        var _x = _w, { node: node2, ordered } = _x, props = __objRest(_x, ["node", "ordered"]);
        return /* @__PURE__ */ React10.createElement("li", __spreadProps(__spreadValues({}, props), {
          className: "!mb-1"
        }));
      },
      h2: (_y) => {
        var _z = _y, { node: node2 } = _z, props = __objRest(_z, ["node"]);
        return /* @__PURE__ */ React10.createElement("h2", __spreadProps(__spreadValues({}, props), {
          className: "!mt-3 !mb-6 !text-2xl !font-bold border-b border-b-[--background-modifier-border]"
        }));
      },
      h3: (_A) => {
        var _B = _A, { node: node2 } = _B, props = __objRest(_B, ["node"]);
        return /* @__PURE__ */ React10.createElement("h3", __spreadProps(__spreadValues({}, props), {
          className: "!mt-3 !mb-1 !text-xl !font-extralight"
        }));
      },
      small: (_C) => {
        var _D = _C, { node: node2 } = _D, props = __objRest(_D, ["node"]);
        return /* @__PURE__ */ React10.createElement("small", __spreadProps(__spreadValues({}, props), {
          className: "!text-xs text-[--text-muted]"
        }));
      }
    };
  }
  return /* @__PURE__ */ React10.createElement("div", {
    className: `markdown-content ${className != null ? className : ""}`
  }, /* @__PURE__ */ React10.createElement(ReactMarkdown, {
    rehypePlugins: [rehypeRaw],
    children: transformedValue,
    components
  }));
}

// src/data/enums/ArcType.ts
var ArcType = /* @__PURE__ */ ((ArcType2) => {
  ArcType2[ArcType2["Positive"] = 1] = "Positive";
  ArcType2[ArcType2["Disillusionment"] = 2] = "Disillusionment";
  ArcType2[ArcType2["Fall"] = 3] = "Fall";
  ArcType2[ArcType2["Corruption"] = 4] = "Corruption";
  ArcType2[ArcType2["Flat"] = 5] = "Flat";
  return ArcType2;
})(ArcType || {});

// src/components/attributes/types/ArcAttributeComponent.tsx
function ArcAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  if (!attribute.isSet)
    return null;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [editing, setEditing] = React11.useState(false);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  const saveAttribute = (arc2) => {
    codeblockService.updateCodeblockData(attribute.id, arc2);
  };
  let content3;
  if (editing) {
    content3 = Object.entries(ArcType).filter(([key]) => isNaN(Number(key))).map(([key]) => {
      const arcType = ArcType[key];
      return /* @__PURE__ */ React11.createElement("div", {
        key,
        className: "flex items-center border border-[--background-modifier-border] rounded-lg m-4 p-4 hover:bg-[--background-secondary] cursor-pointer",
        onClick: () => saveAttribute(arcType)
      }, /* @__PURE__ */ React11.createElement("div", {
        className: "flext min-w[50px] w-[50px] items-center justify-center"
      }, attribute.value === arcType && /* @__PURE__ */ React11.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "30",
        height: "30",
        fill: "currentColor",
        viewBox: "0 0 16 16"
      }, /* @__PURE__ */ React11.createElement("path", {
        d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
      }))), /* @__PURE__ */ React11.createElement("div", null, /* @__PURE__ */ React11.createElement("h4", {
        className: "!m-0 !mb-2"
      }, t2("arc.arc", { context: arcType })), /* @__PURE__ */ React11.createElement("small", null, /* @__PURE__ */ React11.createElement(MarkdownComponent, {
        value: t2("arc.description", { context: arcType })
      }))));
    });
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React11.createElement("div", {
      onClick: () => setEditing(!editing),
      className: "border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-pointer"
    }, attribute.value && /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement("div", {
      className: "!mb-2"
    }, t2("arc.arc", { context: attribute.value })), /* @__PURE__ */ React11.createElement("small", null, /* @__PURE__ */ React11.createElement(MarkdownComponent, {
      value: t2("arc.description", { context: attribute.value })
    }))));
  } else {
    content3 = /* @__PURE__ */ React11.createElement("div", {
      className: "border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-pointer"
    }, attribute.value && /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement("div", {
      className: "!mb-2"
    }, t2("arc.arc", { context: attribute.value })), /* @__PURE__ */ React11.createElement("small", null, /* @__PURE__ */ React11.createElement(MarkdownComponent, {
      value: t2("arc.description", { context: attribute.value })
    }))));
  }
  return /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement(AttributeTitleComponent, {
    attribute
  }), content3);
}

// src/components/attributes/types/BooleanAttributeComponent.tsx
var React12 = __toESM(require_react());
function BooleanAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  }
  const saveAttribute = (newValue) => {
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React12.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React12.createElement("div", null, /* @__PURE__ */ React12.createElement("label", {
      className: "flex items-center cursor-pointer"
    }, /* @__PURE__ */ React12.createElement("div", {
      className: "relative"
    }, /* @__PURE__ */ React12.createElement("input", {
      type: "checkbox",
      className: "hidden",
      checked: attribute.value,
      onChange: (e2) => saveAttribute(e2.target.checked)
    }), /* @__PURE__ */ React12.createElement("div", {
      className: `border b-[--background-modifier-border] bg-[--background-secondary] w-8 h-5 p-1 rounded-full transition-colors duration-300 ${attribute.value ? "bg-[--interactive-accent]" : ""}`
    }), /* @__PURE__ */ React12.createElement("div", {
      className: `toggle-dot absolute top-0.5 left-0.5 w-4 h-4 bg-[--background-primary] rounded-full shadow-md transform-gpu transition-transform duration-300 ${attribute.value ? "translate-x-3" : ""}`
    })))), /* @__PURE__ */ React12.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React12.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: removeAttribute
    }, t2("buttons.delete"))));
  } else {
    content3 = /* @__PURE__ */ React12.createElement("div", {
      className: "flex flex-wrap p-3"
    }, /* @__PURE__ */ React12.createElement("div", {
      className: "flex items-center"
    }, /* @__PURE__ */ React12.createElement("div", {
      className: "relative"
    }, /* @__PURE__ */ React12.createElement("div", {
      className: `border b-[--background-modifier-border] bg-[--background-secondary] w-8 h-5 p-1 rounded-full transition-colors duration-300 ${attribute.value ? "bg-[--interactive-accent]" : ""}`
    }), /* @__PURE__ */ React12.createElement("div", {
      className: `toggle-dot absolute top-0.5 left-0.5 w-4 h-4 bg-[--background-primary] rounded-full shadow-md transform-gpu transition-transform duration-300 ${attribute.value ? "translate-x-3" : ""}`
    }))));
  }
  return /* @__PURE__ */ React12.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React12.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React12.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s2 = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s2,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s2,
  day: n,
  weekday: s2
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s2
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s2
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s2,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s2,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s2,
  day: n,
  weekday: s2,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s2
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s2
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/zone.js
var Zone = class {
  get type() {
    throw new ZoneIsAbstractError();
  }
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class extends Zone {
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone();
    }
    return singleton;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  equals(otherZone) {
    return otherZone.type === "system";
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date2) {
  const formatted = dtf.format(date2).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date2) {
  const formatted = dtf.formatToParts(date2);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type: type2, value } = formatted[i];
    const pos = typeToPos[type2];
    if (type2 === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class extends Zone {
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  static isValidSpecifier(s3) {
    return this.isValidZone(s3);
  }
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e2) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    const date2 = new Date(ts);
    if (isNaN(date2))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date2;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const _a = opts, { base: base2 } = _a, cacheKeyOpts = __objRest(_a, ["base"]);
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e2) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const _a = opts, { padTo, floor } = _a, otherOpts = __objRest(_a, ["padTo", "floor"]);
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = __spreadValues({ useGrouping: false }, opts);
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = __spreadValues({}, this.opts);
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return __spreadProps(__spreadValues({}, part), {
            value: offsetName
          });
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = __spreadValues({ style: "long" }, opts);
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count2, unit) {
    if (this.rtf) {
      return this.rtf.format(count2, unit);
    } else {
      return formatRelativeTime(unit, count2, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count2, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count2, unit);
    } else {
      return [];
    }
  }
};
var Locale = class {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar);
  }
  constructor(locale, numbering, outputCalendar, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: true }));
  }
  redefaultToSystem(alts = {}) {
    return this.clone(__spreadProps(__spreadValues({}, alts), { defaultToEN: false }));
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(this, void 0, () => meridiems, () => {
      if (!this.meridiemCache) {
        const intl = { hour: "numeric", hourCycle: "h12" };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class extends Zone {
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new FixedOffsetZone(0);
    }
    return singleton2;
  }
  static instance(offset4) {
    return offset4 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset4);
  }
  static parseSpecifier(s3) {
    if (s3) {
      const r = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset4) {
    super();
    this.fixed = offset4;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  offsetName() {
    return this.name;
  }
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset4;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var Settings = class {
  static get now() {
    return now;
  }
  static set now(n2) {
    now = n2;
  }
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  static get defaultLocale() {
    return defaultLocale;
  }
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  static set throwOnInvalid(t2) {
    throwOnInvalid = t2;
  }
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e2) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr2, by, compare) {
  if (arr2.length === 0) {
    return void 0;
  }
  return arr2.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys2) {
  return keys2.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string3) {
  if (isUndefined(string3) || string3 === null || string3 === "") {
    return void 0;
  } else {
    return parseInt(string3, 10);
  }
}
function parseFloating(string3) {
  if (isUndefined(string3) || string3 === null || string3 === "") {
    return void 0;
  } else {
    return parseFloat(string3);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number2, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number2 * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d2 = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
  if (obj.year < 100 && obj.year >= 0) {
    d2 = new Date(d2);
    d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d2;
}
function weeksInWeekYear(weekYear) {
  const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
  return p1 === 4 || p2 === 3 ? 53 : 52;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date2 = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = __spreadValues({ timeZoneName: offsetFormat }, intlOpts);
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date2).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty2(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset4, format) {
  const hours = Math.trunc(Math.abs(offset4 / 60)), minutes = Math.trunc(Math.abs(offset4 % 60)), sign = offset4 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count2, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count2) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count2, -0) || count2 < 0, fmtValue = Math.abs(count2), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s3 = "";
  for (const token of splits) {
    if (token.literal) {
      s3 += token.val;
    } else {
      s3 += tokenToString(token.val);
    }
  }
  return s3;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter2 = class {
  static create(locale, opts = {}) {
    return new Formatter2(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, __spreadValues(__spreadValues({}, this.opts), opts));
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p2 = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p2);
    }
    const opts = __spreadValues({}, this.opts);
    if (p2 > 0) {
      opts.padTo = p2;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string3 = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string3({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string3(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string3(standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" }, "weekday"), maybeMacro = (token) => {
      const formatOpts = Formatter2.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string3({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string3({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string3({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string3({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string3({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string3({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string3({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string3({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string3({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string3({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string3({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter2.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce((found, { literal, val }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
    const [val, zone, next] = ex(m, cursor);
    return [__spreadValues(__spreadValues({}, mergedVals), val), zone || mergedZone, next];
  }, [{}, null, 1]).slice(0, 2);
}
function parse4(s3, ...patterns) {
  if (s3 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s3);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys2) {
  return (match3, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys2.length; i++) {
      ret[keys2[i]] = parseInteger(match3[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match3, pos, fallback) {
  const m = match3[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match3, cursor) {
  const item = {
    year: int(match3, cursor),
    month: int(match3, cursor + 1, 1),
    day: int(match3, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match3, cursor) {
  const item = {
    hours: int(match3, cursor, 0),
    minutes: int(match3, cursor + 1, 0),
    seconds: int(match3, cursor + 2, 0),
    milliseconds: parseMillis(match3[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match3, cursor) {
  const local = !match3[cursor] && !match3[cursor + 1], fullOffset = signedOffset(match3[cursor + 1], match3[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match3, cursor) {
  const zone = match3[cursor] ? IANAZone.create(match3[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match3) {
  const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match3;
  const hasNegativePrefix = s3[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match3) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match3, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset4;
  if (obsOffset) {
    offset4 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset4 = 0;
  } else {
    offset4 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset4)];
}
function preprocessRFC2822(s3) {
  return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match3) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match3, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match3) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match3, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseISODate(s3) {
  return parse4(s3, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s3) {
  return parse4(preprocessRFC2822(s3), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s3) {
  return parse4(s3, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s3) {
  return parse4(s3, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s3) {
  return parse4(s3, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s3) {
  return parse4(s3, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = __spreadValues({
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  }
}, lowOrderMatrix);
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = __spreadValues({
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  }
}, lowOrderMatrix);
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : __spreadValues(__spreadValues({}, dur.values), alts.values || {}),
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  var _a;
  let sum = (_a = vals.milliseconds) != null ? _a : 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  reverseUnits.reduce((previous2, current) => {
    if (!isUndefined(vals[current])) {
      if (previous2) {
        const previousVal = vals[previous2] * factor;
        const conv = matrix[current][previous2];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous2] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous2;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class {
  constructor(config3) {
    const accurate = config3.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config3.matrix) {
      matrix = config3.matrix;
    }
    this.values = config3.values;
    this.loc = config3.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config3.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  static fromMillis(count2, opts) {
    return Duration.fromObject({ milliseconds: count2 }, opts);
  }
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
    }
  }
  static fromISO(text6, opts) {
    const [parsed] = parseISODuration(text6);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text6}" can't be parsed as ISO 8601`);
    }
  }
  static fromISOTime(text6, opts) {
    const [parsed] = parseISOTimeOnly(text6);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text6}" can't be parsed as ISO 8601`);
    }
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(fmt, opts = {}) {
    const fmtOpts = __spreadProps(__spreadValues({}, opts), {
      floor: opts.round !== false && opts.floor !== false
    });
    return this.isValid ? Formatter2.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter(__spreadProps(__spreadValues({ style: "unit", unitDisplay: "long" }, opts), { unit: unit.slice(0, -1) })).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter(__spreadValues({ type: "conjunction", style: opts.listStyle || "narrow" }, opts)).format(l2);
  }
  toObject() {
    if (!this.isValid)
      return {};
    return __spreadValues({}, this.values);
  }
  toISO() {
    if (!this.isValid)
      return null;
    let s3 = "P";
    if (this.years !== 0)
      s3 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s3 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s3 += this.weeks + "W";
    if (this.days !== 0)
      s3 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s3 += "T";
    if (this.hours !== 0)
      s3 += this.hours + "H";
    if (this.minutes !== 0)
      s3 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s3 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s3 === "P")
      s3 += "T0S";
    return s3;
  }
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = __spreadProps(__spreadValues({
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended"
    }, opts), {
      includeOffset: false
    });
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  valueOf() {
    return this.toMillis();
  }
  plus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty2(dur.values, k) || hasOwnProperty2(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  minus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2);
    return this.plus(dur.negate());
  }
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  set(values2) {
    if (!this.isValid)
      return this;
    const mixed = __spreadValues(__spreadValues({}, this.values), normalizeObject(values2, Duration.normalizeUnit));
    return clone(this, { values: mixed });
  }
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own12 = 0;
        for (const ak in accumulated) {
          own12 += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own12 += vals[k];
        }
        const i = Math.trunc(own12);
        built[k] = i;
        accumulated[k] = (own12 * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start3, end4) {
  if (!start3 || !start3.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end4 || !end4.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end4 < start3) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start3.toISO()} and end=${end4.toISO()}`);
  } else {
    return null;
  }
}
var Interval = class {
  constructor(config3) {
    this.s = config3.start;
    this.e = config3.end;
    this.invalid = config3.invalid || null;
    this.isLuxonInterval = true;
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  static fromDateTimes(start3, end4) {
    const builtStart = friendlyDateTime(start3), builtEnd = friendlyDateTime(end4);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  static after(start3, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(start3);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  static before(end4, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(end4);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  static fromISO(text6, opts) {
    const [s3, e2] = (text6 || "").split("/", 2);
    if (s3 && e2) {
      let start3, startIsValid;
      try {
        start3 = DateTime.fromISO(s3, opts);
        startIsValid = start3.isValid;
      } catch (e3) {
        startIsValid = false;
      }
      let end4, endIsValid;
      try {
        end4 = DateTime.fromISO(e2, opts);
        endIsValid = end4.isValid;
      } catch (e3) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start3, end4);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e2, opts);
        if (dur.isValid) {
          return Interval.after(start3, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s3, opts);
        if (dur.isValid) {
          return Interval.before(end4, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text6}" can't be parsed as ISO 8601`);
  }
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  count(unit = "milliseconds") {
    if (!this.isValid)
      return NaN;
    const start3 = this.start.startOf(unit), end4 = this.end.startOf(unit);
    return Math.floor(end4.diff(start3, unit).get(unit)) + (end4.valueOf() !== this.end.valueOf());
  }
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  set({ start: start3, end: end4 } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start3 || this.s, end4 || this.e);
  }
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
    let { s: s3 } = this, i = 0;
    while (s3 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s3, next));
      s3 = next;
      i += 1;
    }
    return results;
  }
  splitBy(duration2) {
    const dur = Duration.fromDurationLike(duration2);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s3 } = this, idx = 1, next;
    const results = [];
    while (s3 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s3, next));
      s3 = next;
      idx += 1;
    }
    return results;
  }
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  intersection(other) {
    if (!this.isValid)
      return this;
    const s3 = this.s > other.s ? this.s : other.s, e2 = this.e < other.e ? this.e : other.e;
    if (s3 >= e2) {
      return null;
    } else {
      return Interval.fromDateTimes(s3, e2);
    }
  }
  union(other) {
    if (!this.isValid)
      return this;
    const s3 = this.s < other.s ? this.s : other.s, e2 = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s3, e2);
  }
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);
    if (final) {
      found.push(final);
    }
    return found;
  }
  static xor(intervals) {
    let start3 = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr2 = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr2) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start3 = i.time;
      } else {
        if (start3 && +start3 !== +i.time) {
          results.push(Interval.fromDateTimes(start3, i.time));
        }
        start3 = null;
      }
    }
    return Interval.merge(results);
  }
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter2.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info2 = class {
  static hasDST(zone = Settings.defaultZone) {
    const proto2 = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto2.offset !== proto2.set({ month: 6 }).offset;
  }
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  static features() {
    return { relative: hasRelative() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter((u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration2 = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration2);
  } else {
    return duration2;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code2 = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code2 >= min && code2 <= max) {
            value += code2 - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append2 = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append2}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s3]) => post(parseDigits(s3)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s3) {
  return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s3) {
  return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s3]) => strings.findIndex((i) => stripInsensitivities(s3) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h2, m]) => signedOffset(h2, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s3]) => s3 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one5 = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t2) => ({ regex: RegExp(escapeToken(t2.val)), deser: ([s3]) => s3, literal: true }), unitate = (t2) => {
    if (token.literal) {
      return literal(t2);
    }
    switch (t2.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one5);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one5);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t2);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type: type2, value } = part;
  if (type2 === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style3 = formatOpts[type2];
  let actualType = type2;
  if (type2 === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style3];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers2) {
  const matches = input.match(regex);
  if (matches) {
    const all7 = {};
    let matchIndex = 1;
    for (const i in handlers2) {
      if (hasOwnProperty2(handlers2, i)) {
        const h2 = handlers2[i], groups = h2.groups ? h2.groups + 1 : 1;
        if (!h2.literal && h2.token) {
          all7[h2.token.val[0]] = h2.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all7];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter2.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t2) => maybeExpandMacroToken(t2, locale)));
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter2.parseFormat(format), locale), units = tokens.map((t2) => unitForToken(t2, locale)), disqualifyingUnit = units.find((t2) => t2.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers2] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers2), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter2.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p2) => tokenForPart(p2, formatOpts, resolvedOpts));
}

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
}
function dayOfWeek(year, month, day) {
  const d2 = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
  }
  const js = d2.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table2 = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table2.findIndex((i) => i < ordinal), day = ordinal - table2[month0];
  return { month: month0 + 1, day };
}
function gregorianToWeek(gregObj) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
  let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear);
  } else if (weekNumber > weeksInWeekYear(year)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return __spreadValues({ weekYear, weekNumber, weekday }, timeObject(gregObj));
}
function weekToGregorian(weekData) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return __spreadValues({ year, month, day }, timeObject(weekData));
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return __spreadValues({ year, ordinal }, timeObject(gregData));
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return __spreadValues({ year, month, day }, timeObject(ordinalData));
}
function hasInvalidWeekData(obj) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.week);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime(__spreadProps(__spreadValues(__spreadValues({}, current), alts), { old: current }));
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset4) {
  ts += offset4 * 60 * 1e3;
  const d2 = new Date(ts);
  return {
    year: d2.getUTCFullYear(),
    month: d2.getUTCMonth() + 1,
    day: d2.getUTCDate(),
    hour: d2.getUTCHours(),
    minute: d2.getUTCMinutes(),
    second: d2.getUTCSeconds(),
    millisecond: d2.getUTCMilliseconds()
  };
}
function objToTS(obj, offset4, zone) {
  return fixOffset(objToLocalTS(obj), offset4, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = __spreadProps(__spreadValues({}, inst.c), {
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }), millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text6, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, __spreadProps(__spreadValues({}, opts), {
      zone: interpretationZone,
      specificOffset
    }));
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${text6}" can't be parsed as ${format}`));
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter2.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start3, end4, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end4.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end4.hasSame(start3, unit)) {
        return end4.startOf(unit).diff(start3.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end4.diff(start3, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count2 = differ(unit);
    if (Math.abs(count2) >= 1) {
      return format(count2, unit);
    }
  }
  return format(start3 > end4 ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class {
  constructor(config3) {
    const zone = config3.zone || Settings.defaultZone;
    let invalid = config3.invalid || (Number.isNaN(config3.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config3.ts) ? Settings.now() : config3.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config3.old && config3.old.ts === this.ts && config3.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config3.old.c, config3.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config3.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  static now() {
    return new DateTime({});
  }
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static fromJSDate(date2, options = {}) {
    const ts = isDate(date2) ? date2.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
    }
    return inst;
  }
  static fromISO(text6, opts = {}) {
    const [vals, parsedZone] = parseISODate(text6);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text6);
  }
  static fromRFC2822(text6, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text6);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text6);
  }
  static fromHTTP(text6, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text6);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  static fromFormat(text6, fmt, opts = {}) {
    if (isUndefined(text6) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text6, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text6, specificOffset);
    }
  }
  static fromString(text6, fmt, opts = {}) {
    return DateTime.fromFormat(text6, fmt, opts);
  }
  static fromSQL(text6, opts = {}) {
    const [vals, parsedZone] = parseSQL(text6);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text6);
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
  }
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter2.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t2) => t2.val).join("");
  }
  get(unit) {
    return this[unit];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Info2.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Info2.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Info2.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Info2.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
    }
    return [this];
  }
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter2.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  toUTC(offset4 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset4), opts);
  }
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  set(values2) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values2, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(__spreadValues(__spreadValues({}, gregorianToWeek(this.c)), normalized));
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian(__spreadValues(__spreadValues({}, gregorianToOrdinal(this.c)), normalized));
    } else {
      mixed = __spreadValues(__spreadValues({}, this.toObject()), normalized);
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  plus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2);
    return clone2(this, adjustTime(this, dur));
  }
  minus(duration2) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration2).negate();
    return clone2(this, adjustTime(this, dur));
  }
  startOf(unit) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  endOf(unit) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
  }
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter2.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter2.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter2.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
  }
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base2 = __spreadValues({}, this.c);
    if (opts.includeConfig) {
      base2.outputCalendar = this.outputCalendar;
      base2.numberingSystem = this.loc.numberingSystem;
      base2.locale = this.loc.locale;
    }
    return base2;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = __spreadValues({ locale: this.locale, numberingSystem: this.numberingSystem }, opts);
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  hasSame(otherDateTime, unit) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
  }
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base2 = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base2 ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base2, this.plus(padding), __spreadProps(__spreadValues({}, options), {
      numeric: "always",
      units,
      unit
    }));
  }
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, __spreadProps(__spreadValues({}, options), {
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    }));
  }
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  static fromFormatExplain(text6, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text6, fmt);
  }
  static fromStringExplain(text6, fmt, options = {}) {
    return DateTime.fromFormatExplain(text6, fmt, options);
  }
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  static get DATE_MED() {
    return DATE_MED;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  static get DATE_FULL() {
    return DATE_FULL;
  }
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
  }
}

// src/components/attributes/types/DateAttributeComponent.tsx
var React13 = __toESM(require_react());
var import_react_flatpickr = __toESM(require_build());
function DateAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  }
  const saveAttribute = (newValue) => {
    if (newValue === void 0)
      return;
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React13.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React13.createElement("div", null, /* @__PURE__ */ React13.createElement(import_react_flatpickr.default, {
      value: attribute.value,
      options: { dateFormat: "Y-m-d", altInput: true, altFormat: "D, M j, Y" },
      onChange: (selectedDates, currentDate) => {
        saveAttribute(currentDate);
      }
    })), /* @__PURE__ */ React13.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React13.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: removeAttribute
    }, t2("buttons.delete"))));
  } else {
    content3 = /* @__PURE__ */ React13.createElement("div", {
      className: "flex flex-wrap p-3"
    }, attribute.value ? DateTime.fromISO(attribute.value).toJSDate().toDateString() : "");
  }
  return /* @__PURE__ */ React13.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React13.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React13.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/DefaultAttributeTypeComponent.tsx
var React17 = __toESM(require_react());

// src/components/attributes/primitives/TextInputComponent.tsx
var React16 = __toESM(require_react());

// src/controllers/NewRelationshipController.ts
var import_obsidian2 = require("obsidian");
var import_react13 = __toESM(require_react());
var import_client = __toESM(require_client());

// src/components/search/FuzzyNewElementComponent.tsx
var React14 = __toESM(require_react());
function FuzzyNewElementComponent({ name }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React14.createElement("div", {
    className: "flex items-center"
  }, /* @__PURE__ */ React14.createElement("div", {
    className: "w-full"
  }, name), /* @__PURE__ */ React14.createElement("div", {
    className: "w-64 flex items-center justify-end"
  }, /* @__PURE__ */ React14.createElement("small", null, t2("search.entertocreate"))));
}

// src/components/search/FuzzySearchResult.tsx
var React15 = __toESM(require_react());
function FuzzySearchResult({
  searchableElement,
  hasCampaign
}) {
  var _a, _b;
  const { t: t2 } = useTranslation();
  let small = searchableElement.type ? t2("elements." + searchableElement.type, { count: 1 }) : "playercharacter" /* PlayerCharacter */;
  if (!hasCampaign && searchableElement.type !== "campaign" /* Campaign */ && searchableElement.campaignName !== void 0) {
    small += " (" + ((_a = searchableElement.campaignName) != null ? _a : "") + ")";
  } else if (hasCampaign && searchableElement.type !== "campaign" /* Campaign */ && searchableElement.campaignName === void 0) {
    small += " (" + t2("global") + ")";
  }
  return /* @__PURE__ */ React15.createElement("div", {
    className: "flex items-center"
  }, /* @__PURE__ */ React15.createElement("div", {
    className: "w-[40px] h-[40px] flex items-center justify-center overflow-hidden"
  }, searchableElement.image && /* @__PURE__ */ React15.createElement("img", {
    src: searchableElement.image.src,
    alt: searchableElement.image.caption,
    className: "max-w-[40px] max-h-[40px]"
  })), /* @__PURE__ */ React15.createElement("div", {
    className: "ml-2"
  }, /* @__PURE__ */ React15.createElement("div", null, (_b = searchableElement.alias) != null ? _b : searchableElement.name), /* @__PURE__ */ React15.createElement("small", null, small)));
}

// src/controllers/NewRelationshipController.ts
var NewRelationshipController = class extends import_obsidian2.FuzzySuggestModal {
  constructor(_app, _api, _element, _campaignPath, _typeLimit, _callback, _params) {
    super(_app);
    this._app = _app;
    this._api = _api;
    this._element = _element;
    this._campaignPath = _campaignPath;
    this._typeLimit = _typeLimit;
    this._callback = _callback;
    this._params = _params;
  }
  getSuggestions(query) {
    const response = super.getSuggestions(query);
    if (response.length === 0) {
      const searchableElement = {
        name: query,
        path: "",
        type: "campaign" /* Campaign */
      };
      response.push({ item: searchableElement, match: { score: 1, matches: [] } });
    }
    return response;
  }
  getItems() {
    var _a, _b;
    let allCampaignElements;
    if (!((_a = this._element) == null ? void 0 : _a.campaign) && !this._campaignPath) {
      allCampaignElements = this._api.get(void 0, null);
    } else {
      if (this._element !== void 0) {
        allCampaignElements = this._api.get(void 0, (_b = this._element.campaign) != null ? _b : this._element);
      } else if (this._campaignPath !== void 0) {
        const campaign = this._api.get(this._campaignPath);
        allCampaignElements = this._api.get(void 0, campaign);
      }
      const globalElements = this._api.get();
      allCampaignElements = allCampaignElements.concat(globalElements);
    }
    if (this._typeLimit) {
      allCampaignElements = allCampaignElements.filter((element4) => {
        var _a2;
        return (_a2 = this._typeLimit) == null ? void 0 : _a2.includes(element4.type);
      });
    }
    const relatedPaths = this._element ? this._element.relationships.map((relationship) => relationship.path) : [];
    const elementResponse = allCampaignElements.filter((element4) => {
      var _a2;
      return this._callback || !relatedPaths.includes(element4.path) && element4.path !== ((_a2 = this._element) == null ? void 0 : _a2.path) && element4.type !== "campaign" /* Campaign */;
    });
    const response = [];
    elementResponse.forEach((element4) => {
      var _a2, _b2, _c;
      const searchableElement = {
        name: element4.name,
        path: element4.path,
        type: element4.type,
        image: (_a2 = element4.images[0]) != null ? _a2 : void 0,
        campaignName: (_c = (_b2 = element4.campaign) == null ? void 0 : _b2.name) != null ? _c : void 0
      };
      response.push(searchableElement);
      if (element4.aliases !== void 0 && Array.isArray(element4.aliases) && element4.aliases.length > 0) {
        element4.aliases.forEach((alias) => {
          var _a3, _b3, _c2;
          const searchableElementAlias = {
            name: element4.name,
            path: element4.path,
            type: element4.type,
            alias,
            image: (_a3 = element4.images[0]) != null ? _a3 : void 0,
            campaignName: (_c2 = (_b3 = element4.campaign) == null ? void 0 : _b3.name) != null ? _c2 : void 0
          };
          response.push(searchableElementAlias);
        });
      }
    });
    if (this._element !== void 0 || this._campaignPath !== void 0)
      response.push({
        name: "All player characters",
        path: "all-player-characters",
        type: "playercharacter" /* PlayerCharacter */
      });
    return response;
  }
  getItemText(element4) {
    return element4.alias || (element4.name ? `${element4.name} ${element4.type}` : void 0) || element4.type || element4.path;
  }
  renderSuggestion(item, el) {
    const root3 = (0, import_client.createRoot)(el);
    let reactComponent;
    if (item.item.path === "") {
      reactComponent = (0, import_react13.createElement)(FuzzyNewElementComponent, {
        name: item.item.name
      });
    } else {
      reactComponent = (0, import_react13.createElement)(FuzzySearchResult, {
        searchableElement: item.item,
        hasCampaign: this._element !== void 0 || this._campaignPath !== void 0
      });
    }
    root3.render(reactComponent);
  }
  onChooseItem(found, evt) {
    return __async(this, null, function* () {
      var _a;
      if (found.path === "") {
        yield this._app.vault.create(found.name + ".md", "");
        if (this._callback) {
          this._callback("[[" + found.name + ".md|" + found.name + "]]", this._params);
        }
        return;
      }
      if (this._callback) {
        const foundElement = this._api.get(found.path);
        const alias = "|" + ((_a = found == null ? void 0 : found.alias) != null ? _a : foundElement.name);
        const response = "[[" + foundElement.path + alias + "]]";
        this._callback(response, this._params);
      } else if (this._element) {
        const rpgmCodeblock = new RpgManagerCodeblockService(this._app, this._api, this._element.file);
        if (found.path === "all-player-characters") {
          const allPlayerCharacters = this._api.get(void 0, this._element.campaign, "playercharacter" /* PlayerCharacter */);
          if (allPlayerCharacters.length === 0)
            return;
          const relationships = allPlayerCharacters.map((playerCharacter) => {
            return RelationshipFactory.createFromContent("bidirectional" /* Bidirectional */, playerCharacter.path);
          });
          rpgmCodeblock.addRelationships(relationships);
        } else {
          const relationship = RelationshipFactory.createFromContent("bidirectional" /* Bidirectional */, found.path);
          rpgmCodeblock.addRelationship(relationship);
        }
      }
    });
  }
};

// src/components/attributes/primitives/TextInputComponent.tsx
function TextInputComponent({
  initialValue,
  campaignPath,
  className,
  onChange: onChange2,
  onBlur,
  placeholder: placeholder2
}) {
  const api2 = useApi();
  const app = useApp();
  const [value, setValue] = React16.useState(initialValue || "");
  const inputTextRef = React16.useRef(null);
  const previousValueRef = React16.useRef(value);
  const lastDetectedPositionRef = React16.useRef(null);
  const shadowSpanRef = React16.useRef(null);
  React16.useEffect(() => {
    var _a;
    (_a = inputTextRef.current) == null ? void 0 : _a.focus();
  }, []);
  const handleNewRelationship = () => {
    const relationshipModal = new NewRelationshipController(app, api2, void 0, campaignPath, void 0, replaceSequenceWithModalValue);
    relationshipModal.open();
  };
  const replaceSequenceWithModalValue = (replacementString) => {
    if (lastDetectedPositionRef.current !== null && inputTextRef.current) {
      const startPos = lastDetectedPositionRef.current;
      const nextChar = inputTextRef.current.value.charAt(startPos + 2) || "END_OF_STRING";
      const specialCharacters = [" ", ",", ";", ":", "!", ".", "?", "-"];
      const shouldAppendSpace = !specialCharacters.includes(nextChar) || nextChar === "END_OF_STRING";
      const appendedReplacement = shouldAppendSpace ? replacementString + " " : replacementString;
      setValue((prev) => prev.substring(0, startPos) + appendedReplacement + prev.substring(startPos + 2));
      onChange2(value.substring(0, startPos) + appendedReplacement + value.substring(startPos + 2));
      setTimeout(() => {
        if (inputTextRef.current && shadowSpanRef.current) {
          const newCursorPos = startPos + appendedReplacement.length;
          inputTextRef.current.selectionStart = newCursorPos;
          inputTextRef.current.selectionEnd = newCursorPos;
          shadowSpanRef.current.textContent = inputTextRef.current.value.substring(0, newCursorPos);
          const cursorPixelPos = shadowSpanRef.current.offsetWidth;
          inputTextRef.current.scrollLeft = cursorPixelPos - inputTextRef.current.offsetWidth / 2;
        }
      }, 0);
      lastDetectedPositionRef.current = null;
    }
  };
  const updateValue = (event) => {
    const currentValue = event.target.value;
    const position6 = event.target.selectionStart;
    const lastTwoChars = currentValue.slice(position6 - 2, position6);
    if (lastTwoChars === "[[") {
      lastDetectedPositionRef.current = position6 - 2;
      handleNewRelationship();
    }
    setValue(currentValue);
    onChange2(currentValue);
    previousValueRef.current = currentValue;
  };
  const handleKeyDown = (event) => {
    const { selectionStart, selectionEnd } = inputTextRef.current;
    if (selectionStart === selectionEnd)
      return;
    if ((event.metaKey || event.ctrlKey) && (event.key === "b" || event.key === "i")) {
      if (event.key === "b") {
        const end4 = inputTextRef.current.selectionEnd;
        inputTextRef.current.value = inputTextRef.current.value.substring(0, inputTextRef.current.selectionStart) + "**" + inputTextRef.current.value.substring(inputTextRef.current.selectionStart, inputTextRef.current.selectionEnd) + "**" + inputTextRef.current.value.substring(inputTextRef.current.selectionEnd);
        inputTextRef.current.selectionStart = end4 + 5;
        inputTextRef.current.selectionEnd = end4 + 5;
      }
      if (event.key === "i") {
        const end4 = inputTextRef.current.selectionEnd;
        inputTextRef.current.value = inputTextRef.current.value.substring(0, inputTextRef.current.selectionStart) + "*" + inputTextRef.current.value.substring(inputTextRef.current.selectionStart, inputTextRef.current.selectionEnd) + "*" + inputTextRef.current.value.substring(inputTextRef.current.selectionEnd);
        inputTextRef.current.selectionStart = end4 + 2;
        inputTextRef.current.selectionEnd = end4 + 2;
      }
      setValue(inputTextRef.current.value);
    }
  };
  return /* @__PURE__ */ React16.createElement(React16.Fragment, null, /* @__PURE__ */ React16.createElement("span", {
    ref: shadowSpanRef,
    className: "absolute top-[-9999px] left-[-9999px] whitespace-pre"
  }), /* @__PURE__ */ React16.createElement("input", {
    ref: inputTextRef,
    type: "text",
    className: className != null ? className : "",
    value,
    onKeyDown: handleKeyDown,
    onChange: (event) => {
      updateValue(event);
    },
    onBlur: () => {
      onBlur && onBlur(value);
    },
    placeholder: placeholder2
  }));
}

// src/components/attributes/types/DefaultAttributeTypeComponent.tsx
function DefaultAttributeTypeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!attribute.isSet)
    return null;
  const [value, setValue] = React17.useState((_a = attribute.value) != null ? _a : "");
  const [editing, setEditing] = React17.useState(false);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function reset() {
    var _a2;
    setValue((_a2 = attribute.value) != null ? _a2 : "");
    setEditing(false);
  }
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      setEditing(false);
    });
  }
  function saveAttribute(newValue) {
    if (newValue === void 0) {
      setEditing(false);
      return;
    }
    codeblockService.updateCodeblockData(attribute.id, newValue).then(() => {
      setEditing(false);
    });
  }
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React17.createElement("div", {
      className: "grid grid-cols-1"
    }, /* @__PURE__ */ React17.createElement("div", null, /* @__PURE__ */ React17.createElement(TextInputComponent, {
      initialValue: attribute.value,
      campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath,
      onChange: setValue,
      className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
    })), /* @__PURE__ */ React17.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React17.createElement("button", {
      className: "rpgm-danger",
      onClick: removeAttribute
    }, t2("buttons.delete")), /* @__PURE__ */ React17.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React17.createElement("button", {
      className: "rpgm-primary",
      onClick: () => saveAttribute(value)
    }, t2("buttons.save"))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React17.createElement("div", {
      onClick: () => setEditing(!editing),
      className: "border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-text"
    }, /* @__PURE__ */ React17.createElement(MarkdownComponent, {
      value: attribute.value
    }));
  } else {
    content3 = /* @__PURE__ */ React17.createElement("div", null, /* @__PURE__ */ React17.createElement(MarkdownComponent, {
      value: attribute.value
    }));
  }
  return /* @__PURE__ */ React17.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React17.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React17.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/LinkAttributeComponent.tsx
var React18 = __toESM(require_react());
function LinkAttributeTypeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!attribute.isSet)
    return null;
  const [value, setValue] = React18.useState(attribute.value);
  const [editing, setEditing] = React18.useState(false);
  const inputTextRef = React18.useRef(null);
  React18.useEffect(() => {
    var _a;
    (_a = inputTextRef.current) == null ? void 0 : _a.focus();
  }, []);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function reset() {
    var _a;
    setValue((_a = attribute.value) != null ? _a : "");
    setEditing(false);
  }
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      setEditing(false);
    });
  }
  function saveAttribute(newValue) {
    if (newValue === void 0) {
      setEditing(false);
      return;
    }
    codeblockService.updateCodeblockData(attribute.id, newValue).then(() => {
      setEditing(false);
    });
  }
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React18.createElement("div", {
      className: "grid grid-cols-1"
    }, /* @__PURE__ */ React18.createElement("div", null, /* @__PURE__ */ React18.createElement("input", {
      ref: inputTextRef,
      type: "text",
      defaultValue: attribute.value,
      onChange: (e2) => setValue(e2.target.value),
      className: "w-32 resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
    })), /* @__PURE__ */ React18.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React18.createElement("button", {
      className: "rpgm-danger",
      onClick: removeAttribute
    }, t2("buttons.delete")), /* @__PURE__ */ React18.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React18.createElement("button", {
      className: "rpgm-primary",
      onClick: () => saveAttribute(value)
    }, t2("buttons.save"))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React18.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React18.createElement("div", null, /* @__PURE__ */ React18.createElement("a", {
      href: attribute.value
    }, t2("link"))), /* @__PURE__ */ React18.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React18.createElement("button", {
      className: "rpgm-secondary",
      onClick: () => setEditing(!editing)
    }, t2("buttons.edit"))));
  } else {
    content3 = /* @__PURE__ */ React18.createElement("div", null, /* @__PURE__ */ React18.createElement("a", {
      href: attribute.value
    }, t2("link")));
  }
  return /* @__PURE__ */ React18.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React18.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React18.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/editors/MarkdownEditorComponent.tsx
var import_state2 = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian3 = require("obsidian");
var React19 = __toESM(require_react());
function MarkdownEditorComponent({
  initialValue,
  campaignPath,
  className,
  onChange: onChange2,
  onBlur,
  forceFocus
}) {
  const app = useApp();
  const api2 = useApi();
  const parentDivRef = React19.useRef(null);
  const [value, setValue] = React19.useState(initialValue || "");
  const editorViewRef = React19.useRef(null);
  const lastDetectedPositionRef = React19.useRef(null);
  const [scope, setScope] = React19.useState(void 0);
  const [originalScope] = React19.useState(app.scope);
  const [showRelatioshipModal, setShowRelationshipModal] = React19.useState(false);
  const contentChangeExtension = import_state2.EditorState.changeFilter.of((change) => {
    const newContent = change.state.doc.toString();
    setValue(newContent);
    if (onChange2)
      onChange2(newContent);
    return true;
  });
  const handleBlur = () => {
    if (onBlur && !showRelatioshipModal)
      onBlur(value);
  };
  const handleNewRelationship = () => {
    const relationshipModal = new NewRelationshipController(app, api2, void 0, campaignPath, void 0, replaceSequenceWithModalValue);
    relationshipModal.open();
  };
  const replaceSequenceWithModalValue = (replacementString) => {
    if (editorViewRef.current && lastDetectedPositionRef.current !== null) {
      const startPos = lastDetectedPositionRef.current;
      const editorView = editorViewRef.current;
      const nextChar = editorView.state.doc.sliceString(startPos + 1, startPos + 2).toString() || "END_OF_STRING";
      let toPosition = startPos + 2;
      const specialCharacters = [" ", ",", ";", ":", "!", ".", "?", "-"];
      if (!specialCharacters.includes(nextChar) || nextChar === "END_OF_STRING") {
        replacementString += " ";
      } else {
        toPosition -= 1;
      }
      if (nextChar === "\n")
        toPosition -= 1;
      toPosition = Math.min(toPosition, editorView.state.doc.length);
      const tr = editorView.state.update({
        changes: { from: startPos, to: toPosition, insert: replacementString }
      });
      editorView.dispatch(tr);
      const endPos = Math.min(startPos + replacementString.length, editorView.state.doc.length);
      editorView.dispatch({
        selection: { anchor: endPos, head: endPos },
        scrollIntoView: true
      });
      lastDetectedPositionRef.current = null;
      setShowRelationshipModal(false);
    }
  };
  const doubleBracketKeyBinding = import_view.keymap.of([
    {
      key: "[",
      run: (view) => {
        setShowRelationshipModal(true);
        const cursorPos = view.state.selection.main.head;
        const beforeCursorChar = view.state.doc.sliceString(cursorPos - 1, cursorPos);
        if (beforeCursorChar === "[") {
          lastDetectedPositionRef.current = cursorPos - 1;
          handleNewRelationship();
          return true;
        }
        return false;
      }
    }
  ]);
  const initializeEditor = () => __async(this, null, function* () {
    if (parentDivRef.current) {
      const localScope = new import_obsidian3.Scope(app.scope);
      localScope.register(["Mod"], "b", (evt) => {
        evt.preventDefault();
        applyBold(editorViewRef.current);
      });
      localScope.register(["Mod"], "i", (evt) => {
        evt.preventDefault();
        applyItalic(editorViewRef.current);
      });
      app.keymap.pushScope(localScope);
      setScope(localScope);
      const view = new import_view.EditorView({
        state: import_state2.EditorState.create({
          doc: value,
          extensions: [inlinePlugin(), contentChangeExtension, doubleBracketKeyBinding]
        }),
        parent: parentDivRef.current
      });
      editorViewRef.current = view;
      if (forceFocus)
        view.focus();
    }
  });
  React19.useEffect(() => {
    initializeEditor();
    return () => {
      var _a;
      (_a = editorViewRef.current) == null ? void 0 : _a.destroy();
      if (scope !== void 0)
        app.keymap.popScope(scope);
      app.keymap.pushScope(originalScope);
    };
  }, []);
  return /* @__PURE__ */ React19.createElement("div", {
    id: "rpgm-editor",
    className: `border-[--text-accent] markdown-editor-component p-3 ${className}`,
    ref: parentDivRef,
    onBlur: handleBlur
  });
}
function inlinePlugin() {
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      __publicField(this, "decorations");
      this.decorations = this.inlineRender(view);
    }
    update(update2) {
      if (update2.docChanged || update2.selectionSet || update2.viewportChanged) {
        this.decorations = this.inlineRender(update2.view);
      }
    }
    inlineRender(view) {
      const decorations = findMarkdownElements(view.state.doc, view);
      const { from, to } = view.state.selection.main;
      return import_view.Decoration.set(decorations.filter((decoRange) => {
        const { from: decoFrom, to: decoTo } = decoRange;
        return to <= decoFrom || from >= decoTo;
      }));
    }
  }, { decorations: (v) => v.decorations });
}
var Widget = class extends import_view.WidgetType {
  constructor(_el) {
    super();
    this._el = _el;
  }
  toDOM(view) {
    return this._el;
  }
};
function nextMatch(doc, position6, patterns) {
  let closestMatch = null;
  let closestPattern = null;
  for (const pattern of patterns) {
    const regex = new RegExp(pattern.regex.source, "gm");
    regex.lastIndex = position6;
    const match3 = regex.exec(doc);
    if (match3 && (!closestMatch || match3.index < closestMatch.index)) {
      closestMatch = match3;
      closestPattern = pattern;
    }
  }
  if (closestMatch && closestPattern) {
    return {
      match: closestMatch,
      pattern: closestPattern
    };
  }
  return null;
}
function findMarkdownElements(doc, view) {
  const patterns = [
    {
      regex: /^(#{1})\s+(.+?)(?=\n|$)/gm,
      renderWidget: (match3, view2) => renderHeading(match3, view2, 1)
    },
    {
      regex: /^(#{2})\s+(.+?)(?=\n|$)/gm,
      renderWidget: (match3, view2) => renderHeading(match3, view2, 2)
    },
    {
      regex: /^(#{3})\s+(.+?)(?=\n|$)/gm,
      renderWidget: (match3, view2) => renderHeading(match3, view2, 3)
    },
    {
      regex: /\*\*((?!\*).+?)\*\*/,
      renderWidget: (match3, view2) => renderBold(match3, view2)
    },
    {
      regex: /\*([^*]+?)\*(?!\*)/,
      renderWidget: (match3, view2) => renderItalic(match3, view2)
    },
    {
      regex: /_([^_]+?)_(?!_)/,
      renderWidget: (match3, view2) => renderItalic(match3, view2)
    },
    {
      regex: /\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g,
      renderWidget: (match3, view2) => renderLink(match3, view2)
    }
  ];
  const decorations = [];
  const text6 = doc.toString().trim();
  let position6 = 0;
  while (position6 < text6.length) {
    const next = nextMatch(text6, position6, patterns);
    if (next) {
      const { match: match3, pattern } = next;
      const start3 = match3.index;
      const end4 = start3 + match3[0].length;
      if (!isCursorInsideRange(view.state.selection, start3, end4)) {
        const deco = pattern.renderWidget(match3, view);
        decorations.push(deco);
      }
      position6 = end4;
    } else {
      position6 = text6.length;
    }
  }
  return decorations;
}
function isCursorInsideRange(selection, start3, end4) {
  if (selection.ranges[0].from === 0 && selection.ranges[0].from === selection.ranges[0].to)
    return false;
  for (const range of selection.ranges) {
    if (range.from <= end4 && range.to >= start3) {
      return true;
    }
  }
  return false;
}
function renderBold(match3, view) {
  const el = document.createElement("strong");
  el.textContent = match3[1];
  return import_view.Decoration.replace({ widget: new Widget(el) }).range(match3.index, match3.index + match3[0].length);
}
function renderItalic(match3, view) {
  const el = document.createElement("em");
  el.textContent = match3[1];
  return import_view.Decoration.replace({ widget: new Widget(el) }).range(match3.index, match3.index + match3[0].length);
}
function renderHeading(match3, view, headingLevel) {
  const el = document.createElement("h" + headingLevel);
  el.textContent = match3[2];
  el.className = "!-mt-1 !-mb-5";
  const endOffset = match3[0].endsWith("\n") ? match3.index + match3[0].length - 1 : match3.index + match3[0].length;
  return import_view.Decoration.replace({ widget: new Widget(el) }).range(match3.index, endOffset);
}
function renderLink(match3, view) {
  const el = document.createElement("a");
  const linkTarget = match3[1];
  const linkText = match3[2] || linkTarget;
  el.setAttribute("href", linkTarget);
  el.textContent = linkText;
  el.className = "internal-link !no-underline";
  return import_view.Decoration.replace({ widget: new Widget(el) }).range(match3.index, match3.index + match3[0].length);
}
function applyBold(view) {
  const { from, to } = view.state.selection.main;
  const changes = [
    { from, insert: "**" },
    { from: to, insert: "**" }
  ];
  const tr = view.state.update({
    changes,
    selection: { anchor: from, head: to + 4 }
  });
  view.dispatch(tr);
}
function applyItalic(view) {
  const { from, to } = view.state.selection.main;
  const changes = [
    { from, insert: "*" },
    { from: to, insert: "*" }
  ];
  const tr = view.state.update({
    changes,
    selection: { anchor: from, head: to + 2 }
  });
  view.dispatch(tr);
}

// src/components/attributes/types/LongTextAttributeComponent.tsx
var React20 = __toESM(require_react());
function LongTextAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!attribute.isSet)
    return null;
  const [value, setValue] = React20.useState((_a = attribute.value) != null ? _a : "");
  const [editing, setEditing] = React20.useState(false);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function reset() {
    var _a2;
    setValue((_a2 = attribute.value) != null ? _a2 : "");
    setEditing(false);
  }
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      setEditing(false);
    });
  }
  function saveAttribute(newValue) {
    if (newValue === void 0) {
      setEditing(false);
      return;
    }
    codeblockService.updateCodeblockData(attribute.id, newValue).then(() => {
      setEditing(false);
    });
  }
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React20.createElement("div", {
      className: "grid grid-cols-1"
    }, /* @__PURE__ */ React20.createElement("div", null, /* @__PURE__ */ React20.createElement(MarkdownEditorComponent, {
      initialValue: attribute.value,
      campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath,
      onChange: setValue,
      className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
    })), /* @__PURE__ */ React20.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React20.createElement("button", {
      className: "rpgm-danger",
      onClick: removeAttribute
    }, t2("buttons.delete")), /* @__PURE__ */ React20.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React20.createElement("button", {
      className: "rpgm-primary",
      onClick: () => saveAttribute(value)
    }, t2("buttons.save"))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React20.createElement("div", {
      onClick: () => setEditing(!editing),
      className: "border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-text"
    }, /* @__PURE__ */ React20.createElement(MarkdownComponent, {
      value: attribute.value
    }));
  } else {
    content3 = /* @__PURE__ */ React20.createElement("div", null, /* @__PURE__ */ React20.createElement(MarkdownComponent, {
      value: attribute.value
    }));
  }
  return /* @__PURE__ */ React20.createElement(React20.Fragment, null, /* @__PURE__ */ React20.createElement(AttributeTitleComponent, {
    attribute
  }), content3);
}

// src/components/attributes/types/MajorCluesAttributeComponent.tsx
var React21 = __toESM(require_react());

// src/services/HelperService.ts
var HelperService = class {
  static extractPath(input) {
    const regex = /\[\[(.*?)(?:\|.*?)?\]\]/;
    const match3 = input.match(regex);
    if (match3 && match3[1]) {
      return match3[1];
    }
    return void 0;
  }
  static getPositionInParent(elements) {
    if (elements.length === 0)
      return 1;
    const highestPositionInParent = Math.max(...elements.map((element4) => element4.positionInParent));
    return highestPositionInParent + 1;
  }
};

// src/components/attributes/types/MajorCluesAttributeComponent.tsx
function MajorCluesEdit({
  element: element4,
  attribute
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const cluesData = attribute.value;
  const cl = cluesData.map((clueData) => {
    return {
      clue: clueData.clue ? api2.get(HelperService.extractPath(clueData.clue)) : void 0,
      description: clueData.description,
      destination: clueData.destination ? api2.get(HelperService.extractPath(clueData.destination)) : void 0
    };
  });
  const [clues, setClues] = React21.useState(cl);
  const handleSave = () => {
    const value = [];
    clues.forEach((clue) => {
      value.push({
        clue: "[[" + clue.clue.path + "]]",
        description: clue.description,
        destination: clue.destination ? "[[" + clue.destination.path + "]]" : ""
      });
    });
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData(attribute.id, value);
  };
  const handleReplaceClue = (value, params) => {
    if (params.clue === void 0)
      return;
    const newClue = api2.get(HelperService.extractPath(value));
    setClues(clues.map((currentClue) => {
      if (currentClue.clue.path === params.clue)
        currentClue.clue = newClue;
      return currentClue;
    }));
  };
  const handleAddClue = (value) => {
    const clue = api2.get(HelperService.extractPath(value));
    setClues([...clues, { clue, description: "", destination: void 0 }]);
  };
  const handleReplaceDestination = (value, params) => {
    if (params.clue === void 0)
      return;
    const destination = api2.get(HelperService.extractPath(value));
    setClues(clues.map((currentClue) => {
      if (currentClue.clue.path === params.clue)
        currentClue.destination = destination;
      return currentClue;
    }));
  };
  const handleSearchClue = (type2, clue) => {
    const searcher = new NewRelationshipController(app, api2, element4, void 0, ["clue" /* Clue */], type2 === "add" ? handleAddClue : handleReplaceClue, clue ? { clue: clue.clue.path } : void 0);
    searcher.open();
  };
  const handleSearchDestination = (clue) => {
    const searcher = new NewRelationshipController(app, api2, element4, void 0, void 0, handleReplaceDestination, {
      clue: clue.clue.path
    });
    searcher.open();
  };
  const handleDeleteClue = (clue) => {
    setClues(clues.filter((currentClue) => currentClue.clue.path !== clue.clue.path));
  };
  return /* @__PURE__ */ React21.createElement("div", {
    className: "w-full p-3 border border-[--background-modifier-border] rounded-lg"
  }, /* @__PURE__ */ React21.createElement(MajorClueHeader, {
    isEditing: true
  }), /* @__PURE__ */ React21.createElement("div", {
    className: "w-full"
  }, clues.map((clue, index2) => /* @__PURE__ */ React21.createElement("div", {
    key: index2,
    className: "grid grid-cols-6 border-b border-b[--background-modifier-border] pt-2 pb-2 pr-1 group"
  }, /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-1"
  }, /* @__PURE__ */ React21.createElement("a", {
    href: clue.clue.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, clue.clue.name), " (", /* @__PURE__ */ React21.createElement("span", {
    className: "!no-underline cursor-pointer hover:text-[--text-accent-hover]",
    onClick: () => handleSearchClue("replace", clue)
  }, t2("buttons.replace")), ")"), /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-3 pr-1"
  }, /* @__PURE__ */ React21.createElement(TextInputComponent, {
    initialValue: clue.description,
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaign.path,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md",
    onChange: (value) => {
      setClues(clues.map((currentClue) => {
        if (currentClue.clue.path === clue.clue.path)
          currentClue.description = value;
        return currentClue;
      }));
    }
  })), /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-1 pr-1"
  }, clue.destination ? /* @__PURE__ */ React21.createElement(React21.Fragment, null, /* @__PURE__ */ React21.createElement("a", {
    href: clue.destination.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, clue.destination.name), " (", /* @__PURE__ */ React21.createElement("span", {
    className: "!no-underline cursor-pointer hover:text-[--text-accent-hover]",
    onClick: () => handleSearchDestination(clue)
  }, t2("buttons.replace")), ")") : /* @__PURE__ */ React21.createElement("span", {
    className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]",
    onClick: () => handleSearchDestination(clue)
  }, t2("buttons.adddestination"))), /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-1 flex justify-end"
  }, /* @__PURE__ */ React21.createElement("button", {
    className: "rpgm-danger opacity-0 group-hover:opacity-100",
    onClick: () => handleDeleteClue(clue)
  }, t2("buttons.delete"))))), /* @__PURE__ */ React21.createElement("div", {
    className: "grid grid-cols-5 border-b border-b[--background-modifier-border] pt-2 pb-2"
  }, /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-1"
  }, /* @__PURE__ */ React21.createElement("span", {
    className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]",
    onClick: () => handleSearchClue("add")
  }, t2("create.add", { context: "clue" }))), /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-3"
  }), /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-1"
  })), /* @__PURE__ */ React21.createElement("div", {
    className: "flex justify-end mt-3"
  }, /* @__PURE__ */ React21.createElement("button", {
    className: "rpgm-primary",
    onClick: handleSave
  }, t2("buttons.save")))));
}
function MajorCluesView({ attribute, edit }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React21.createElement("div", {
    className: "w-full p-3 border border-[--background-modifier-border] rounded-lg hover:bg-[--background-secondary] cursor-pointer"
  }, /* @__PURE__ */ React21.createElement(MajorCluesBrowse, {
    attribute
  }), /* @__PURE__ */ React21.createElement("div", {
    className: "w-full flex justify-end mt-3"
  }, /* @__PURE__ */ React21.createElement("button", {
    className: "rpgm-secondary",
    onClick: edit
  }, t2("buttons.edit"))));
}
function MajorCluesBrowse({ attribute }) {
  if (!attribute.isSet)
    return /* @__PURE__ */ React21.createElement(React21.Fragment, null);
  const api2 = useApi();
  const cluesData = attribute.value;
  const clues = cluesData.map((clueData) => {
    return {
      clue: clueData.clue ? api2.get(extractPath(clueData.clue)) : void 0,
      description: clueData.description,
      destination: clueData.destination ? api2.get(extractPath(clueData.destination)) : void 0
    };
  });
  function extractPath(input) {
    const regex = /\[\[(.*?)(?:\|.*?)?\]\]/;
    const match3 = input.match(regex);
    if (match3 && match3[1]) {
      return match3[1];
    }
    return void 0;
  }
  return /* @__PURE__ */ React21.createElement("div", {
    className: "w-full"
  }, /* @__PURE__ */ React21.createElement(MajorClueHeader, {
    isEditing: false
  }), clues.map((clue, index2) => /* @__PURE__ */ React21.createElement("div", {
    key: index2,
    className: "grid grid-cols-5 border-b border-b-[--background-modifier-border] pt-1 pb-1"
  }, /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-1 pr-1"
  }, clue.clue && /* @__PURE__ */ React21.createElement("a", {
    href: clue.clue.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, clue.clue.name)), /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-3 pr-1"
  }, /* @__PURE__ */ React21.createElement(MarkdownComponent, {
    value: clue.description
  })), /* @__PURE__ */ React21.createElement("div", {
    className: "col-span-1"
  }, clue.destination && /* @__PURE__ */ React21.createElement("a", {
    href: clue.destination.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, clue.destination.name)))));
}
function MajorClueHeader({ isEditing }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React21.createElement("div", {
    className: `grid ${isEditing ? "grid-cols-6" : "grid-cols-5"} border-b border-b-[--background-modifier-border] mb-2 pb-2`
  }, /* @__PURE__ */ React21.createElement("div", {
    className: "text-xs !text-[--text-faint] col-span-1 pr-1"
  }, t2("elements.clue", { count: 1 })), /* @__PURE__ */ React21.createElement("div", {
    className: "text-xs !text-[--text-faint] col-span-3 pr-1"
  }, t2("clues.description")), /* @__PURE__ */ React21.createElement("div", {
    className: `text-xs !text-[--text-faint] ${isEditing ? "col-span-2" : "col-span-1"}`
  }, t2("clues.destination")));
}
function MajorCluesAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const [editing, setEditing] = React21.useState(false);
  const handleEdit = () => {
    setEditing(true);
  };
  return /* @__PURE__ */ React21.createElement(React21.Fragment, null, /* @__PURE__ */ React21.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React21.createElement("div", null, editing ? /* @__PURE__ */ React21.createElement(MajorCluesEdit, {
    element: element4,
    attribute
  }) : isEditable ? /* @__PURE__ */ React21.createElement(MajorCluesView, {
    attribute,
    edit: handleEdit
  }) : /* @__PURE__ */ React21.createElement(MajorCluesBrowse, {
    attribute
  })));
}

// src/components/attributes/types/MapAttributeComponent.tsx
var React22 = __toESM(require_react());
var import_react_simple_maps = __toESM(require_index_umd());
function MapAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const containerRef = React22.useRef(null);
  const [editing, setEditing] = React22.useState(false);
  const [attributeValue, setAttributeValue] = React22.useState(attribute.value);
  const [isTooltipVisible, setIsTooltipVisible] = React22.useState(false);
  const [tooltipContent, setTooltipContent] = React22.useState("");
  const [tooltipX, setTooltipX] = React22.useState(0);
  const [tooltipY, setTooltipY] = React22.useState(0);
  const renderTooltip = () => {
    if (!isTooltipVisible)
      return null;
    return /* @__PURE__ */ React22.createElement("div", {
      style: {
        position: "absolute",
        top: tooltipY,
        left: tooltipX,
        background: "white",
        padding: "5px",
        border: "1px solid black",
        borderRadius: "3px",
        transform: "translate(-50%, -100%)",
        pointerEvents: "none"
      }
    }, tooltipContent);
  };
  const [latitude, longitude] = (attribute == null ? void 0 : attribute.value) ? attribute.value.split(",") : [0, 0];
  const allLocations = api2.get(void 0, element4.campaign).filter((otherElement) => {
    var _a;
    return ((_a = otherElement.attribute("location" /* Location */)) == null ? void 0 : _a.value) !== void 0 && otherElement.path !== element4.path;
  });
  function handleLinkClick(element5) {
    return __async(this, null, function* () {
      app.workspace.openLinkText(element5.path, "", false);
    });
  }
  function removeAttribute() {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      setEditing(false);
    });
  }
  function saveAttribute() {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData(attribute.id, attributeValue).then(() => {
      setEditing(false);
    });
  }
  const map = /* @__PURE__ */ React22.createElement(import_react_simple_maps.ComposableMap, {
    projection: "geoMercator",
    projectionConfig: {
      scale: 1e3
    }
  }, /* @__PURE__ */ React22.createElement(import_react_simple_maps.ZoomableGroup, {
    center: [longitude, latitude],
    zoom: 2
  }, /* @__PURE__ */ React22.createElement(import_react_simple_maps.Geographies, {
    geography: "https://raw.githubusercontent.com/deldersveld/topojson/master/world-countries.json",
    fill: "#D6D6DA",
    stroke: "#FFFFFF",
    strokeWidth: 0.5
  }, ({ geographies }) => geographies.map((geo) => /* @__PURE__ */ React22.createElement(import_react_simple_maps.Geography, {
    key: geo.rsmKey,
    geography: geo
  }))), /* @__PURE__ */ React22.createElement(import_react_simple_maps.Marker, {
    key: element4.path,
    coordinates: [longitude, latitude]
  }, /* @__PURE__ */ React22.createElement("circle", {
    r: 3,
    fill: "#FF5533"
  })), allLocations.map((location3) => {
    var _a, _b, _c;
    const [latitude2, longitude2] = (_c = (_b = (_a = location3.attribute("location" /* Location */)) == null ? void 0 : _a.value) == null ? void 0 : _b.split(",")) != null ? _c : [0, 0];
    return /* @__PURE__ */ React22.createElement(import_react_simple_maps.Marker, {
      key: location3.path,
      coordinates: [longitude2, latitude2],
      className: "hover:cursor-pointer",
      onClick: () => handleLinkClick(location3),
      onMouseEnter: (e2) => {
        const { top, left } = containerRef.current.getBoundingClientRect();
        const x = e2.clientX - left;
        const y = e2.clientY - top;
        setTooltipX(x);
        setTooltipY(y);
        setIsTooltipVisible(true);
        setTooltipContent(location3.name);
      },
      onMouseLeave: () => {
        setIsTooltipVisible(false);
      }
    }, /* @__PURE__ */ React22.createElement("circle", {
      r: 3,
      fill: "#5533ff"
    }));
  })));
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React22.createElement("div", null, /* @__PURE__ */ React22.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-4"
    }, /* @__PURE__ */ React22.createElement("div", {
      className: "!font-bold col-span-1"
    }, t2("attributes.coordinates")), /* @__PURE__ */ React22.createElement("div", {
      className: "col-span-3 pl-0 lg:pl-3"
    }, /* @__PURE__ */ React22.createElement("div", null, /* @__PURE__ */ React22.createElement("input", {
      type: "text",
      defaultValue: attribute.value,
      onChange: (e2) => setAttributeValue(e2.target.value),
      className: "!pl-2 !pr-4"
    })), /* @__PURE__ */ React22.createElement("div", {
      className: "flex mt-3"
    }, /* @__PURE__ */ React22.createElement("button", {
      className: "rpgm-danger !ml-0",
      onClick: removeAttribute
    }, t2("buttons.delete")), /* @__PURE__ */ React22.createElement("button", {
      className: "rpgm-secondary",
      onClick: () => setEditing(false)
    }, t2("buttons.cancel")), /* @__PURE__ */ React22.createElement("button", {
      className: "rpgm-primary",
      onClick: saveAttribute
    }, t2("buttons.save"))))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React22.createElement("div", null, /* @__PURE__ */ React22.createElement("div", null, map), /* @__PURE__ */ React22.createElement("div", {
      className: "flex justify-end ml-3 mt-3"
    }, /* @__PURE__ */ React22.createElement("button", {
      className: "rpgm-secondary",
      onClick: () => setEditing(true)
    }, t2("buttons.edit"))));
  } else {
    content3 = map;
  }
  return /* @__PURE__ */ React22.createElement("div", {
    ref: containerRef
  }, renderTooltip(), content3);
}

// src/components/attributes/types/NonPlayerCharacterTypeAttributeComponent.tsx
var React23 = __toESM(require_react());

// src/data/enums/NonPlayerCharacterType.ts
var NonPlayerCharacterType = /* @__PURE__ */ ((NonPlayerCharacterType2) => {
  NonPlayerCharacterType2["Main"] = "main";
  NonPlayerCharacterType2["Supporting"] = "supporting";
  NonPlayerCharacterType2["Extra"] = "extra";
  return NonPlayerCharacterType2;
})(NonPlayerCharacterType || {});

// src/components/attributes/types/NonPlayerCharacterTypeAttributeComponent.tsx
function NonPlayerCharacterTypeAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  if (!attribute.isSet)
    return null;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const value = attribute.value;
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  }
  const saveAttribute = (newValue) => {
    if (newValue === "") {
      codeblockService.updateCodeblockData(attribute.id, void 0);
      return;
    }
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React23.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React23.createElement("div", null, /* @__PURE__ */ React23.createElement("select", {
      defaultValue: attribute.value,
      onChange: (e2) => saveAttribute(e2.target.value),
      className: "!pl-2 !pr-4"
    }, /* @__PURE__ */ React23.createElement("option", {
      value: ""
    }), Object.entries(NonPlayerCharacterType).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React23.createElement("option", {
      key,
      value: index2
    }, key)))), /* @__PURE__ */ React23.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React23.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: removeAttribute
    }, t2("buttons.delete"))));
  } else {
    content3 = /* @__PURE__ */ React23.createElement("div", null, Object.keys(NonPlayerCharacterType).find((key) => NonPlayerCharacterType[key] === value));
  }
  return /* @__PURE__ */ React23.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React23.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React23.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/NumberAttributeTypeComponent.tsx
var React24 = __toESM(require_react());
function NumberAttributeTypeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!attribute.isSet)
    return null;
  const [value, setValue] = React24.useState(attribute.value);
  const [editing, setEditing] = React24.useState(false);
  const inputTextRef = React24.useRef(null);
  React24.useEffect(() => {
    var _a;
    (_a = inputTextRef.current) == null ? void 0 : _a.focus();
  }, []);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function reset() {
    var _a;
    setValue((_a = attribute.value) != null ? _a : "");
    setEditing(false);
  }
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      setEditing(false);
    });
  }
  function saveAttribute(newValue) {
    if (newValue === void 0) {
      setEditing(false);
      return;
    }
    codeblockService.updateCodeblockData(attribute.id, newValue).then(() => {
      setEditing(false);
    });
  }
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React24.createElement("div", {
      className: "grid grid-cols-1"
    }, /* @__PURE__ */ React24.createElement("div", null, /* @__PURE__ */ React24.createElement("input", {
      ref: inputTextRef,
      type: "number",
      defaultValue: attribute.value,
      onChange: (e2) => setValue(e2.target.value ? +e2.target.value : void 0),
      className: "w-32 resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
    })), /* @__PURE__ */ React24.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React24.createElement("button", {
      className: "rpgm-danger",
      onClick: removeAttribute
    }, t2("buttons.delete")), /* @__PURE__ */ React24.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React24.createElement("button", {
      className: "rpgm-primary",
      onClick: () => saveAttribute(value)
    }, t2("buttons.save"))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React24.createElement("div", {
      onClick: () => setEditing(!editing),
      className: "border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-text"
    }, attribute.value);
  } else {
    content3 = /* @__PURE__ */ React24.createElement("div", null, attribute.value);
  }
  return /* @__PURE__ */ React24.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React24.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React24.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/PronounComponent.tsx
var React25 = __toESM(require_react());
function PronounComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  }
  const saveAttribute = (newValue) => {
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React25.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React25.createElement("div", null, /* @__PURE__ */ React25.createElement("select", {
      defaultValue: attribute.value,
      onChange: (e2) => saveAttribute(e2.target.value),
      className: "!pl-2 !pr-4"
    }, /* @__PURE__ */ React25.createElement("option", {
      value: ""
    }), /* @__PURE__ */ React25.createElement("option", {
      value: "they"
    }, "They / Them / Themself"), /* @__PURE__ */ React25.createElement("option", {
      value: "she"
    }, "She / Her / Herself"), /* @__PURE__ */ React25.createElement("option", {
      value: "st"
    }, "She / They / Themself"), /* @__PURE__ */ React25.createElement("option", {
      value: "he"
    }, "He / Him / Himself"), /* @__PURE__ */ React25.createElement("option", {
      value: "ht"
    }, "He / They / Themself"), /* @__PURE__ */ React25.createElement("option", {
      value: "it"
    }, "It / Its / Itself"), /* @__PURE__ */ React25.createElement("option", {
      value: "ae"
    }, "(f)Ae / (f)Aer / (f)Aerself"), /* @__PURE__ */ React25.createElement("option", {
      value: "e"
    }, "E(Ey) / Em / Eirelf"), /* @__PURE__ */ React25.createElement("option", {
      value: "per"
    }, "Per / Per / Perself"), /* @__PURE__ */ React25.createElement("option", {
      value: "ve"
    }, "Ve / Ver / Verself"), /* @__PURE__ */ React25.createElement("option", {
      value: "xe"
    }, 'Xe / Xem / Xemself"'), /* @__PURE__ */ React25.createElement("option", {
      value: "ze"
    }, "Ze(Zie) / Hir / Hirself"))), /* @__PURE__ */ React25.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React25.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: removeAttribute
    }, t2("buttons.delete"))));
  } else {
    let value = "";
    switch (attribute.value) {
      case "they":
        value = "They / Them / Themself";
        break;
      case "she":
        value = "She / Her / Herself";
        break;
      case "st":
        value = "She / They / Themself";
        break;
      case "he":
        value = "He / Him / Himself";
        break;
      case "ht":
        value = "He / They / Themself";
        break;
      case "it":
        value = "It / Its / Itself";
        break;
      case "ae":
        value = "(f)Ae / (f)Aer / (f)Aerself";
        break;
      case "e":
        value = "E(Ey) / Em / Eirelf";
        break;
      case "per":
        value = "Per / Per / Perself";
        break;
      case "ve":
        value = "Ve / Ver / Verself";
        break;
      case "xe":
        value = "Xe / Xem / Xemself";
        break;
      case "ze":
        value = "Ze(Zie) / Hir / Hirself";
        break;
    }
    content3 = /* @__PURE__ */ React25.createElement("div", null, value);
  }
  return /* @__PURE__ */ React25.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React25.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React25.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/ScaleTypeAttributeComponent.tsx
var React26 = __toESM(require_react());
function ScaleTypeAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  if (attribute === void 0 || !attribute.isSet)
    return null;
  const [editing, setEditing] = React26.useState(false);
  const handleEdit = () => {
    setEditing(!editing);
  };
  return /* @__PURE__ */ React26.createElement("div", {
    className: "grid grid-cols-1"
  }, /* @__PURE__ */ React26.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React26.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, editing ? /* @__PURE__ */ React26.createElement(EditComponent, {
    element: element4,
    attribute,
    onSave: handleEdit
  }) : isEditable ? /* @__PURE__ */ React26.createElement(ViewComponent, {
    attribute,
    edit: handleEdit
  }) : /* @__PURE__ */ React26.createElement(BrowseComponent, {
    attribute
  })));
}
function EditComponent({
  element: element4,
  attribute,
  onSave
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [widthPercentage, setWidthPercentage] = React26.useState(attribute.value / 10 * 100);
  React26.useEffect(() => {
    setWidthPercentage(attribute.value / 10 * 100);
  }, [attribute.value]);
  const handleMouseOver = (event) => {
    const rect = event.currentTarget.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const newWidthPercentage = x / rect.width * 100;
    setWidthPercentage(newWidthPercentage);
  };
  const handleDelete = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      onSave();
    });
  };
  const handleSave = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    const newValue = widthPercentage / 100 * 10;
    codeblockService.updateCodeblockData(attribute.id, Math.round(newValue)).then(() => {
      onSave();
    });
  };
  return /* @__PURE__ */ React26.createElement(React26.Fragment, null, /* @__PURE__ */ React26.createElement("div", {
    className: "w-full mt-3 cursor-pointer"
  }, /* @__PURE__ */ React26.createElement("div", {
    className: "relative mr-3 h-2 bg-[--background-primary-alt] rounded-full",
    onMouseMove: handleMouseOver,
    onClick: handleSave
  }, /* @__PURE__ */ React26.createElement("div", {
    style: { width: `${widthPercentage}%` },
    className: "absolute h-2 bg-[--text-accent] rounded-full"
  })), /* @__PURE__ */ React26.createElement("div", {
    className: "text-xs text-[--text-faint] text-center"
  }, Math.round(widthPercentage / 100 * 10))), /* @__PURE__ */ React26.createElement("div", {
    className: `w-full flex justify-end mt-3`
  }, /* @__PURE__ */ React26.createElement("button", {
    className: "rpgm-danger",
    onClick: handleDelete
  }, t2("buttons.delete")), /* @__PURE__ */ React26.createElement("button", {
    className: "rpgm-secondary",
    onClick: onSave
  }, t2("buttons.cancel")), /* @__PURE__ */ React26.createElement("button", {
    className: "rpgm-primary ml-3",
    onClick: handleSave
  }, t2("buttons.save"))));
}
function ViewComponent({ attribute, edit }) {
  return /* @__PURE__ */ React26.createElement("div", {
    onClick: edit,
    className: "cursor-pointer"
  }, /* @__PURE__ */ React26.createElement(BrowseComponent, {
    attribute
  }));
}
function BrowseComponent({ attribute }) {
  const widthPercentage = attribute.value / 10 * 100;
  return /* @__PURE__ */ React26.createElement("div", {
    className: "w-full mt-3"
  }, /* @__PURE__ */ React26.createElement("div", {
    className: "relative mr-3 h-2 bg-[--background-primary-alt] rounded-full"
  }, /* @__PURE__ */ React26.createElement("div", {
    style: { width: `${widthPercentage}%` },
    className: "absolute h-2 bg-[--text-accent] rounded-full"
  })), /* @__PURE__ */ React26.createElement("div", {
    className: "text-xs text-[--text-faint] text-center"
  }, attribute.value));
}

// src/components/attributes/types/SceneTypeAttributeComponent.tsx
var React27 = __toESM(require_react());

// src/data/enums/StoryCircleStage.ts
var StoryCircleStage = /* @__PURE__ */ ((StoryCircleStage2) => {
  StoryCircleStage2["You"] = "you";
  StoryCircleStage2["Need"] = "need";
  StoryCircleStage2["Go"] = "go";
  StoryCircleStage2["Search"] = "search";
  StoryCircleStage2["Find"] = "find";
  StoryCircleStage2["Take"] = "take";
  StoryCircleStage2["Return"] = "return";
  StoryCircleStage2["Change"] = "change";
  return StoryCircleStage2;
})(StoryCircleStage || {});

// src/components/attributes/types/SceneTypeAttributeComponent.tsx
function SceneTypeAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  if (!attribute.isSet)
    return null;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const value = attribute.value;
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  }
  const saveAttribute = (newValue) => {
    if (newValue === "") {
      codeblockService.updateCodeblockData(attribute.id, void 0);
      return;
    }
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React27.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React27.createElement("div", null, /* @__PURE__ */ React27.createElement("select", {
      defaultValue: attribute.value,
      onChange: (e2) => saveAttribute(e2.target.value),
      className: "!pl-2 !pr-4"
    }, /* @__PURE__ */ React27.createElement("option", {
      value: ""
    }), Object.entries(SceneType).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React27.createElement("option", {
      key,
      value: index2
    }, key + (isSceneActive(index2) ? " (active)" : ""))))), /* @__PURE__ */ React27.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React27.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: removeAttribute
    }, t2("buttons.delete"))));
  } else {
    content3 = /* @__PURE__ */ React27.createElement("div", null, Object.keys(StoryCircleStage).find((key) => StoryCircleStage[key] === value));
  }
  return /* @__PURE__ */ React27.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React27.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React27.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/SelectAttributeTypeComponent.tsx
var React28 = __toESM(require_react());
function SelectAttributeTypeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  var _a, _b;
  if (!attribute.isSet)
    return null;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  }
  const saveAttribute = (newValue) => {
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React28.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React28.createElement("div", null, /* @__PURE__ */ React28.createElement("select", {
      defaultValue: attribute.value,
      onChange: (e2) => saveAttribute(e2.target.value),
      className: "!pl-2 !pr-4"
    }, /* @__PURE__ */ React28.createElement("option", {
      value: ""
    }), (_a = attribute.options) == null ? void 0 : _a.map((key, index2) => /* @__PURE__ */ React28.createElement("option", {
      key: index2,
      value: key
    }, key)))), /* @__PURE__ */ React28.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React28.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: removeAttribute
    }, t2("buttons.delete"))));
  } else {
    content3 = /* @__PURE__ */ React28.createElement("div", null, (_b = attribute == null ? void 0 : attribute.value) != null ? _b : "");
  }
  return /* @__PURE__ */ React28.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React28.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React28.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/StoryCircleStageAttributeComponent.tsx
var React29 = __toESM(require_react());
function StoryCircleStageAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  if (!attribute.isSet)
    return null;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const value = attribute.value;
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function removeAttribute() {
    codeblockService.updateCodeblockData(attribute.id, void 0);
  }
  const saveAttribute = (newValue) => {
    codeblockService.updateCodeblockData(attribute.id, newValue);
  };
  let content3;
  if (isEditable) {
    content3 = /* @__PURE__ */ React29.createElement("div", {
      className: "grid grid-cols-1 lg:grid-cols-2 group"
    }, /* @__PURE__ */ React29.createElement("div", null, /* @__PURE__ */ React29.createElement("select", {
      defaultValue: attribute.value,
      onChange: (e2) => saveAttribute(e2.target.value),
      className: "!pl-2 !pr-4"
    }, /* @__PURE__ */ React29.createElement("option", {
      value: ""
    }), Object.entries(StoryCircleStage).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React29.createElement("option", {
      key,
      value: index2
    }, key)))), /* @__PURE__ */ React29.createElement("div", {
      className: "flex justify-end !ml-3"
    }, /* @__PURE__ */ React29.createElement("button", {
      className: "rpgm-danger opacity-0 group-hover:opacity-100",
      onClick: removeAttribute
    }, t2("buttons.delete"))));
  } else {
    content3 = /* @__PURE__ */ React29.createElement("div", null, Object.keys(StoryCircleStage).find((key) => StoryCircleStage[key] === value));
  }
  return /* @__PURE__ */ React29.createElement("div", {
    className: "grid grid-cols-1 lg:grid-cols-4"
  }, /* @__PURE__ */ React29.createElement(AttributeTitleComponent, {
    attribute
  }), /* @__PURE__ */ React29.createElement("div", {
    className: "col-span-3 pl-0 lg:pl-3"
  }, content3));
}

// src/components/attributes/types/StrengthsAttributeComponent.tsx
var React31 = __toESM(require_react());

// src/components/editors/StrengthsComponent.tsx
var React30 = __toESM(require_react());

// src/data/enums/StrengthType.ts
var StrengthType = /* @__PURE__ */ ((StrengthType2) => {
  StrengthType2[StrengthType2["Adaptable"] = 1] = "Adaptable";
  StrengthType2[StrengthType2["Ambitious"] = 2] = "Ambitious";
  StrengthType2[StrengthType2["Assertive"] = 4] = "Assertive";
  StrengthType2[StrengthType2["Charismatic"] = 8] = "Charismatic";
  StrengthType2[StrengthType2["Compassionate"] = 16] = "Compassionate";
  StrengthType2[StrengthType2["Courageous"] = 32] = "Courageous";
  StrengthType2[StrengthType2["Creative"] = 64] = "Creative";
  StrengthType2[StrengthType2["Decisive"] = 128] = "Decisive";
  StrengthType2[StrengthType2["Diligent"] = 256] = "Diligent";
  StrengthType2[StrengthType2["Disciplined"] = 512] = "Disciplined";
  StrengthType2[StrengthType2["Energetic"] = 1024] = "Energetic";
  StrengthType2[StrengthType2["Empathetic"] = 2048] = "Empathetic";
  StrengthType2[StrengthType2["Humble"] = 4096] = "Humble";
  StrengthType2[StrengthType2["Inspirational"] = 8192] = "Inspirational";
  StrengthType2[StrengthType2["Intuitive"] = 16384] = "Intuitive";
  StrengthType2[StrengthType2["Loyal"] = 32768] = "Loyal";
  StrengthType2[StrengthType2["Patient"] = 65536] = "Patient";
  StrengthType2[StrengthType2["Resilient"] = 131072] = "Resilient";
  StrengthType2[StrengthType2["SelfConfident"] = 262144] = "SelfConfident";
  StrengthType2[StrengthType2["Strategic"] = 524288] = "Strategic";
  StrengthType2[StrengthType2["Tenacious"] = 1048576] = "Tenacious";
  StrengthType2[StrengthType2["Visionary"] = 2097152] = "Visionary";
  StrengthType2[StrengthType2["Witty"] = 4194304] = "Witty";
  return StrengthType2;
})(StrengthType || {});

// src/components/editors/StrengthsComponent.tsx
function StrengthsComponent({
  initialValue,
  propagateValue
}) {
  const toggleStrength = (strength) => {
    propagateValue(strength);
  };
  return /* @__PURE__ */ React30.createElement(React30.Fragment, null, /* @__PURE__ */ React30.createElement("div", {
    className: "flex flex-wrap"
  }, Object.entries(StrengthType).filter(([key]) => isNaN(Number(key))).map(([key, value]) => {
    const strengthValue = value;
    return /* @__PURE__ */ React30.createElement("div", {
      key,
      className: `pl-2 pr-2 cursor-pointer hover:text-[--text-accent-hover] ${(initialValue & strengthValue) === strengthValue ? "text-[--text-accent]" : ""}`,
      onClick: () => toggleStrength(strengthValue)
    }, key);
  })));
}

// src/components/attributes/types/StrengthsAttributeComponent.tsx
function StrengthsAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!attribute.isSet)
    return null;
  const [editing, setEditing] = React31.useState(false);
  const [value, setValue] = React31.useState(attribute.value);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  const reset = () => {
    setValue(attribute.value);
    setEditing(false);
  };
  const removeAttribute = (attribute2) => () => {
    codeblockService.updateCodeblockData(attribute2.id, void 0);
  };
  const saveAttribute = (strength) => {
    setValue(value ^ strength);
  };
  const updateAttribute = () => {
    codeblockService.updateCodeblockData(attribute.id, value);
    setEditing(false);
  };
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React31.createElement(React31.Fragment, null, /* @__PURE__ */ React31.createElement("div", null, /* @__PURE__ */ React31.createElement(StrengthsComponent, {
      initialValue: value,
      propagateValue: saveAttribute
    })), /* @__PURE__ */ React31.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React31.createElement("button", {
      className: "rpgm-danger",
      onClick: removeAttribute(attribute)
    }, t2("buttons.delete")), /* @__PURE__ */ React31.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React31.createElement("button", {
      className: "rpgm-primary",
      onClick: updateAttribute
    }, t2("buttons.save"))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React31.createElement("div", {
      onClick: () => setEditing(!editing),
      className: "flex flex-wrap border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-pointer"
    }, Object.entries(StrengthType).filter(([key]) => isNaN(Number(key))).map(([key, currentStrength]) => {
      const strengthValue = currentStrength;
      if ((attribute.value & strengthValue) !== strengthValue)
        return null;
      return /* @__PURE__ */ React31.createElement("div", {
        key,
        className: "pl-2 pr-2"
      }, key);
    }));
  } else {
    content3 = /* @__PURE__ */ React31.createElement("div", {
      className: "flex flex-wrap p-3"
    }, Object.entries(StrengthType).filter(([key]) => isNaN(Number(key))).map(([key, currentStrength]) => {
      const strengthValue = currentStrength;
      if ((attribute.value & strengthValue) !== strengthValue)
        return null;
      return /* @__PURE__ */ React31.createElement("div", {
        key,
        className: "pl-2 pr-2"
      }, key);
    }));
  }
  return /* @__PURE__ */ React31.createElement(React31.Fragment, null, /* @__PURE__ */ React31.createElement("div", {
    className: "!font-bold"
  }, t2("attributes." + attribute.id)), content3);
}

// src/components/attributes/types/WeaknessesAttributeComponent.tsx
var React33 = __toESM(require_react());

// src/components/editors/WeaknessesComponent.tsx
var React32 = __toESM(require_react());

// src/data/enums/WeaknessType.ts
var WeaknessType = /* @__PURE__ */ ((WeaknessType2) => {
  WeaknessType2[WeaknessType2["Impulsive"] = 1] = "Impulsive";
  WeaknessType2[WeaknessType2["Indecisive"] = 2] = "Indecisive";
  WeaknessType2[WeaknessType2["Inflexible"] = 4] = "Inflexible";
  WeaknessType2[WeaknessType2["Insecure"] = 8] = "Insecure";
  WeaknessType2[WeaknessType2["Intolerant"] = 16] = "Intolerant";
  WeaknessType2[WeaknessType2["Irresponsible"] = 32] = "Irresponsible";
  WeaknessType2[WeaknessType2["Lazy"] = 64] = "Lazy";
  WeaknessType2[WeaknessType2["Naive"] = 128] = "Naive";
  WeaknessType2[WeaknessType2["Neglectful"] = 256] = "Neglectful";
  WeaknessType2[WeaknessType2["Nervous"] = 512] = "Nervous";
  WeaknessType2[WeaknessType2["Obstinate"] = 1024] = "Obstinate";
  WeaknessType2[WeaknessType2["Overbearing"] = 2048] = "Overbearing";
  WeaknessType2[WeaknessType2["Overcritical"] = 4096] = "Overcritical";
  WeaknessType2[WeaknessType2["Perfectionist"] = 8192] = "Perfectionist";
  WeaknessType2[WeaknessType2["Pessimistic"] = 16384] = "Pessimistic";
  WeaknessType2[WeaknessType2["Procrastinator"] = 32768] = "Procrastinator";
  WeaknessType2[WeaknessType2["Reactive"] = 65536] = "Reactive";
  WeaknessType2[WeaknessType2["Rigid"] = 131072] = "Rigid";
  WeaknessType2[WeaknessType2["SelfCentered"] = 262144] = "SelfCentered";
  WeaknessType2[WeaknessType2["Sensitive"] = 524288] = "Sensitive";
  WeaknessType2[WeaknessType2["Shy"] = 1048576] = "Shy";
  WeaknessType2[WeaknessType2["Stubborn"] = 2097152] = "Stubborn";
  WeaknessType2[WeaknessType2["Timid"] = 4194304] = "Timid";
  WeaknessType2[WeaknessType2["Unfocused"] = 8388608] = "Unfocused";
  WeaknessType2[WeaknessType2["Vague"] = 16777216] = "Vague";
  return WeaknessType2;
})(WeaknessType || {});

// src/components/editors/WeaknessesComponent.tsx
function WeaknessesComponent({
  initialValue,
  propagateValue
}) {
  const toggleWeaknesses = (weakness) => {
    propagateValue(weakness);
  };
  return /* @__PURE__ */ React32.createElement(React32.Fragment, null, /* @__PURE__ */ React32.createElement("div", {
    className: "flex flex-wrap"
  }, Object.entries(WeaknessType).filter(([key]) => isNaN(Number(key))).map(([key, value]) => {
    const weaknessValue = value;
    return /* @__PURE__ */ React32.createElement("div", {
      key,
      className: `pl-2 pr-2 cursor-pointer hover:text-[--text-accent-hover] ${(initialValue & weaknessValue) === weaknessValue ? "text-[--text-accent]" : ""}`,
      onClick: () => toggleWeaknesses(weaknessValue)
    }, key);
  })));
}

// src/components/attributes/types/WeaknessesAttributeComponent.tsx
function WeaknessesAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!attribute.isSet)
    return null;
  const [editing, setEditing] = React33.useState(false);
  const [value, setValue] = React33.useState(attribute.value);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  function reset() {
    setValue(attribute.value);
    setEditing(false);
  }
  const removeAttribute = (attribute2) => () => {
    codeblockService.updateCodeblockData(attribute2.id, void 0);
  };
  const saveAttribute = (weakness) => {
    setValue(value ^ weakness);
  };
  const updateAttribute = () => {
    codeblockService.updateCodeblockData(attribute.id, value);
    setEditing(false);
  };
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React33.createElement(React33.Fragment, null, /* @__PURE__ */ React33.createElement("div", null, /* @__PURE__ */ React33.createElement(WeaknessesComponent, {
      initialValue: value,
      propagateValue: saveAttribute
    })), /* @__PURE__ */ React33.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React33.createElement("button", {
      className: "rpgm-danger",
      onClick: removeAttribute(attribute)
    }, t2("buttons.delete")), /* @__PURE__ */ React33.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React33.createElement("button", {
      className: "rpgm-primary",
      onClick: updateAttribute
    }, t2("buttons.save"))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React33.createElement("div", {
      onClick: () => setEditing(!editing),
      className: "flex flex-wrap border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-pointer"
    }, Object.entries(WeaknessType).filter(([key]) => isNaN(Number(key))).map(([key, currentWeaknesses]) => {
      const weaknessesValue = currentWeaknesses;
      if ((attribute.value & weaknessesValue) !== weaknessesValue)
        return null;
      return /* @__PURE__ */ React33.createElement("div", {
        key,
        className: "pl-2 pr-2"
      }, key);
    }));
  } else {
    content3 = /* @__PURE__ */ React33.createElement("div", {
      className: "flex flex-wrap p-3"
    }, Object.entries(WeaknessType).filter(([key]) => isNaN(Number(key))).map(([key, currentWeaknesses]) => {
      const weaknessesValue = currentWeaknesses;
      if ((attribute.value & weaknessesValue) !== weaknessesValue)
        return null;
      return /* @__PURE__ */ React33.createElement("div", {
        key,
        className: "pl-2 pr-2"
      }, key);
    }));
  }
  return /* @__PURE__ */ React33.createElement(React33.Fragment, null, /* @__PURE__ */ React33.createElement("div", {
    className: "!font-bold"
  }, t2("attributes." + attribute.id)), content3);
}

// src/components/attributes/AttributeListComponent.tsx
function AttributeListComponent({
  element: element4,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React34.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] relative p-3"
  }, /* @__PURE__ */ React34.createElement("div", null, /* @__PURE__ */ React34.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("attributes.attribute", { count: 2 }))), /* @__PURE__ */ React34.createElement("div", null, element4.attributes.map((attribute, index2) => {
    if (attribute.type === "Description" /* Description */ || attribute.type === "StoryCircle" /* StoryCircle */ || attribute.type === "Kishotenketsu" /* Kishotenketsu */ || attribute.type === "Duration" /* Duration */ || attribute.type === "Parent" /* Parent */ || attribute.type === "Conflict" /* Conflict */ || attribute.type === "SensoryImprint" /* SensoryImprint */ || !attribute.isSet)
      return null;
    let attributeComponent;
    switch (attribute.type) {
      case "Pronoun" /* Pronoun */:
        attributeComponent = /* @__PURE__ */ React34.createElement(PronounComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Scale" /* Scale */:
        attributeComponent = /* @__PURE__ */ React34.createElement(ScaleTypeAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "SceneType" /* SceneType */:
        attributeComponent = /* @__PURE__ */ React34.createElement(SceneTypeAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Map" /* Map */:
        attributeComponent = /* @__PURE__ */ React34.createElement(MapAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Arc" /* Arc */:
        attributeComponent = /* @__PURE__ */ React34.createElement(ArcAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Date" /* Date */:
        attributeComponent = /* @__PURE__ */ React34.createElement(DateAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Strengths" /* Strengths */:
        attributeComponent = /* @__PURE__ */ React34.createElement(StrengthsAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Weaknesses" /* Weaknesses */:
        attributeComponent = /* @__PURE__ */ React34.createElement(WeaknessesAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "LongText" /* LongText */:
        attributeComponent = /* @__PURE__ */ React34.createElement(LongTextAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "StoryCircleStage" /* StoryCircleStage */:
        attributeComponent = /* @__PURE__ */ React34.createElement(StoryCircleStageAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "AbtStage" /* AbtStage */:
        attributeComponent = /* @__PURE__ */ React34.createElement(AbtStageAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Boolean" /* Boolean */:
        attributeComponent = /* @__PURE__ */ React34.createElement(BooleanAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Number" /* Number */:
        attributeComponent = /* @__PURE__ */ React34.createElement(NumberAttributeTypeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Link" /* Link */:
        attributeComponent = /* @__PURE__ */ React34.createElement(LinkAttributeTypeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Select" /* Select */:
        attributeComponent = /* @__PURE__ */ React34.createElement(SelectAttributeTypeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "MajorClues" /* MajorClues */:
        attributeComponent = /* @__PURE__ */ React34.createElement(MajorCluesAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "NonPlayerCharacterType" /* NonPlayerCharacterType */:
        attributeComponent = /* @__PURE__ */ React34.createElement(NonPlayerCharacterTypeAttributeComponent, {
          element: element4,
          attribute,
          isEditable
        });
        break;
      case "Text" /* Text */:
      default:
        attributeComponent = /* @__PURE__ */ React34.createElement(DefaultAttributeTypeComponent, {
          element: element4,
          attribute,
          isEditable
        });
    }
    if (attributeComponent === void 0)
      return null;
    return /* @__PURE__ */ React34.createElement("div", {
      className: "!mb-6",
      key: index2
    }, attributeComponent);
  })));
}

// src/components/attributes/types/DescriptionAttributeComponent.tsx
var React35 = __toESM(require_react());
function DescriptionAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [editing, setEditing] = React35.useState(false);
  const [description2, setDescription] = React35.useState((_a = attribute.value) != null ? _a : "");
  function reset() {
    var _a2;
    setDescription((_a2 = attribute.value) != null ? _a2 : "");
    setEditing(false);
  }
  const updateDescription = (newValue) => {
    if (newValue === void 0) {
      setEditing(false);
      return;
    }
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData("description", newValue).then(() => {
      setEditing(false);
    });
  };
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React35.createElement("div", {
      className: "grid grid-cols-1"
    }, /* @__PURE__ */ React35.createElement("div", null, /* @__PURE__ */ React35.createElement(MarkdownEditorComponent, {
      initialValue: attribute.value,
      campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath,
      onChange: setDescription,
      className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
    })), /* @__PURE__ */ React35.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React35.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React35.createElement("button", {
      className: "rpgm-primary",
      onClick: () => updateDescription(description2)
    }, t2("buttons.save"))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React35.createElement("div", {
      onClick: () => setEditing(!editing),
      className: "p-3 border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md cursor-text"
    }, /* @__PURE__ */ React35.createElement(MarkdownComponent, {
      value: attribute.value
    }));
  } else {
    content3 = /* @__PURE__ */ React35.createElement("div", {
      className: ""
    }, /* @__PURE__ */ React35.createElement(MarkdownComponent, {
      value: attribute.value
    }));
  }
  return /* @__PURE__ */ React35.createElement(React35.Fragment, null, /* @__PURE__ */ React35.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("attributes.description")), /* @__PURE__ */ React35.createElement("div", null, content3));
}

// src/components/attributes/types/ParentAttributeComponent.tsx
var React36 = __toESM(require_react());
function ParentAttributeComponent({
  element: element4,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const possibleParents = api2.get(void 0, element4.campaign, element4.parent.type);
  if (possibleParents === void 0 || possibleParents.length === 0)
    return null;
  possibleParents.sort((a, b) => b.positionInParent - a.positionInParent);
  const updateParent = (newPath) => {
    const newParentChildren = api2.get(void 0, element4.campaign, element4.type, possibleParents.find((parentElement) => parentElement.path === newPath));
    const newPositionInParent = newParentChildren.length === 0 ? 0 : Math.max(...newParentChildren.map((element5) => element5.positionInParent));
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockIdList([
      { name: "parent", value: newPath },
      { name: "positionInParent", value: newPositionInParent + 1 }
    ]);
  };
  return /* @__PURE__ */ React36.createElement(React36.Fragment, null, /* @__PURE__ */ React36.createElement("div", {
    className: "!font-bold"
  }, t2("parents.parent", { context: element4.parent.type })), /* @__PURE__ */ React36.createElement("div", null, isEditable && /* @__PURE__ */ React36.createElement("select", {
    onChange: (e2) => updateParent(e2.target.value),
    className: "min-w-full pl-3",
    defaultValue: element4.parent.file.path
  }, possibleParents.map((parent) => /* @__PURE__ */ React36.createElement("option", {
    key: parent.path,
    value: parent.path
  }, parent.name))), /* @__PURE__ */ React36.createElement("div", {
    className: "!ml-3 text-sm !mt-1"
  }, /* @__PURE__ */ React36.createElement("a", {
    href: element4.parent.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, element4.parent.name))));
}

// src/components/attributes/types/StoryCircleAttributeComponent.tsx
var React39 = __toESM(require_react());

// node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faPenToSquare = {
  prefix: "fas",
  iconName: "pen-to-square",
  icon: [512, 512, ["edit"], "f044", "M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160V416c0 53 43 96 96 96H352c53 0 96-43 96-96V320c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7-14.3 32-32 32H96c-17.7 0-32-14.3-32-32V160c0-17.7 14.3-32 32-32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H96z"]
};
var faEdit = faPenToSquare;
var faAngleRight = {
  prefix: "fas",
  iconName: "angle-right",
  icon: [320, 512, [8250], "f105", "M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"]
};
var faAnglesRight = {
  prefix: "fas",
  iconName: "angles-right",
  icon: [512, 512, [187, "angle-double-right"], "f101", "M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"]
};
var faAngleDoubleRight = faAnglesRight;
var faCircleQuestion = {
  prefix: "fas",
  iconName: "circle-question",
  icon: [512, 512, [62108, "question-circle"], "f059", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM169.8 165.3c7.9-22.3 29.1-37.3 52.8-37.3h58.3c34.9 0 63.1 28.3 63.1 63.1c0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6c-13.3 0-24-10.7-24-24V250.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1c0-8.4-6.8-15.1-15.1-15.1H222.6c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
};
var faEye = {
  prefix: "fas",
  iconName: "eye",
  icon: [576, 512, [128065], "f06e", "M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"]
};
var faHandPointer = {
  prefix: "fas",
  iconName: "hand-pointer",
  icon: [448, 512, [], "f25a", "M128 40c0-22.1 17.9-40 40-40s40 17.9 40 40V188.2c8.5-7.6 19.7-12.2 32-12.2c20.6 0 38.2 13 45 31.2c8.8-9.3 21.2-15.2 35-15.2c25.3 0 46 19.5 47.9 44.3c8.5-7.7 19.8-12.3 32.1-12.3c26.5 0 48 21.5 48 48v48 16 48c0 70.7-57.3 128-128 128l-16 0H240l-.1 0h-5.2c-5 0-9.9-.3-14.7-1c-55.3-5.6-106.2-34-140-79L8 336c-13.3-17.7-9.7-42.7 8-56s42.7-9.7 56 8l56 74.7V40zM240 304c0-8.8-7.2-16-16-16s-16 7.2-16 16v96c0 8.8 7.2 16 16 16s16-7.2 16-16V304zm48-16c-8.8 0-16 7.2-16 16v96c0 8.8 7.2 16 16 16s16-7.2 16-16V304c0-8.8-7.2-16-16-16zm80 16c0-8.8-7.2-16-16-16s-16 7.2-16 16v96c0 8.8 7.2 16 16 16s16-7.2 16-16V304z"]
};
var faDroplet = {
  prefix: "fas",
  iconName: "droplet",
  icon: [384, 512, [128167, "tint"], "f043", "M192 512C86 512 0 426 0 320C0 228.8 130.2 57.7 166.6 11.7C172.6 4.2 181.5 0 191.1 0h1.8c9.6 0 18.5 4.2 24.5 11.7C253.8 57.7 384 228.8 384 320c0 106-86 192-192 192zM96 336c0-8.8-7.2-16-16-16s-16 7.2-16 16c0 61.9 50.1 112 112 112c8.8 0 16-7.2 16-16s-7.2-16-16-16c-44.2 0-80-35.8-80-80z"]
};
var faTint = faDroplet;
var faEarListen = {
  prefix: "fas",
  iconName: "ear-listen",
  icon: [512, 512, ["assistive-listening-systems"], "f2a2", "M398.3 3.4c-15.8-7.9-35-1.5-42.9 14.3c-7.9 15.8-1.5 34.9 14.2 42.9l.4 .2c.4 .2 1.1 .6 2.1 1.2c2 1.2 5 3 8.7 5.6c7.5 5.2 17.6 13.2 27.7 24.2C428.5 113.4 448 146 448 192c0 17.7 14.3 32 32 32s32-14.3 32-32c0-66-28.5-113.4-56.5-143.7C441.6 33.2 427.7 22.2 417.3 15c-5.3-3.7-9.7-6.4-13-8.3c-1.6-1-3-1.7-4-2.2c-.5-.3-.9-.5-1.2-.7l-.4-.2-.2-.1-.1 0 0 0c0 0 0 0-14.3 28.6L398.3 3.4zM128.7 227.5c6.2-56 53.7-99.5 111.3-99.5c61.9 0 112 50.1 112 112c0 29.3-11.2 55.9-29.6 75.9c-17 18.4-34.4 45.1-34.4 78V400c0 26.5-21.5 48-48 48c-17.7 0-32 14.3-32 32s14.3 32 32 32c61.9 0 112-50.1 112-112v-6.1c0-9.8 5.4-21.7 17.4-34.7C398.3 327.9 416 286 416 240c0-97.2-78.8-176-176-176C149.4 64 74.8 132.5 65.1 220.5c-1.9 17.6 10.7 33.4 28.3 35.3s33.4-10.7 35.3-28.3zM32 512a32 32 0 1 0 0-64 32 32 0 1 0 0 64zM192 352a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zM41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3l64 64c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-64-64c-12.5-12.5-32.8-12.5-45.3 0zM208 240c0-17.7 14.3-32 32-32s32 14.3 32 32c0 13.3 10.7 24 24 24s24-10.7 24-24c0-44.2-35.8-80-80-80s-80 35.8-80 80c0 13.3 10.7 24 24 24s24-10.7 24-24z"]
};
var faWind = {
  prefix: "fas",
  iconName: "wind",
  icon: [512, 512, [], "f72e", "M288 32c0 17.7 14.3 32 32 32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32 14.3-32 32s14.3 32 32 32H352c53 0 96-43 96-96s-43-96-96-96H320c-17.7 0-32 14.3-32 32zm64 352c0 17.7 14.3 32 32 32h32c53 0 96-43 96-96s-43-96-96-96H32c-17.7 0-32 14.3-32 32s14.3 32 32 32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H384c-17.7 0-32 14.3-32 32zM128 512h32c53 0 96-43 96-96s-43-96-96-96H32c-17.7 0-32 14.3-32 32s14.3 32 32 32H160c17.7 0 32 14.3 32 32s-14.3 32-32 32H128c-17.7 0-32 14.3-32 32s14.3 32 32 32z"]
};
var faXmark = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
};
var faTimes = faXmark;
var faAnglesLeft = {
  prefix: "fas",
  iconName: "angles-left",
  icon: [512, 512, [171, "angle-double-left"], "f100", "M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"]
};
var faAngleDoubleLeft = faAnglesLeft;
var faAngleLeft = {
  prefix: "fas",
  iconName: "angle-left",
  icon: [320, 512, [8249], "f104", "M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"]
};

// node_modules/@fortawesome/fontawesome-svg-core/index.mjs
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function _classCallCheck2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr2, i) {
  return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i) || _unsupportedIterableToArray(arr2, i) || _nonIterableRest();
}
function _toConsumableArray(arr2) {
  return _arrayWithoutHoles(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray(arr2) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr2) {
  if (Array.isArray(arr2))
    return _arrayLikeToArray(arr2);
}
function _arrayWithHoles(arr2) {
  if (Array.isArray(arr2))
    return arr2;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _iterableToArrayLimit(arr2, i) {
  var _i = arr2 == null ? null : typeof Symbol !== "undefined" && arr2[Symbol.iterator] || arr2["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr2); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++)
    arr22[i] = arr2[i];
  return arr22;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var noop2 = function noop3() {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop2,
  measure: noop2
};
try {
  if (typeof window !== "undefined")
    _WINDOW = window;
  if (typeof document !== "undefined")
    _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined")
    _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined")
    _PERFORMANCE = performance;
} catch (e2) {
}
var _ref = _WINDOW.navigator || {};
var _ref$userAgent = _ref.userAgent;
var userAgent = _ref$userAgent === void 0 ? "" : _ref$userAgent;
var WINDOW = _WINDOW;
var DOCUMENT = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
var IS_BROWSER = !!WINDOW.document;
var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var _familyProxy;
var _familyProxy2;
var _familyProxy3;
var _familyProxy4;
var _familyProxy5;
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var UNITS_IN_GRID = 16;
var DEFAULT_CSS_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
var DATA_PREFIX = "data-prefix";
var DATA_ICON = "data-icon";
var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
var MUTATION_APPROACH_ASYNC = "async";
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
var PRODUCTION = function() {
  try {
    return false;
  } catch (e2) {
    return false;
  }
}();
var FAMILY_CLASSIC = "classic";
var FAMILY_SHARP = "sharp";
var FAMILIES = [FAMILY_CLASSIC, FAMILY_SHARP];
function familyProxy(obj) {
  return new Proxy(obj, {
    get: function get4(target, prop) {
      return prop in target ? target[prop] : target[FAMILY_CLASSIC];
    }
  });
}
var PREFIX_TO_STYLE = familyProxy((_familyProxy = {}, _defineProperty(_familyProxy, FAMILY_CLASSIC, {
  "fa": "solid",
  "fas": "solid",
  "fa-solid": "solid",
  "far": "regular",
  "fa-regular": "regular",
  "fal": "light",
  "fa-light": "light",
  "fat": "thin",
  "fa-thin": "thin",
  "fad": "duotone",
  "fa-duotone": "duotone",
  "fab": "brands",
  "fa-brands": "brands",
  "fak": "kit",
  "fa-kit": "kit"
}), _defineProperty(_familyProxy, FAMILY_SHARP, {
  "fa": "solid",
  "fass": "solid",
  "fa-solid": "solid",
  "fasr": "regular",
  "fa-regular": "regular",
  "fasl": "light",
  "fa-light": "light"
}), _familyProxy));
var STYLE_TO_PREFIX = familyProxy((_familyProxy2 = {}, _defineProperty(_familyProxy2, FAMILY_CLASSIC, {
  "solid": "fas",
  "regular": "far",
  "light": "fal",
  "thin": "fat",
  "duotone": "fad",
  "brands": "fab",
  "kit": "fak"
}), _defineProperty(_familyProxy2, FAMILY_SHARP, {
  "solid": "fass",
  "regular": "fasr",
  "light": "fasl"
}), _familyProxy2));
var PREFIX_TO_LONG_STYLE = familyProxy((_familyProxy3 = {}, _defineProperty(_familyProxy3, FAMILY_CLASSIC, {
  "fab": "fa-brands",
  "fad": "fa-duotone",
  "fak": "fa-kit",
  "fal": "fa-light",
  "far": "fa-regular",
  "fas": "fa-solid",
  "fat": "fa-thin"
}), _defineProperty(_familyProxy3, FAMILY_SHARP, {
  "fass": "fa-solid",
  "fasr": "fa-regular",
  "fasl": "fa-light"
}), _familyProxy3));
var LONG_STYLE_TO_PREFIX = familyProxy((_familyProxy4 = {}, _defineProperty(_familyProxy4, FAMILY_CLASSIC, {
  "fa-brands": "fab",
  "fa-duotone": "fad",
  "fa-kit": "fak",
  "fa-light": "fal",
  "fa-regular": "far",
  "fa-solid": "fas",
  "fa-thin": "fat"
}), _defineProperty(_familyProxy4, FAMILY_SHARP, {
  "fa-solid": "fass",
  "fa-regular": "fasr",
  "fa-light": "fasl"
}), _familyProxy4));
var ICON_SELECTION_SYNTAX_PATTERN = /fa(s|r|l|t|d|b|k|ss|sr|sl)?[\-\ ]/;
var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
var FONT_FAMILY_PATTERN = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i;
var FONT_WEIGHT_TO_PREFIX = familyProxy((_familyProxy5 = {}, _defineProperty(_familyProxy5, FAMILY_CLASSIC, {
  "900": "fas",
  "400": "far",
  "normal": "far",
  "300": "fal",
  "100": "fat"
}), _defineProperty(_familyProxy5, FAMILY_SHARP, {
  "900": "fass",
  "400": "fasr",
  "300": "fasl"
}), _familyProxy5));
var oneToTen = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var oneToTwenty = oneToTen.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
var DUOTONE_CLASSES = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var prefixes = /* @__PURE__ */ new Set();
Object.keys(STYLE_TO_PREFIX[FAMILY_CLASSIC]).map(prefixes.add.bind(prefixes));
Object.keys(STYLE_TO_PREFIX[FAMILY_SHARP]).map(prefixes.add.bind(prefixes));
var RESERVED_CLASSES = [].concat(FAMILIES, _toConsumableArray(prefixes), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", DUOTONE_CLASSES.GROUP, DUOTONE_CLASSES.SWAP_OPACITY, DUOTONE_CLASSES.PRIMARY, DUOTONE_CLASSES.SECONDARY]).concat(oneToTen.map(function(n2) {
  return "".concat(n2, "x");
})).concat(oneToTwenty.map(function(n2) {
  return "w-".concat(n2);
}));
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element4 = DOCUMENT.querySelector("script[" + attr + "]");
  if (element4) {
    return element4.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "")
    return true;
  if (val === "false")
    return false;
  if (val === "true")
    return true;
  return val;
}
if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
  attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach(function(_ref2) {
    var _ref22 = _slicedToArray(_ref2, 2), attr = _ref22[0], key = _ref22[1];
    var val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var attrs;
var _default = {
  styleDefault: "solid",
  familyDefault: "classic",
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}
var _config = _objectSpread2(_objectSpread2({}, _default), initial);
if (!_config.autoReplaceSvg)
  _config.observeMutations = false;
var config = {};
Object.keys(_default).forEach(function(key) {
  Object.defineProperty(config, key, {
    enumerable: true,
    set: function set2(val) {
      _config[key] = val;
      _onChangeCb.forEach(function(cb) {
        return cb(config);
      });
    },
    get: function get4() {
      return _config[key];
    }
  });
});
Object.defineProperty(config, "familyPrefix", {
  enumerable: true,
  set: function set(val) {
    _config.cssPrefix = val;
    _onChangeCb.forEach(function(cb) {
      return cb(config);
    });
  },
  get: function get2() {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config;
var _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);
  return function() {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
var d = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  var style3 = DOCUMENT.createElement("style");
  style3.setAttribute("type", "text/css");
  style3.innerHTML = css2;
  var headChildren = DOCUMENT.head.childNodes;
  var beforeChild = null;
  for (var i = headChildren.length - 1; i > -1; i--) {
    var child = headChildren[i];
    var tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT.head.insertBefore(style3, beforeChild);
  return css2;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  var size = 12;
  var id = "";
  while (size-- > 0) {
    id += idPool[Math.random() * 62 | 0];
  }
  return id;
}
function toArray(obj) {
  var array = [];
  for (var i = (obj || []).length >>> 0; i--; ) {
    array[i] = obj[i];
  }
  return array;
}
function classArray(node2) {
  if (node2.classList) {
    return toArray(node2.classList);
  } else {
    return (node2.getAttribute("class") || "").split(" ").filter(function(i) {
      return i;
    });
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes3) {
  return Object.keys(attributes3 || {}).reduce(function(acc, attributeName) {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes3[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce(function(acc, styleName) {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref2) {
  var transform = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
  var outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  var inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  var path4 = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path: path4
  };
}
function transformForCss(_ref2) {
  var transform = _ref2.transform, _ref2$width = _ref2.width, width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width, _ref2$height = _ref2.height, height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height, _ref2$startCentered = _ref2.startCentered, startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
  var val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d - width / 2, "em, ").concat(transform.y / d - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d, "em), calc(-50% + ").concat(transform.y / d, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d, "em, ").concat(transform.y / d, "em) ");
  }
  val += "scale(".concat(transform.size / d * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}
var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-counter-scale, 0.25));\n          transform: scale(var(--fa-counter-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  -webkit-transform: scale(var(--fa-layers-scale, 0.25));\n          transform: scale(var(--fa-layers-scale, 0.25));\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(var(--fa-li-width, 2em) * -1);\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  -webkit-animation-name: fa-beat;\n          animation-name: fa-beat;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  -webkit-animation-name: fa-bounce;\n          animation-name: fa-bounce;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  -webkit-animation-name: fa-fade;\n          animation-name: fa-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  -webkit-animation-name: fa-beat-fade;\n          animation-name: fa-beat-fade;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  -webkit-animation-name: fa-flip;\n          animation-name: fa-flip;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);\n          animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  -webkit-animation-name: fa-shake;\n          animation-name: fa-shake;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-delay: var(--fa-animation-delay, 0s);\n          animation-delay: var(--fa-animation-delay, 0s);\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 2s);\n          animation-duration: var(--fa-animation-duration, 2s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, linear);\n          animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  -webkit-animation-name: fa-spin;\n          animation-name: fa-spin;\n  -webkit-animation-direction: var(--fa-animation-direction, normal);\n          animation-direction: var(--fa-animation-direction, normal);\n  -webkit-animation-duration: var(--fa-animation-duration, 1s);\n          animation-duration: var(--fa-animation-duration, 1s);\n  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n          animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));\n          animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    -webkit-animation-delay: -1ms;\n            animation-delay: -1ms;\n    -webkit-animation-duration: 1ms;\n            animation-duration: 1ms;\n    -webkit-animation-iteration-count: 1;\n            animation-iteration-count: 1;\n    -webkit-transition-delay: 0s;\n            transition-delay: 0s;\n    -webkit-transition-duration: 0s;\n            transition-duration: 0s;\n  }\n}\n@-webkit-keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  45% {\n    -webkit-transform: scale(var(--fa-beat-scale, 1.25));\n            transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@-webkit-keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    -webkit-transform: scale(1, 1) translateY(0);\n            transform: scale(1, 1) translateY(0);\n  }\n}\n@-webkit-keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@-webkit-keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    -webkit-transform: scale(1);\n            transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));\n            transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@-webkit-keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@-webkit-keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@keyframes fa-shake {\n  0% {\n    -webkit-transform: rotate(-15deg);\n            transform: rotate(-15deg);\n  }\n  4% {\n    -webkit-transform: rotate(15deg);\n            transform: rotate(15deg);\n  }\n  8%, 24% {\n    -webkit-transform: rotate(-18deg);\n            transform: rotate(-18deg);\n  }\n  12%, 28% {\n    -webkit-transform: rotate(18deg);\n            transform: rotate(18deg);\n  }\n  16% {\n    -webkit-transform: rotate(-22deg);\n            transform: rotate(-22deg);\n  }\n  20% {\n    -webkit-transform: rotate(22deg);\n            transform: rotate(22deg);\n  }\n  32% {\n    -webkit-transform: rotate(-12deg);\n            transform: rotate(-12deg);\n  }\n  36% {\n    -webkit-transform: rotate(12deg);\n            transform: rotate(12deg);\n  }\n  40%, 100% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  -webkit-transform: rotate(var(--fa-rotate-angle, none));\n          transform: rotate(var(--fa-rotate-angle, none));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse,\n.fa-duotone.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}';
function css() {
  var dcp = DEFAULT_CSS_PREFIX;
  var drc = DEFAULT_REPLACEMENT_CLASS;
  var fp = config.cssPrefix;
  var rc = config.replacementClass;
  var s3 = baseStyles;
  if (fp !== dcp || rc !== drc) {
    var dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
    var customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
    var rPatt = new RegExp("\\.".concat(drc), "g");
    s3 = s3.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s3;
}
var _cssInserted = false;
function ensureCss() {
  if (config.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout: function mixout() {
    return {
      dom: {
        css,
        insertCss: ensureCss
      }
    };
  },
  hooks: function hooks() {
    return {
      beforeDOMElementCreation: function beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg: function beforeI2svg() {
        ensureCss();
      }
    };
  }
};
var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER])
  w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles)
  w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks)
  w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims)
  w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function listener2() {
  DOCUMENT.removeEventListener("DOMContentLoaded", listener2);
  loaded = 1;
  functions.map(function(fn) {
    return fn();
  });
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
  if (!loaded)
    DOCUMENT.addEventListener("DOMContentLoaded", listener);
}
function domready(fn) {
  if (!IS_DOM)
    return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}
function toHtml(abstractNodes) {
  var tag = abstractNodes.tag, _abstractNodes$attrib = abstractNodes.attributes, attributes3 = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib, _abstractNodes$childr = abstractNodes.children, children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes3), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix3, iconName) {
  if (mapping && mapping[prefix3] && mapping[prefix3][iconName]) {
    return {
      prefix: prefix3,
      iconName,
      icon: mapping[prefix3][iconName]
    };
  }
}
var bindInternal4 = function bindInternal42(func, thisContext) {
  return function(a, b, c, d2) {
    return func.call(thisContext, a, b, c, d2);
  };
};
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys2 = Object.keys(subject), length = keys2.length, iterator = thisContext !== void 0 ? bindInternal4(fn, thisContext) : fn, i, key, result;
  if (initialValue === void 0) {
    i = 1;
    result = subject[keys2[0]];
  } else {
    i = 0;
    result = initialValue;
  }
  for (; i < length; i++) {
    key = keys2[i];
    result = iterator(result, subject[key], key, subject);
  }
  return result;
};
function ucs2decode(string3) {
  var output = [];
  var counter2 = 0;
  var length = string3.length;
  while (counter2 < length) {
    var value = string3.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length) {
      var extra = string3.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function toHex(unicode) {
  var decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string3, index2) {
  var size = string3.length;
  var first = string3.charCodeAt(index2);
  var second;
  if (first >= 55296 && first <= 56319 && size > index2 + 1) {
    second = string3.charCodeAt(index2 + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce(function(acc, iconName) {
    var icon3 = icons[iconName];
    var expanded = !!icon3.icon;
    if (expanded) {
      acc[icon3.iconName] = icon3.icon;
    } else {
      acc[iconName] = icon3;
    }
    return acc;
  }, {});
}
function defineIcons(prefix3, icons) {
  var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _params$skipHooks = params.skipHooks, skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
  var normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix3, normalizeIcons(icons));
  } else {
    namespace.styles[prefix3] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix3] || {}), normalized);
  }
  if (prefix3 === "fas") {
    defineIcons("fa", icons);
  }
}
var _LONG_STYLE;
var _PREFIXES;
var _PREFIXES_FOR_FAMILY;
var styles = namespace.styles;
var shims = namespace.shims;
var LONG_STYLE = (_LONG_STYLE = {}, _defineProperty(_LONG_STYLE, FAMILY_CLASSIC, Object.values(PREFIX_TO_LONG_STYLE[FAMILY_CLASSIC])), _defineProperty(_LONG_STYLE, FAMILY_SHARP, Object.values(PREFIX_TO_LONG_STYLE[FAMILY_SHARP])), _LONG_STYLE);
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
var PREFIXES = (_PREFIXES = {}, _defineProperty(_PREFIXES, FAMILY_CLASSIC, Object.keys(PREFIX_TO_STYLE[FAMILY_CLASSIC])), _defineProperty(_PREFIXES, FAMILY_SHARP, Object.keys(PREFIX_TO_STYLE[FAMILY_SHARP])), _PREFIXES);
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  var parts = cls.split("-");
  var prefix3 = parts[0];
  var iconName = parts.slice(1).join("-");
  if (prefix3 === cssPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = function build2() {
  var lookup9 = function lookup10(reducer2) {
    return reduce(styles, function(o, style3, prefix3) {
      o[prefix3] = reduce(style3, reducer2, {});
      return o;
    }, {});
  };
  _byUnicode = lookup9(function(acc, icon3, iconName) {
    if (icon3[3]) {
      acc[icon3[3]] = iconName;
    }
    if (icon3[2]) {
      var aliases = icon3[2].filter(function(a) {
        return typeof a === "number";
      });
      aliases.forEach(function(alias) {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup9(function(acc, icon3, iconName) {
    acc[iconName] = iconName;
    if (icon3[2]) {
      var aliases = icon3[2].filter(function(a) {
        return typeof a === "string";
      });
      aliases.forEach(function(alias) {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup9(function(acc, icon3, iconName) {
    var aliases = icon3[2];
    acc[iconName] = iconName;
    aliases.forEach(function(alias) {
      acc[alias] = iconName;
    });
    return acc;
  });
  var hasRegular = "far" in styles || config.autoFetchSvg;
  var shimLookups = reduce(shims, function(acc, shim) {
    var maybeNameMaybeUnicode = shim[0];
    var prefix3 = shim[1];
    var iconName = shim[2];
    if (prefix3 === "far" && !hasRegular) {
      prefix3 = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix: prefix3,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix: prefix3,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
    family: config.familyDefault
  });
};
onChange(function(c) {
  _defaultUsablePrefix = getCanonicalPrefix(c.styleDefault, {
    family: config.familyDefault
  });
});
build();
function byUnicode(prefix3, unicode) {
  return (_byUnicode[prefix3] || {})[unicode];
}
function byLigature(prefix3, ligature) {
  return (_byLigature[prefix3] || {})[ligature];
}
function byAlias(prefix3, alias) {
  return (_byAlias[prefix3] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  var oldUnicode = _byOldUnicode[unicode];
  var newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = function emptyCanonicalIcon2() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getCanonicalPrefix(styleOrPrefix) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$family = params.family, family = _params$family === void 0 ? FAMILY_CLASSIC : _params$family;
  var style3 = PREFIX_TO_STYLE[family][styleOrPrefix];
  var prefix3 = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style3];
  var defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  return prefix3 || defined || null;
}
var PREFIXES_FOR_FAMILY = (_PREFIXES_FOR_FAMILY = {}, _defineProperty(_PREFIXES_FOR_FAMILY, FAMILY_CLASSIC, Object.keys(PREFIX_TO_LONG_STYLE[FAMILY_CLASSIC])), _defineProperty(_PREFIXES_FOR_FAMILY, FAMILY_SHARP, Object.keys(PREFIX_TO_LONG_STYLE[FAMILY_SHARP])), _PREFIXES_FOR_FAMILY);
function getCanonicalIcon(values2) {
  var _famProps;
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$skipLookups = params.skipLookups, skipLookups = _params$skipLookups === void 0 ? false : _params$skipLookups;
  var famProps = (_famProps = {}, _defineProperty(_famProps, FAMILY_CLASSIC, "".concat(config.cssPrefix, "-").concat(FAMILY_CLASSIC)), _defineProperty(_famProps, FAMILY_SHARP, "".concat(config.cssPrefix, "-").concat(FAMILY_SHARP)), _famProps);
  var givenPrefix = null;
  var family = FAMILY_CLASSIC;
  if (values2.includes(famProps[FAMILY_CLASSIC]) || values2.some(function(v) {
    return PREFIXES_FOR_FAMILY[FAMILY_CLASSIC].includes(v);
  })) {
    family = FAMILY_CLASSIC;
  }
  if (values2.includes(famProps[FAMILY_SHARP]) || values2.some(function(v) {
    return PREFIXES_FOR_FAMILY[FAMILY_SHARP].includes(v);
  })) {
    family = FAMILY_SHARP;
  }
  var canonical = values2.reduce(function(acc, cls) {
    var iconName = getIconName(config.cssPrefix, cls);
    if (styles[cls]) {
      cls = LONG_STYLE[family].includes(cls) ? LONG_STYLE_TO_PREFIX[family][cls] : cls;
      givenPrefix = cls;
      acc.prefix = cls;
    } else if (PREFIXES[family].indexOf(cls) > -1) {
      givenPrefix = cls;
      acc.prefix = getCanonicalPrefix(cls, {
        family
      });
    } else if (iconName) {
      acc.iconName = iconName;
    } else if (cls !== config.replacementClass && cls !== famProps[FAMILY_CLASSIC] && cls !== famProps[FAMILY_SHARP]) {
      acc.rest.push(cls);
    }
    if (!skipLookups && acc.prefix && acc.iconName) {
      var shim = givenPrefix === "fa" ? byOldName(acc.iconName) : {};
      var aliasIconName = byAlias(acc.prefix, acc.iconName);
      if (shim.prefix) {
        givenPrefix = null;
      }
      acc.iconName = shim.iconName || aliasIconName || acc.iconName;
      acc.prefix = shim.prefix || acc.prefix;
      if (acc.prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
        acc.prefix = "fas";
      }
    }
    return acc;
  }, emptyCanonicalIcon());
  if (values2.includes("fa-brands") || values2.includes("fab")) {
    canonical.prefix = "fab";
  }
  if (values2.includes("fa-duotone") || values2.includes("fad")) {
    canonical.prefix = "fad";
  }
  if (!canonical.prefix && family === FAMILY_SHARP && (styles["fass"] || config.autoFetchSvg)) {
    canonical.prefix = "fass";
    canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
  }
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}
var Library = /* @__PURE__ */ function() {
  function Library2() {
    _classCallCheck2(this, Library2);
    this.definitions = {};
  }
  _createClass2(Library2, [{
    key: "add",
    value: function add3() {
      var _this = this;
      for (var _len = arguments.length, definitions2 = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions2[_key] = arguments[_key];
      }
      var additions = definitions2.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach(function(key) {
        _this.definitions[key] = _objectSpread2(_objectSpread2({}, _this.definitions[key] || {}), additions[key]);
        defineIcons(key, additions[key]);
        var longPrefix = PREFIX_TO_LONG_STYLE[FAMILY_CLASSIC][key];
        if (longPrefix)
          defineIcons(longPrefix, additions[key]);
        build();
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function _pullDefinitions(additions, definition2) {
      var normalized = definition2.prefix && definition2.iconName && definition2.icon ? {
        0: definition2
      } : definition2;
      Object.keys(normalized).map(function(key) {
        var _normalized$key = normalized[key], prefix3 = _normalized$key.prefix, iconName = _normalized$key.iconName, icon3 = _normalized$key.icon;
        var aliases = icon3[2];
        if (!additions[prefix3])
          additions[prefix3] = {};
        if (aliases.length > 0) {
          aliases.forEach(function(alias) {
            if (typeof alias === "string") {
              additions[prefix3][alias] = icon3;
            }
          });
        }
        additions[prefix3][iconName] = icon3;
      });
      return additions;
    }
  }]);
  return Library2;
}();
var _plugins = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref2) {
  var obj = _ref2.mixoutsTo;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach(function(k) {
    if (defaultProviderKeys.indexOf(k) === -1) {
      delete providers[k];
    }
  });
  _plugins.forEach(function(plugin) {
    var mixout8 = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout8).forEach(function(tk) {
      if (typeof mixout8[tk] === "function") {
        obj[tk] = mixout8[tk];
      }
      if (_typeof2(mixout8[tk]) === "object") {
        Object.keys(mixout8[tk]).forEach(function(sk) {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout8[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      var hooks8 = plugin.hooks();
      Object.keys(hooks8).forEach(function(hook) {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks8[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function(hookFn) {
    accumulator = hookFn.apply(null, [accumulator].concat(args));
  });
  return accumulator;
}
function callHooks(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  var hookFns = _hooks[hook] || [];
  hookFns.forEach(function(hookFn) {
    hookFn.apply(null, args);
  });
  return void 0;
}
function callProvided() {
  var hook = arguments[0];
  var args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : void 0;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  var iconName = iconLookup.iconName;
  var prefix3 = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName)
    return;
  iconName = byAlias(prefix3, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix3, iconName) || iconFromMapping(namespace.styles, prefix3, iconName);
}
var library = new Library();
var noAuto = function noAuto2() {
  config.autoReplaceSvg = false;
  config.observeMutations = false;
  callHooks("noAuto");
};
var dom = {
  i2svg: function i2svg() {
    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (IS_DOM) {
      callHooks("beforeI2svg", params);
      callProvided("pseudoElements2svg", params);
      return callProvided("i2svg", params);
    } else {
      return Promise.reject("Operation requires a DOM of some kind.");
    }
  },
  watch: function watch() {
    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var autoReplaceSvgRoot = params.autoReplaceSvgRoot;
    if (config.autoReplaceSvg === false) {
      config.autoReplaceSvg = true;
    }
    config.observeMutations = true;
    domready(function() {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks("watch", params);
    });
  }
};
var parse5 = {
  icon: function icon(_icon) {
    if (_icon === null) {
      return null;
    }
    if (_typeof2(_icon) === "object" && _icon.prefix && _icon.iconName) {
      return {
        prefix: _icon.prefix,
        iconName: byAlias(_icon.prefix, _icon.iconName) || _icon.iconName
      };
    }
    if (Array.isArray(_icon) && _icon.length === 2) {
      var iconName = _icon[1].indexOf("fa-") === 0 ? _icon[1].slice(3) : _icon[1];
      var prefix3 = getCanonicalPrefix(_icon[0]);
      return {
        prefix: prefix3,
        iconName: byAlias(prefix3, iconName) || iconName
      };
    }
    if (typeof _icon === "string" && (_icon.indexOf("".concat(config.cssPrefix, "-")) > -1 || _icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      var canonicalIcon = getCanonicalIcon(_icon.split(" "), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof _icon === "string") {
      var _prefix = getDefaultUsablePrefix();
      return {
        prefix: _prefix,
        iconName: byAlias(_prefix, _icon) || _icon
      };
    }
  }
};
var api = {
  noAuto,
  config,
  dom,
  parse: parse5,
  library,
  findIconDefinition,
  toHtml
};
var autoReplace = function autoReplace2() {
  var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _params$autoReplaceSv = params.autoReplaceSvgRoot, autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
  if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg)
    api.dom.i2svg({
      node: autoReplaceSvgRoot
    });
};
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function get4() {
      return val.abstract.map(function(a) {
        return toHtml(a);
      });
    }
  });
  Object.defineProperty(val, "node", {
    get: function get4() {
      if (!IS_DOM)
        return;
      var container = DOCUMENT.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref2) {
  var children = _ref2.children, main = _ref2.main, mask = _ref2.mask, attributes3 = _ref2.attributes, styles2 = _ref2.styles, transform = _ref2.transform;
  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    var width = main.width, height = main.height;
    var offset4 = {
      x: width / height / 2,
      y: 0.5
    };
    attributes3["style"] = joinStyles(_objectSpread2(_objectSpread2({}, styles2), {}, {
      "transform-origin": "".concat(offset4.x + transform.x / 16, "em ").concat(offset4.y + transform.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: attributes3,
    children
  }];
}
function asSymbol(_ref2) {
  var prefix3 = _ref2.prefix, iconName = _ref2.iconName, children = _ref2.children, attributes3 = _ref2.attributes, symbol = _ref2.symbol;
  var id = symbol === true ? "".concat(prefix3, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread2(_objectSpread2({}, attributes3), {}, {
        id
      }),
      children
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  var _params$icons = params.icons, main = _params$icons.main, mask = _params$icons.mask, prefix3 = params.prefix, iconName = params.iconName, transform = params.transform, symbol = params.symbol, title = params.title, maskId = params.maskId, titleId = params.titleId, extra = params.extra, _params$watchable = params.watchable, watchable = _params$watchable === void 0 ? false : _params$watchable;
  var _ref2 = mask.found ? mask : main, width = _ref2.width, height = _ref2.height;
  var isUploadedIcon = prefix3 === "fak";
  var attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""].filter(function(c) {
    return extra.classes.indexOf(c) === -1;
  }).filter(function(c) {
    return c !== "" || !!c;
  }).concat(extra.classes).join(" ");
  var content3 = {
    children: [],
    attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
      "data-prefix": prefix3,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    })
  };
  var uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content3.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) {
    content3.children.push({
      tag: "title",
      attributes: {
        id: content3.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content3.attributes.title;
  }
  var args = _objectSpread2(_objectSpread2({}, content3), {}, {
    prefix: prefix3,
    iconName,
    main,
    mask,
    maskId,
    transform,
    symbol,
    styles: _objectSpread2(_objectSpread2({}, uploadedIconWidthStyle), extra.styles)
  });
  var _ref22 = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  }, children = _ref22.children, attributes3 = _ref22.attributes;
  args.children = children;
  args.attributes = attributes3;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  var content3 = params.content, width = params.width, height = params.height, transform = params.transform, title = params.title, extra = params.extra, _params$watchable2 = params.watchable, watchable = _params$watchable2 === void 0 ? false : _params$watchable2;
  var attributes3 = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    "title": title
  } : {}), {}, {
    "class": extra.classes.join(" ")
  });
  if (watchable) {
    attributes3[DATA_FA_I2SVG] = "";
  }
  var styles2 = _objectSpread2({}, extra.styles);
  if (transformIsMeaningful(transform)) {
    styles2["transform"] = transformForCss({
      transform,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  var styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes3["style"] = styleString;
  }
  var val = [];
  val.push({
    tag: "span",
    attributes: attributes3,
    children: [content3]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  var content3 = params.content, title = params.title, extra = params.extra;
  var attributes3 = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    "title": title
  } : {}), {}, {
    "class": extra.classes.join(" ")
  });
  var styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes3["style"] = styleString;
  }
  var val = [];
  val.push({
    tag: "span",
    attributes: attributes3,
    children: [content3]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
var styles$1 = namespace.styles;
function asFoundIcon(icon3) {
  var width = icon3[0];
  var height = icon3[1];
  var _icon$slice = icon3.slice(4), _icon$slice2 = _slicedToArray(_icon$slice, 1), vectorData = _icon$slice2[0];
  var element4 = null;
  if (Array.isArray(vectorData)) {
    element4 = {
      tag: "g",
      attributes: {
        class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element4 = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element4
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix3) {
  if (!PRODUCTION && !config.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix3, '" is missing.'));
  }
}
function findIcon(iconName, prefix3) {
  var givenPrefix = prefix3;
  if (prefix3 === "fa" && config.styleDefault !== null) {
    prefix3 = getDefaultUsablePrefix();
  }
  return new Promise(function(resolve, reject) {
    var val = {
      found: false,
      width: 512,
      height: 512,
      icon: callProvided("missingIconAbstract") || {}
    };
    if (givenPrefix === "fa") {
      var shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix3 = shim.prefix || prefix3;
    }
    if (iconName && prefix3 && styles$1[prefix3] && styles$1[prefix3][iconName]) {
      var icon3 = styles$1[prefix3][iconName];
      return resolve(asFoundIcon(icon3));
    }
    maybeNotifyMissing(iconName, prefix3);
    resolve(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
      icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    }));
  });
}
var noop$1 = function noop4() {
};
var p = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = 'FA "6.4.2"';
var begin = function begin2(name) {
  p.mark("".concat(preamble, " ").concat(name, " begins"));
  return function() {
    return end(name);
  };
};
var end = function end2(name) {
  p.mark("".concat(preamble, " ").concat(name, " ends"));
  p.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};
var noop$2 = function noop5() {
};
function isWatched(node2) {
  var i2svg2 = node2.getAttribute ? node2.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg2 === "string";
}
function hasPrefixAndIcon(node2) {
  var prefix3 = node2.getAttribute ? node2.getAttribute(DATA_PREFIX) : null;
  var icon3 = node2.getAttribute ? node2.getAttribute(DATA_ICON) : null;
  return prefix3 && icon3;
}
function hasBeenReplaced(node2) {
  return node2 && node2.classList && node2.classList.contains && node2.classList.contains(config.replacementClass);
}
function getMutator() {
  if (config.autoReplaceSvg === true) {
    return mutators.replace;
  }
  var mutator = mutators[config.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement35(tag) {
  return DOCUMENT.createElement(tag);
}
function convertSVG(abstractObj) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$ceFn = params.ceFn, ceFn = _params$ceFn === void 0 ? abstractObj.tag === "svg" ? createElementNS : createElement35 : _params$ceFn;
  if (typeof abstractObj === "string") {
    return DOCUMENT.createTextNode(abstractObj);
  }
  var tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  var children = abstractObj.children || [];
  children.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node2) {
  var comment2 = " ".concat(node2.outerHTML, " ");
  comment2 = "".concat(comment2, "Font Awesome fontawesome.com ");
  return comment2;
}
var mutators = {
  replace: function replace(mutation) {
    var node2 = mutation[0];
    if (node2.parentNode) {
      mutation[1].forEach(function(_abstract) {
        node2.parentNode.insertBefore(convertSVG(_abstract), node2);
      });
      if (node2.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
        var comment2 = DOCUMENT.createComment(nodeAsComment(node2));
        node2.parentNode.replaceChild(comment2, node2);
      } else {
        node2.remove();
      }
    }
  },
  nest: function nest(mutation) {
    var node2 = mutation[0];
    var _abstract2 = mutation[1];
    if (~classArray(node2).indexOf(config.replacementClass)) {
      return mutators.replace(mutation);
    }
    var forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
    delete _abstract2[0].attributes.id;
    if (_abstract2[0].attributes.class) {
      var splitClasses = _abstract2[0].attributes.class.split(" ").reduce(function(acc, cls) {
        if (cls === config.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      _abstract2[0].attributes.class = splitClasses.toSvg.join(" ");
      if (splitClasses.toNode.length === 0) {
        node2.removeAttribute("class");
      } else {
        node2.setAttribute("class", splitClasses.toNode.join(" "));
      }
    }
    var newInnerHTML = _abstract2.map(function(a) {
      return toHtml(a);
    }).join("\n");
    node2.setAttribute(DATA_FA_I2SVG, "");
    node2.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  var callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    var frame = performOperationSync;
    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame(function() {
      var mutator = getMutator();
      var mark2 = perf.begin("mutate");
      mutations.map(mutator);
      mark2();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config.observeMutations) {
    return;
  }
  var _options$treeCallback = options.treeCallback, treeCallback = _options$treeCallback === void 0 ? noop$2 : _options$treeCallback, _options$nodeCallback = options.nodeCallback, nodeCallback = _options$nodeCallback === void 0 ? noop$2 : _options$nodeCallback, _options$pseudoElemen = options.pseudoElementsCallback, pseudoElementsCallback = _options$pseudoElemen === void 0 ? noop$2 : _options$pseudoElemen, _options$observeMutat = options.observeMutationsRoot, observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
  mo = new MUTATION_OBSERVER(function(objects) {
    if (disabled)
      return;
    var defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach(function(mutationRecord) {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)), prefix3 = _getCanonicalIcon.prefix, iconName = _getCanonicalIcon.iconName;
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix3 || defaultPrefix);
          if (iconName)
            mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM)
    return;
  mo.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo)
    return;
  mo.disconnect();
}
function styleParser(node2) {
  var style3 = node2.getAttribute("style");
  var val = [];
  if (style3) {
    val = style3.split(";").reduce(function(acc, style4) {
      var styles2 = style4.split(":");
      var prop = styles2[0];
      var value = styles2.slice(1);
      if (prop && value.length > 0) {
        acc[prop] = value.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node2) {
  var existingPrefix = node2.getAttribute("data-prefix");
  var existingIconName = node2.getAttribute("data-icon");
  var innerText = node2.innerText !== void 0 ? node2.innerText.trim() : "";
  var val = getCanonicalIcon(classArray(node2));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node2.innerText) || byUnicode(val.prefix, toHex(node2.innerText));
  }
  if (!val.iconName && config.autoFetchSvg && node2.firstChild && node2.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node2.firstChild.data;
  }
  return val;
}
function attributesParser(node2) {
  var extraAttributes = toArray(node2.attributes).reduce(function(acc, attr) {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  var title = node2.getAttribute("title");
  var titleId = node2.getAttribute("data-fa-title-id");
  if (config.autoA11y) {
    if (title) {
      extraAttributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes["aria-hidden"] = "true";
      extraAttributes["focusable"] = "false";
    }
  }
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node2) {
  var parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  var _classParser = classParser(node2), iconName = _classParser.iconName, prefix3 = _classParser.prefix, extraClasses = _classParser.rest;
  var extraAttributes = attributesParser(node2);
  var pluginMeta = chainHooks("parseNodeAttributes", {}, node2);
  var extraStyles = parser.styleParser ? styleParser(node2) : [];
  return _objectSpread2({
    iconName,
    title: node2.getAttribute("title"),
    titleId: node2.getAttribute("data-fa-title-id"),
    prefix: prefix3,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}
var styles$2 = namespace.styles;
function generateMutation(node2) {
  var nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node2, {
    styleParser: false
  }) : parseMeta(node2);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node2, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node2, nodeMeta);
  }
}
var knownPrefixes = /* @__PURE__ */ new Set();
FAMILIES.map(function(family) {
  knownPrefixes.add("fa-".concat(family));
});
Object.keys(PREFIX_TO_STYLE[FAMILY_CLASSIC]).map(knownPrefixes.add.bind(knownPrefixes));
Object.keys(PREFIX_TO_STYLE[FAMILY_SHARP]).map(knownPrefixes.add.bind(knownPrefixes));
knownPrefixes = _toConsumableArray(knownPrefixes);
function onTree(root3) {
  var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!IS_DOM)
    return Promise.resolve();
  var htmlClassList = DOCUMENT.documentElement.classList;
  var hclAdd = function hclAdd2(suffix2) {
    return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix2));
  };
  var hclRemove = function hclRemove2(suffix2) {
    return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix2));
  };
  var prefixes2 = config.autoFetchSvg ? knownPrefixes : FAMILIES.map(function(f) {
    return "fa-".concat(f);
  }).concat(Object.keys(styles$2));
  if (!prefixes2.includes("fa")) {
    prefixes2.push("fa");
  }
  var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map(function(p2) {
    return ".".concat(p2, ":not([").concat(DATA_FA_I2SVG, "])");
  })).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  var candidates = [];
  try {
    candidates = toArray(root3.querySelectorAll(prefixesDomQuery));
  } catch (e2) {
  }
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  var mark2 = perf.begin("onTree");
  var mutations = candidates.reduce(function(acc, node2) {
    try {
      var mutation = generateMutation(node2);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e2) {
      if (!PRODUCTION) {
        if (e2.name === "MissingIcon") {
          console.error(e2);
        }
      }
    }
    return acc;
  }, []);
  return new Promise(function(resolve, reject) {
    Promise.all(mutations).then(function(resolvedMutations) {
      perform(resolvedMutations, function() {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function")
          callback();
        mark2();
        resolve();
      });
    }).catch(function(e2) {
      mark2();
      reject(e2);
    });
  });
}
function onNode(node2) {
  var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  generateMutation(node2).then(function(mutation) {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next) {
  return function(maybeIconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    var mask = params.mask;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
      mask
    }));
  };
}
var render = function render2(iconDefinition) {
  var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _params$transform = params.transform, transform = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$symbol = params.symbol, symbol = _params$symbol === void 0 ? false : _params$symbol, _params$mask = params.mask, mask = _params$mask === void 0 ? null : _params$mask, _params$maskId = params.maskId, maskId = _params$maskId === void 0 ? null : _params$maskId, _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$titleId = params.titleId, titleId = _params$titleId === void 0 ? null : _params$titleId, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes3 = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
  if (!iconDefinition)
    return;
  var prefix3 = iconDefinition.prefix, iconName = iconDefinition.iconName, icon3 = iconDefinition.icon;
  return domVariants(_objectSpread2({
    type: "icon"
  }, iconDefinition), function() {
    callHooks("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    if (config.autoA11y) {
      if (title) {
        attributes3["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes3["aria-hidden"] = "true";
        attributes3["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon3),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix: prefix3,
      iconName,
      transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes: attributes3,
        styles: styles2,
        classes
      }
    });
  });
};
var ReplaceElements = {
  mixout: function mixout2() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks: function hooks2() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides: function provides(providers$$1) {
    providers$$1.i2svg = function(params) {
      var _params$node = params.node, node2 = _params$node === void 0 ? DOCUMENT : _params$node, _params$callback = params.callback, callback = _params$callback === void 0 ? function() {
      } : _params$callback;
      return onTree(node2, callback);
    };
    providers$$1.generateSvgReplacementMutation = function(node2, nodeMeta) {
      var iconName = nodeMeta.iconName, title = nodeMeta.title, titleId = nodeMeta.titleId, prefix3 = nodeMeta.prefix, transform = nodeMeta.transform, symbol = nodeMeta.symbol, mask = nodeMeta.mask, maskId = nodeMeta.maskId, extra = nodeMeta.extra;
      return new Promise(function(resolve, reject) {
        Promise.all([findIcon(iconName, prefix3), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(_ref2) {
          var _ref22 = _slicedToArray(_ref2, 2), main = _ref22[0], mask2 = _ref22[1];
          resolve([node2, makeInlineSvgAbstract({
            icons: {
              main,
              mask: mask2
            },
            prefix: prefix3,
            iconName,
            transform,
            symbol,
            maskId,
            title,
            titleId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function(_ref3) {
      var children = _ref3.children, attributes3 = _ref3.attributes, main = _ref3.main, transform = _ref3.transform, styles2 = _ref3.styles;
      var styleString = joinStyles(styles2);
      if (styleString.length > 0) {
        attributes3["style"] = styleString;
      }
      var nextChild;
      if (transformIsMeaningful(transform)) {
        nextChild = callProvided("generateAbstractTransformGrouping", {
          main,
          transform,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }
      children.push(nextChild || main.icon);
      return {
        children,
        attributes: attributes3
      };
    };
  }
};
var Layers = {
  mixout: function mixout3() {
    return {
      layer: function layer2(assembler) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes;
        return domVariants({
          type: "layer"
        }, function() {
          callHooks("beforeDOMElementCreation", {
            assembler,
            params
          });
          var children = [];
          assembler(function(args) {
            Array.isArray(args) ? args.map(function(a) {
              children = children.concat(a.abstract);
            }) : children = children.concat(args.abstract);
          });
          return [{
            tag: "span",
            attributes: {
              class: ["".concat(config.cssPrefix, "-layers")].concat(_toConsumableArray(classes)).join(" ")
            },
            children
          }];
        });
      }
    };
  }
};
var LayersCounter = {
  mixout: function mixout4() {
    return {
      counter: function counter2(content3) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes3 = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: "counter",
          content: content3
        }, function() {
          callHooks("beforeDOMElementCreation", {
            content: content3,
            params
          });
          return makeLayersCounterAbstract({
            content: content3.toString(),
            title,
            extra: {
              attributes: attributes3,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-counter")].concat(_toConsumableArray(classes))
            }
          });
        });
      }
    };
  }
};
var LayersText = {
  mixout: function mixout5() {
    return {
      text: function text6(content3) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$transform = params.transform, transform = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes3 = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
        return domVariants({
          type: "text",
          content: content3
        }, function() {
          callHooks("beforeDOMElementCreation", {
            content: content3,
            params
          });
          return makeLayersTextAbstract({
            content: content3,
            transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
            title,
            extra: {
              attributes: attributes3,
              styles: styles2,
              classes: ["".concat(config.cssPrefix, "-layers-text")].concat(_toConsumableArray(classes))
            }
          });
        });
      }
    };
  },
  provides: function provides2(providers$$1) {
    providers$$1.generateLayersText = function(node2, nodeMeta) {
      var title = nodeMeta.title, transform = nodeMeta.transform, extra = nodeMeta.extra;
      var width = null;
      var height = null;
      if (IS_IE) {
        var computedFontSize = parseInt(getComputedStyle(node2).fontSize, 10);
        var boundingClientRect = node2.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      if (config.autoA11y && !title) {
        extra.attributes["aria-hidden"] = "true";
      }
      return Promise.resolve([node2, makeLayersTextAbstract({
        content: node2.innerHTML,
        width,
        height,
        transform,
        title,
        extra,
        watchable: true
      })]);
    };
  }
};
var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
function hexValueFromContent(content3) {
  var cleaned = content3.replace(CLEAN_CONTENT_PATTERN, "");
  var codePoint = codePointAt(cleaned, 0);
  var isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  var isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function replaceForPosition(node2, position6) {
  var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position6.replace(":", "-"));
  return new Promise(function(resolve, reject) {
    if (node2.getAttribute(pendingAttribute) !== null) {
      return resolve();
    }
    var children = toArray(node2.children);
    var alreadyProcessedPseudoElement = children.filter(function(c) {
      return c.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position6;
    })[0];
    var styles2 = WINDOW.getComputedStyle(node2, position6);
    var fontFamily = styles2.getPropertyValue("font-family").match(FONT_FAMILY_PATTERN);
    var fontWeight = styles2.getPropertyValue("font-weight");
    var content3 = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamily) {
      node2.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamily && content3 !== "none" && content3 !== "") {
      var _content = styles2.getPropertyValue("content");
      var family = ~["Sharp"].indexOf(fontFamily[2]) ? FAMILY_SHARP : FAMILY_CLASSIC;
      var prefix3 = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(fontFamily[2]) ? STYLE_TO_PREFIX[family][fontFamily[2].toLowerCase()] : FONT_WEIGHT_TO_PREFIX[family][fontWeight];
      var _hexValueFromContent = hexValueFromContent(_content), hexValue = _hexValueFromContent.value, isSecondary = _hexValueFromContent.isSecondary;
      var isV4 = fontFamily[0].startsWith("FontAwesome");
      var iconName = byUnicode(prefix3, hexValue);
      var iconIdentifier = iconName;
      if (isV4) {
        var iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix3 = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix3 || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node2.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node2.removeChild(alreadyProcessedPseudoElement);
        }
        var meta = blankMeta();
        var extra = meta.extra;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position6;
        findIcon(iconName, prefix3).then(function(main) {
          var _abstract = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix: prefix3,
            iconName: iconIdentifier,
            extra,
            watchable: true
          }));
          var element4 = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (position6 === "::before") {
            node2.insertBefore(element4, node2.firstChild);
          } else {
            node2.appendChild(element4);
          }
          element4.outerHTML = _abstract.map(function(a) {
            return toHtml(a);
          }).join("\n");
          node2.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}
function replace2(node2) {
  return Promise.all([replaceForPosition(node2, "::before"), replaceForPosition(node2, "::after")]);
}
function processable(node2) {
  return node2.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node2.tagName.toUpperCase()) && !node2.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node2.parentNode || node2.parentNode.tagName !== "svg");
}
function searchPseudoElements(root3) {
  if (!IS_DOM)
    return;
  return new Promise(function(resolve, reject) {
    var operations = toArray(root3.querySelectorAll("*")).filter(processable).map(replace2);
    var end4 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(function() {
      end4();
      enableObservation();
      resolve();
    }).catch(function() {
      end4();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks: function hooks3() {
    return {
      mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides: function provides3(providers$$1) {
    providers$$1.pseudoElements2svg = function(params) {
      var _params$node = params.node, node2 = _params$node === void 0 ? DOCUMENT : _params$node;
      if (config.searchPseudoElements) {
        searchPseudoElements(node2);
      }
    };
  }
};
var _unwatched = false;
var MutationObserver$1 = {
  mixout: function mixout6() {
    return {
      dom: {
        unwatch: function unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks: function hooks4() {
    return {
      bootstrap: function bootstrap() {
        observe(chainHooks("mutationObserverCallbacks", {}));
      },
      noAuto: function noAuto3() {
        disconnect();
      },
      watch: function watch2(params) {
        var observeMutationsRoot = params.observeMutationsRoot;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks("mutationObserverCallbacks", {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};
var parseTransformString = function parseTransformString2(transformString) {
  var transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce(function(acc, n2) {
    var parts = n2.toLowerCase().split("-");
    var first = parts[0];
    var rest = parts.slice(1).join("-");
    if (first && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform);
};
var PowerTransforms = {
  mixout: function mixout7() {
    return {
      parse: {
        transform: function transform(transformString) {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks: function hooks5() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node2) {
        var transformString = node2.getAttribute("data-fa-transform");
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides: function provides4(providers2) {
    providers2.generateAbstractTransformGrouping = function(_ref2) {
      var main = _ref2.main, transform = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
      var outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
      var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
      var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
      var inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      var path4 = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      var operations = {
        outer,
        inner,
        path: path4
      };
      return {
        tag: "g",
        attributes: _objectSpread2({}, operations.outer),
        children: [{
          tag: "g",
          attributes: _objectSpread2({}, operations.inner),
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
          }]
        }]
      };
    };
  }
};
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(_abstract) {
  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (_abstract.attributes && (_abstract.attributes.fill || force)) {
    _abstract.attributes.fill = "black";
  }
  return _abstract;
}
function deGroup(_abstract2) {
  if (_abstract2.tag === "g") {
    return _abstract2.children;
  } else {
    return [_abstract2];
  }
}
var Masks = {
  hooks: function hooks6() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node2) {
        var maskData = node2.getAttribute("data-fa-mask");
        var mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map(function(i) {
          return i.trim();
        }));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node2.getAttribute("data-fa-mask-id");
        return accumulator;
      }
    };
  },
  provides: function provides5(providers2) {
    providers2.generateAbstractMask = function(_ref2) {
      var children = _ref2.children, attributes3 = _ref2.attributes, main = _ref2.main, mask = _ref2.mask, explicitMaskId = _ref2.maskId, transform = _ref2.transform;
      var mainWidth = main.width, mainPath = main.icon;
      var maskWidth = mask.width, maskPath = mask.icon;
      var trans = transformForSvg({
        transform,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      var maskRect = {
        tag: "rect",
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          fill: "white"
        })
      };
      var maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      var maskInnerGroup = {
        tag: "g",
        attributes: _objectSpread2({}, trans.inner),
        children: [fillBlack(_objectSpread2({
          tag: mainPath.tag,
          attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
        }, maskInnerGroupChildrenMixin))]
      };
      var maskOuterGroup = {
        tag: "g",
        attributes: _objectSpread2({}, trans.outer),
        children: [maskInnerGroup]
      };
      var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      var maskTag = {
        tag: "mask",
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          id: maskId,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [maskRect, maskOuterGroup]
      };
      var defs = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children.push(defs, {
        tag: "rect",
        attributes: _objectSpread2({
          fill: "currentColor",
          "clip-path": "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")")
        }, ALL_SPACE)
      });
      return {
        children,
        attributes: attributes3
      };
    };
  }
};
var MissingIconIndicator = {
  provides: function provides6(providers2) {
    var reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }
    providers2.missingIconAbstract = function() {
      var gChildren = [];
      var FILL = {
        fill: "currentColor"
      };
      var ANIMATION_BASE = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
        attributeName: "opacity"
      });
      var dot = {
        tag: "circle",
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      if (!reduceMotion) {
        dot.children.push({
          tag: "animate",
          attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          })
        }, {
          tag: "animate",
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: "1;0;1;1;0;1;"
          })
        });
      }
      gChildren.push(dot);
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: reduceMotion ? [] : [{
          tag: "animate",
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      });
      if (!reduceMotion) {
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          }),
          children: [{
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "0;0;1;1;0;0;"
            })
          }]
        });
      }
      return {
        tag: "g",
        attributes: {
          "class": "missing"
        },
        children: gChildren
      };
    };
  }
};
var SvgSymbols = {
  hooks: function hooks7() {
    return {
      parseNodeAttributes: function parseNodeAttributes(accumulator, node2) {
        var symbolData = node2.getAttribute("data-fa-symbol");
        var symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
        accumulator["symbol"] = symbol;
        return accumulator;
      }
    };
  }
};
var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
registerPlugins(plugins, {
  mixoutsTo: api
});
var noAuto$1 = api.noAuto;
var config$1 = api.config;
var library$1 = api.library;
var dom$1 = api.dom;
var parse$1 = api.parse;
var findIconDefinition$1 = api.findIconDefinition;
var toHtml$1 = api.toHtml;
var icon2 = api.icon;
var layer = api.layer;
var text5 = api.text;
var counter = api.counter;

// node_modules/@fortawesome/react-fontawesome/index.es.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react14 = __toESM(require_react());
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray2(arr2) {
  return _arrayWithoutHoles2(arr2) || _iterableToArray2(arr2) || _unsupportedIterableToArray2(arr2) || _nonIterableSpread2();
}
function _arrayWithoutHoles2(arr2) {
  if (Array.isArray(arr2))
    return _arrayLikeToArray2(arr2);
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr2, len) {
  if (len == null || len > arr2.length)
    len = arr2.length;
  for (var i = 0, arr22 = new Array(len); i < len; i++)
    arr22[i] = arr2[i];
  return arr22;
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function classList(props) {
  var _classes;
  var beat = props.beat, fade = props.fade, beatFade = props.beatFade, bounce = props.bounce, shake = props.shake, flash = props.flash, spin = props.spin, spinPulse = props.spinPulse, spinReverse = props.spinReverse, pulse = props.pulse, fixedWidth = props.fixedWidth, inverse = props.inverse, border = props.border, listItem2 = props.listItem, flip = props.flip, size = props.size, rotation = props.rotation, pull = props.pull;
  var classes = (_classes = {
    "fa-beat": beat,
    "fa-fade": fade,
    "fa-beat-fade": beatFade,
    "fa-bounce": bounce,
    "fa-shake": shake,
    "fa-flash": flash,
    "fa-spin": spin,
    "fa-spin-reverse": spinReverse,
    "fa-spin-pulse": spinPulse,
    "fa-pulse": pulse,
    "fa-fw": fixedWidth,
    "fa-inverse": inverse,
    "fa-border": border,
    "fa-li": listItem2,
    "fa-flip": flip === true,
    "fa-flip-horizontal": flip === "horizontal" || flip === "both",
    "fa-flip-vertical": flip === "vertical" || flip === "both"
  }, _defineProperty2(_classes, "fa-".concat(size), typeof size !== "undefined" && size !== null), _defineProperty2(_classes, "fa-rotate-".concat(rotation), typeof rotation !== "undefined" && rotation !== null && rotation !== 0), _defineProperty2(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty2(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
  return Object.keys(classes).map(function(key) {
    return classes[key] ? key : null;
  }).filter(function(key) {
    return key;
  });
}
function _isNumerical(obj) {
  obj = obj - 0;
  return obj === obj;
}
function camelize(string3) {
  if (_isNumerical(string3)) {
    return string3;
  }
  string3 = string3.replace(/[\-_\s]+(.)?/g, function(match3, chr) {
    return chr ? chr.toUpperCase() : "";
  });
  return string3.substr(0, 1).toLowerCase() + string3.substr(1);
}
var _excluded = ["style"];
function capitalize2(val) {
  return val.charAt(0).toUpperCase() + val.slice(1);
}
function styleToObject(style3) {
  return style3.split(";").map(function(s3) {
    return s3.trim();
  }).filter(function(s3) {
    return s3;
  }).reduce(function(acc, pair) {
    var i = pair.indexOf(":");
    var prop = camelize(pair.slice(0, i));
    var value = pair.slice(i + 1).trim();
    prop.startsWith("webkit") ? acc[capitalize2(prop)] = value : acc[prop] = value;
    return acc;
  }, {});
}
function convert2(createElement133, element4) {
  var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof element4 === "string") {
    return element4;
  }
  var children = (element4.children || []).map(function(child) {
    return convert2(createElement133, child);
  });
  var mixins = Object.keys(element4.attributes || {}).reduce(function(acc, key) {
    var val = element4.attributes[key];
    switch (key) {
      case "class":
        acc.attrs["className"] = val;
        delete element4.attributes["class"];
        break;
      case "style":
        acc.attrs["style"] = styleToObject(val);
        break;
      default:
        if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
          acc.attrs[key.toLowerCase()] = val;
        } else {
          acc.attrs[camelize(key)] = val;
        }
    }
    return acc;
  }, {
    attrs: {}
  });
  var _extraProps$style = extraProps.style, existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style, remaining = _objectWithoutProperties(extraProps, _excluded);
  mixins.attrs["style"] = _objectSpread22(_objectSpread22({}, mixins.attrs["style"]), existingStyle);
  return createElement133.apply(void 0, [element4.tag, _objectSpread22(_objectSpread22({}, mixins.attrs), remaining)].concat(_toConsumableArray2(children)));
}
var PRODUCTION2 = false;
try {
  PRODUCTION2 = false;
} catch (e2) {
}
function log() {
  if (!PRODUCTION2 && console && typeof console.error === "function") {
    var _console;
    (_console = console).error.apply(_console, arguments);
  }
}
function normalizeIconArgs(icon3) {
  if (icon3 && _typeof3(icon3) === "object" && icon3.prefix && icon3.iconName && icon3.icon) {
    return icon3;
  }
  if (parse$1.icon) {
    return parse$1.icon(icon3);
  }
  if (icon3 === null) {
    return null;
  }
  if (icon3 && _typeof3(icon3) === "object" && icon3.prefix && icon3.iconName) {
    return icon3;
  }
  if (Array.isArray(icon3) && icon3.length === 2) {
    return {
      prefix: icon3[0],
      iconName: icon3[1]
    };
  }
  if (typeof icon3 === "string") {
    return {
      prefix: "fas",
      iconName: icon3
    };
  }
}
function objectWithKey(key, value) {
  return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty2({}, key, value) : {};
}
var FontAwesomeIcon = /* @__PURE__ */ import_react14.default.forwardRef(function(props, ref2) {
  var iconArgs = props.icon, maskArgs = props.mask, symbol = props.symbol, className = props.className, title = props.title, titleId = props.titleId, maskId = props.maskId;
  var iconLookup = normalizeIconArgs(iconArgs);
  var classes = objectWithKey("classes", [].concat(_toConsumableArray2(classList(props)), _toConsumableArray2(className.split(" "))));
  var transform = objectWithKey("transform", typeof props.transform === "string" ? parse$1.transform(props.transform) : props.transform);
  var mask = objectWithKey("mask", normalizeIconArgs(maskArgs));
  var renderedIcon = icon2(iconLookup, _objectSpread22(_objectSpread22(_objectSpread22(_objectSpread22({}, classes), transform), mask), {}, {
    symbol,
    title,
    titleId,
    maskId
  }));
  if (!renderedIcon) {
    log("Could not find icon", iconLookup);
    return null;
  }
  var abstract = renderedIcon.abstract;
  var extraProps = {
    ref: ref2
  };
  Object.keys(props).forEach(function(key) {
    if (!FontAwesomeIcon.defaultProps.hasOwnProperty(key)) {
      extraProps[key] = props[key];
    }
  });
  return convertCurry(abstract[0], extraProps);
});
FontAwesomeIcon.displayName = "FontAwesomeIcon";
FontAwesomeIcon.propTypes = {
  beat: import_prop_types2.default.bool,
  border: import_prop_types2.default.bool,
  beatFade: import_prop_types2.default.bool,
  bounce: import_prop_types2.default.bool,
  className: import_prop_types2.default.string,
  fade: import_prop_types2.default.bool,
  flash: import_prop_types2.default.bool,
  mask: import_prop_types2.default.oneOfType([import_prop_types2.default.object, import_prop_types2.default.array, import_prop_types2.default.string]),
  maskId: import_prop_types2.default.string,
  fixedWidth: import_prop_types2.default.bool,
  inverse: import_prop_types2.default.bool,
  flip: import_prop_types2.default.oneOf([true, false, "horizontal", "vertical", "both"]),
  icon: import_prop_types2.default.oneOfType([import_prop_types2.default.object, import_prop_types2.default.array, import_prop_types2.default.string]),
  listItem: import_prop_types2.default.bool,
  pull: import_prop_types2.default.oneOf(["right", "left"]),
  pulse: import_prop_types2.default.bool,
  rotation: import_prop_types2.default.oneOf([0, 90, 180, 270]),
  shake: import_prop_types2.default.bool,
  size: import_prop_types2.default.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: import_prop_types2.default.bool,
  spinPulse: import_prop_types2.default.bool,
  spinReverse: import_prop_types2.default.bool,
  symbol: import_prop_types2.default.oneOfType([import_prop_types2.default.bool, import_prop_types2.default.string]),
  title: import_prop_types2.default.string,
  titleId: import_prop_types2.default.string,
  transform: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.object]),
  swapOpacity: import_prop_types2.default.bool
};
FontAwesomeIcon.defaultProps = {
  border: false,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: false,
  inverse: false,
  flip: false,
  icon: null,
  listItem: false,
  pull: null,
  pulse: false,
  rotation: null,
  size: null,
  spin: false,
  spinPulse: false,
  spinReverse: false,
  beat: false,
  fade: false,
  beatFade: false,
  bounce: false,
  shake: false,
  symbol: false,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: false
};
var convertCurry = convert2.bind(null, import_react14.default.createElement);

// src/components/attributes/types/StoryCircleStageComponent.tsx
var React38 = __toESM(require_react());
function StoryCircleStageComponent({
  element: element4,
  attribute,
  stage,
  isEditable
}) {
  var _a, _b;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [value, setValue] = React38.useState((_b = (_a = attribute == null ? void 0 : attribute.value) == null ? void 0 : _a[stage.toLowerCase()]) != null ? _b : "");
  const [editing, setEditing] = React38.useState(false);
  const [showHelp, setShowHelp] = React38.useState(false);
  function reset() {
    var _a2, _b2;
    setValue((_b2 = (_a2 = attribute == null ? void 0 : attribute.value) == null ? void 0 : _a2[stage.toLowerCase()]) != null ? _b2 : "");
    setEditing(false);
  }
  function saveStage(newValue) {
    if (newValue === void 0) {
      setEditing(false);
      return;
    }
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockSubData([attribute.id, stage.toLowerCase()], newValue).then(() => {
      setEditing(false);
    });
  }
  let content3;
  if (editing) {
    content3 = /* @__PURE__ */ React38.createElement("div", {
      className: `${isEditable && "sm:col-span-1 lg:col-span-6"}`
    }, /* @__PURE__ */ React38.createElement("div", {
      className: "grid grid-cols-1"
    }, /* @__PURE__ */ React38.createElement("div", null, /* @__PURE__ */ React38.createElement(MarkdownEditorComponent, {
      initialValue: value,
      campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath,
      onChange: setValue,
      className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
    })), /* @__PURE__ */ React38.createElement("div", {
      className: "flex justify-end mt-3"
    }, /* @__PURE__ */ React38.createElement("button", {
      className: "rpgm-secondary",
      onClick: reset
    }, t2("buttons.cancel")), /* @__PURE__ */ React38.createElement("button", {
      className: "rpgm-primary",
      onClick: () => saveStage(value)
    }, t2("buttons.save")))));
  } else if (isEditable) {
    content3 = /* @__PURE__ */ React38.createElement("div", {
      className: `border border-[--background-modifier-border] hover:border-[--background-modifier-border-hover] rounded-md p-3 cursor-text min-h-[3rem] ${isEditable && "sm:col-span-1 lg:col-span-6"}`,
      onClick: () => setEditing(!editing)
    }, /* @__PURE__ */ React38.createElement(MarkdownComponent, {
      value: attribute.value[stage.toLowerCase()]
    }));
  } else {
    content3 = /* @__PURE__ */ React38.createElement("div", null, /* @__PURE__ */ React38.createElement(MarkdownComponent, {
      value: attribute.value[stage.toLowerCase()]
    }));
  }
  return /* @__PURE__ */ React38.createElement(React38.Fragment, null, /* @__PURE__ */ React38.createElement("div", {
    className: `!font-bold ${isEditable && "sm:col-span-1 lg:col-span-1"}`
  }, /* @__PURE__ */ React38.createElement("div", null, t2("storycircle." + stage.toLowerCase())), /* @__PURE__ */ React38.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React38.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), content3, showHelp && /* @__PURE__ */ React38.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React38.createElement(MarkdownComponent, {
    value: t2("storycircle.description", { context: stage.toLocaleLowerCase() })
  })));
}

// src/components/attributes/types/StoryCircleAttributeComponent.tsx
function StoryCircleAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React39.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] overflow-hidden bg-[--background-primary] mb-3 p-3"
  }, /* @__PURE__ */ React39.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("attributes.storycircle")), /* @__PURE__ */ React39.createElement("div", {
    className: `gap-3 grid grid-cols-1 ${isEditable && "sm:grid-cols-1 lg:grid-cols-7"}`
  }, Object.entries(StoryCircleStage).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => {
    return /* @__PURE__ */ React39.createElement(StoryCircleStageComponent, {
      key,
      element: element4,
      attribute,
      stage: key,
      isEditable
    });
  })));
}

// src/components/conflict/ConflictComponent.tsx
var React40 = __toESM(require_react());
function ConflictComponent({
  element: element4,
  attribute,
  isEditable
}) {
  var _a;
  const api2 = useApi();
  const app = useApp();
  const [edit, setEdit] = React40.useState(false);
  const [conflictValue, setConflictValue] = React40.useState((_a = attribute.value) != null ? _a : {
    status: "planned"
  });
  const save = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    attribute.value = conflictValue;
    codeblockService.updateCodeblockData(attribute.id, conflictValue).then(() => {
      setEdit(false);
    });
  };
  const remove2 = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    attribute.value = conflictValue;
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      setEdit(false);
    });
  };
  const setValue = (subAttibute, newValue) => {
    setConflictValue(__spreadProps(__spreadValues({}, conflictValue), { [subAttibute]: newValue }));
  };
  const reset = () => {
    setEdit(false);
  };
  const campaignPath = element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath;
  if (edit)
    return /* @__PURE__ */ React40.createElement(Edit, {
      element: element4,
      campaignPath,
      attribute,
      setValue,
      save,
      remove: remove2,
      reset
    });
  if (isEditable)
    return /* @__PURE__ */ React40.createElement(View, {
      attribute,
      campaignPath,
      setEdit
    });
  return /* @__PURE__ */ React40.createElement(Browse, {
    attribute,
    campaignPath
  });
}
function Edit({
  element: element4,
  campaignPath,
  attribute,
  setValue,
  save,
  remove: remove2,
  reset
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React40.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] overflow-hidden bg-[--background-primary] mb-3 p-3"
  }, /* @__PURE__ */ React40.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("attributes.conflict")), /* @__PURE__ */ React40.createElement("div", {
    className: "gap-3 grid grid-cols-7"
  }, /* @__PURE__ */ React40.createElement(EditableTitleAttribute, {
    attribute,
    campaignPath,
    setValue
  }), /* @__PURE__ */ React40.createElement(EditableStatusAttribute, {
    attribute,
    setValue
  }), /* @__PURE__ */ React40.createElement(EditableCategoryAttribute, {
    attribute,
    setValue
  }), /* @__PURE__ */ React40.createElement(EditableInvolvementAttribute, {
    attribute,
    setValue
  }), /* @__PURE__ */ React40.createElement(EditableLongTextAttribute, {
    attribute,
    campaignPath,
    setValue,
    type: "description"
  }), /* @__PURE__ */ React40.createElement(EditableConflictStakesAttribute, {
    attribute,
    setValue
  }), /* @__PURE__ */ React40.createElement(EditableRelationshipsAttribute, {
    attribute,
    type: "opposingforces",
    campaignPath,
    setValue
  }), /* @__PURE__ */ React40.createElement(EditableRelationshipsAttribute, {
    attribute,
    type: "events",
    campaignPath,
    setValue
  }), /* @__PURE__ */ React40.createElement(EditableLongTextAttribute, {
    attribute,
    campaignPath,
    setValue,
    type: "outcome"
  })), /* @__PURE__ */ React40.createElement("div", {
    className: "flex justify-end mt-3"
  }, /* @__PURE__ */ React40.createElement("button", {
    className: "rpgm-danger",
    onClick: remove2
  }, t2("buttons.delete")), /* @__PURE__ */ React40.createElement("button", {
    className: "rpgm-secondary",
    onClick: reset
  }, t2("buttons.cancel")), /* @__PURE__ */ React40.createElement("button", {
    className: "rpgm-primary",
    onClick: save
  }, t2("buttons.save"))));
}
function View({
  attribute,
  campaignPath,
  setEdit
}) {
  return /* @__PURE__ */ React40.createElement("div", {
    onClick: () => {
      setEdit(true);
    },
    className: "cursor-pointer hover:bg-[--background-secondary]"
  }, /* @__PURE__ */ React40.createElement(Browse, {
    attribute,
    campaignPath
  }));
}
function Browse({
  attribute,
  campaignPath
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React40.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] overflow-hidden bg-[--background-primary] mb-3 p-3"
  }, /* @__PURE__ */ React40.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("attributes.conflict")), /* @__PURE__ */ React40.createElement("div", {
    className: "gap-3 grid grid-cols-7"
  }, /* @__PURE__ */ React40.createElement(EditableTitleAttribute, {
    attribute,
    campaignPath
  }), /* @__PURE__ */ React40.createElement(EditableStatusAttribute, {
    attribute
  }), /* @__PURE__ */ React40.createElement(EditableCategoryAttribute, {
    attribute
  }), /* @__PURE__ */ React40.createElement(EditableInvolvementAttribute, {
    attribute
  }), /* @__PURE__ */ React40.createElement(EditableLongTextAttribute, {
    attribute,
    campaignPath,
    type: "description"
  }), /* @__PURE__ */ React40.createElement(EditableConflictStakesAttribute, {
    attribute
  }), /* @__PURE__ */ React40.createElement(EditableRelationshipsAttribute, {
    attribute,
    type: "opposingforces"
  }), /* @__PURE__ */ React40.createElement(EditableRelationshipsAttribute, {
    attribute,
    type: "events"
  }), /* @__PURE__ */ React40.createElement(EditableLongTextAttribute, {
    attribute,
    campaignPath,
    type: "outcome"
  })));
}
function EditableTitleAttribute({
  attribute,
  campaignPath,
  setValue
}) {
  var _a, _b;
  const { t: t2 } = useTranslation();
  const [showHelp, setShowHelp] = React40.useState(false);
  const setTitle = (newValue) => {
    setValue("title", newValue);
  };
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React40.createElement("div", null, t2("conflict.title")), setValue && /* @__PURE__ */ React40.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React40.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React40.createElement(TextInputComponent, {
    className: "min-h-[2em] w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md",
    onChange: setTitle,
    initialValue: (_b = (_a = attribute.value) == null ? void 0 : _a.title) != null ? _b : "",
    campaignPath
  }) : /* @__PURE__ */ React40.createElement("div", {
    className: "min-h-[2em] p-2 w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: attribute.value.title
  }))), showHelp && /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: t2("conflict.description", { context: "title" })
  })));
}
function EditableRelationshipsAttribute({
  attribute,
  type: type2,
  campaignPath,
  setValue
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!setValue && !attribute.value[type2])
    return null;
  const [showHelp, setShowHelp] = React40.useState(false);
  const [relationships, setRelationships] = React40.useState((_a = attribute.value[type2]) != null ? _a : []);
  const addRelationship = (newValue) => {
    const value = HelperService.extractPath(newValue);
    setRelationships((prevRelationships) => {
      const updatedRelationships = [...prevRelationships, value];
      setValue(type2, updatedRelationships);
      return updatedRelationships;
    });
  };
  const removeRelationship = (value) => {
    setRelationships((prevRelationships) => {
      const updatedRelationships = prevRelationships.filter((relationship) => relationship !== value);
      setValue(type2, updatedRelationships);
      return updatedRelationships;
    });
  };
  let rel = "";
  if (!setValue) {
    rel = relationships.map((relationship) => "[[" + relationship + "|" + api2.get(relationship).name + "]]").join("\\\n");
  }
  const handleSearch = () => {
    const limits = type2 === "opposingforces" ? ["nonplayercharacter" /* NonPlayerCharacter */, "faction" /* Faction */] : ["event" /* Event */];
    const searcher = new NewRelationshipController(app, api2, void 0, campaignPath, limits, addRelationship);
    searcher.open();
  };
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React40.createElement("div", null, t2("conflict." + type2)), setValue && /* @__PURE__ */ React40.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React40.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React40.createElement(React40.Fragment, null, relationships && relationships.length > 0 && /* @__PURE__ */ React40.createElement("div", {
    className: "mb-3"
  }, relationships.map((relationship, index2) => /* @__PURE__ */ React40.createElement("span", {
    key: index2,
    className: "mb-3"
  }, /* @__PURE__ */ React40.createElement("a", {
    href: relationship,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, api2.get(relationship).name), " (", /* @__PURE__ */ React40.createElement("span", {
    className: "cursor-pointer text-[--text-muted] text-sm",
    onClick: () => removeRelationship(relationship)
  }, t2("buttons.delete")), ") "))), /* @__PURE__ */ React40.createElement("div", {
    key: "new-relationship",
    className: "flex mb-3"
  }, /* @__PURE__ */ React40.createElement("span", {
    className: "cursor-pointer text-[--text-muted] text-sm",
    onClick: () => handleSearch()
  }, "Add ", t2("conflict." + type2)))) : /* @__PURE__ */ React40.createElement("div", {
    className: "min-h-[2em] p-2 w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: rel
  }))), showHelp && /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: t2("conflict.description", { context: type2 })
  })));
}
function EditableCategoryAttribute({
  attribute,
  setValue
}) {
  const { t: t2 } = useTranslation();
  if (!setValue && !attribute.value.category)
    return null;
  const [showHelp, setShowHelp] = React40.useState(false);
  const setCategory = (newValue) => {
    setValue("category", newValue);
  };
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React40.createElement("div", null, t2("conflict.category")), setValue && /* @__PURE__ */ React40.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React40.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React40.createElement("select", {
    defaultValue: attribute.value.category,
    onChange: (e2) => setCategory(e2.target.value),
    className: "!pl-2 !pr-4"
  }, /* @__PURE__ */ React40.createElement("option", {
    value: ""
  }), /* @__PURE__ */ React40.createElement("option", {
    value: "ambition"
  }, t2("conflict.category", { context: "ambition" })), /* @__PURE__ */ React40.createElement("option", {
    value: "betrayal"
  }, t2("conflict.category", { context: "betrayal" })), /* @__PURE__ */ React40.createElement("option", {
    value: "survival"
  }, t2("conflict.category", { context: "survival" })), /* @__PURE__ */ React40.createElement("option", {
    value: "revenge"
  }, t2("conflict.category", { context: "revenge" })), /* @__PURE__ */ React40.createElement("option", {
    value: "ideology"
  }, t2("conflict.category", { context: "ideology" })), /* @__PURE__ */ React40.createElement("option", {
    value: "love"
  }, t2("conflict.category", { context: "love" })), /* @__PURE__ */ React40.createElement("option", {
    value: "guilt"
  }, t2("conflict.category", { context: "guilt" })), /* @__PURE__ */ React40.createElement("option", {
    value: "fear"
  }, t2("conflict.category", { context: "fear" }))) : /* @__PURE__ */ React40.createElement("div", {
    className: "min-h-[2em] p-2 w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, t2("conflict.category", { context: attribute.value.category }))), showHelp && /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-full mb-3 p-2 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: t2("conflict.description", { context: "category" })
  })));
}
function EditableInvolvementAttribute({
  attribute,
  setValue
}) {
  const { t: t2 } = useTranslation();
  if (!setValue && !attribute.value.involvement)
    return null;
  const [showHelp, setShowHelp] = React40.useState(false);
  const setCategory = (newValue) => {
    setValue("involvement", newValue);
  };
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React40.createElement("div", null, t2("conflict.involvement")), setValue && /* @__PURE__ */ React40.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React40.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React40.createElement("select", {
    defaultValue: attribute.value.involvement,
    onChange: (e2) => setCategory(e2.target.value),
    className: "!pl-2 !pr-4"
  }, /* @__PURE__ */ React40.createElement("option", {
    value: ""
  }), /* @__PURE__ */ React40.createElement("option", {
    value: "active"
  }, t2("conflict.involvement", { context: "active" })), /* @__PURE__ */ React40.createElement("option", {
    value: "passive"
  }, t2("conflict.involvement", { context: "passive" })), /* @__PURE__ */ React40.createElement("option", {
    value: "unaware"
  }, t2("conflict.involvement", { context: "unaware" })), /* @__PURE__ */ React40.createElement("option", {
    value: "forced"
  }, t2("conflict.involvement", { context: "forced" })), /* @__PURE__ */ React40.createElement("option", {
    value: "opportunistic"
  }, t2("conflict.involvement", { context: "opportunistic" }))) : /* @__PURE__ */ React40.createElement("div", {
    className: "min-h-[2em] p-2 w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, t2("conflict.involvement", { context: attribute.value.involvement }))), showHelp && /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: t2("conflict.description", { context: "involvement" })
  })));
}
function EditableStatusAttribute({
  attribute,
  setValue
}) {
  const { t: t2 } = useTranslation();
  if (!setValue && !attribute.value.status)
    return null;
  const [showHelp, setShowHelp] = React40.useState(false);
  const setStatus = (newValue) => {
    setValue("status", newValue);
  };
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React40.createElement("div", null, t2("conflict.status")), setValue && /* @__PURE__ */ React40.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React40.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React40.createElement("select", {
    defaultValue: attribute.value.status,
    onChange: (e2) => setStatus(e2.target.value),
    className: "!pl-2 !pr-4"
  }, /* @__PURE__ */ React40.createElement("option", {
    value: ""
  }), /* @__PURE__ */ React40.createElement("option", {
    value: "planned"
  }, t2("conflict.status", { context: "planned" })), /* @__PURE__ */ React40.createElement("option", {
    value: "inprogress"
  }, t2("conflict.status", { context: "inprogress" })), /* @__PURE__ */ React40.createElement("option", {
    value: "resolved"
  }, t2("conflict.status", { context: "resolved" }))) : /* @__PURE__ */ React40.createElement("div", {
    className: "min-h-[2em] p-2 w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, t2("conflict.status", { context: attribute.value.status }))), showHelp && /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: t2("conflict.description", { context: "status" })
  })));
}
function EditableLongTextAttribute({
  attribute,
  campaignPath,
  setValue,
  type: type2
}) {
  const { t: t2 } = useTranslation();
  if (!setValue && !attribute.value[type2])
    return null;
  const [showHelp, setShowHelp] = React40.useState(false);
  const setSubAttributeValue = (newValue) => {
    setValue(type2, newValue);
  };
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React40.createElement("div", null, t2("conflict." + type2)), setValue && /* @__PURE__ */ React40.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React40.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React40.createElement(MarkdownEditorComponent, {
    className: "min-h-[2em] w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md",
    campaignPath,
    onChange: setSubAttributeValue,
    initialValue: attribute.value[type2]
  }) : /* @__PURE__ */ React40.createElement("div", {
    className: "min-h-[2em] p-2 w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: attribute.value[type2]
  }))), showHelp && /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: t2("conflict.description", { context: type2 })
  })));
}
function EditableConflictStakesAttribute({
  attribute,
  setValue
}) {
  var _a;
  const { t: t2 } = useTranslation();
  if (!setValue && (!attribute.value.stakes || attribute.value.stakes.length === 0))
    return null;
  const [showHelp, setShowHelp] = React40.useState(false);
  const [selectedStakes, setSelectedStakes] = React40.useState((_a = attribute.value.stakes) != null ? _a : []);
  const setStakesValue = (newValue) => {
    setSelectedStakes((prevStakes) => {
      let updatedStakes;
      if (prevStakes.includes(newValue)) {
        updatedStakes = prevStakes.filter((stake2) => stake2 !== newValue);
      } else {
        updatedStakes = [...prevStakes, newValue];
      }
      setValue("stakes", updatedStakes);
      return updatedStakes;
    });
  };
  let stakes = "";
  if (selectedStakes) {
    stakes = selectedStakes.map((stake2) => t2("conflict.stake." + stake2)).join("\\\n");
  }
  return /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React40.createElement("div", null, t2("conflict.stakes")), setValue && /* @__PURE__ */ React40.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React40.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React40.createElement(React40.Fragment, null, /* @__PURE__ */ React40.createElement("label", {
    key: "lifeanddeath",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("lifeanddeath") || false,
    onChange: (e2) => setStakesValue("lifeanddeath")
  }), t2("conflict.stake.lifeanddeath")), /* @__PURE__ */ React40.createElement("label", {
    key: "loveandrelationships",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("loveandrelationships") || false,
    onChange: (e2) => setStakesValue("loveandrelationships")
  }), t2("conflict.stake.loveandrelationships")), /* @__PURE__ */ React40.createElement("label", {
    key: "powerandcontrol",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("powerandcontrol") || false,
    onChange: (e2) => setStakesValue("powerandcontrol")
  }), t2("conflict.stake.powerandcontrol")), /* @__PURE__ */ React40.createElement("label", {
    key: "reputationandhonor",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("reputationandhonor") || false,
    onChange: (e2) => setStakesValue("reputationandhonor")
  }), t2("conflict.stake.reputationandhonor")), /* @__PURE__ */ React40.createElement("label", {
    key: "wealthandresources",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("wealthandresources") || false,
    onChange: (e2) => setStakesValue("wealthandresources")
  }), t2("conflict.stake.wealthandresources")), /* @__PURE__ */ React40.createElement("label", {
    key: "freedomandjustice",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("freedomandjustice") || false,
    onChange: (e2) => setStakesValue("freedomandjustice")
  }), t2("conflict.stake.freedomandjustice")), /* @__PURE__ */ React40.createElement("label", {
    key: "knowledgeandinformation",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("knowledgeandinformation") || false,
    onChange: (e2) => setStakesValue("knowledgeandinformation")
  }), t2("conflict.stake.knowledgeandinformation")), /* @__PURE__ */ React40.createElement("label", {
    key: "moralityandethics",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("moralityandethics") || false,
    onChange: (e2) => setStakesValue("moralityandethics")
  }), t2("conflict.stake.moralityandethics")), /* @__PURE__ */ React40.createElement("label", {
    key: "beliefsandvalues",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("beliefsandvalues") || false,
    onChange: (e2) => setStakesValue("beliefsandvalues")
  }), t2("conflict.stake.beliefsandvalues")), /* @__PURE__ */ React40.createElement("label", {
    key: "futureandlegacy",
    className: "block"
  }, /* @__PURE__ */ React40.createElement("input", {
    type: "checkbox",
    checked: selectedStakes.includes("futureandlegacy") || false,
    onChange: (e2) => setStakesValue("futureandlegacy")
  }), t2("conflict.stake.futureandlegacy"))) : /* @__PURE__ */ React40.createElement("div", {
    className: "min-h-[2em] p-2 w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: stakes
  }))), showHelp && /* @__PURE__ */ React40.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React40.createElement(MarkdownComponent, {
    value: t2("conflict.description", { context: "stakes" })
  })));
}

// src/components/headers/BannerComponent.tsx
var React41 = __toESM(require_react());
function BannerComponent({ image: image2 }) {
  return /* @__PURE__ */ React41.createElement("div", {
    className: "relative w-full pb-[56.25%] overflow-hidden rounded-lg"
  }, /* @__PURE__ */ React41.createElement("img", {
    src: image2.src,
    alt: image2.caption,
    className: "absolute top-0 left-0 w-full h-full object-cover"
  }));
}

// src/components/headers/HeaderComponent.tsx
var React42 = __toESM(require_react());
function HeaderComponent({
  element: element4,
  isInPopover
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const siblings = api2.get(void 0, element4.campaign, element4.type, element4.parent);
  const previousElement = siblings.find((sibling) => sibling.positionInParent === element4.positionInParent - 1);
  const nextElement = siblings.find((sibling) => sibling.positionInParent === element4.positionInParent + 1);
  return /* @__PURE__ */ React42.createElement(React42.Fragment, null, /* @__PURE__ */ React42.createElement("div", {
    className: "!m-0 flex justify-end p-1 text-[--text-faint] text-xs absolute right-0 !mt-[-1.25rem]"
  }, "Rpg Manager ", api2.version), /* @__PURE__ */ React42.createElement("div", {
    className: "relative flex flex-col justify-center items-center h-full"
  }, /* @__PURE__ */ React42.createElement("h1", {
    className: "!text-4xl !font-extralight"
  }, element4.name), element4.type !== "campaign" /* Campaign */ && element4.campaign === void 0 && /* @__PURE__ */ React42.createElement("h3", {
    className: "!text-xl !font-extralight !text-[--text-muted] !-mt-3 !mb-3 !italic"
  }, t2("global")), !isInPopover && /* @__PURE__ */ React42.createElement("div", {
    className: "!font-extralight text-[--text-faint] grid grid-cols-12"
  }, /* @__PURE__ */ React42.createElement("div", {
    className: "text-center col-span-4"
  }, previousElement ? /* @__PURE__ */ React42.createElement("a", {
    href: previousElement.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, "<\xA0", previousElement.name) : /* @__PURE__ */ React42.createElement(React42.Fragment, null, "\xA0")), /* @__PURE__ */ React42.createElement("div", {
    className: "text-center"
  }, previousElement ? /* @__PURE__ */ React42.createElement(React42.Fragment, null, "|") : /* @__PURE__ */ React42.createElement(React42.Fragment, null, "\xA0")), /* @__PURE__ */ React42.createElement("div", {
    className: "text-center col-span-2"
  }, t2("elements." + element4.type, { count: 1 })), /* @__PURE__ */ React42.createElement("div", {
    className: "text-center"
  }, nextElement ? /* @__PURE__ */ React42.createElement(React42.Fragment, null, "|") : /* @__PURE__ */ React42.createElement(React42.Fragment, null, "\xA0")), /* @__PURE__ */ React42.createElement("div", {
    className: "text-center col-span-4"
  }, nextElement ? /* @__PURE__ */ React42.createElement("a", {
    href: nextElement.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, nextElement.name, "\xA0>") : /* @__PURE__ */ React42.createElement(React42.Fragment, null, "\xA0"))), /* @__PURE__ */ React42.createElement("div", {
    className: "absolute bottom-0 right-0 flex justify-end p-1 text-[--text-faint] text-xs z-10",
    onClick: () => __async(this, null, function* () {
      app.workspace.detachLeavesOfType("rpg-manager-options");
      yield app.workspace.getRightLeaf(false).setViewState({
        type: "rpg-manager-options",
        active: true
      });
      const leaf = app.workspace.getLeavesOfType("rpg-manager-options")[0];
      const view = leaf.view;
      app.workspace.revealLeaf(leaf);
      view.render();
    })
  }, /* @__PURE__ */ React42.createElement("div", {
    className: "ml-4 cursor-pointer"
  }, t2("options.option", { count: 2 })))));
}

// src/components/images/ImageCarouselComponent.tsx
var React43 = __toESM(require_react());
function ImageCarouselComponent({ element: element4 }) {
  const { t: t2 } = useTranslation();
  const carouselRef = React43.useRef(null);
  const [clickedImage, setClickedImage] = React43.useState(void 0);
  const scroll3 = (direction) => {
    if (carouselRef.current) {
      carouselRef.current.scrollBy({
        top: 0,
        left: direction === "left" ? -200 : 200,
        behavior: "smooth"
      });
    }
  };
  return /* @__PURE__ */ React43.createElement("div", null, /* @__PURE__ */ React43.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("gallery.carousel")), /* @__PURE__ */ React43.createElement("div", {
    className: "relative w-full h-48"
  }, /* @__PURE__ */ React43.createElement("button", {
    onClick: () => scroll3("left"),
    className: "absolute left-0 top-1/2 transform -translate-y-1/2 z-10 bg-[--background-primary] p-2 rounded-full shadow-md"
  }, "<"), /* @__PURE__ */ React43.createElement("div", {
    className: "flex w-full overflow-x-scroll overflow-y-hidden h-48 scrollbar-hide",
    ref: carouselRef
  }, element4.images.map((image2, index2) => {
    var _a;
    return /* @__PURE__ */ React43.createElement("div", {
      key: index2,
      className: "flex-none"
    }, /* @__PURE__ */ React43.createElement("img", {
      src: image2.src,
      alt: (_a = image2.caption) != null ? _a : "Image of " + element4.name,
      className: "h-full object-contain mx-2 cursor-zoom-in hover:bg-[--background-primary] hover:opacity-50",
      onClick: () => setClickedImage(image2)
    }));
  })), /* @__PURE__ */ React43.createElement("button", {
    onClick: () => scroll3("right"),
    className: "absolute right-0 top-1/2 transform -translate-y-1/2 z-10 bg-[--background-primary] p-2 rounded-full shadow-md"
  }, ">"), clickedImage && /* @__PURE__ */ React43.createElement("div", {
    className: "fixed top-0 left-0 p-10 w-full h-full z-[9999] flex flex-col justify-start bg-black bg-opacity-75 cursor-zoom-out",
    onClick: () => setClickedImage(void 0)
  }, /* @__PURE__ */ React43.createElement("img", {
    src: clickedImage.src,
    alt: clickedImage.caption,
    className: "max-w-full max-h-full"
  }), /* @__PURE__ */ React43.createElement("div", {
    className: "text-white text-center text-xl mt-5"
  }, /* @__PURE__ */ React43.createElement(MarkdownComponent, {
    value: clickedImage.caption
  })))));
}

// src/components/kishotenketsu/KishotenketsuComponent.tsx
var React44 = __toESM(require_react());
function KishotenketsuComponent({
  element: element4,
  attribute,
  isEditable
}) {
  var _a;
  const api2 = useApi();
  const app = useApp();
  const [edit, setEdit] = React44.useState(false);
  const [kishotenketsuValue, setKishotenketsuValue] = React44.useState((_a = attribute.value) != null ? _a : {});
  const save = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    attribute.value = kishotenketsuValue;
    codeblockService.updateCodeblockData(attribute.id, kishotenketsuValue).then(() => {
      setEdit(false);
    });
  };
  const remove2 = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      setEdit(false);
    });
  };
  const setValue = (subAttibute, newValue) => {
    setKishotenketsuValue(__spreadProps(__spreadValues({}, kishotenketsuValue), { [subAttibute]: newValue }));
  };
  const reset = () => {
    setEdit(false);
  };
  if (edit)
    return /* @__PURE__ */ React44.createElement(Edit2, {
      element: element4,
      attribute,
      setValue,
      save,
      remove: remove2,
      reset
    });
  if (isEditable)
    return /* @__PURE__ */ React44.createElement(View2, {
      attribute,
      setEdit
    });
  return /* @__PURE__ */ React44.createElement(Browse2, {
    attribute
  });
}
function Edit2({
  element: element4,
  attribute,
  setValue,
  save,
  remove: remove2,
  reset
}) {
  const { t: t2 } = useTranslation();
  const campaignPath = element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath;
  return /* @__PURE__ */ React44.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] overflow-hidden bg-[--background-primary] mb-3 p-3"
  }, /* @__PURE__ */ React44.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("attributes.kishotenketsu")), /* @__PURE__ */ React44.createElement("div", {
    className: "gap-3 grid grid-cols-7"
  }, /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    campaignPath,
    subAttribute: "ki",
    setValue
  }), /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    campaignPath,
    subAttribute: "sho",
    setValue
  }), /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    campaignPath,
    subAttribute: "ten",
    setValue
  }), /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    campaignPath,
    subAttribute: "ketsu",
    setValue
  })), /* @__PURE__ */ React44.createElement("div", {
    className: "flex justify-end mt-3"
  }, /* @__PURE__ */ React44.createElement("button", {
    className: "rpgm-danger",
    onClick: remove2
  }, t2("buttons.delete")), /* @__PURE__ */ React44.createElement("button", {
    className: "rpgm-secondary",
    onClick: reset
  }, t2("buttons.cancel")), /* @__PURE__ */ React44.createElement("button", {
    className: "rpgm-primary",
    onClick: save
  }, t2("buttons.save"))));
}
function View2({
  attribute,
  setEdit
}) {
  return /* @__PURE__ */ React44.createElement("div", {
    onClick: () => {
      setEdit(true);
    },
    className: "cursor-pointer"
  }, /* @__PURE__ */ React44.createElement(Browse2, {
    attribute
  }));
}
function Browse2({ attribute }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React44.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] overflow-hidden bg-[--background-primary] mb-3 p-3"
  }, /* @__PURE__ */ React44.createElement("h2", {
    className: "!text-2xl !font-bold border-b border-b-[--background-modifier-border]"
  }, t2("attributes.kishotenketsu")), /* @__PURE__ */ React44.createElement("div", {
    className: "gap-3 grid grid-cols-7"
  }, /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    subAttribute: "ki"
  }), /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    subAttribute: "sho"
  }), /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    subAttribute: "ten"
  }), /* @__PURE__ */ React44.createElement(EditableAttribute, {
    attribute,
    subAttribute: "ketsu"
  })));
}
function EditableAttribute({
  attribute,
  subAttribute,
  setValue,
  campaignPath
}) {
  const { t: t2 } = useTranslation();
  const [showHelp, setShowHelp] = React44.useState(false);
  const setSubAttributeValue = (newValue) => {
    setValue(subAttribute, newValue);
  };
  return /* @__PURE__ */ React44.createElement(React44.Fragment, null, /* @__PURE__ */ React44.createElement("div", {
    className: "!font-bold col-span-1"
  }, /* @__PURE__ */ React44.createElement("div", null, /* @__PURE__ */ React44.createElement(MarkdownComponent, {
    value: t2("kishotenketsu." + subAttribute)
  })), setValue && /* @__PURE__ */ React44.createElement("div", {
    className: "text-xs cursor-pointer text-[--color-base-25] hover:text-[--text-accent-hover]",
    onClick: () => setShowHelp(!showHelp)
  }, /* @__PURE__ */ React44.createElement(FontAwesomeIcon, {
    icon: faCircleQuestion
  }))), /* @__PURE__ */ React44.createElement("div", {
    className: "col-span-6"
  }, setValue ? /* @__PURE__ */ React44.createElement(MarkdownEditorComponent, {
    className: "min-h-[2em] w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md",
    campaignPath,
    onChange: setSubAttributeValue,
    initialValue: attribute.value[subAttribute]
  }) : /* @__PURE__ */ React44.createElement("div", {
    className: "min-h-[2em] w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
  }, /* @__PURE__ */ React44.createElement(MarkdownComponent, {
    value: attribute.value[subAttribute]
  }))), showHelp && /* @__PURE__ */ React44.createElement("div", {
    className: "col-span-full mb-3 p-3 rounded-lg bg-[--background-primary-alt] text-sm"
  }, /* @__PURE__ */ React44.createElement(MarkdownComponent, {
    value: t2("kishotenketsu.description", { context: subAttribute })
  })));
}

// src/components/relationships/RelationshipsComponent.tsx
var React48 = __toESM(require_react());

// src/components/relationships/RelationshipListComponent.tsx
var React47 = __toESM(require_react());

// src/components/relationships/RelationshipComponent.tsx
var React46 = __toESM(require_react());

// src/components/relationships/RelationshipDescriptionComponent.tsx
var React45 = __toESM(require_react());
function RelationshipDescriptionComponent({
  element: element4,
  relationship
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [editing, setEditing] = React45.useState(false);
  const [value, setValue] = React45.useState(relationship.description || "");
  const [type2, setType] = React45.useState(relationship.type === "reverse" /* Reversed */ ? "bidirectional" /* Bidirectional */ : relationship.type);
  const textAreaRef = React45.useRef(null);
  const resizeTextArea = () => {
    if (textAreaRef.current) {
      textAreaRef.current.style.height = "auto";
      textAreaRef.current.style.minHeight = "2em";
      textAreaRef.current.style.height = textAreaRef.current.scrollHeight + 10 + "px";
    }
  };
  React45.useEffect(() => {
    var _a;
    if (editing) {
      resizeTextArea();
      (_a = textAreaRef.current) == null ? void 0 : _a.focus();
    }
  }, [editing]);
  function updateRelationship(value2) {
    setValue(value2);
    resizeTextArea();
  }
  const updateRelationshipType = (type3) => {
    setType(type3);
  };
  function deleteRelationship() {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.removeRelationship(element4, relationship.component);
  }
  const saveRelationship = () => {
    let requiresUpdate = false;
    if (relationship.type !== type2) {
      relationship.type = type2;
      requiresUpdate = true;
    }
    if (relationship.description !== value) {
      if (relationship.isInContent) {
        relationship.isAlsoInContent = true;
        relationship.isInContent = false;
      }
      relationship.description = value;
      requiresUpdate = true;
    }
    if (requiresUpdate) {
      const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
      codeblockService.updateRelationship(relationship);
    }
  };
  return /* @__PURE__ */ React45.createElement(React45.Fragment, null, editing ? /* @__PURE__ */ React45.createElement("div", {
    className: "w-full text-sm group"
  }, /* @__PURE__ */ React45.createElement("div", {
    className: "font-bold"
  }, t2("relationships.relationshiptype")), /* @__PURE__ */ React45.createElement("div", null, /* @__PURE__ */ React45.createElement("select", {
    defaultValue: relationship.type,
    onChange: (e2) => updateRelationshipType(e2.target.value),
    className: "selectBorder w-full \n							!border !border-transparent group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border]\n							h-7 pl-1 \n							focus:!shadow-none !shadow-none\n							bg-transparent group-hover:bg-[--background-modifier-form-field]\n							"
  }, Object.entries(RelationshipType).filter(([key]) => !(RelationshipType[key] === "reverse" /* Reversed */) && !(element4.type !== relationship.component.type && (RelationshipType[key] === "parent" /* Parent */ || RelationshipType[key] === "child" /* Child */))).map(([key]) => /* @__PURE__ */ React45.createElement("option", {
    key,
    value: RelationshipType[key]
  }, key)))), /* @__PURE__ */ React45.createElement("div", null, /* @__PURE__ */ React45.createElement(MarkdownEditorComponent, {
    initialValue: value,
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath,
    onChange: updateRelationship,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), /* @__PURE__ */ React45.createElement("div", null, relationship.type !== "reverse" /* Reversed */ && !relationship.isInContent && !relationship.isAlsoInContent && /* @__PURE__ */ React45.createElement("button", {
    className: "rpgm-danger !ml-0 w-full",
    onClick: () => {
      deleteRelationship();
      setEditing(!editing);
    }
  }, t2("buttons.delete")), /* @__PURE__ */ React45.createElement("button", {
    className: "rpgm-secondary w-full !ml-0",
    onClick: () => {
      setEditing(!editing);
    }
  }, t2("buttons.cancel")), /* @__PURE__ */ React45.createElement("button", {
    className: "rpgm-primary w-full !ml-0",
    onClick: () => {
      saveRelationship();
      setEditing(!editing);
    }
  }, t2("buttons.save")))) : /* @__PURE__ */ React45.createElement("div", {
    className: "w-full text-sm group ",
    onClick: () => setEditing(!editing)
  }, /* @__PURE__ */ React45.createElement("div", {
    className: "font-bold"
  }, t2("relationships.relationshiptype")), /* @__PURE__ */ React45.createElement("div", {
    className: "mb-3 border border-transparent group-hover:border-[--background-modifier-border-hover] rounded-md min-h-[2em] cursor-pointer w-full"
  }, t2("relationships.relationshiptype", { context: relationship.type })), /* @__PURE__ */ React45.createElement("div", {
    className: "border border-transparent group-hover:border-[--background-modifier-border-hover] rounded-md min-h-[2em] cursor-text w-full"
  }, /* @__PURE__ */ React45.createElement(MarkdownComponent, {
    value
  }))));
}

// src/components/relationships/RelationshipComponent.tsx
function RelationshipComponent({
  element: element4,
  relationship
}) {
  var _a, _b, _c;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const removeRelationship = () => {
    let file;
    let relatedElementToRemove;
    let currentElement;
    if (relationship.type === "reverse" /* Reversed */) {
      file = relationship.component.file;
      currentElement = relationship.component;
      relatedElementToRemove = element4;
    } else {
      file = element4.file;
      currentElement = element4;
      relatedElementToRemove = relationship.component;
    }
    const codeblockService = new RpgManagerCodeblockService(app, api2, file);
    codeblockService.removeRelationship(currentElement, relatedElementToRemove);
  };
  let campaign = void 0;
  if (element4.type !== "campaign" /* Campaign */ && element4.campaign === void 0)
    campaign = (_b = (_a = relationship.component) == null ? void 0 : _a.campaign) == null ? void 0 : _b.path;
  let isGeneric = false;
  if (relationship.component.type !== "campaign" /* Campaign */ && !relationship.component.campaign)
    isGeneric = true;
  return /* @__PURE__ */ React46.createElement("div", {
    className: "border border-[--background-modifier-border] rounded-lg flex flex-col"
  }, relationship.component.images.length > 0 && /* @__PURE__ */ React46.createElement("div", {
    className: "flex justify-center relative"
  }, /* @__PURE__ */ React46.createElement("div", {
    className: "w-full relative pb-[100%]"
  }, /* @__PURE__ */ React46.createElement("div", {
    className: "absolute top-0 left-0 w-full h-full overflow-hidden rounded-tl-lg rounded-tr-lg"
  }, /* @__PURE__ */ React46.createElement("a", {
    href: relationship.component.file.path,
    className: "w-full h-full internal-link flex items-center justify-center"
  }, /* @__PURE__ */ React46.createElement("img", {
    src: relationship.component.images[0].src,
    alt: relationship.component.images[0].caption,
    className: "min-w-full min-h-full object-cover !cursor-pointer"
  }))))), /* @__PURE__ */ React46.createElement("div", {
    className: "flex justify-center p-2"
  }, /* @__PURE__ */ React46.createElement("a", {
    href: relationship.component.file.path,
    className: "internal-link !no-underline !text-[--text-normal]"
  }, /* @__PURE__ */ React46.createElement("h4", {
    className: "!font-extralight !m-0 !text-base"
  }, relationship.component.file.basename))), campaign !== void 0 && /* @__PURE__ */ React46.createElement("div", {
    className: "flex justify-center -mt-2 mb-2"
  }, /* @__PURE__ */ React46.createElement("a", {
    href: campaign,
    className: "internal-link !no-underline !text-[--text-muted] text-sm mt-0"
  }, (_c = relationship.component.campaign) == null ? void 0 : _c.name)), isGeneric && /* @__PURE__ */ React46.createElement("div", {
    className: "flex justify-center -mt-2 mb-2!text-[--text-muted] text-xs italic"
  }, t2("global")), /* @__PURE__ */ React46.createElement("div", {
    className: "flex p-2"
  }, /* @__PURE__ */ React46.createElement(RelationshipDescriptionComponent, {
    element: element4,
    relationship
  })), /* @__PURE__ */ React46.createElement("div", {
    className: "flex align-bottom mt-auto w-full p-2"
  }, /* @__PURE__ */ React46.createElement("button", {
    className: `w-full
							${relationship.isInContent || relationship.isAlsoInContent || relationship.type === "reverse" /* Reversed */ ? "text-[--text-faint] cursor-not-allowed" : "rpgm-danger"}`,
    disabled: relationship.isInContent || relationship.isAlsoInContent || relationship.type === "reverse" /* Reversed */,
    onClick: removeRelationship,
    title: relationship.isInContent || relationship.isAlsoInContent || relationship.type === "reverse" /* Reversed */ ? relationship.type === "reverse" /* Reversed */ ? "You cannot remove the relationship, as it is contained in the content of the related element" : "You cannot remove the relationship, as it is contained in the content" : "Remove relationship"
  }, t2("buttons.delete"))));
}

// src/components/relationships/RelationshipListComponent.tsx
function RelationshipListComponent({
  element: element4,
  type: type2,
  parent,
  children
}) {
  const { t: t2 } = useTranslation();
  let relationships = element4.relationships.filter((relationship) => relationship.component !== void 0 && relationship.component.type === type2 && relationship.component.path !== element4.path);
  if (relationships === void 0 || relationships.length === 0)
    return null;
  let title = t2("elements." + type2, { count: 2 });
  if (parent) {
    relationships = relationships.filter((relationship) => relationship.type === "parent" /* Parent */ || relationship.type === "reverse" /* Reversed */ && relationship.component.relationships.find((rel) => rel.component !== void 0 && rel.component.path === element4.path && rel.type === "child" /* Child */));
    title = t2("elements." + element4.type, { context: "inside" });
  } else if (children) {
    relationships = relationships.filter((relationship) => relationship.type === "child" /* Child */ || relationship.type === "reverse" /* Reversed */ && relationship.component.relationships.find((rel) => rel.component !== void 0 && rel.component.path === element4.path && rel.type === "parent" /* Parent */));
    title = t2("elements." + element4.type, { context: "contains" });
  } else {
    relationships = relationships.filter((relationship) => relationship.type !== "parent" /* Parent */ && relationship.type !== "child" /* Child */);
  }
  if (relationships === void 0 || relationships.length === 0)
    return null;
  return /* @__PURE__ */ React47.createElement("div", null, /* @__PURE__ */ React47.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, title), /* @__PURE__ */ React47.createElement("div", {
    className: "grid grid-cols-1 sm:grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-3"
  }, relationships.map((relationship) => /* @__PURE__ */ React47.createElement(RelationshipComponent, {
    key: relationship.component.file.path,
    element: element4,
    relationship
  }))));
}

// src/components/relationships/RelationshipsComponent.tsx
function RelationshipsComponent({ element: element4 }) {
  if (element4.relationships.length === 0)
    return null;
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React48.createElement("div", null, /* @__PURE__ */ React48.createElement("h2", null, t2("relationships.relationship", { count: 2 })), /* @__PURE__ */ React48.createElement(RelationshipListComponent, {
    key: element4.type + "parent",
    element: element4,
    type: element4.type,
    parent: true,
    children: false
  }), /* @__PURE__ */ React48.createElement(RelationshipListComponent, {
    key: element4.type + "children",
    element: element4,
    type: element4.type,
    parent: false,
    children: true
  }), Object.values(ElementType).map((type2) => {
    if (type2 === "campaign" /* Campaign */ || type2 === "session" /* Session */ || type2 === "scene" /* Scene */)
      return null;
    return /* @__PURE__ */ React48.createElement(RelationshipListComponent, {
      key: type2,
      element: element4,
      type: type2,
      parent: false,
      children: false
    });
  }));
}

// src/components/tasks/TasksContainerComponent.tsx
var React58 = __toESM(require_react());

// src/components/tasks/AllTaskListComponent.tsx
var React52 = __toESM(require_react());

// src/components/tasks/AllTaskComponent.tsx
var React50 = __toESM(require_react());

// src/components/tasks/TaskDetailComponent.tsx
var React49 = __toESM(require_react());
function TaskDetailComponent({
  element: element4,
  task,
  onTaskUpdate
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [name, setName] = React49.useState(task.name);
  const [priority, setPriority] = React49.useState(task.priority);
  const [description2, setDescription] = React49.useState(task.description);
  const [mentionedIn, setMentionedIn] = React49.useState((_a = task.mentionedIn) != null ? _a : []);
  const handleCompleteTask = () => {
    task.click();
    onTaskUpdate(task);
  };
  const handleSaveTask = () => {
    task.name = name;
    task.priority = priority;
    task.description = description2;
    onTaskUpdate(task);
  };
  const handleRemoveMentionedIn = (mentionedInElement) => {
    var _a2;
    task.mentionedIn = (_a2 = task.mentionedIn) == null ? void 0 : _a2.filter((path4) => path4 !== mentionedInElement.path);
    setMentionedIn(task.mentionedIn);
  };
  const handleAddMentionedInPath = (path4) => {
    var _a2;
    path4 = HelperService.extractPath(path4);
    if (task.mentionedIn.includes(path4))
      return;
    task.mentionedIn = [...(_a2 = task.mentionedIn) != null ? _a2 : [], path4];
    setMentionedIn(task.mentionedIn);
  };
  const handleAddmentionedIn = () => {
    const searcher = new NewRelationshipController(app, api2, element4, void 0, void 0, handleAddMentionedInPath);
    searcher.open();
  };
  return /* @__PURE__ */ React49.createElement("div", {
    className: "grid grid-cols-1 md:grid-cols-4 align-items-start border border-[--background-modifier-border] rounded-lg text-sm m-3 p-3 space-y-3"
  }, /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-4"
  }, /* @__PURE__ */ React49.createElement("button", {
    className: `text-xs p-3 hover:text-[--text-on-accent] hover:!bg-[--interactive-accent-hover] ${task.status === "complete" && "!bg-green-100 hover:!bg-green-100 !text-green-600 hover:!text-green-800 !border-green-600 hover:!border-green-800"}`,
    onClick: handleCompleteTask
  }, task.status === "complete" ? "Completed" : "Mark complete")), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-4"
  }, /* @__PURE__ */ React49.createElement("input", {
    type: "text",
    defaultValue: name,
    className: "w-full !text-xl p-1",
    onChange: (e2) => setName(e2.target.value)
  })), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-1 ml-2 text-xs text-[--text-faint] h-7 "
  }, t2("elements.element", { count: 1 })), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-3 ml-3 text-sm h-7 "
  }, /* @__PURE__ */ React49.createElement("a", {
    href: task.element.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, task.element.name)), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-1 ml-2 text-xs text-[--text-faint] h-7 "
  }, t2("tasks.mentionedin")), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-3 min-h-[1.75rem]"
  }, mentionedIn.map((path4) => {
    const mentionedInElement = api2.get(path4);
    return /* @__PURE__ */ React49.createElement("div", {
      key: mentionedInElement.path,
      className: `ml-3 group w-full`
    }, /* @__PURE__ */ React49.createElement("a", {
      href: mentionedInElement.path,
      className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
    }, mentionedInElement.name), /* @__PURE__ */ React49.createElement("span", {
      className: "ml-5 opacity-0 group-hover:opacity-100 cursor-pointer",
      title: `Remove task from ${mentionedInElement.name}`,
      onClick: () => handleRemoveMentionedIn(mentionedInElement)
    }, /* @__PURE__ */ React49.createElement(FontAwesomeIcon, {
      icon: faTimes
    })));
  }), /* @__PURE__ */ React49.createElement("div", null, /* @__PURE__ */ React49.createElement("button", {
    className: "!m-0 !mt-2 !p-3\n                            !border-0 hover:!border-0\n                            hover:bg-[--background-secondary] \n                            focus:!shadow-none !shadow-none hover:!shadow-none\n                            text-[--text-muted] hover:text-[--text-normal] text-xs",
    onClick: handleAddmentionedIn
  }, t2("tasks.mentionedin")))), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-1 ml-2 text-xs text-[--text-faint] h-7 "
  }, t2("tasks.priority")), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-3 h-7 ml-3"
  }, /* @__PURE__ */ React49.createElement("select", {
    onChange: (e2) => setPriority(e2.target.value),
    defaultValue: priority,
    className: "selectBorderVisible !border !border-[--background-modifier-border]\n                    h-7 pl-1 pr-3\n                        focus:!shadow-none !shadow-none selectBorder"
  }, Object.entries(PriorityType).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React49.createElement("option", {
    key,
    value: index2
  }, key)))), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-1 ml-2 text-xs text-[--text-faint]"
  }, t2("tasks.description")), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-3 ml-3"
  }, /* @__PURE__ */ React49.createElement(MarkdownEditorComponent, {
    initialValue: description2,
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaign.path,
    onChange: setDescription,
    className: "text-sm w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md focus:!shadow-none !shadow-none"
  })), /* @__PURE__ */ React49.createElement("div", {
    className: "col-span-4 flex justify-end"
  }, /* @__PURE__ */ React49.createElement("button", {
    className: "rpgm-primary",
    onClick: handleSaveTask
  }, t2("buttons.save"))));
}

// src/components/tasks/AllTaskComponent.tsx
function AllTaskComponent({
  element: element4,
  task,
  onTaskUpdate
}) {
  const { t: t2 } = useTranslation();
  const [showDetails, setShowDetails] = React50.useState(false);
  const handleTaskAssign = (task2) => {
    task2.mentionedIn = [...task2.mentionedIn, element4.path];
    onTaskUpdate(task2);
  };
  const handleStatusChange = (task2) => {
    task2.click();
    onTaskUpdate(task2);
  };
  const handlePriorityChange = (priority) => {
    task.priority = priority;
    onTaskUpdate(task);
  };
  const handleNameChange = (name) => {
    task.name = name;
    onTaskUpdate(task);
  };
  const handleUpdate = (task2) => {
    setShowDetails(false);
    onTaskUpdate(task2);
  };
  let taskIcon;
  if (task.status === "complete" /* Complete */) {
    taskIcon = /* @__PURE__ */ React50.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "h-5 w-5",
      viewBox: "0 0 24 24"
    }, /* @__PURE__ */ React50.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "10",
      fill: "green"
    }), /* @__PURE__ */ React50.createElement("path", {
      d: "M9 12l2 2l4-4",
      fill: "lightgray",
      stroke: "lightgray"
    }));
  } else {
    taskIcon = /* @__PURE__ */ React50.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "h-5 w-5 text-[--background-modifier-border] group-hover:text-green-500 active:text-green-700 transition-colors duration-200",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }, /* @__PURE__ */ React50.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "10"
    }), /* @__PURE__ */ React50.createElement("path", {
      d: "M9 12l2 2l4-4"
    }));
  }
  return /* @__PURE__ */ React50.createElement(React50.Fragment, null, /* @__PURE__ */ React50.createElement("div", {
    className: `flex items-center w-full text-sm cursor-pointer group ${!showDetails && "border-b border-b-[--background-modifier-border] hover:bg-[--background-primary-alt]"}`
  }, /* @__PURE__ */ React50.createElement("div", {
    className: "max-w-5 w-5 align-middle items-center !m-2",
    onClick: (e2) => {
      e2.stopPropagation();
      handleStatusChange(task);
    }
  }, taskIcon), /* @__PURE__ */ React50.createElement("div", {
    className: "col-span-1 max-w-[10rem] w-40 align-middle items-center !m-2"
  }, /* @__PURE__ */ React50.createElement("a", {
    href: task.element.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, task.element.name)), /* @__PURE__ */ React50.createElement("div", {
    className: "w-full p-1 flex-grow"
  }, /* @__PURE__ */ React50.createElement("div", {
    contentEditable: true,
    suppressContentEditableWarning: true,
    className: "min-w-[60px] rounded-sm p-1 !border !border-transparent bg-[--background-primary] group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border] focus:!shadow-none",
    style: { display: "inline-block" },
    onBlur: (e2) => {
      if (task.name !== e2.target.textContent)
        handleNameChange(e2.target.textContent || "");
    },
    onKeyDown: (e2) => {
      if (e2.key === "Enter") {
        e2.preventDefault();
      }
    }
  }, task.name)), /* @__PURE__ */ React50.createElement("div", {
    className: "pr-1 w-32 min-w-[8rem]"
  }, /* @__PURE__ */ React50.createElement("select", {
    defaultValue: task.priority,
    onChange: (e2) => handlePriorityChange(e2.target.value),
    className: "selectBorder w-full \n                        !border !border-transparent group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border]\n                        h-7 pl-1 \n                        focus:!shadow-none !shadow-none\n                        bg-transparent group-hover:bg-[--background-modifier-form-field]\n                        "
  }, Object.entries(PriorityType).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React50.createElement("option", {
    key,
    value: index2
  }, key)))), /* @__PURE__ */ React50.createElement("div", {
    className: "pr-1 w-28 min-w-[7rem] align-middle items-center opacity-0 group-hover:opacity-100 !text-[--text-muted] hover:!text-[--text-accent]"
  }, /* @__PURE__ */ React50.createElement("button", {
    className: "rpgm-secondary",
    onClick: (e2) => {
      e2.stopPropagation();
      handleTaskAssign(task);
    }
  }, t2("buttons.assign"))), /* @__PURE__ */ React50.createElement("div", {
    className: "pr-1 w-4 min-w-[1rem] align-middle items-center opacity-0 group-hover:opacity-100 !text-[--text-muted] hover:!text-[--text-accent]",
    onClick: () => setShowDetails(!showDetails)
  }, ">")), showDetails && /* @__PURE__ */ React50.createElement(TaskDetailComponent, {
    element: element4,
    task,
    onTaskUpdate: handleUpdate
  }));
}

// src/components/tasks/TaskPaginatorComponent.tsx
var React51 = __toESM(require_react());
function TaskPaginatorComponent({
  tasks,
  onPageChange
}) {
  const ITEMS_PER_PAGE = 10;
  const [currentPage, setCurrentPage] = React51.useState(1);
  const totalPages = Math.ceil(tasks.length / ITEMS_PER_PAGE);
  const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
  const endIndex = startIndex + ITEMS_PER_PAGE;
  const currentTasks = tasks.slice(startIndex, endIndex);
  React51.useEffect(() => {
    onPageChange(currentTasks);
  }, [currentPage, tasks]);
  if (tasks.length <= ITEMS_PER_PAGE)
    return null;
  return /* @__PURE__ */ React51.createElement("div", {
    className: "flex justify-center items-center mt-4"
  }, currentPage > 1 && /* @__PURE__ */ React51.createElement(React51.Fragment, null, /* @__PURE__ */ React51.createElement("span", {
    onClick: () => setCurrentPage(1),
    className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, /* @__PURE__ */ React51.createElement(FontAwesomeIcon, {
    icon: faAngleDoubleLeft
  })), /* @__PURE__ */ React51.createElement("span", {
    onClick: () => setCurrentPage(currentPage - 1),
    className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] mx-2"
  }, /* @__PURE__ */ React51.createElement(FontAwesomeIcon, {
    icon: faAngleLeft
  }))), /* @__PURE__ */ React51.createElement("span", {
    className: "mx-4"
  }, `Page ${currentPage} of ${totalPages}`), currentPage < totalPages && /* @__PURE__ */ React51.createElement(React51.Fragment, null, /* @__PURE__ */ React51.createElement("span", {
    onClick: () => setCurrentPage(currentPage + 1),
    className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] mx-2"
  }, /* @__PURE__ */ React51.createElement(FontAwesomeIcon, {
    icon: faAngleRight
  })), /* @__PURE__ */ React51.createElement("span", {
    onClick: () => setCurrentPage(totalPages),
    className: "!no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, /* @__PURE__ */ React51.createElement(FontAwesomeIcon, {
    icon: faAngleDoubleRight
  }))));
}

// src/components/tasks/AllTaskListComponent.tsx
function AllTaskListComponent({
  element: element4,
  tasks
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const ITEMS_PER_PAGE = 10;
  const initialTasks = tasks.slice(0, ITEMS_PER_PAGE);
  const [paginatedTasks, setPaginatedTasks] = React52.useState(initialTasks);
  const handleSave = (task) => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, task.element.file);
    codeblockService.addOrUpdateTask(task);
  };
  return /* @__PURE__ */ React52.createElement("div", null, /* @__PURE__ */ React52.createElement("div", {
    className: "text-xs text-[--text-muted] flex items-center w-full hover:bg-[--background-primary-alt] border-b border-b-[--background-modifier-border] cursor-pointer group"
  }, /* @__PURE__ */ React52.createElement("div", {
    className: "col-span-1 max-w-5 w-5 align-middle items-center !m-2"
  }, "\xA0"), /* @__PURE__ */ React52.createElement("div", {
    className: "col-span-1 max-w-[10rem] w-40 align-middle items-center !m-2"
  }, t2("elements.element", { count: 1 })), /* @__PURE__ */ React52.createElement("div", {
    className: "w-full p-1 pl-3 flex-grow"
  }, t2("tasks.name")), /* @__PURE__ */ React52.createElement("div", {
    className: "pr-1 pl-1 w-64 min-w-[16rem]"
  }, t2("tasks.priority"))), paginatedTasks.map((task, index2) => /* @__PURE__ */ React52.createElement(AllTaskComponent, {
    key: task.id,
    element: element4,
    task,
    onTaskUpdate: handleSave
  })), /* @__PURE__ */ React52.createElement(TaskPaginatorComponent, {
    tasks,
    onPageChange: setPaginatedTasks
  }));
}

// src/components/tasks/AssignedTaskListComponent.tsx
var React54 = __toESM(require_react());

// src/components/tasks/AssignedTaskComponent.tsx
var React53 = __toESM(require_react());
function AssignedTaskComponent({
  element: element4,
  task,
  onTaskUpdate
}) {
  const { t: t2 } = useTranslation();
  const [showDetails, setShowDetails] = React53.useState(false);
  const handleTaskRemoval = (task2) => {
    task2.mentionedIn = task2.mentionedIn.filter((item) => item !== element4.path);
    onTaskUpdate(task2);
  };
  const handleStatusChange = (task2) => {
    task2.click();
    onTaskUpdate(task2);
  };
  const handlePriorityChange = (priority) => {
    task.priority = priority;
    onTaskUpdate(task);
  };
  const handleNameChange = (name) => {
    task.name = name;
    onTaskUpdate(task);
  };
  const handleUpdate = (task2) => {
    setShowDetails(false);
    onTaskUpdate(task2);
  };
  let taskIcon;
  if (task.status === "complete" /* Complete */) {
    taskIcon = /* @__PURE__ */ React53.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "h-5 w-5",
      viewBox: "0 0 24 24"
    }, /* @__PURE__ */ React53.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "10",
      fill: "green"
    }), /* @__PURE__ */ React53.createElement("path", {
      d: "M9 12l2 2l4-4",
      fill: "lightgray",
      stroke: "lightgray"
    }));
  } else {
    taskIcon = /* @__PURE__ */ React53.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "h-5 w-5 text-[--background-modifier-border] group-hover:text-green-500 active:text-green-700 transition-colors duration-200",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }, /* @__PURE__ */ React53.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "10"
    }), /* @__PURE__ */ React53.createElement("path", {
      d: "M9 12l2 2l4-4"
    }));
  }
  return /* @__PURE__ */ React53.createElement(React53.Fragment, null, /* @__PURE__ */ React53.createElement("div", {
    className: `flex items-center w-full text-sm cursor-pointer group ${!showDetails && "border-b border-b-[--background-modifier-border] hover:bg-[--background-primary-alt]"}`
  }, /* @__PURE__ */ React53.createElement("div", {
    className: "max-w-5 w-5 align-middle items-center !m-2",
    onClick: (e2) => {
      e2.stopPropagation();
      handleStatusChange(task);
    }
  }, taskIcon), /* @__PURE__ */ React53.createElement("div", {
    className: "col-span-1 max-w-[10rem] w-40 align-middle items-center !m-2"
  }, /* @__PURE__ */ React53.createElement("a", {
    href: task.element.path,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, task.element.name)), /* @__PURE__ */ React53.createElement("div", {
    className: "w-full p-1 flex-grow"
  }, /* @__PURE__ */ React53.createElement("div", {
    contentEditable: true,
    suppressContentEditableWarning: true,
    className: "min-w-[60px] rounded-sm p-1 !border !border-transparent bg-[--background-primary] group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border] focus:!shadow-none",
    style: { display: "inline-block" },
    onBlur: (e2) => {
      if (task.name !== e2.target.textContent)
        handleNameChange(e2.target.textContent || "");
    },
    onKeyDown: (e2) => {
      if (e2.key === "Enter") {
        e2.preventDefault();
      }
    }
  }, task.name)), /* @__PURE__ */ React53.createElement("div", {
    className: "pr-1 w-32 min-w-[8rem]"
  }, /* @__PURE__ */ React53.createElement("select", {
    defaultValue: task.priority,
    onChange: (e2) => handlePriorityChange(e2.target.value),
    className: "selectBorder w-full \n                        !border !border-transparent group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border]\n                        h-7 pl-1 \n                        focus:!shadow-none !shadow-none\n                        bg-transparent group-hover:bg-[--background-modifier-form-field]\n                        "
  }, Object.entries(PriorityType).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React53.createElement("option", {
    key,
    value: index2
  }, key)))), /* @__PURE__ */ React53.createElement("div", {
    className: "pr-1 w-28 min-w-[7rem] align-middle items-center opacity-0 group-hover:opacity-100 !text-[--text-muted] hover:!text-[--text-accent]"
  }, /* @__PURE__ */ React53.createElement("button", {
    className: "rpgm-danger",
    onClick: (e2) => {
      e2.stopPropagation();
      handleTaskRemoval(task);
    }
  }, t2("buttons.unassign"))), /* @__PURE__ */ React53.createElement("div", {
    className: "pr-1 w-4 min-w-[1rem] align-middle items-center opacity-0 group-hover:opacity-100 !text-[--text-muted] hover:!text-[--text-accent]",
    onClick: () => setShowDetails(!showDetails)
  }, ">")), showDetails && /* @__PURE__ */ React53.createElement(TaskDetailComponent, {
    element: element4,
    task,
    onTaskUpdate: handleUpdate
  }));
}

// src/components/tasks/AssignedTaskListComponent.tsx
function AssignedTaskListComponent({
  element: element4,
  tasks
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const ITEMS_PER_PAGE = 10;
  const initialTasks = tasks.slice(0, ITEMS_PER_PAGE);
  const [paginatedTasks, setPaginatedTasks] = React54.useState(initialTasks);
  const handleSave = (task) => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, task.element.file);
    codeblockService.addOrUpdateTask(task);
  };
  return /* @__PURE__ */ React54.createElement("div", null, /* @__PURE__ */ React54.createElement("div", {
    className: "text-xs text-[--text-muted] flex items-center w-full hover:bg-[--background-primary-alt] border-b border-b-[--background-modifier-border] cursor-pointer group"
  }, /* @__PURE__ */ React54.createElement("div", {
    className: "col-span-1 max-w-5 w-5 align-middle items-center !m-2"
  }, "\xA0"), /* @__PURE__ */ React54.createElement("div", {
    className: "col-span-1 max-w-[10rem] w-40 align-middle items-center !m-2"
  }, t2("elements.element", { count: 1 })), /* @__PURE__ */ React54.createElement("div", {
    className: "w-full p-1 pl-3 flex-grow"
  }, t2("tasks.name")), /* @__PURE__ */ React54.createElement("div", {
    className: "pr-1 pl-1 w-64 min-w-[16rem]"
  }, t2("tasks.priority"))), paginatedTasks.map((task, index2) => /* @__PURE__ */ React54.createElement(AssignedTaskComponent, {
    key: task.id,
    element: element4,
    task,
    onTaskUpdate: handleSave
  })), /* @__PURE__ */ React54.createElement(TaskPaginatorComponent, {
    tasks,
    onPageChange: setPaginatedTasks
  }));
}

// src/components/tasks/OwnTaskListComponent.tsx
var React57 = __toESM(require_react());

// src/components/tasks/NewTaskComponent.tsx
var React55 = __toESM(require_react());
function NewTaskComponent({
  element: element4,
  onTaskCreation,
  onCancel
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const [name, setName] = React55.useState("");
  const inputRef = React55.useRef(null);
  React55.useEffect(() => {
    var _a;
    (_a = inputRef.current) == null ? void 0 : _a.focus();
  }, []);
  const handleCreateNewTask = () => {
    const task = new Task(api2, element4);
    task.name = name;
    onTaskCreation(task);
  };
  return /* @__PURE__ */ React55.createElement("div", {
    className: "flex w-full pb-1 mb-1 pt-1"
  }, /* @__PURE__ */ React55.createElement("div", {
    className: "flex"
  }, /* @__PURE__ */ React55.createElement("div", {
    className: "col-span-1 max-w-5 w-5 align-middle items-center !m-2"
  }, "\xA0"), /* @__PURE__ */ React55.createElement("div", {
    className: "w-full p-1 pl-3 flex-grow"
  }, /* @__PURE__ */ React55.createElement("div", {
    ref: inputRef,
    contentEditable: true,
    suppressContentEditableWarning: true,
    className: "min-w-[60px] rounded-sm p-1 !border !border-transparent bg-[--background-primary] group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border] focus:!shadow-none",
    style: { whiteSpace: "nowrap", overflow: "hidden" },
    onBlur: (e2) => setName(e2.currentTarget.textContent || ""),
    onKeyDown: (e2) => {
      if (e2.key === "Enter") {
        e2.preventDefault();
      }
    }
  }))), /* @__PURE__ */ React55.createElement("div", {
    className: "flex justify-end w-full text-xs"
  }, /* @__PURE__ */ React55.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 mr-3",
    onClick: () => onCancel(false)
  }, t2("buttons.cancel")), /* @__PURE__ */ React55.createElement("button", {
    className: "rpgm-primary pl-3 pr-3",
    onClick: handleCreateNewTask
  }, t2("create.add", { context: "task" }))));
}

// src/components/tasks/TaskComponent.tsx
var React56 = __toESM(require_react());
var TaskComponent = React56.memo(function TaskComponent2({
  element: element4,
  task,
  onTaskDeletion,
  onTaskUpdate
}) {
  const { t: t2 } = useTranslation();
  const [showDetails, setShowDetails] = React56.useState(false);
  const handleStatusChange = (task2) => {
    task2.click();
    onTaskUpdate(task2);
  };
  const handlePriorityChange = (priority) => {
    task.priority = priority;
    onTaskUpdate(task);
  };
  const handleNameChange = (name) => {
    task.name = name;
    onTaskUpdate(task);
  };
  const handleUpdate = (task2) => {
    setShowDetails(false);
    onTaskUpdate(task2);
  };
  let taskIcon;
  if (task.status === "complete" /* Complete */) {
    taskIcon = /* @__PURE__ */ React56.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "h-5 w-5",
      viewBox: "0 0 24 24"
    }, /* @__PURE__ */ React56.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "10",
      fill: "green"
    }), /* @__PURE__ */ React56.createElement("path", {
      d: "M9 12l2 2l4-4",
      fill: "lightgray",
      stroke: "lightgray"
    }));
  } else if (task.status === "incomplete" /* Incomplete */) {
    taskIcon = /* @__PURE__ */ React56.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "h-5 w-5 text-[--background-modifier-border] group-hover:text-green-500 active:text-green-700 transition-colors duration-200",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }, /* @__PURE__ */ React56.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "10"
    }), /* @__PURE__ */ React56.createElement("path", {
      d: "M9 12l2 2l4-4"
    }));
  } else if (task.status === "proposed" /* Proposed */) {
    taskIcon = /* @__PURE__ */ React56.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "h-5 w-5 text-[--text-warning] transition-colors duration-200",
      viewBox: "0 0 24 24"
    }, /* @__PURE__ */ React56.createElement("circle", {
      cx: "12",
      cy: "12",
      r: "10",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React56.createElement("text", {
      x: "12",
      y: "16",
      fontSize: "10",
      textAnchor: "middle",
      fill: "currentColor"
    }, "?"));
  }
  return /* @__PURE__ */ React56.createElement(React56.Fragment, null, /* @__PURE__ */ React56.createElement("div", {
    className: `flex items-center w-full text-sm cursor-pointer group ${!showDetails && "border-b border-b-[--background-modifier-border] hover:bg-[--background-primary-alt]"}`
  }, /* @__PURE__ */ React56.createElement("div", {
    className: "max-w-5 w-5 align-middle items-center !m-2",
    onClick: (e2) => {
      e2.stopPropagation();
      handleStatusChange(task);
    }
  }, taskIcon), /* @__PURE__ */ React56.createElement("div", {
    className: "w-full p-1 flex-grow"
  }, /* @__PURE__ */ React56.createElement("div", {
    contentEditable: true,
    suppressContentEditableWarning: true,
    className: "min-w-[60px] rounded-sm p-1 !border !border-transparent bg-[--background-primary] group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border] focus:!shadow-none",
    style: { display: "inline-block" },
    onBlur: (e2) => {
      if (task.name !== e2.target.textContent)
        handleNameChange(e2.target.textContent || "");
    },
    onKeyDown: (e2) => {
      if (e2.key === "Enter") {
        e2.preventDefault();
      }
    }
  }, task.name)), /* @__PURE__ */ React56.createElement("div", {
    className: "pr-1 w-32 min-w-[8rem]"
  }, /* @__PURE__ */ React56.createElement("select", {
    defaultValue: task.priority,
    onChange: (e2) => handlePriorityChange(e2.target.value),
    className: "selectBorder w-full \n                        !border !border-transparent group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border]\n                        h-7 pl-1 \n                        focus:!shadow-none !shadow-none\n                        bg-transparent group-hover:bg-[--background-modifier-form-field]\n                        "
  }, Object.entries(PriorityType).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React56.createElement("option", {
    key,
    value: index2
  }, key)))), /* @__PURE__ */ React56.createElement("div", {
    className: "pr-1 w-28 min-w-[7rem] align-middle items-center opacity-0 group-hover:opacity-100 !text-[--text-muted] hover:!text-[--text-accent]"
  }, /* @__PURE__ */ React56.createElement("button", {
    className: "rpgm-danger",
    onClick: (e2) => {
      e2.stopPropagation();
      onTaskDeletion(task);
    }
  }, t2("buttons.delete"))), /* @__PURE__ */ React56.createElement("div", {
    className: "pr-1 w-4 min-w-[1rem] align-middle items-center opacity-0 group-hover:opacity-100 !text-[--text-muted] hover:!text-[--text-accent]",
    onClick: () => setShowDetails(!showDetails)
  }, ">")), showDetails && /* @__PURE__ */ React56.createElement(TaskDetailComponent, {
    element: element4,
    task,
    onTaskUpdate: handleUpdate
  }));
});
var TaskComponent_default = TaskComponent;

// src/components/tasks/OwnTaskListComponent.tsx
function OwnTaskListComponent({
  element: element4,
  tasks,
  allowNewTask
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const ITEMS_PER_PAGE = 10;
  const initialTasks = tasks.slice(0, ITEMS_PER_PAGE);
  const [paginatedTasks, setPaginatedTasks] = React57.useState(initialTasks);
  const [newTask, setNewTask] = React57.useState(false);
  const [showNewTask, setShowNewTask] = React57.useState(allowNewTask);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  const handleDelete = (task) => {
    codeblockService.deleteTask(task);
  };
  const handleSave = (task) => {
    codeblockService.addOrUpdateTask(task);
    setNewTask(false);
    setShowNewTask(true);
  };
  function handleCreateNewTask() {
    setNewTask(true);
    setShowNewTask(false);
  }
  return /* @__PURE__ */ React57.createElement("div", null, /* @__PURE__ */ React57.createElement("div", {
    className: "text-xs text-[--text-muted] flex items-center w-full hover:bg-[--background-primary-alt] border-b border-b-[--background-modifier-border] cursor-pointer group"
  }, /* @__PURE__ */ React57.createElement("div", {
    className: "col-span-1 max-w-5 w-5 align-middle items-center !m-2"
  }, "\xA0"), /* @__PURE__ */ React57.createElement("div", {
    className: "w-full p-1 pl-3 flex-grow"
  }, t2("tasks.name")), /* @__PURE__ */ React57.createElement("div", {
    className: "pr-1 pl-1 w-64 min-w-[16rem]"
  }, t2("tasks.priority"))), paginatedTasks.map((task, index2) => /* @__PURE__ */ React57.createElement(TaskComponent_default, {
    key: task.id,
    element: element4,
    task,
    onTaskDeletion: handleDelete,
    onTaskUpdate: handleSave
  })), newTask && /* @__PURE__ */ React57.createElement(NewTaskComponent, {
    element: element4,
    onTaskCreation: handleSave,
    onCancel: () => {
      setNewTask(false);
      setShowNewTask(true);
    }
  }), allowNewTask && showNewTask && !newTask && /* @__PURE__ */ React57.createElement("div", {
    className: "pb-1 mb-1 pt-1 text-xs flex justify-end w-full"
  }, /* @__PURE__ */ React57.createElement("button", {
    className: "rpgm-secondary",
    onClick: handleCreateNewTask
  }, t2("create.new", { context: "task" }))), /* @__PURE__ */ React57.createElement(TaskPaginatorComponent, {
    tasks,
    onPageChange: setPaginatedTasks
  }));
}

// src/components/tasks/TasksContainerComponent.tsx
function TasksContainerComponent({ element: element4 }) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  let tasks = api2.tasks.getMentionedIn(element4);
  const [viewTasks, setViewTasks] = React58.useState(true);
  const [viewType, setViewType] = React58.useState(tasks.length > 0 ? "assigned" : "own");
  if (viewType === "own") {
    tasks = element4.tasks;
  } else if (viewType === "all") {
    tasks = api2.tasks.getByStatus("incomplete" /* Incomplete */, element4);
  }
  return /* @__PURE__ */ React58.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React58.createElement("div", {
    className: "flex items-center"
  }, /* @__PURE__ */ React58.createElement("div", {
    onClick: () => setViewTasks(!viewTasks),
    className: "h-5 w-5 mr-2 flex items-center justify-center cursor-pointer"
  }, /* @__PURE__ */ React58.createElement("svg", {
    className: "transform transition-transform duration-200",
    viewBox: "0 0 24 24",
    style: {
      transform: viewTasks ? "rotate(0deg)" : "rotate(-90deg)"
    }
  }, /* @__PURE__ */ React58.createElement("path", {
    fill: "currentColor",
    d: "M12 16l-8-8h16l-8 8z"
  }))), /* @__PURE__ */ React58.createElement("h2", {
    className: "!m-0"
  }, t2("tasks.task", { count: 2 }))), viewTasks && /* @__PURE__ */ React58.createElement("div", {
    className: "w-full mt-3 p-3 rounded-lg border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React58.createElement("div", {
    className: "w-full pb-3 mb-3 border-b border-b-[--background-modifier-border] flex justify-between"
  }, /* @__PURE__ */ React58.createElement("div", {
    className: "w-full flex"
  }, /* @__PURE__ */ React58.createElement("div", {
    className: `${viewType === "own" && "text-[--text-accent]"} pr-3 mr-3 border-r border-r-[--background-modifier-border] cursor-pointer hover:text-[--text-accent-hover]`,
    onClick: () => setViewType("own")
  }, t2("tasks.owned", { variable: element4.name })), /* @__PURE__ */ React58.createElement("div", {
    className: `${viewType === "assigned" && "text-[--text-accent]"} pr-3 mr-3 border-r border-r-[--background-modifier-border] cursor-pointer hover:text-[--text-accent-hover]`,
    onClick: () => setViewType("assigned")
  }, t2("tasks.assignedto"), " ", element4.name), /* @__PURE__ */ React58.createElement("div", {
    className: `${viewType === "all" && "text-[--text-accent]"} cursor-pointer hover:text-[--text-accent-hover]`,
    onClick: () => setViewType("all")
  }, t2("tasks.all")))), /* @__PURE__ */ React58.createElement("div", {
    className: "w-full min-h-[100px] relative"
  }, viewType === "own" ? /* @__PURE__ */ React58.createElement(OwnTaskListComponent, {
    element: element4,
    tasks,
    allowNewTask: viewTasks && viewType === "own"
  }) : viewType === "assigned" ? /* @__PURE__ */ React58.createElement(AssignedTaskListComponent, {
    element: element4,
    tasks
  }) : /* @__PURE__ */ React58.createElement(AllTaskListComponent, {
    element: element4,
    tasks
  }))));
}

// src/components/elements/ChapterComponent.tsx
function ChapterComponent({
  element: element4,
  isInPopover
}) {
  const storyCircle = element4.attribute("StoryCircle" /* StoryCircle */);
  const kishotenketsu2 = element4.attribute("kishotenketsu" /* Kishotenketsu */);
  const conflict2 = element4.attribute("conflict" /* Conflict */);
  return /* @__PURE__ */ React59.createElement(React59.Fragment, null, /* @__PURE__ */ React59.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React59.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.images.length > 0 && /* @__PURE__ */ React59.createElement(BannerComponent, {
    image: element4.images[0]
  }), /* @__PURE__ */ React59.createElement("div", {
    className: `grid grid-cols-1 sm:grid-cols-1 lg:grid-cols-5 gap-3 !mb-3}`
  }, /* @__PURE__ */ React59.createElement("div", {
    className: `col-span-5 sm:col-span-1 lg:col-span-5`
  }, /* @__PURE__ */ React59.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 !mb-3"
  }, /* @__PURE__ */ React59.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  }), /* @__PURE__ */ React59.createElement(ParentAttributeComponent, {
    element: element4,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React59.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), element4.images.length > 1 && /* @__PURE__ */ React59.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React59.createElement(ImageCarouselComponent, {
    element: element4
  })), conflict2 && conflict2.isSet && /* @__PURE__ */ React59.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React59.createElement(ConflictComponent, {
    element: element4,
    attribute: conflict2,
    isEditable: !isInPopover
  })), kishotenketsu2 && kishotenketsu2.isSet && /* @__PURE__ */ React59.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React59.createElement(KishotenketsuComponent, {
    element: element4,
    attribute: kishotenketsu2,
    isEditable: !isInPopover
  })), storyCircle && storyCircle.isSet && /* @__PURE__ */ React59.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React59.createElement(StoryCircleAttributeComponent, {
    element: element4,
    attribute: storyCircle,
    isEditable: !isInPopover
  })), !isInPopover && /* @__PURE__ */ React59.createElement(TasksContainerComponent, {
    element: element4
  }), isInPopover === false && element4.relationships.length > 0 && /* @__PURE__ */ React59.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React59.createElement(RelationshipsComponent, {
    element: element4
  }))));
}

// src/components/elements/ClueComponent.tsx
var React65 = __toESM(require_react());

// src/components/groups/MainV1Component.tsx
var React64 = __toESM(require_react());

// src/components/attributes/types/OgasAttributeComponent.tsx
var React60 = __toESM(require_react());
function OgasAttributeComponent({ element: element4 }) {
  var _a, _b, _c, _d;
  const { t: t2 } = useTranslation();
  if (element4.type !== "nonplayercharacter" /* NonPlayerCharacter */)
    return null;
  const occupation2 = (_a = element4.attribute("occupation" /* Occupation */)) == null ? void 0 : _a.value;
  const stake2 = (_b = element4.attribute("stake" /* Stake */)) == null ? void 0 : _b.value;
  const goal = (_c = element4.attribute("want" /* Want */)) == null ? void 0 : _c.value;
  const attitude = (_d = element4.attribute("behaviour" /* Behaviour */)) == null ? void 0 : _d.value;
  if (!occupation2 || !stake2 || !goal || !attitude)
    return null;
  const widthPercentage = stake2 / 10 * 100;
  return /* @__PURE__ */ React60.createElement("div", {
    className: "space-y-3 mt-3 border border-[--background-modifier-border] grid grid-cols-4 p-3 rounded-lg text-xs"
  }, /* @__PURE__ */ React60.createElement("div", {
    className: "col-span-4 font-bold text-base"
  }, "OGAS"), /* @__PURE__ */ React60.createElement("div", {
    className: "font-bold"
  }, t2("attributes.occupation")), /* @__PURE__ */ React60.createElement("div", {
    className: "col-span-3"
  }, /* @__PURE__ */ React60.createElement(MarkdownComponent, {
    key: "occupation",
    value: occupation2
  })), /* @__PURE__ */ React60.createElement("div", {
    className: "font-bold"
  }, t2("attributes.goals")), /* @__PURE__ */ React60.createElement("div", {
    className: "col-span-3"
  }, /* @__PURE__ */ React60.createElement(MarkdownComponent, {
    key: "goals",
    value: goal
  })), /* @__PURE__ */ React60.createElement("div", {
    className: "font-bold"
  }, t2("attributes.attitude")), /* @__PURE__ */ React60.createElement("div", {
    className: "col-span-3"
  }, /* @__PURE__ */ React60.createElement(MarkdownComponent, {
    key: "attitude",
    value: attitude
  })), /* @__PURE__ */ React60.createElement("div", {
    className: "font-bold"
  }, t2("attributes.stake")), /* @__PURE__ */ React60.createElement("div", {
    className: "col-span-3 pt-1"
  }, /* @__PURE__ */ React60.createElement("div", {
    className: "relative mr-3 h-2 bg-[--background-primary-alt] rounded-full"
  }, /* @__PURE__ */ React60.createElement("div", {
    style: { width: `${widthPercentage}%` },
    className: "absolute h-2 bg-[--text-accent] rounded-full"
  })), /* @__PURE__ */ React60.createElement("div", {
    className: "text-xs text-[--text-faint] text-center"
  }, stake2)));
}

// src/components/attributes/types/SensoryImprintAttributeComponent.tsx
var React62 = __toESM(require_react());

// src/components/chatgpt/ChatGptOverlay.tsx
var React61 = __toESM(require_react());
function ChatGptOverlay({ type: type2 }) {
  const { t: t2 } = useTranslation();
  const [currentMessage, setCurrentMessage] = React61.useState(t2("chatgpt.messages", { returnObjects: true })[0]);
  React61.useEffect(() => {
    const interval = setInterval(() => {
      const randomMessage = t2("chatgpt.messages", { returnObjects: true })[Math.floor(Math.random() * (t2("chatgpt.messages", { returnObjects: true }).length - 1)) + 1];
      setCurrentMessage(randomMessage);
    }, 5e3);
    return () => clearInterval(interval);
  }, []);
  return /* @__PURE__ */ React61.createElement("div", {
    className: "absolute inset-0 z-10 flex items-center justify-center bg-black bg-opacity-50 p-4"
  }, /* @__PURE__ */ React61.createElement("div", {
    className: "text-center space-y-4"
  }, /* @__PURE__ */ React61.createElement("div", {
    className: "text-2xl text-white font-semibold"
  }, t2("chatgpt.overlaytitle", { context: type2 })), /* @__PURE__ */ React61.createElement("div", {
    className: "text-xl text-white"
  }, t2("chatgpt.overlaydescription")), /* @__PURE__ */ React61.createElement("div", {
    className: "text-white"
  }, currentMessage)));
}

// src/services/ChatGptService/ChatGptMessage.ts
var ChatGptMessage = class {
  constructor(role, content3) {
    this.role = role;
    this.content = content3;
    this.content = this._simplifyLinks(this.content);
  }
  _simplifyLinks(input) {
    const wikiLinkRegex = /\[\[(?:.*\/)?(.*?)(?:\.md)?(\|([^]]+))?\]\]/g;
    return input.replace(wikiLinkRegex, (_2, link2, __, alias) => alias ? alias : link2);
  }
};

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap3() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString2 } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
var typeOfTest = (type2) => (thing) => typeof thing === type2;
var { isArray } = Array;
var isUndefined2 = typeOfTest("undefined");
function isBuffer2(val) {
  return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString2 = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber2 = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject2 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate2 = kindOfTest("Date");
var isFile2 = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined2(context) && context !== _global;
function merge2() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
      result[targetKey] = merge2(result[targetKey], val);
    } else if (isPlainObject2(val)) {
      result[targetKey] = merge2({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend2 = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content3) => {
  if (content3.charCodeAt(0) === 65279) {
    content3 = content3.slice(1);
  }
  return content3;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position6) => {
  str = String(str);
  if (position6 === void 0 || position6 > str.length) {
    position6 = str.length;
  }
  position6 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position6);
  return lastIndex !== -1 && lastIndex === position6;
};
var toArray2 = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber2(i))
    return null;
  const arr2 = new Array(i);
  while (i-- > 0) {
    arr2[i] = thing[i];
  }
  return arr2;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr2 = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr2.push(matches);
  }
  return arr2;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
var hasOwnProperty3 = (({ hasOwnProperty: hasOwnProperty4 }) => (obj, prop) => hasOwnProperty4.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer2) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer2(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr2) => {
    arr2.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop6 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit2 = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit2(value, i + 1);
          !isUndefined2(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit2(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer: isBuffer2,
  isFormData,
  isArrayBufferView,
  isString: isString2,
  isNumber: isNumber2,
  isBoolean,
  isObject,
  isPlainObject: isPlainObject2,
  isUndefined: isUndefined2,
  isDate: isDate2,
  isFile: isFile2,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge2,
  extend: extend2,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray2,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty3,
  hasOwnProp: hasOwnProperty3,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop6,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code2, config3, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config3 && (this.config = config3);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error2, code2, config3, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code2, config3, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path4, key, dots) {
  if (!path4)
    return key;
  return path4.concat(key).map(function each2(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr2) {
  return utils_default.isArray(arr2) && !arr2.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path4) {
    let arr2 = value;
    if (value && !path4 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr2 = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr2.forEach(function each2(el, index2) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]", convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path4, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build3(value, path4) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path4.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each2(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path4, exposedHelpers);
      if (result === true) {
        build3(el, path4 ? path4.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build3(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match3) {
    return charMap[match3];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString3(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
var isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new browser_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path4, helpers) {
      if (browser_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match3) => {
    return match3[0] === "[]" ? "" : match3[1] || match3[0];
  });
}
function arrayToObject(arr2) {
  const obj = {};
  const keys2 = Object.keys(arr2);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr2[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path4, value, target, index2) {
    let name = path4[index2++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path4.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path4, value, target[name], index2);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults2 = {
  transitional: transitional_default,
  adapter: browser_default.isNode ? "http" : "xhr",
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults2.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: browser_default.classes.FormData,
    Blob: browser_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults2.headers[method] = {};
});
var defaults_default = defaults2;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match3;
  while (match3 = tokensRE.exec(str)) {
    tokens[match3[1]] = match3[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config3 = this || defaults_default;
  const context = response || config3;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config3, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config3, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config3, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = browser_default.isStandardBrowserEnv ? function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path4, domain, secure) {
      const cookie2 = [];
      cookie2.push(name + "=" + encodeURIComponent(value));
      if (utils_default.isNumber(expires)) {
        cookie2.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils_default.isString(path4)) {
        cookie2.push("path=" + path4);
      }
      if (utils_default.isString(domain)) {
        cookie2.push("domain=" + domain);
      }
      if (secure === true) {
        cookie2.push("secure");
      }
      document.cookie = cookie2.join("; ");
    },
    read: function read2(name) {
      const match3 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match3 ? decodeURIComponent(match3[3]) : null;
    },
    remove: function remove2(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read2() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = browser_default.isStandardBrowserEnv ? function standardBrowserEnv2() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url) {
    let href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin(requestURL) {
    const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin() {
    return true;
  };
}();

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match3 && match3[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push2(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener3, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e2) => {
    const loaded2 = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded2 - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded2 <= total;
    bytesNotified = loaded2;
    const data = {
      loaded: loaded2,
      total,
      progress: total ? loaded2 / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded2) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener3(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config3) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config3.data;
    const requestHeaders = AxiosHeaders_default.from(config3.headers).normalize();
    const responseType = config3.responseType;
    let onCanceled;
    function done() {
      if (config3.cancelToken) {
        config3.cancelToken.unsubscribe(onCanceled);
      }
      if (config3.signal) {
        config3.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils_default.isFormData(requestData)) {
      if (browser_default.isStandardBrowserEnv || browser_default.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request = new XMLHttpRequest();
    if (config3.auth) {
      const username = config3.auth.username || "";
      const password = config3.auth.password ? unescape(encodeURIComponent(config3.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config3.baseURL, config3.url);
    request.open(config3.method.toUpperCase(), buildURL(fullPath, config3.params, config3.paramsSerializer), true);
    request.timeout = config3.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config3,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config3, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config3, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config3.timeout ? "timeout of " + config3.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config3.transitional || transitional_default;
      if (config3.timeoutErrorMessage) {
        timeoutErrorMessage = config3.timeoutErrorMessage;
      }
      reject(new AxiosError_default(timeoutErrorMessage, transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config3, request));
      request = null;
    };
    if (browser_default.isStandardBrowserEnv) {
      const xsrfValue = (config3.withCredentials || isURLSameOrigin_default(fullPath)) && config3.xsrfCookieName && cookies_default.read(config3.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config3.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config3.withCredentials)) {
      request.withCredentials = !!config3.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config3.responseType;
    }
    if (typeof config3.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config3.onDownloadProgress, true));
    }
    if (typeof config3.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config3.onUploadProgress));
    }
    if (config3.cancelToken || config3.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config3, request) : cancel);
        request.abort();
        request = null;
      };
      config3.cancelToken && config3.cancelToken.subscribe(onCanceled);
      if (config3.signal) {
        config3.signal.aborted ? onCanceled() : config3.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && browser_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config3));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if (adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError_default(`Adapter ${nameOrAdapter} is not supported by the environment`, "ERR_NOT_SUPPORT");
      }
      throw new Error(utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
    }
    if (!utils_default.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config3) {
  if (config3.cancelToken) {
    config3.cancelToken.throwIfRequested();
  }
  if (config3.signal && config3.signal.aborted) {
    throw new CanceledError_default(null, config3);
  }
}
function dispatchRequest(config3) {
  throwIfCancellationRequested(config3);
  config3.headers = AxiosHeaders_default.from(config3.headers);
  config3.data = transformData.call(config3, config3.transformRequest);
  if (["post", "put", "patch"].indexOf(config3.method) !== -1) {
    config3.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config3.adapter || defaults_default.adapter);
  return adapter(config3).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config3);
    response.data = transformData.call(config3, config3.transformResponse, response);
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config3);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config3, config3.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config22) {
  config22 = config22 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config22) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config22)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config22[prop], prop);
    utils_default.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.5.0";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators[type2] = function validator(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError_default.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  request(configOrUrl, config3) {
    if (typeof configOrUrl === "string") {
      config3 = config3 || {};
      config3.url = configOrUrl;
    } else {
      config3 = configOrUrl || {};
    }
    config3 = mergeConfig(this.defaults, config3);
    const { transitional: transitional2, paramsSerializer, headers } = config3;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config3.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config3.method = (config3.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(headers.common, headers[config3.method]);
    headers && utils_default.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config3.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config3) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config3);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config3;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config3) {
    config3 = mergeConfig(this.defaults, config3);
    const fullPath = buildFullPath(config3.baseURL, config3.url);
    return buildURL(fullPath, config3.params, config3.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config3) {
    return this.request(mergeConfig(config3 || {}, {
      method,
      url,
      data: (config3 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config3) {
      return this.request(mergeConfig(config3 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config3, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config3, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener3) {
    if (this.reason) {
      listener3(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener3);
    } else {
      this._listeners = [listener3];
    }
  }
  unsubscribe(listener3) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener3);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap3(arr2) {
    return callback.apply(null, arr2);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance2(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance2 = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance2, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance2, context, null, { allOwnKeys: true });
  instance2.create = function create4(instanceConfig) {
    return createInstance2(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios = createInstance2(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all5(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all6,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/services/ChatGptService/ChatGptService.ts
var ChatGptService = class {
  constructor(_api, _model = "gpt-3.5-turbo" /* Gpt3Turbo */) {
    this._api = _api;
    this._model = _model;
    __publicField(this, "_endpoint", "https://api.openai.com/v1/chat/completions");
  }
  persona() {
    return `You are an expert storyteller with more than 20 years of experience in scriptwriting, storytelling, plotting and ttrpgs.`;
  }
  context(campaign) {
    var _a;
    let response = `You are the Game Master of a campaign called ${campaign.name}.`;
    response += `The campaign synopsis is this: ${(_a = campaign.attribute("description" /* Description */).value) != null ? _a : ""}.`;
    return response;
  }
  format() {
    return `You will provide 10 possible standalone responses to the question, one response per line.
You are forbidden to write any introduction, numbering, or concluding remarks. Just the responses.
Do not include any characters outside of the 10 provided options.`;
  }
  length(type2) {
    switch (type2) {
      case "long":
        return `You will write your responses in a detailed manner. 
Each option (response) will contain one or more sentences
Each option should be qualitative, not a short sentence and will allow the storyteller to use it as source of multiple ideas.`;
      default:
        return `You will write your responses in a short, concise manner. Each option (response) will be a short sentence.`;
    }
  }
  tone() {
    return `You will write your responses in a straightforward tone.`;
  }
  sendMessage(messages) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      try {
        const response = yield axios_default.post(this._endpoint, {
          model: this._model,
          messages
        }, {
          headers: {
            Authorization: `Bearer ${this._api.settings.chatGptKey}`,
            "Content-Type": "application/json"
          }
        });
        const latestMessage = (_c = (_b = (_a = response.data.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content;
        return this._processLatestMessage(latestMessage);
      } catch (error2) {
        console.warn(error2);
        throw error2;
      }
    });
  }
  _processLatestMessage(latestMessage) {
    const splitResponses = latestMessage.trim().split("\n");
    const results = splitResponses.filter((resp) => resp.trim() !== "").map((resp) => ({ response: resp.replace(/^\d+\.\s*/, "").trim() }));
    return results;
  }
};

// src/services/ChatGptService/models/ChatGptNonPlayerCharacterModel.ts
var ChatGptNonPlayerCharacterModel = class {
  constructor(_api, _campaign, _name, _model = "gpt-3.5-turbo" /* Gpt3Turbo */) {
    this._api = _api;
    this._campaign = _campaign;
    this._name = _name;
    this._model = _model;
    __publicField(this, "_service");
    __publicField(this, "_dataMessages", /* @__PURE__ */ new Map());
    this._service = new ChatGptService(_api, _model);
  }
  _generateMessages(length) {
    const response = [];
    response.push(new ChatGptMessage("system", this._service.persona()));
    response.push(new ChatGptMessage("system", this.persona()));
    response.push(new ChatGptMessage("system", this._service.format()));
    response.push(new ChatGptMessage("system", this._service.tone()));
    response.push(new ChatGptMessage("system", this._service.length(length)));
    response.push(new ChatGptMessage("system", this._service.context(this._campaign)));
    response.push(new ChatGptMessage("system", this.context()));
    const descriptionMessage = this._dataMessages.get("description");
    if (descriptionMessage)
      response.push(descriptionMessage);
    const characterArcMessage = this._dataMessages.get("characterArc");
    if (characterArcMessage)
      response.push(characterArcMessage);
    const beliefsMessage = this._dataMessages.get("beliefs");
    if (beliefsMessage)
      response.push(beliefsMessage);
    const ghostMessage = this._dataMessages.get("ghost");
    if (ghostMessage)
      response.push(ghostMessage);
    const lieMessage = this._dataMessages.get("lie");
    if (lieMessage)
      response.push(lieMessage);
    const needMessage = this._dataMessages.get("need");
    if (needMessage)
      response.push(needMessage);
    const strengthsMessage = this._dataMessages.get("strengths");
    if (strengthsMessage)
      response.push(strengthsMessage);
    const weaknessesMessage = this._dataMessages.get("weaknesses");
    if (weaknessesMessage)
      response.push(weaknessesMessage);
    const behaviourMessage = this._dataMessages.get("behaviour");
    if (behaviourMessage)
      response.push(behaviourMessage);
    const wantMessage = this._dataMessages.get("want");
    if (wantMessage)
      response.push(wantMessage);
    const oppositionMessage = this._dataMessages.get("opposition");
    if (oppositionMessage)
      response.push(oppositionMessage);
    return response;
  }
  _generateSuggestions(message, length) {
    const messages = this._generateMessages(length);
    messages.push(message);
    return this._service.sendMessage(messages).then((response) => {
      return response.map((message2) => message2.response);
    });
  }
  persona() {
    return `You are particularly experienced in creating three dimensional characters. To create a character you use the following attributes:
- Character Arc (it can be "Positive", "Disillusionment", "Fall", "Corruption" or "Flat")
- Beliefs (What are the character's core beliefs?)
- Ghost (a past event that defines the belief of a character and a lie the character believes to be true)
- Lie (Something the character accepts as the truth and make them follow their want instead of their need (only If the Type of Character Arc is Positive, Disillusionment or Fall)
- Need (What is the real need of the character?)
- Strengths (picked from this list: Adaptable, Ambitious, Assertive, Charismatic, Compassionate, Courageous, Creative, Decisive, Diligent, Disciplined, Energetic, Empathetic, Humble, Inspirational, Intuitive, Loyal, Patient, Resilient, Self-confident, Strategic, Tenacious, Visionary, Witty)
- Weaknesses (picked from this list: Impulsive, Indecisive, Inflexible, Insecure, Intolerant, Irresponsible, Lazy, Naive, Neglectful, Nervous, Obstinate, Overbearing, Overcritical, Perfectionist, Pessimistic, Procrastinator, Reactive, Rigid, Self-centered, Sensitive, Shy, Stubborn, Timid, Unfocused, Vague)
- Behaviour (What is the general behaviour of the character?)
- Want (What does the character believe they want?)
- Opposition (What forces oppose the character in getting what they want?)
`;
  }
  context() {
    return `The non-player character you are creating is ${this._name}. `;
  }
  set description(description2) {
    this._dataMessages.set("description", {
      role: "system",
      content: `The "description" of ${this._name} is: \`\`\`${description2}\`\`\`.`
    });
  }
  set occupation(occupation2) {
    this._dataMessages.set("occupation", {
      role: "system",
      content: `The "occupation" of ${this._name} is: \`\`\`${occupation2}\`\`\`.`
    });
  }
  set characterArc(characterArc) {
    this._dataMessages.set("characterArc", {
      role: "system",
      content: `The "character arc" of ${this._name} is ${ArcType[characterArc]}.`
    });
  }
  getBeliefs() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 10 core beliefs for ${this._name} that are consistent with the character description and arc.
The core beliefs are the beliefs that define the character. They are the core of the character's personality.
The beliefs should not just circle around the specific information provided so far, but should be more general and applicable to multiple situations.
Imagine the character as a real person and think about what they would believe in, what would be their core values and what would they fight for.`
      };
      return this._generateSuggestions(message, "long");
    });
  }
  set beliefs(beliefs2) {
    this._dataMessages.set("beliefs", {
      role: "system",
      content: `The "beliefs" of ${this._name} is: \`\`\`${beliefs2}\`\`\`.`
    });
  }
  getGhost() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 10 "ghosts" for ${this._name} 
that are consistent with the character description and arc.
A Ghost is a challenging event in ${this._name}'s past that created a crack between the reality and the lie the character believes to be true.`
      };
      return this._generateSuggestions(message, "long");
    });
  }
  set ghost(ghost2) {
    this._dataMessages.set("ghost", {
      role: "system",
      content: `The "ghost" of ${this._name} is: \`\`\`${ghost2}\`\`\`.`
    });
  }
  getLie() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 10 "lies" for ${this._name} that are consistent with the character described so far.
A lie is something the character accepts as the truth and make them follow their want instead of their need.`
      };
      return this._generateSuggestions(message, "long");
    });
  }
  set lie(lie2) {
    this._dataMessages.set("lie", {
      role: "system",
      content: `The "lie" of ${this._name} is: \`\`\`${lie2}\`\`\`.`
    });
  }
  getNeed() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 10 "needs" for ${this._name} with a strong link to the "lie" provided.
The "needs" must are consistent with the character described so far.
A need is what the character really needs to grow and change, even if they don't realise it. They know their want, but they don't know their need.`
      };
      return this._generateSuggestions(message, "long");
    });
  }
  set need(need2) {
    this._dataMessages.set("need", {
      role: "system",
      content: `The "need" of ${this._name} is: \`\`\`${need2}\`\`\`.`
    });
  }
  getStrenghts() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 5 "strengths" for ${this._name} that are consistent with the character described so far.
A strength is a positive trait of the character. Your responses should ONLY contain strengths from this list: Adaptable, Ambitious, Assertive, Charismatic, Compassionate, Courageous, Creative, Decisive, Diligent, Disciplined, Energetic, Empathetic, Humble, Inspirational, Intuitive, Loyal, Patient, Resilient, Self-confident, Strategic, Tenacious, Visionary, Witty.
Write ONE strength per line, using exclusively the words from the list without any additional characters.`
      };
      return this._generateSuggestions(message, "short");
    });
  }
  set strengths(strengths2) {
    this._dataMessages.set("strenghts", {
      role: "system",
      content: `The "strenghts" of ${this._name} are: \`\`\`${strengths2}\`\`\`.`
    });
  }
  getWeaknesses() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 5 "weaknesses" for ${this._name} that are consistent with the character described so far.
A weakness is a negative trait of the character. Your responses should ONLY contain weaknesses from this list: Impulsive, Indecisive, Inflexible, Insecure, Intolerant, Irresponsible, Lazy, Naive, Neglectful, Nervous, Obstinate, Overbearing, Overcritical, Perfectionist, Pessimistic, Procrastinator, Reactive, Rigid, Self-centered, Sensitive, Shy, Stubborn, Timid, Unfocused, Vague.
Write ONE weakness per line, using exclusively the words from the list without any additional characters.`
      };
      return this._generateSuggestions(message, "short");
    });
  }
  set weaknesses(weaknesses2) {
    this._dataMessages.set("weaknesses", {
      role: "system",
      content: `The "weaknesses" of ${this._name} are: \`\`\`${weaknesses2}\`\`\`.`
    });
  }
  getBehaviour() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Generate 10 distinct sets of mixed behaviors, mannerisms, and speech patterns for ${this._name}
			using all the information provided so far. Each set should encompass various facets of the character's traits 
			into a collection of diverse actions and reactions suitable for immediate role-play. 
			Remember, each set should be a blend of their traits rather than focusing on just one aspect and I will only
			pick one of your answers, so each of them should be a complete set of behaviors. Give me one set of behaviours
			per line, no introduction, lists or numbering. Just the behaviors.`
      };
      return this._generateSuggestions(message, "long");
    });
  }
  set behaviour(behaviour2) {
    this._dataMessages.set("behaviour", {
      role: "system",
      content: `The "behaviour" of ${this._name} is: \`\`\`${behaviour2}\`\`\`.`
    });
  }
  getWant() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 10 "wants" for ${this._name} that are consistent with the character described so far.
A want is what the character wants to achieve. They know their want, but they don't know their need.`
      };
      return this._generateSuggestions(message, "long");
    });
  }
  set want(want2) {
    this._dataMessages.set("want", {
      role: "system",
      content: `The "want" of ${this._name} is: \`\`\`${want2}\`\`\`.`
    });
  }
  getOpposition() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest 10 "oppositions" for ${this._name} that are consistent with the character described so far.
An opposition is an obstacle that prevents the character from achieving their want. Your responses should provide hints about possible scenarios that could be used to create a story.`
      };
      return this._generateSuggestions(message, "long");
    });
  }
  set opposition(opposition2) {
    this._dataMessages.set("opposition", {
      role: "system",
      content: `The "opposition" of ${this._name} is: \`\`\`${opposition2}\`\`\`.`
    });
  }
  getSensoryImprint() {
    return __async(this, null, function* () {
      const message = {
        role: "user",
        content: `Based on the information provided, suggest the 5 "sensory imprints" for ${this._name} 
that are consistent with the character described so far.
A "Sensory Imprint" is a description of the immediately perceptible characteristincs of ${this._name}.
Each "sensory imprint" (sight, sound, smell, touch, taste) should be a list of 3-5 bullet points of straightforward, short perceptible characteristincs.
Reply with the sensory imprints in the following order: sight, sound, smell, touch, taste.`
      };
      const response = yield this._generateSuggestions(message, "short");
      const result = [];
      let temp = [];
      response.forEach((item, index2) => {
        if (item.startsWith("-")) {
          temp.push(item);
        } else {
          if (temp.length > 0) {
            result.push(temp.join("\n"));
            temp = [];
          }
        }
        if (index2 === response.length - 1 && temp.length > 0) {
          result.push(temp.join("\n"));
        }
      });
      return result;
    });
  }
};

// src/components/attributes/types/SensoryImprintAttributeComponent.tsx
function EditComponent2({
  element: element4,
  attribute,
  onSave
}) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [showOverlay, setShowOverlay] = React62.useState(false);
  const [sensoryImprint, setSensoryImprint] = React62.useState(attribute.value);
  const [sight, setSight] = React62.useState((_b = (_a = attribute == null ? void 0 : attribute.value) == null ? void 0 : _a.sight) != null ? _b : "");
  const [hear, setHear] = React62.useState((_d = (_c = attribute == null ? void 0 : attribute.value) == null ? void 0 : _c.hear) != null ? _d : "");
  const [smell, setSmell] = React62.useState((_f = (_e = attribute == null ? void 0 : attribute.value) == null ? void 0 : _e.smell) != null ? _f : "");
  const [touch, setTouch] = React62.useState((_h = (_g = attribute == null ? void 0 : attribute.value) == null ? void 0 : _g.touch) != null ? _h : "");
  const [taste, setTaste] = React62.useState((_j = (_i = attribute == null ? void 0 : attribute.value) == null ? void 0 : _i.taste) != null ? _j : "");
  let chatGpt = void 0;
  if (api2.settings.chatGptKey !== void 0 && api2.settings.chatGptKey !== "") {
    chatGpt = new ChatGptNonPlayerCharacterModel(api2, element4.type === "campaign" /* Campaign */ ? element4 : element4.campaign, element4.name);
  }
  const handleGeneration = () => {
    if (chatGpt === void 0)
      return;
    setShowOverlay(true);
    if (element4.attribute("description" /* Description */).isSet)
      chatGpt.description = element4.attribute("description" /* Description */).value;
    if (element4.attribute("behaviour" /* Behaviour */).isSet)
      chatGpt.description = element4.attribute("behaviour" /* Behaviour */).value;
    chatGpt.getSensoryImprint().then((sensoryImprint2) => {
      var _a2, _b2, _c2, _d2, _e2;
      const newSensoryImprint = {
        sight: sensoryImprint2[0],
        hear: sensoryImprint2[1],
        smell: sensoryImprint2[2],
        touch: sensoryImprint2[3],
        taste: sensoryImprint2[4]
      };
      setSight((_a2 = newSensoryImprint.sight) != null ? _a2 : "");
      setHear((_b2 = newSensoryImprint.hear) != null ? _b2 : "");
      setSmell((_c2 = newSensoryImprint.smell) != null ? _c2 : "");
      setTouch((_d2 = newSensoryImprint.touch) != null ? _d2 : "");
      setTaste((_e2 = newSensoryImprint.taste) != null ? _e2 : "");
      setSensoryImprint(newSensoryImprint);
      setShowOverlay(false);
    });
  };
  const handleSightChange = (value) => {
    setSensoryImprint((prevSensoryImprint) => {
      return __spreadProps(__spreadValues({}, prevSensoryImprint), { sight: value });
    });
  };
  const handleHearChange = (value) => {
    setSensoryImprint((prevSensoryImprint) => {
      return __spreadProps(__spreadValues({}, prevSensoryImprint), { hear: value });
    });
  };
  const handleTasteChange = (value) => {
    setSensoryImprint((prevSensoryImprint) => {
      return __spreadProps(__spreadValues({}, prevSensoryImprint), { taste: value });
    });
  };
  const handleTouchChange = (value) => {
    setSensoryImprint((prevSensoryImprint) => {
      return __spreadProps(__spreadValues({}, prevSensoryImprint), { touch: value });
    });
  };
  const handleSmellChange = (value) => {
    setSensoryImprint((prevSensoryImprint) => {
      return __spreadProps(__spreadValues({}, prevSensoryImprint), { smell: value });
    });
  };
  const handleDelete = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData(attribute.id, void 0).then(() => {
      onSave();
    });
  };
  const handleSave = () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.updateCodeblockData(attribute.id, sensoryImprint).then(() => {
      onSave();
    });
  };
  return /* @__PURE__ */ React62.createElement("div", {
    className: "relative w-full bg-[--background-primary] p-3 border border-[--background-modifier-border] rounded-lg"
  }, showOverlay && /* @__PURE__ */ React62.createElement(ChatGptOverlay, {
    type: "sensoryimprint"
  }), /* @__PURE__ */ React62.createElement("div", {
    className: "w-full flex justify-center mb-3"
  }, /* @__PURE__ */ React62.createElement("h3", {
    className: "!p-0 !text-xl !font-extralight"
  }, t2("attributes.sensoryimprints"))), /* @__PURE__ */ React62.createElement("div", {
    className: `w-full grid grid-cols-5 gap-3 items-start`
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "grid grid-cols-1 items-center justify-center w-full"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint] mb-1"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faEye,
    title: "Sight"
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center"
  }, /* @__PURE__ */ React62.createElement(MarkdownEditorComponent, {
    key: "sight:" + sight,
    initialValue: sight,
    onChange: handleSightChange,
    className: "!p-1 m-0 border rounded-md !border-solid !border-[--background-modifier-border] bg-[--background-modifier-form-field] min-w-full min-h[100px] text-xs",
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaign.path
  }))), /* @__PURE__ */ React62.createElement("div", {
    className: "grid grid-cols-1 items-center justify-center w-full mb-3"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint] mb-1"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faEarListen,
    title: "Hearing"
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center"
  }, /* @__PURE__ */ React62.createElement(MarkdownEditorComponent, {
    key: "hear:" + hear,
    initialValue: hear,
    onChange: handleHearChange,
    className: "!p-1 m-0 border rounded-md !border-solid !border-[--background-modifier-border] bg-[--background-modifier-form-field] min-w-full min-h[100px] text-xs",
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaign.path
  }))), /* @__PURE__ */ React62.createElement("div", {
    className: "grid grid-cols-1 items-center justify-center w-full"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint] mb-1"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faWind,
    title: "Smell"
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center"
  }, /* @__PURE__ */ React62.createElement(MarkdownEditorComponent, {
    key: "smell:" + smell,
    initialValue: smell,
    onChange: handleSmellChange,
    className: "!p-1 m-0 border rounded-md !border-solid !border-[--background-modifier-border] bg-[--background-modifier-form-field] min-w-full min-h[100px] text-xs",
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaign.path
  }))), /* @__PURE__ */ React62.createElement("div", {
    className: "grid grid-cols-1 items-center justify-center w-full"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint] mb-1"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faHandPointer,
    title: "Touch"
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center"
  }, /* @__PURE__ */ React62.createElement(MarkdownEditorComponent, {
    key: "touch:" + touch,
    initialValue: touch,
    onChange: handleTouchChange,
    className: "!p-1 m-0 border rounded-md !border-solid !border-[--background-modifier-border] bg-[--background-modifier-form-field] min-w-full min-h[100px] text-xs",
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaign.path
  }))), /* @__PURE__ */ React62.createElement("div", {
    className: "grid grid-cols-1 items-center justify-center w-full"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint] mb-1"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faTint,
    title: "Taste"
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center"
  }, /* @__PURE__ */ React62.createElement(MarkdownEditorComponent, {
    key: "taste:" + taste,
    initialValue: taste,
    onChange: handleTasteChange,
    className: "!p-1 m-0 border rounded-md !border-solid !border-[--background-modifier-border] bg-[--background-modifier-form-field] min-w-full min-h[100px] text-xs",
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaign.path
  })))), /* @__PURE__ */ React62.createElement("div", {
    className: `w-full flex justify-end mt-3`
  }, /* @__PURE__ */ React62.createElement("button", {
    className: "rpgm-danger",
    onClick: handleDelete
  }, t2("buttons.delete")), chatGpt && /* @__PURE__ */ React62.createElement("button", {
    className: "rpgm-secondary",
    onClick: handleGeneration
  }, t2("chatgpt.generate")), /* @__PURE__ */ React62.createElement("button", {
    className: "rpgm-secondary",
    onClick: onSave
  }, t2("buttons.cancel")), /* @__PURE__ */ React62.createElement("button", {
    className: "rpgm-primary ml-3",
    onClick: handleSave
  }, t2("buttons.save"))));
}
function ViewComponent2({ attribute, edit }) {
  return /* @__PURE__ */ React62.createElement("div", {
    className: "relative w-full"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faEdit,
    onClick: edit,
    className: "absolute top-3 right-3 cursor-pointer"
  }), /* @__PURE__ */ React62.createElement(BrowseComponent2, {
    attribute
  }));
}
function BrowseComponent2({ attribute }) {
  const { t: t2 } = useTranslation();
  const sensoryImprint = attribute.value;
  const totalSenses = Object.values(sensoryImprint).filter(Boolean).length;
  return /* @__PURE__ */ React62.createElement("div", {
    className: "w-full bg-[--background-primary] p-3 border border-[--background-modifier-border] rounded-lg group"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "w-full flex justify-center mb-3"
  }, /* @__PURE__ */ React62.createElement("h3", {
    className: "!p-0 !text-xl !font-extralight"
  }, t2("attributes.sensoryimprints"))), /* @__PURE__ */ React62.createElement("div", {
    className: `w-full grid grid-cols-${totalSenses} gap-3 items-start opacity-0 visibility-hidden max-h-0 pointer-events-none group-hover:opacity-100 group-hover:visibility-visible group-hover:max-h-[300px] group-hover:pointer-events-auto transition-all duration-500 ease-in-out`
  }, sensoryImprint.sight && /* @__PURE__ */ React62.createElement("div", {
    className: "grid items-center justify-center"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint]"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faEye
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center -ml-8 text-sm"
  }, /* @__PURE__ */ React62.createElement(MarkdownComponent, {
    value: sensoryImprint.sight,
    specificComponent: "sensory"
  }))), sensoryImprint.hear && /* @__PURE__ */ React62.createElement("div", {
    className: "grid items-center justify-center"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint]"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faEarListen
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center -ml-8 text-sm"
  }, /* @__PURE__ */ React62.createElement(MarkdownComponent, {
    value: sensoryImprint.hear,
    specificComponent: "sensory"
  }))), sensoryImprint.smell && /* @__PURE__ */ React62.createElement("div", {
    className: "grid items-center justify-center"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint]"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faWind
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center -ml-8 text-sm"
  }, /* @__PURE__ */ React62.createElement(MarkdownComponent, {
    value: sensoryImprint.smell,
    specificComponent: "sensory"
  }))), sensoryImprint.touch && /* @__PURE__ */ React62.createElement("div", {
    className: "grid items-center justify-center"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint]"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faHandPointer
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center -ml-8 text-sm"
  }, /* @__PURE__ */ React62.createElement(MarkdownComponent, {
    value: sensoryImprint.touch,
    specificComponent: "sensory"
  }))), sensoryImprint.taste && /* @__PURE__ */ React62.createElement("div", {
    className: "grid items-center justify-center"
  }, /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center !text-[--text-faint]"
  }, /* @__PURE__ */ React62.createElement(FontAwesomeIcon, {
    icon: faTint
  })), /* @__PURE__ */ React62.createElement("div", {
    className: "flex justify-center -ml-8 text-sm"
  }, /* @__PURE__ */ React62.createElement(MarkdownComponent, {
    value: sensoryImprint.taste,
    specificComponent: "sensory"
  })))));
}
function SensoryImprintAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  if (attribute === void 0 || !attribute.isSet)
    return null;
  const [editing, setEditing] = React62.useState(false);
  const handleEdit = () => {
    setEditing(!editing);
  };
  return /* @__PURE__ */ React62.createElement(React62.Fragment, null, editing ? /* @__PURE__ */ React62.createElement(EditComponent2, {
    element: element4,
    attribute,
    onSave: handleEdit
  }) : isEditable ? /* @__PURE__ */ React62.createElement(ViewComponent2, {
    attribute,
    edit: handleEdit
  }) : /* @__PURE__ */ React62.createElement(BrowseComponent2, {
    attribute
  }));
}

// src/components/images/ImageComponent.tsx
var React63 = __toESM(require_react());

// src/services/FileUploadService.ts
var FileUploadService = class {
  constructor(_app, _api) {
    this._app = _app;
    this._api = _api;
  }
  uploadFileList(element4, files) {
    return __async(this, null, function* () {
      const codeblockService = new RpgManagerCodeblockService(this._app, this._api, element4.file);
      const hasAssetsFolder = this._api.settings.assetsFolder !== void 0 && this._api.settings.assetsFolder !== "";
      const folderName = this._api.settings.assetsFolder !== void 0 && this._api.settings.assetsFolder !== "" ? this._api.settings.assetsFolder : "Assets";
      if (!this._app.vault.getAbstractFileByPath(folderName)) {
        try {
          yield this._app.vault.createFolder(folderName);
        } catch (e2) {
        }
      }
      const availableFiles = this._app.vault.getFiles().filter((file) => file.path.startsWith(folderName + "/" + element4.name));
      const fs = require("fs");
      const imagesToAdd = [];
      const copyPromises = Array.from(files).map((file, index2) => {
        const extension2 = file.name.substring(file.name.lastIndexOf("."));
        const fileName = element4.name + " " + (availableFiles.length + index2 + 1) + extension2;
        const link2 = folderName + "/" + fileName;
        const linkForImage = hasAssetsFolder ? fileName : link2;
        const path4 = this._app.vault.adapter.basePath + "/" + link2;
        imagesToAdd.push({ path: linkForImage, caption: "" });
        return new Promise((resolve, reject) => {
          fs.copyFile(file.path, path4, (err) => {
            if (err)
              reject(err);
            resolve(null);
          });
        });
      });
      return Promise.all(copyPromises).then(() => codeblockService.addImages(imagesToAdd));
    });
  }
};

// src/components/images/ImageComponent.tsx
function ImageComponent({
  element: element4,
  isEditable
}) {
  const [currentIndex, setCurrentIndex] = React63.useState(0);
  const api2 = useApi();
  const app = useApp();
  const goPrev = () => {
    if (currentIndex === 0)
      setCurrentIndex(element4.images.length - 1);
    else
      setCurrentIndex(currentIndex - 1);
  };
  const goNext = () => {
    if (currentIndex === element4.images.length - 1)
      setCurrentIndex(0);
    else
      setCurrentIndex(currentIndex + 1);
  };
  const handleDragOver = (event) => {
    event.preventDefault();
  };
  const handleFileDrop = (event) => {
    event.preventDefault();
    const fileUpload = new FileUploadService(app, api2);
    fileUpload.uploadFileList(element4, event.dataTransfer.files);
  };
  let content3;
  if (element4.images.length === 0) {
    if (isEditable) {
      content3 = /* @__PURE__ */ React63.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        className: "w-full h-full border-2 border-dashed p-4",
        viewBox: "0 0 16 16",
        onDrop: handleFileDrop,
        onDragOver: handleDragOver
      }, /* @__PURE__ */ React63.createElement("path", {
        d: "m 4 1 c -1.644531 0 -3 1.355469 -3 3 v 1 h 1 v -1 c 0 -1.109375 0.890625 -2 2 -2 h 1 v -1 z m 2 0 v 1 h 4 v -1 z m 5 0 v 1 h 1 c 1.109375 0 2 0.890625 2 2 v 1 h 1 v -1 c 0 -1.644531 -1.355469 -3 -3 -3 z m -5 4 c -0.550781 0 -1 0.449219 -1 1 s 0.449219 1 1 1 s 1 -0.449219 1 -1 s -0.449219 -1 -1 -1 z m -5 1 v 4 h 1 v -4 z m 13 0 v 4 h 1 v -4 z m -4.5 2 l -2 2 l -1.5 -1 l -2 2 v 0.5 c 0 0.5 0.5 0.5 0.5 0.5 h 7 s 0.472656 -0.035156 0.5 -0.5 v -1 z m -8.5 3 v 1 c 0 1.644531 1.355469 3 3 3 h 1 v -1 h -1 c -1.109375 0 -2 -0.890625 -2 -2 v -1 z m 13 0 v 1 c 0 1.109375 -0.890625 2 -2 2 h -1 v 1 h 1 c 1.644531 0 3 -1.355469 3 -3 v -1 z m -8 3 v 1 h 4 v -1 z m 0 0",
        fill: "#2e3434",
        fillOpacity: "0.34902"
      }));
    } else {
      content3 = /* @__PURE__ */ React63.createElement(React63.Fragment, null);
    }
  } else {
    if (isEditable) {
      content3 = /* @__PURE__ */ React63.createElement(React63.Fragment, null, /* @__PURE__ */ React63.createElement("img", {
        src: element4.images[currentIndex].src,
        alt: element4.images[currentIndex].caption,
        className: "w-full h-full object-cover"
      }), element4.images[currentIndex].caption && /* @__PURE__ */ React63.createElement("div", {
        className: "p-2"
      }, /* @__PURE__ */ React63.createElement(MarkdownComponent, {
        value: element4.images[currentIndex].caption
      })), element4.images.length > 1 && /* @__PURE__ */ React63.createElement(React63.Fragment, null, /* @__PURE__ */ React63.createElement("div", {
        onClick: goPrev,
        className: "absolute left-0 top-0 w-1/2 h-full z-10 cursor-pointer flex items-center justify-start hover:bg-gradient-to-r hover:from-black hover:to-transparent hover:opacity-100 opacity-0"
      }, /* @__PURE__ */ React63.createElement("span", {
        className: "text-[--text-faint] text-6xl ml-2"
      }, "<")), /* @__PURE__ */ React63.createElement("div", {
        onClick: goNext,
        className: "absolute right-0 top-0 w-1/2 h-full z-10 cursor-pointer flex items-center justify-end hover:bg-gradient-to-l hover:from-black hover:to-transparent hover:opacity-100 opacity-0"
      }, /* @__PURE__ */ React63.createElement("span", {
        className: "text-[--text-faint] text-6xl mr-2"
      }, ">"))));
    } else {
      content3 = /* @__PURE__ */ React63.createElement(React63.Fragment, null, /* @__PURE__ */ React63.createElement("img", {
        src: element4.images[currentIndex].src,
        alt: element4.images[currentIndex].caption,
        className: "w-full h-full object-cover"
      }), element4.images[currentIndex].caption && /* @__PURE__ */ React63.createElement("div", {
        className: "p-2"
      }, /* @__PURE__ */ React63.createElement(MarkdownComponent, {
        value: element4.images[currentIndex].caption
      })));
    }
  }
  return /* @__PURE__ */ React63.createElement("div", {
    className: "relative"
  }, content3);
}

// src/components/groups/MainV1Component.tsx
function MainV1Component({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React64.createElement(React64.Fragment, null, /* @__PURE__ */ React64.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.attribute("sensoryimprint" /* SensoryImprint */) && /* @__PURE__ */ React64.createElement(SensoryImprintAttributeComponent, {
    element: element4,
    attribute: element4.attribute("sensoryimprint" /* SensoryImprint */),
    isEditable: !isInPopover
  }), /* @__PURE__ */ React64.createElement("div", {
    className: `gap-3 !mb-3 grid grid-cols-1 ${isInPopover ? "" : "sm:grid-cols-1 lg:grid-cols-5"}`
  }, /* @__PURE__ */ React64.createElement("div", {
    className: `grid ${isInPopover ? "grid-cols-1" : "lg:col-span-5 lg:grid-cols-5"} gap-3`
  }, element4.images.length > 0 && /* @__PURE__ */ React64.createElement("div", {
    className: `${isInPopover ? "col-span-1" : "lg:col-span-2"} `
  }, /* @__PURE__ */ React64.createElement("div", {
    className: "\n							rounded-lg border border-[--background-modifier-border] \n							overflow-hidden \n							bg-[--background-primary]\n							"
  }, /* @__PURE__ */ React64.createElement(ImageComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), /* @__PURE__ */ React64.createElement("div", {
    className: `${isInPopover ? "col-span-1" : element4.images.length > 0 ? "lg:col-span-3" : "lg:col-span-5"} rounded-lg border border-[--background-modifier-border] overflow-hidden bg-[--background-primary] !mt-0 p-3`
  }, /* @__PURE__ */ React64.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  }), element4.type === "nonplayercharacter" /* NonPlayerCharacter */ && /* @__PURE__ */ React64.createElement(OgasAttributeComponent, {
    element: element4
  })), /* @__PURE__ */ React64.createElement("div", {
    className: `col-span-1 ${!isInPopover && "lg:col-span-5"}`
  }, /* @__PURE__ */ React64.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  })))), element4.images.length > 0 && /* @__PURE__ */ React64.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React64.createElement(ImageCarouselComponent, {
    element: element4
  })), !isInPopover && /* @__PURE__ */ React64.createElement(TasksContainerComponent, {
    element: element4
  }), isInPopover === false && element4.relationships.length > 0 && /* @__PURE__ */ React64.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React64.createElement(RelationshipsComponent, {
    element: element4
  })));
}

// src/components/elements/ClueComponent.tsx
function ClueComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React65.createElement(React65.Fragment, null, /* @__PURE__ */ React65.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React65.createElement(MainV1Component, {
    element: element4,
    isInPopover
  })));
}

// src/components/elements/EventComponent.tsx
var React66 = __toESM(require_react());
function EventComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React66.createElement(React66.Fragment, null, /* @__PURE__ */ React66.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React66.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.images.length > 0 && /* @__PURE__ */ React66.createElement(BannerComponent, {
    image: element4.images[0]
  }), /* @__PURE__ */ React66.createElement("div", {
    className: `grid grid-cols-1 sm:grid-cols-1 lg:grid-cols-5 gap-3 !mb-3}`
  }, /* @__PURE__ */ React66.createElement("div", {
    className: `col-span-5 sm:col-span-1 lg:col-span-5`
  }, /* @__PURE__ */ React66.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 !mb-3"
  }, /* @__PURE__ */ React66.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  })), /* @__PURE__ */ React66.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), element4.images.length > 1 && /* @__PURE__ */ React66.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React66.createElement(ImageCarouselComponent, {
    element: element4
  })), !isInPopover && /* @__PURE__ */ React66.createElement(TasksContainerComponent, {
    element: element4
  }), isInPopover === false && element4.relationships.length > 0 && /* @__PURE__ */ React66.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React66.createElement(RelationshipsComponent, {
    element: element4
  }))));
}

// src/components/elements/FactionComponent.tsx
var React67 = __toESM(require_react());
function FactionComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React67.createElement(React67.Fragment, null, /* @__PURE__ */ React67.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React67.createElement(MainV1Component, {
    element: element4,
    isInPopover
  })));
}

// src/components/elements/LocationComponent.tsx
var React68 = __toESM(require_react());
function LocationComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React68.createElement(React68.Fragment, null, /* @__PURE__ */ React68.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React68.createElement(MainV1Component, {
    element: element4,
    isInPopover
  })));
}

// src/components/elements/MonsterComponent.tsx
var React69 = __toESM(require_react());
function MonsterComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React69.createElement(React69.Fragment, null, /* @__PURE__ */ React69.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React69.createElement(MainV1Component, {
    element: element4,
    isInPopover
  })));
}

// src/components/elements/ObjectComponent.tsx
var React70 = __toESM(require_react());
function ObjectComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React70.createElement(React70.Fragment, null, /* @__PURE__ */ React70.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React70.createElement(MainV1Component, {
    element: element4,
    isInPopover
  })));
}

// src/components/elements/PlayerCharacterComponent.tsx
var React71 = __toESM(require_react());
function PlayerCharacterComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React71.createElement(React71.Fragment, null, /* @__PURE__ */ React71.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React71.createElement(MainV1Component, {
    element: element4,
    isInPopover
  })));
}

// src/components/elements/SceneComponent.tsx
var React73 = __toESM(require_react());

// src/components/attributes/types/DurationAttributeComponent.tsx
var React72 = __toESM(require_react());

// src/services/TimerService.ts
var _TimerService = class {
  static get runningScene() {
    return this._runningScene;
  }
  static startTimer(app, api2, element4) {
    if (this._runningScene !== void 0 && this._runningScene !== element4.path)
      return;
    if (this._runningScene !== void 0)
      _TimerService.endTimer(app, api2);
    this._runningScene = element4.path;
    this._runningStart = Math.round(Date.now() / 1e3);
  }
  static endTimer(app, api2) {
    var _a;
    if (_TimerService._runningScene === void 0 || _TimerService._runningStart === void 0) {
      _TimerService._runningScene = void 0;
      _TimerService._runningStart = void 0;
      return;
    }
    const scene = api2.get(_TimerService._runningScene);
    if (scene === void 0)
      return;
    const attribute = scene.attribute("Duration" /* Duration */);
    if (attribute === void 0)
      return;
    const duration2 = Math.round(Date.now() / 1e3) - _TimerService._runningStart;
    const codeblockService = new RpgManagerCodeblockService(app, api2, scene.file);
    codeblockService.updateCodeblockData(attribute.id, ((_a = attribute.value) != null ? _a : 0) + duration2);
    _TimerService._runningScene = void 0;
    _TimerService._runningStart = void 0;
  }
};
var TimerService = _TimerService;
__publicField(TimerService, "_runningScene");
__publicField(TimerService, "_runningStart");

// src/components/attributes/types/DurationAttributeComponent.tsx
function DurationAttributeComponent({
  element: element4,
  attribute,
  isEditable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [isRunning, setIsRunning] = React72.useState(false);
  const [duration2, setDuration] = React72.useState(attribute.value || 0);
  const timerRef = React72.useRef(null);
  const handleStartStop = () => {
    if (isRunning)
      TimerService.endTimer(app, api2);
    else
      TimerService.startTimer(app, api2, element4);
    setIsRunning(!isRunning);
  };
  React72.useEffect(() => {
    if (isRunning) {
      timerRef.current = setInterval(() => {
        setDuration((prev) => prev + 1);
      }, 1e3);
    }
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [isRunning]);
  const formatDuration = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = seconds % 60;
    return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  };
  return /* @__PURE__ */ React72.createElement("div", {
    className: "flex items-center space-x-4"
  }, /* @__PURE__ */ React72.createElement("div", {
    className: "font-bold"
  }, t2("attributes.duration")), /* @__PURE__ */ React72.createElement("div", {
    className: "bg-[--background-secondary] border border-[--background-modifier-border] p-2 rounded cursor-pointer transition-transform duration-300 transform-gpu hover:scale-105",
    onClick: handleStartStop
  }, isRunning ? /* @__PURE__ */ React72.createElement("div", {
    className: "w-4 h-4 bg-[--text-normal]"
  }) : /* @__PURE__ */ React72.createElement("svg", {
    viewBox: "0 0 12 14",
    className: "fill-current text-[--text-normal]",
    width: "12",
    height: "14"
  }, /* @__PURE__ */ React72.createElement("polygon", {
    points: "0,0 12,7 0,14"
  }))), /* @__PURE__ */ React72.createElement("div", null, formatDuration(duration2)));
}

// src/components/elements/SceneComponent.tsx
function SceneComponent({
  element: element4,
  isInPopover
}) {
  const attribute = element4.attribute("Duration" /* Duration */);
  return /* @__PURE__ */ React73.createElement(React73.Fragment, null, /* @__PURE__ */ React73.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React73.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.attribute("sensoryimprint" /* SensoryImprint */) && /* @__PURE__ */ React73.createElement(SensoryImprintAttributeComponent, {
    element: element4,
    attribute: element4.attribute("sensoryimprint" /* SensoryImprint */),
    isEditable: !isInPopover
  }), element4.images.length > 0 && /* @__PURE__ */ React73.createElement("div", {
    className: "max-h-32 h-32 overflow-hidden"
  }, /* @__PURE__ */ React73.createElement(ImageComponent, {
    element: element4,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React73.createElement("div", {
    className: `grid grid-cols-1 sm:grid-cols-1 lg:grid-cols-5 gap-3 !mb-3}`
  }, /* @__PURE__ */ React73.createElement("div", {
    className: `col-span-5 sm:col-span-1 lg:col-span-5`
  }, /* @__PURE__ */ React73.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 !mb-3"
  }, /* @__PURE__ */ React73.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  }), /* @__PURE__ */ React73.createElement(ParentAttributeComponent, {
    element: element4,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React73.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), /* @__PURE__ */ React73.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React73.createElement(DurationAttributeComponent, {
    element: element4,
    attribute,
    isEditable: !isInPopover
  })), element4.images.length > 1 && /* @__PURE__ */ React73.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React73.createElement(ImageCarouselComponent, {
    element: element4
  })), !isInPopover && /* @__PURE__ */ React73.createElement(TasksContainerComponent, {
    element: element4
  }), isInPopover === false && element4.relationships.length > 0 && /* @__PURE__ */ React73.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React73.createElement(RelationshipsComponent, {
    element: element4
  }))));
}

// src/components/elements/SessionComponent.tsx
var React87 = __toESM(require_react());

// src/components/hierarchies/HierarchyComponent.tsx
var React86 = __toESM(require_react());

// node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js
var import_react23 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys3(e2, r) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t2.push.apply(t2, o);
  }
  return t2;
}
function _objectSpread23(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t2 = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t2), true).forEach(function(r2) {
      _defineProperty3(e2, r2, t2[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys3(Object(t2)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t2, r2));
    });
  }
  return e2;
}

// node_modules/redux/es/redux.js
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type2 = typeof val;
  switch (type2) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type2;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate3(val))
    return "date";
  if (isError(val))
    return "error";
  var constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return type2.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate3(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf2(val) {
  var typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer2, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf2(enhancer) + "'");
    }
    return enhancer(createStore)(reducer2, preloadedState);
  }
  if (typeof reducer2 !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf2(reducer2) + "'");
  }
  var currentReducer = reducer2;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener3) {
    if (typeof listener3 !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf2(listener3) + "'");
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener3);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener3);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject3(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf2(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener3 = listeners[i];
      listener3();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf2(nextReducer));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref3;
    var outerSubscribe = subscribe;
    return _ref3 = {
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf2(observer) + "'");
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref3[$$observable] = function() {
      return this;
    }, _ref3;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(false ? formatProdErrorMessage(16) : "bindActionCreators expected an object or a function, but instead received: '" + kindOf2(actionCreators) + `'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a, b) {
    return function() {
      return a(b.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore3) {
    return function() {
      var store = createStore3.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread23(_objectSpread23({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

// node_modules/react-redux/es/components/Provider.js
var import_react17 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/react-redux/es/components/Context.js
var import_react15 = __toESM(require_react());
var ReactReduxContext = /* @__PURE__ */ import_react15.default.createContext(null);
if (true) {
  ReactReduxContext.displayName = "ReactRedux";
}

// node_modules/react-redux/es/utils/batch.js
function defaultNoopBatch(callback) {
  callback();
}
var batch = defaultNoopBatch;
var setBatch = function setBatch2(newBatch) {
  return batch = newBatch;
};
var getBatch = function getBatch2() {
  return batch;
};

// node_modules/react-redux/es/utils/Subscription.js
function createListenerCollection() {
  var batch2 = getBatch();
  var first = null;
  var last = null;
  return {
    clear: function clear() {
      first = null;
      last = null;
    },
    notify: function notify2() {
      batch2(function() {
        var listener3 = first;
        while (listener3) {
          listener3.callback();
          listener3 = listener3.next;
        }
      });
    },
    get: function get4() {
      var listeners = [];
      var listener3 = first;
      while (listener3) {
        listeners.push(listener3);
        listener3 = listener3.next;
      }
      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener3 = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener3.prev) {
        listener3.prev.next = listener3;
      } else {
        first = listener3;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener3.next) {
          listener3.next.prev = listener3.prev;
        } else {
          last = listener3.prev;
        }
        if (listener3.prev) {
          listener3.prev.next = listener3.next;
        } else {
          first = listener3.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify: function notify() {
  },
  get: function get3() {
    return [];
  }
};
function createSubscription(store, parentSub) {
  var unsubscribe;
  var listeners = nullListeners;
  function addNestedSub(listener3) {
    trySubscribe();
    return listeners.subscribe(listener3);
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe);
  }
  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  var subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: function getListeners() {
      return listeners;
    }
  };
  return subscription;
}

// node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js
var import_react16 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react16.useLayoutEffect : import_react16.useEffect;

// node_modules/react-redux/es/components/Provider.js
function Provider(_ref2) {
  var store = _ref2.store, context = _ref2.context, children = _ref2.children;
  var contextValue = (0, import_react17.useMemo)(function() {
    var subscription = createSubscription(store);
    return {
      store,
      subscription
    };
  }, [store]);
  var previousState = (0, import_react17.useMemo)(function() {
    return store.getState();
  }, [store]);
  useIsomorphicLayoutEffect(function() {
    var subscription = contextValue.subscription;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return function() {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || ReactReduxContext;
  return /* @__PURE__ */ import_react17.default.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
if (true) {
  Provider.propTypes = {
    store: import_prop_types3.default.shape({
      subscribe: import_prop_types3.default.func.isRequired,
      dispatch: import_prop_types3.default.func.isRequired,
      getState: import_prop_types3.default.func.isRequired
    }),
    context: import_prop_types3.default.object,
    children: import_prop_types3.default.any
  };
}
var Provider_default = Provider;

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// node_modules/react-redux/es/components/connectAdvanced.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_react18 = __toESM(require_react());
var import_react_is2 = __toESM(require_react_is4());
var _excluded2 = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"];
var _excluded22 = ["reactReduxForwardedRef"];
var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];
var stringifyComponent = function stringifyComponent2(Comp) {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};
function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect(function() {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  if (!shouldHandleStateChanges)
    return;
  var didUnsubscribe = false;
  var lastThrownError = null;
  var checkForUpdates = function checkForUpdates2() {
    if (didUnsubscribe) {
      return;
    }
    var latestStoreState = store.getState();
    var newChildProps, error2;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e2) {
      error2 = e2;
      lastThrownError = e2;
    }
    if (!error2) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      forceComponentUpdateDispatch({
        type: "STORE_UPDATED",
        payload: {
          error: error2
        }
      });
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  var unsubscribeWrapper = function unsubscribeWrapper2() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
var initStateUpdates = function initStateUpdates2() {
  return [null, 0];
};
function connectAdvanced(selectorFactory, _ref2) {
  if (_ref2 === void 0) {
    _ref2 = {};
  }
  var _ref22 = _ref2, _ref2$getDisplayName = _ref22.getDisplayName, getDisplayName2 = _ref2$getDisplayName === void 0 ? function(name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName, _ref2$methodName = _ref22.methodName, methodName = _ref2$methodName === void 0 ? "connectAdvanced" : _ref2$methodName, _ref2$renderCountProp = _ref22.renderCountProp, renderCountProp = _ref2$renderCountProp === void 0 ? void 0 : _ref2$renderCountProp, _ref2$shouldHandleSta = _ref22.shouldHandleStateChanges, shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta, _ref2$storeKey = _ref22.storeKey, storeKey = _ref2$storeKey === void 0 ? "store" : _ref2$storeKey, _ref2$withRef = _ref22.withRef, withRef = _ref2$withRef === void 0 ? false : _ref2$withRef, _ref2$forwardRef = _ref22.forwardRef, forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef, _ref2$context = _ref22.context, context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context, connectOptions = _objectWithoutPropertiesLoose2(_ref22, _excluded2);
  if (true) {
    if (renderCountProp !== void 0) {
      throw new Error("renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension");
    }
    if (withRef) {
      throw new Error("withRef is removed. To access the wrapped instance, use a ref on the connected component");
    }
    var customStoreWarningMessage = "To use a custom Redux store for specific components, create a custom React context with React.createContext(), and pass the context object to React Redux's Provider and specific components like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. You may also pass a {context : MyContext} option to connect";
    if (storeKey !== "store") {
      throw new Error("storeKey has been removed and does not do anything. " + customStoreWarningMessage);
    }
  }
  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    if (!(0, import_react_is2.isValidElementType)(WrappedComponent)) {
      throw new Error("You must pass a component to the function returned by " + (methodName + ". Instead received " + stringifyComponent(WrappedComponent)));
    }
    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    var displayName = getDisplayName2(wrappedComponentName);
    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName2,
      methodName,
      renderCountProp,
      shouldHandleStateChanges,
      storeKey,
      displayName,
      wrappedComponentName,
      WrappedComponent
    });
    var pure = connectOptions.pure;
    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    }
    var usePureOnlyMemo = pure ? import_react18.useMemo : function(callback) {
      return callback();
    };
    function ConnectFunction(props) {
      var _useMemo = (0, import_react18.useMemo)(function() {
        var reactReduxForwardedRef2 = props.reactReduxForwardedRef, wrapperProps2 = _objectWithoutPropertiesLoose2(props, _excluded22);
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]), propsContext = _useMemo[0], reactReduxForwardedRef = _useMemo[1], wrapperProps = _useMemo[2];
      var ContextToUse = (0, import_react18.useMemo)(function() {
        return propsContext && propsContext.Consumer && (0, import_react_is2.isContextConsumer)(/* @__PURE__ */ import_react18.default.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]);
      var contextValue = (0, import_react18.useContext)(ContextToUse);
      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      if (!didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error('Could not find "store" in the context of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + "or pass a custom React context provider to <Provider> and the corresponding " + ("React context consumer to " + displayName + " in connect options."));
      }
      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = (0, import_react18.useMemo)(function() {
        return createChildSelector(store);
      }, [store]);
      var _useMemo2 = (0, import_react18.useMemo)(function() {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        var subscription2 = createSubscription(store, didStoreComeFromProps ? null : contextValue.subscription);
        var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]), subscription = _useMemo2[0], notifyNestedSubs = _useMemo2[1];
      var overriddenContextValue = (0, import_react18.useMemo)(function() {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return _extends({}, contextValue, {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      var _useReducer = (0, import_react18.useReducer)(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates), _useReducer$ = _useReducer[0], previousStateUpdateResult = _useReducer$[0], forceComponentUpdateDispatch = _useReducer[1];
      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      }
      var lastChildProps = (0, import_react18.useRef)();
      var lastWrapperProps = (0, import_react18.useRef)(wrapperProps);
      var childPropsFromStoreUpdate = (0, import_react18.useRef)();
      var renderIsScheduled = (0, import_react18.useRef)(false);
      var actualChildProps = usePureOnlyMemo(function() {
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        }
        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]);
      var renderedWrappedComponent = (0, import_react18.useMemo)(function() {
        return /* @__PURE__ */ import_react18.default.createElement(WrappedComponent, _extends({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      var renderedChild = (0, import_react18.useMemo)(function() {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ import_react18.default.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    var Connect = pure ? import_react18.default.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      var forwarded = import_react18.default.forwardRef(function forwardConnectRef(props, ref2) {
        return /* @__PURE__ */ import_react18.default.createElement(Connect, _extends({}, props, {
          reactReduxForwardedRef: ref2
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return (0, import_hoist_non_react_statics.default)(forwarded, WrappedComponent);
    }
    return (0, import_hoist_non_react_statics.default)(Connect, WrappedComponent);
  };
}

// node_modules/react-redux/es/utils/shallowEqual.js
function is2(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function shallowEqual(objA, objB) {
  if (is2(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is2(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// node_modules/react-redux/es/utils/bindActionCreators.js
function bindActionCreators2(actionCreators, dispatch) {
  var boundActionCreators = {};
  var _loop = function _loop2(key2) {
    var actionCreator = actionCreators[key2];
    if (typeof actionCreator === "function") {
      boundActionCreators[key2] = function() {
        return dispatch(actionCreator.apply(void 0, arguments));
      };
    }
  };
  for (var key in actionCreators) {
    _loop(key);
  }
  return boundActionCreators;
}

// node_modules/react-redux/es/utils/isPlainObject.js
function isPlainObject4(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto2 = Object.getPrototypeOf(obj);
  if (proto2 === null)
    return true;
  var baseProto = proto2;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto2 === baseProto;
}

// node_modules/react-redux/es/utils/warning.js
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e2) {
  }
}

// node_modules/react-redux/es/utils/verifyPlainObject.js
function verifyPlainObject(value, displayName, methodName) {
  if (!isPlainObject4(value)) {
    warning(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
  }
}

// node_modules/react-redux/es/connect/wrapMapToProps.js
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== void 0 ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref2) {
    var displayName = _ref2.displayName;
    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      if (true)
        verifyPlainObject(props, displayName, methodName);
      return props;
    };
    return proxy;
  };
}

// node_modules/react-redux/es/connect/mapDispatchToProps.js
function whenMapDispatchToPropsIsFunction(mapDispatchToProps2) {
  return typeof mapDispatchToProps2 === "function" ? wrapMapToPropsFunc(mapDispatchToProps2, "mapDispatchToProps") : void 0;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps2) {
  return !mapDispatchToProps2 ? wrapMapToPropsConstant(function(dispatch) {
    return {
      dispatch
    };
  }) : void 0;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant(function(dispatch) {
    return bindActionCreators2(mapDispatchToProps2, dispatch);
  }) : void 0;
}
var mapDispatchToProps_default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

// node_modules/react-redux/es/connect/mapStateToProps.js
function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : void 0;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(function() {
    return {};
  }) : void 0;
}
var mapStateToProps_default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

// node_modules/react-redux/es/connect/mergeProps.js
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref2) {
    var displayName = _ref2.displayName, pure = _ref2.pure, areMergedPropsEqual = _ref2.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (true)
          verifyPlainObject(mergedProps, displayName, "mergeProps");
      }
      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : void 0;
}
function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function() {
    return defaultMergeProps;
  } : void 0;
}
var mergeProps_default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];

// node_modules/react-redux/es/connect/verifySubselectors.js
function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
  } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
    if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
      warning("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
    }
  }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps, displayName) {
  verify(mapStateToProps, "mapStateToProps", displayName);
  verify(mapDispatchToProps2, "mapDispatchToProps", displayName);
  verify(mergeProps, "mergeProps", displayName);
}

// node_modules/react-redux/es/connect/selectorFactory.js
var _excluded3 = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps2(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, _ref2) {
  var areStatesEqual = _ref2.areStatesEqual, areOwnPropsEqual = _ref2.areOwnPropsEqual, areStatePropsEqual = _ref2.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options = _objectWithoutPropertiesLoose2(_ref2, _excluded3);
  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps2 = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);
  if (true) {
    verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps, options.displayName);
  }
  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, options);
}

// node_modules/react-redux/es/connect/connect.js
var _excluded4 = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
function match2(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result)
      return result;
  }
  return function(dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}
function strictEqual(a, b) {
  return a === b;
}
function createConnect(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp, _ref$connectHOC = _ref2.connectHOC, connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref2.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? mapStateToProps_default : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref2.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? mapDispatchToProps_default : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref2.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === void 0 ? mergeProps_default : _ref$mergePropsFactor, _ref$selectorFactory = _ref2.selectorFactory, selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
  return function connect(mapStateToProps, mapDispatchToProps2, mergeProps, _ref22) {
    if (_ref22 === void 0) {
      _ref22 = {};
    }
    var _ref3 = _ref22, _ref3$pure = _ref3.pure, pure = _ref3$pure === void 0 ? true : _ref3$pure, _ref3$areStatesEqual = _ref3.areStatesEqual, areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual, _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual, areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua, _ref3$areStatePropsEq = _ref3.areStatePropsEqual, areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq, _ref3$areMergedPropsE = _ref3.areMergedPropsEqual, areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE, extraOptions = _objectWithoutPropertiesLoose2(_ref3, _excluded4);
    var initMapStateToProps = match2(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
    var initMapDispatchToProps = match2(mapDispatchToProps2, mapDispatchToPropsFactories, "mapDispatchToProps");
    var initMergeProps = match2(mergeProps, mergePropsFactories, "mergeProps");
    return connectHOC(selectorFactory, _extends({
      methodName: "connect",
      getDisplayName: function getDisplayName2(name) {
        return "Connect(" + name + ")";
      },
      shouldHandleStateChanges: Boolean(mapStateToProps),
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual
    }, extraOptions));
  };
}
var connect_default = /* @__PURE__ */ createConnect();

// node_modules/react-redux/es/hooks/useStore.js
var import_react20 = __toESM(require_react());

// node_modules/react-redux/es/hooks/useReduxContext.js
var import_react19 = __toESM(require_react());

// node_modules/react-redux/es/hooks/useSelector.js
var import_react21 = __toESM(require_react());

// node_modules/react-redux/es/utils/reactBatchedUpdates.js
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-redux/es/index.js
setBatch(import_react_dom.unstable_batchedUpdates);

// node_modules/use-memo-one/dist/use-memo-one.esm.js
var import_react22 = __toESM(require_react());
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (newInputs[i] !== lastInputs[i]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial2 = (0, import_react22.useState)(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = (0, import_react22.useRef)(true);
  var committed = (0, import_react22.useRef)(initial2);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
  var cache = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  (0, import_react22.useEffect)(function() {
    isFirstRun.current = false;
    committed.current = cache;
  }, [cache]);
  return cache.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function() {
    return callback;
  }, inputs);
}
var useMemo5 = useMemoOne;
var useCallback = useCallbackOne;

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/css-box-model/dist/css-box-model.esm.js
var getRect = function getRect2(_ref2) {
  var top = _ref2.top, right = _ref2.right, bottom = _ref2.bottom, left = _ref2.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top,
    right,
    bottom,
    left,
    width,
    height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var shift = function shift2(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse6 = function parse7(raw2) {
  var value = raw2.slice(0, -2);
  var suffix2 = raw2.slice(-2);
  if (suffix2 !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? true ? invariant(false, "Could not parse value [raw: " + raw2 + ", without suffix: " + value + "]") : invariant(false) : void 0;
  return result;
};
var getWindowScroll = function getWindowScroll2() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset2 = function offset3(original, change) {
  var borderBox = original.borderBox, border = original.border, margin = original.margin, padding = original.padding;
  var shifted = shift(borderBox, change);
  return createBox({
    borderBox: shifted,
    border,
    margin,
    padding
  });
};
var withScroll = function withScroll2(original, scroll3) {
  if (scroll3 === void 0) {
    scroll3 = getWindowScroll();
  }
  return offset2(original, scroll3);
};
var calculateBox = function calculateBox2(borderBox, styles2) {
  var margin = {
    top: parse6(styles2.marginTop),
    right: parse6(styles2.marginRight),
    bottom: parse6(styles2.marginBottom),
    left: parse6(styles2.marginLeft)
  };
  var padding = {
    top: parse6(styles2.paddingTop),
    right: parse6(styles2.paddingRight),
    bottom: parse6(styles2.paddingBottom),
    left: parse6(styles2.paddingLeft)
  };
  var border = {
    top: parse6(styles2.borderTopWidth),
    right: parse6(styles2.borderRightWidth),
    bottom: parse6(styles2.borderBottomWidth),
    left: parse6(styles2.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el) {
  var borderBox = el.getBoundingClientRect();
  var styles2 = window.getComputedStyle(el);
  return calculateBox(borderBox, styles2);
};

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual2(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual5) {
  if (isEqual5 === void 0) {
    isEqual5 = areInputsEqual2;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual5(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoize_one_esm_default = memoizeOne;

// node_modules/raf-schd/dist/raf-schd.esm.js
var rafSchd = function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
var raf_schd_esm_default = rafSchd;

// node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js
var import_react_dom2 = __toESM(require_react_dom());
var isProduction2 = false;
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;
var clean2 = function clean3(value) {
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
};
var getDevMessage = function getDevMessage2(message) {
  return clean2("\n  %creact-beautiful-dnd\n\n  %c" + clean2(message) + "\n\n  %c\u{1F477}\u200D This is a development only message. It will be removed in production builds.\n");
};
var getFormattedMessage = function getFormattedMessage2(message) {
  return [getDevMessage(message), "color: #00C584; font-size: 1.2em; font-weight: bold;", "line-height: 1.5", "color: #723874;"];
};
var isDisabledFlag = "__react-beautiful-dnd-disable-dev-warnings";
function log2(type2, message) {
  var _console;
  if (isProduction2) {
    return;
  }
  if (typeof window !== "undefined" && window[isDisabledFlag]) {
    return;
  }
  (_console = console)[type2].apply(_console, getFormattedMessage(message));
}
var warning2 = log2.bind(null, "warn");
var error = log2.bind(null, "error");
function noop7() {
}
function getOptions(shared2, fromBinding) {
  return _extends({}, shared2, {}, fromBinding);
}
function bindEvents(el, bindings, sharedOptions) {
  var unbindings = bindings.map(function(binding) {
    var options = getOptions(sharedOptions, binding.options);
    el.addEventListener(binding.eventName, binding.fn, options);
    return function unbind() {
      el.removeEventListener(binding.eventName, binding.fn, options);
    };
  });
  return function unbindAll() {
    unbindings.forEach(function(unbind) {
      unbind();
    });
  };
}
var isProduction$1 = false;
var prefix2 = "Invariant failed";
function RbdInvariant(message) {
  this.message = message;
}
RbdInvariant.prototype.toString = function toString4() {
  return this.message;
};
function invariant2(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction$1) {
    throw new RbdInvariant(prefix2);
  } else {
    throw new RbdInvariant(prefix2 + ": " + (message || ""));
  }
}
var ErrorBoundary = function(_React$Component) {
  _inheritsLoose(ErrorBoundary2, _React$Component);
  function ErrorBoundary2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.callbacks = null;
    _this.unbind = noop7;
    _this.onWindowError = function(event) {
      var callbacks = _this.getCallbacks();
      if (callbacks.isDragging()) {
        callbacks.tryAbort();
        true ? warning2("\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      ") : void 0;
      }
      var err = event.error;
      if (err instanceof RbdInvariant) {
        event.preventDefault();
        if (true) {
          error(err.message);
        }
      }
    };
    _this.getCallbacks = function() {
      if (!_this.callbacks) {
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      }
      return _this.callbacks;
    };
    _this.setCallbacks = function(callbacks) {
      _this.callbacks = callbacks;
    };
    return _this;
  }
  var _proto = ErrorBoundary2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  };
  _proto.componentDidCatch = function componentDidCatch(err) {
    if (err instanceof RbdInvariant) {
      if (true) {
        error(err.message);
      }
      this.setState({});
      return;
    }
    throw err;
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.unbind();
  };
  _proto.render = function render3() {
    return this.props.children(this.setCallbacks);
  };
  return ErrorBoundary2;
}(import_react23.default.Component);
var dragHandleUsageInstructions = "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n";
var position4 = function position5(index2) {
  return index2 + 1;
};
var onDragStart = function onDragStart2(start3) {
  return "\n  You have lifted an item in position " + position4(start3.source.index) + "\n";
};
var withLocation = function withLocation2(source, destination) {
  var isInHomeList = source.droppableId === destination.droppableId;
  var startPosition = position4(source.index);
  var endPosition = position4(destination.index);
  if (isInHomeList) {
    return "\n      You have moved the item from position " + startPosition + "\n      to position " + endPosition + "\n    ";
  }
  return "\n    You have moved the item from position " + startPosition + "\n    in list " + source.droppableId + "\n    to list " + destination.droppableId + "\n    in position " + endPosition + "\n  ";
};
var withCombine = function withCombine2(id, source, combine2) {
  var inHomeList = source.droppableId === combine2.droppableId;
  if (inHomeList) {
    return "\n      The item " + id + "\n      has been combined with " + combine2.draggableId;
  }
  return "\n      The item " + id + "\n      in list " + source.droppableId + "\n      has been combined with " + combine2.draggableId + "\n      in list " + combine2.droppableId + "\n    ";
};
var onDragUpdate = function onDragUpdate2(update2) {
  var location3 = update2.destination;
  if (location3) {
    return withLocation(update2.source, location3);
  }
  var combine2 = update2.combine;
  if (combine2) {
    return withCombine(update2.draggableId, update2.source, combine2);
  }
  return "You are over an area that cannot be dropped on";
};
var returnedToStart = function returnedToStart2(source) {
  return "\n  The item has returned to its starting position\n  of " + position4(source.index) + "\n";
};
var onDragEnd = function onDragEnd2(result) {
  if (result.reason === "CANCEL") {
    return "\n      Movement cancelled.\n      " + returnedToStart(result.source) + "\n    ";
  }
  var location3 = result.destination;
  var combine2 = result.combine;
  if (location3) {
    return "\n      You have dropped the item.\n      " + withLocation(result.source, location3) + "\n    ";
  }
  if (combine2) {
    return "\n      You have dropped the item.\n      " + withCombine(result.draggableId, result.source, combine2) + "\n    ";
  }
  return "\n    The item has been dropped while not over a drop area.\n    " + returnedToStart(result.source) + "\n  ";
};
var preset = {
  dragHandleUsageInstructions,
  onDragStart,
  onDragUpdate,
  onDragEnd
};
var origin = {
  x: 0,
  y: 0
};
var add = function add2(point1, point22) {
  return {
    x: point1.x + point22.x,
    y: point1.y + point22.y
  };
};
var subtract = function subtract2(point1, point22) {
  return {
    x: point1.x - point22.x,
    y: point1.y - point22.y
  };
};
var isEqual2 = function isEqual3(point1, point22) {
  return point1.x === point22.x && point1.y === point22.y;
};
var negate = function negate2(point5) {
  return {
    x: point5.x !== 0 ? -point5.x : 0,
    y: point5.y !== 0 ? -point5.y : 0
  };
};
var patch4 = function patch5(line, value, otherValue) {
  var _ref2;
  if (otherValue === void 0) {
    otherValue = 0;
  }
  return _ref2 = {}, _ref2[line] = value, _ref2[line === "x" ? "y" : "x"] = otherValue, _ref2;
};
var distance = function distance2(point1, point22) {
  return Math.sqrt(Math.pow(point22.x - point1.x, 2) + Math.pow(point22.y - point1.y, 2));
};
var closest = function closest2(target, points) {
  return Math.min.apply(Math, points.map(function(point5) {
    return distance(target, point5);
  }));
};
var apply = function apply2(fn) {
  return function(point5) {
    return {
      x: fn(point5.x),
      y: fn(point5.y)
    };
  };
};
var executeClip = function(frame, subject) {
  var result = getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });
  if (result.width <= 0 || result.height <= 0) {
    return null;
  }
  return result;
};
var offsetByPosition = function offsetByPosition2(spacing, point5) {
  return {
    top: spacing.top + point5.y,
    left: spacing.left + point5.x,
    bottom: spacing.bottom + point5.y,
    right: spacing.right + point5.x
  };
};
var getCorners = function getCorners2(spacing) {
  return [{
    x: spacing.left,
    y: spacing.top
  }, {
    x: spacing.right,
    y: spacing.top
  }, {
    x: spacing.left,
    y: spacing.bottom
  }, {
    x: spacing.right,
    y: spacing.bottom
  }];
};
var noSpacing2 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var scroll = function scroll2(target, frame) {
  if (!frame) {
    return target;
  }
  return offsetByPosition(target, frame.scroll.diff.displacement);
};
var increase = function increase2(target, axis, withPlaceholder) {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    var _extends2;
    return _extends({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));
  }
  return target;
};
var clip = function clip2(target, frame) {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }
  return getRect(target);
};
var getSubject = function(_ref2) {
  var page = _ref2.page, withPlaceholder = _ref2.withPlaceholder, axis = _ref2.axis, frame = _ref2.frame;
  var scrolled = scroll(page.marginBox, frame);
  var increased = increase(scrolled, axis, withPlaceholder);
  var clipped = clip(increased, frame);
  return {
    page,
    withPlaceholder,
    active: clipped
  };
};
var scrollDroppable = function(droppable2, newScroll) {
  !droppable2.frame ? true ? invariant2(false) : invariant2(false) : void 0;
  var scrollable = droppable2.frame;
  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  var scrollDisplacement = negate(scrollDiff);
  var frame = _extends({}, scrollable, {
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  });
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: droppable2.subject.withPlaceholder,
    axis: droppable2.axis,
    frame
  });
  var result = _extends({}, droppable2, {
    frame,
    subject
  });
  return result;
};
function isInteger2(value) {
  if (Number.isInteger) {
    return Number.isInteger(value);
  }
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
}
function values(map) {
  if (Object.values) {
    return Object.values(map);
  }
  return Object.keys(map).map(function(key) {
    return map[key];
  });
}
function findIndex(list3, predicate) {
  if (list3.findIndex) {
    return list3.findIndex(predicate);
  }
  for (var i = 0; i < list3.length; i++) {
    if (predicate(list3[i])) {
      return i;
    }
  }
  return -1;
}
function find2(list3, predicate) {
  if (list3.find) {
    return list3.find(predicate);
  }
  var index2 = findIndex(list3, predicate);
  if (index2 !== -1) {
    return list3[index2];
  }
  return void 0;
}
function toArray3(list3) {
  return Array.prototype.slice.call(list3);
}
var toDroppableMap = memoize_one_esm_default(function(droppables) {
  return droppables.reduce(function(previous2, current) {
    previous2[current.descriptor.id] = current;
    return previous2;
  }, {});
});
var toDraggableMap = memoize_one_esm_default(function(draggables) {
  return draggables.reduce(function(previous2, current) {
    previous2[current.descriptor.id] = current;
    return previous2;
  }, {});
});
var toDroppableList = memoize_one_esm_default(function(droppables) {
  return values(droppables);
});
var toDraggableList = memoize_one_esm_default(function(draggables) {
  return values(draggables);
});
var getDraggablesInsideDroppable = memoize_one_esm_default(function(droppableId, draggables) {
  var result = toDraggableList(draggables).filter(function(draggable2) {
    return droppableId === draggable2.descriptor.droppableId;
  }).sort(function(a, b) {
    return a.descriptor.index - b.descriptor.index;
  });
  return result;
});
function tryGetDestination(impact) {
  if (impact.at && impact.at.type === "REORDER") {
    return impact.at.destination;
  }
  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === "COMBINE") {
    return impact.at.combine;
  }
  return null;
}
var removeDraggableFromList = memoize_one_esm_default(function(remove2, list3) {
  return list3.filter(function(item) {
    return item.descriptor.id !== remove2.descriptor.id;
  });
});
var moveToNextCombine = function(_ref2) {
  var isMovingForward = _ref2.isMovingForward, draggable2 = _ref2.draggable, destination = _ref2.destination, insideDestination = _ref2.insideDestination, previousImpact = _ref2.previousImpact;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var location3 = tryGetDestination(previousImpact);
  if (!location3) {
    return null;
  }
  function getImpact(target) {
    var at = {
      type: "COMBINE",
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return _extends({}, previousImpact, {
      at
    });
  }
  var all7 = previousImpact.displaced.all;
  var closestId = all7.length ? all7[0] : null;
  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }
  var withoutDraggable = removeDraggableFromList(draggable2, insideDestination);
  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }
    var last = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last.descriptor.id);
  }
  var indexOfClosest = findIndex(withoutDraggable, function(d2) {
    return d2.descriptor.id === closestId;
  });
  !(indexOfClosest !== -1) ? true ? invariant2(false, "Could not find displaced item in set") : invariant2(false) : void 0;
  var proposedIndex = indexOfClosest - 1;
  if (proposedIndex < 0) {
    return null;
  }
  var before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
};
var isHomeOf = function(draggable2, destination) {
  return draggable2.descriptor.droppableId === destination.descriptor.id;
};
var noDisplacedBy = {
  point: origin,
  value: 0
};
var emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
var noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};
var isWithin = function(lowerBound, upperBound) {
  return function(value) {
    return lowerBound <= value && value <= upperBound;
  };
};
var isPartiallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    if (isContained) {
      return true;
    }
    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
    if (isPartiallyContained) {
      return true;
    }
    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
    if (isTargetBiggerThanFrame) {
      return true;
    }
    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
};
var isTotallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
};
var vertical = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
};
var horizontal = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var isTotallyVisibleThroughFrameOnAxis = function(axis) {
  return function(frame) {
    var isWithinVertical = isWithin(frame.top, frame.bottom);
    var isWithinHorizontal = isWithin(frame.left, frame.right);
    return function(subject) {
      if (axis === vertical) {
        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
      }
      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    };
  };
};
var getDroppableDisplaced = function getDroppableDisplaced2(target, destination) {
  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};
var isVisibleInDroppable = function isVisibleInDroppable2(target, destination, isVisibleThroughFrameFn) {
  if (!destination.subject.active) {
    return false;
  }
  return isVisibleThroughFrameFn(destination.subject.active)(target);
};
var isVisibleInViewport = function isVisibleInViewport2(target, viewport, isVisibleThroughFrameFn) {
  return isVisibleThroughFrameFn(viewport)(target);
};
var isVisible = function isVisible2(_ref2) {
  var toBeDisplaced = _ref2.target, destination = _ref2.destination, viewport = _ref2.viewport, withDroppableDisplacement2 = _ref2.withDroppableDisplacement, isVisibleThroughFrameFn = _ref2.isVisibleThroughFrameFn;
  var displacedTarget = withDroppableDisplacement2 ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);
};
var isPartiallyVisible = function isPartiallyVisible2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
  }));
};
var isTotallyVisible = function isTotallyVisible2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
  }));
};
var isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
  }));
};
var getShouldAnimate = function getShouldAnimate2(id, last, forceShouldAnimate) {
  if (typeof forceShouldAnimate === "boolean") {
    return forceShouldAnimate;
  }
  if (!last) {
    return true;
  }
  var invisible = last.invisible, visible = last.visible;
  if (invisible[id]) {
    return false;
  }
  var previous2 = visible[id];
  return previous2 ? previous2.shouldAnimate : true;
};
function getTarget(draggable2, displacedBy) {
  var marginBox = draggable2.page.marginBox;
  var expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return getRect(expand(marginBox, expandBy));
}
function getDisplacementGroups(_ref2) {
  var afterDragging = _ref2.afterDragging, destination = _ref2.destination, displacedBy = _ref2.displacedBy, viewport = _ref2.viewport, forceShouldAnimate = _ref2.forceShouldAnimate, last = _ref2.last;
  return afterDragging.reduce(function process2(groups, draggable2) {
    var target = getTarget(draggable2, displacedBy);
    var id = draggable2.descriptor.id;
    groups.all.push(id);
    var isVisible3 = isPartiallyVisible({
      target,
      destination,
      viewport,
      withDroppableDisplacement: true
    });
    if (!isVisible3) {
      groups.invisible[draggable2.descriptor.id] = true;
      return groups;
    }
    var shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);
    var displacement = {
      draggableId: id,
      shouldAnimate
    };
    groups.visible[id] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function getIndexOfLastItem(draggables, options) {
  if (!draggables.length) {
    return 0;
  }
  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}
function goAtEnd(_ref2) {
  var insideDestination = _ref2.insideDestination, inHomeList = _ref2.inHomeList, displacedBy = _ref2.displacedBy, destination = _ref2.destination;
  var newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}
function calculateReorderImpact(_ref2) {
  var draggable2 = _ref2.draggable, insideDestination = _ref2.insideDestination, destination = _ref2.destination, viewport = _ref2.viewport, displacedBy = _ref2.displacedBy, last = _ref2.last, index2 = _ref2.index, forceShouldAnimate = _ref2.forceShouldAnimate;
  var inHomeList = isHomeOf(draggable2, destination);
  if (index2 == null) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var match3 = find2(insideDestination, function(item) {
    return item.descriptor.index === index2;
  });
  if (!match3) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var sliceFrom = insideDestination.indexOf(match3);
  var impacted = withoutDragging.slice(sliceFrom);
  var displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination,
    displacedBy,
    last,
    viewport: viewport.frame,
    forceShouldAnimate
  });
  return {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: index2
      }
    }
  };
}
function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}
var fromCombine = function(_ref2) {
  var isMovingForward = _ref2.isMovingForward, destination = _ref2.destination, draggables = _ref2.draggables, combine2 = _ref2.combine, afterCritical = _ref2.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var combineId = combine2.draggableId;
  var combineWith = draggables[combineId];
  var combineWithIndex = combineWith.descriptor.index;
  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }
    return combineWithIndex - 1;
  }
  if (isMovingForward) {
    return combineWithIndex + 1;
  }
  return combineWithIndex;
};
var fromReorder = function(_ref2) {
  var isMovingForward = _ref2.isMovingForward, isInHomeList = _ref2.isInHomeList, insideDestination = _ref2.insideDestination, location3 = _ref2.location;
  if (!insideDestination.length) {
    return null;
  }
  var currentIndex = location3.index;
  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  var firstIndex = insideDestination[0].descriptor.index;
  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;
  if (proposedIndex < firstIndex) {
    return null;
  }
  if (proposedIndex > upperBound) {
    return null;
  }
  return proposedIndex;
};
var moveToNextIndex = function(_ref2) {
  var isMovingForward = _ref2.isMovingForward, isInHomeList = _ref2.isInHomeList, draggable2 = _ref2.draggable, draggables = _ref2.draggables, destination = _ref2.destination, insideDestination = _ref2.insideDestination, previousImpact = _ref2.previousImpact, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var wasAt = previousImpact.at;
  !wasAt ? true ? invariant2(false, "Cannot move in direction without previous impact location") : invariant2(false) : void 0;
  if (wasAt.type === "REORDER") {
    var _newIndex = fromReorder({
      isMovingForward,
      isInHomeList,
      location: wasAt.destination,
      insideDestination
    });
    if (_newIndex == null) {
      return null;
    }
    return calculateReorderImpact({
      draggable: draggable2,
      insideDestination,
      destination,
      viewport,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: _newIndex
    });
  }
  var newIndex = fromCombine({
    isMovingForward,
    destination,
    displaced: previousImpact.displaced,
    draggables,
    combine: wasAt.combine,
    afterCritical
  });
  if (newIndex == null) {
    return null;
  }
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
};
var getCombinedItemDisplacement = function(_ref2) {
  var displaced = _ref2.displaced, afterCritical = _ref2.afterCritical, combineWith = _ref2.combineWith, displacedBy = _ref2.displacedBy;
  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }
  return isDisplaced ? displacedBy.point : origin;
};
var whenCombining = function(_ref2) {
  var afterCritical = _ref2.afterCritical, impact = _ref2.impact, draggables = _ref2.draggables;
  var combine2 = tryGetCombine(impact);
  !combine2 ? true ? invariant2(false) : invariant2(false) : void 0;
  var combineWith = combine2.draggableId;
  var center = draggables[combineWith].page.borderBox.center;
  var displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical,
    combineWith,
    displacedBy: impact.displacedBy
  });
  return add(center, displaceBy);
};
var distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter2(axis, box) {
  return box.margin[axis.start] + box.borderBox[axis.size] / 2;
};
var distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter2(axis, box) {
  return box.margin[axis.end] + box.borderBox[axis.size] / 2;
};
var getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter2(axis, target, isMoving) {
  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
};
var goAfter = function goAfter2(_ref2) {
  var axis = _ref2.axis, moveRelativeTo = _ref2.moveRelativeTo, isMoving = _ref2.isMoving;
  return patch4(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goBefore = function goBefore2(_ref2) {
  var axis = _ref2.axis, moveRelativeTo = _ref2.moveRelativeTo, isMoving = _ref2.isMoving;
  return patch4(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goIntoStart = function goIntoStart2(_ref3) {
  var axis = _ref3.axis, moveInto = _ref3.moveInto, isMoving = _ref3.isMoving;
  return patch4(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
};
var whenReordering = function(_ref2) {
  var impact = _ref2.impact, draggable2 = _ref2.draggable, draggables = _ref2.draggables, droppable2 = _ref2.droppable, afterCritical = _ref2.afterCritical;
  var insideDestination = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var draggablePage = draggable2.page;
  var axis = droppable2.axis;
  if (!insideDestination.length) {
    return goIntoStart({
      axis,
      moveInto: droppable2.page,
      isMoving: draggablePage
    });
  }
  var displaced = impact.displaced, displacedBy = impact.displacedBy;
  var closestAfter = displaced.all[0];
  if (closestAfter) {
    var closest3 = draggables[closestAfter];
    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis,
        moveRelativeTo: closest3.page,
        isMoving: draggablePage
      });
    }
    var withDisplacement = offset2(closest3.page, displacedBy.point);
    return goBefore({
      axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }
  var last = insideDestination[insideDestination.length - 1];
  if (last.descriptor.id === draggable2.descriptor.id) {
    return draggablePage.borderBox.center;
  }
  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
    var page = offset2(last.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }
  return goAfter({
    axis,
    moveRelativeTo: last.page,
    isMoving: draggablePage
  });
};
var withDroppableDisplacement = function(droppable2, point5) {
  var frame = droppable2.frame;
  if (!frame) {
    return point5;
  }
  return add(point5, frame.scroll.diff.displacement);
};
var getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement2(_ref2) {
  var impact = _ref2.impact, draggable2 = _ref2.draggable, droppable2 = _ref2.droppable, draggables = _ref2.draggables, afterCritical = _ref2.afterCritical;
  var original = draggable2.page.borderBox.center;
  var at = impact.at;
  if (!droppable2) {
    return original;
  }
  if (!at) {
    return original;
  }
  if (at.type === "REORDER") {
    return whenReordering({
      impact,
      draggable: draggable2,
      draggables,
      droppable: droppable2,
      afterCritical
    });
  }
  return whenCombining({
    impact,
    draggables,
    afterCritical
  });
};
var getPageBorderBoxCenterFromImpact = function(args) {
  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  var droppable2 = args.droppable;
  var withDisplacement = droppable2 ? withDroppableDisplacement(droppable2, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
};
var scrollViewport = function(viewport, newScroll) {
  var diff = subtract(newScroll, viewport.scroll.initial);
  var displacement = negate(diff);
  var frame = getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport.frame.width
  });
  var updated = {
    frame,
    scroll: {
      initial: viewport.scroll.initial,
      max: viewport.scroll.max,
      current: newScroll,
      diff: {
        value: diff,
        displacement
      }
    }
  };
  return updated;
};
function getDraggables(ids, draggables) {
  return ids.map(function(id) {
    return draggables[id];
  });
}
function tryGetVisible(id, groups) {
  for (var i = 0; i < groups.length; i++) {
    var displacement = groups[i].visible[id];
    if (displacement) {
      return displacement;
    }
  }
  return null;
}
var speculativelyIncrease = function(_ref2) {
  var impact = _ref2.impact, viewport = _ref2.viewport, destination = _ref2.destination, draggables = _ref2.draggables, maxScrollChange = _ref2.maxScrollChange;
  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));
  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
  var last = impact.displaced;
  var withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last,
    forceShouldAnimate: false
  });
  var withDroppableScroll2 = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    last,
    forceShouldAnimate: false
  });
  var invisible = {};
  var visible = {};
  var groups = [last, withViewportScroll, withDroppableScroll2];
  last.all.forEach(function(id) {
    var displacement = tryGetVisible(id, groups);
    if (displacement) {
      visible[id] = displacement;
      return;
    }
    invisible[id] = true;
  });
  var newImpact = _extends({}, impact, {
    displaced: {
      all: last.all,
      invisible,
      visible
    }
  });
  return newImpact;
};
var withViewportDisplacement = function(viewport, point5) {
  return add(viewport.scroll.diff.displacement, point5);
};
var getClientFromPageBorderBoxCenter = function(_ref2) {
  var pageBorderBoxCenter = _ref2.pageBorderBoxCenter, draggable2 = _ref2.draggable, viewport = _ref2.viewport;
  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);
  var offset4 = subtract(withoutPageScrollChange, draggable2.page.borderBox.center);
  return add(draggable2.client.borderBox.center, offset4);
};
var isTotallyVisibleInNewLocation = function(_ref2) {
  var draggable2 = _ref2.draggable, destination = _ref2.destination, newPageBorderBoxCenter = _ref2.newPageBorderBoxCenter, viewport = _ref2.viewport, withDroppableDisplacement2 = _ref2.withDroppableDisplacement, _ref$onlyOnMainAxis = _ref2.onlyOnMainAxis, onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;
  var changeNeeded = subtract(newPageBorderBoxCenter, draggable2.page.borderBox.center);
  var shifted = offsetByPosition(draggable2.page.borderBox, changeNeeded);
  var args = {
    target: shifted,
    destination,
    withDroppableDisplacement: withDroppableDisplacement2,
    viewport
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
};
var moveToNextPlace = function(_ref2) {
  var isMovingForward = _ref2.isMovingForward, draggable2 = _ref2.draggable, destination = _ref2.destination, draggables = _ref2.draggables, previousImpact = _ref2.previousImpact, viewport = _ref2.viewport, previousPageBorderBoxCenter = _ref2.previousPageBorderBoxCenter, previousClientSelection = _ref2.previousClientSelection, afterCritical = _ref2.afterCritical;
  if (!destination.isEnabled) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var isInHomeList = isHomeOf(draggable2, destination);
  var impact = moveToNextCombine({
    isMovingForward,
    draggable: draggable2,
    destination,
    insideDestination,
    previousImpact
  }) || moveToNextIndex({
    isMovingForward,
    isInHomeList,
    draggable: draggable2,
    draggables,
    destination,
    insideDestination,
    previousImpact,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable2,
    destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });
  if (isVisibleInNewLocation) {
    var clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter,
      draggable: draggable2,
      viewport
    });
    return {
      clientSelection,
      impact,
      scrollJumpRequest: null
    };
  }
  var distance3 = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  var cautious = speculativelyIncrease({
    impact,
    viewport,
    destination,
    draggables,
    maxScrollChange: distance3
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance3
  };
};
var getKnownActive = function getKnownActive2(droppable2) {
  var rect = droppable2.subject.active;
  !rect ? true ? invariant2(false, "Cannot get clipped area from droppable") : invariant2(false) : void 0;
  return rect;
};
var getBestCrossAxisDroppable = function(_ref2) {
  var isMovingForward = _ref2.isMovingForward, pageBorderBoxCenter = _ref2.pageBorderBoxCenter, source = _ref2.source, droppables = _ref2.droppables, viewport = _ref2.viewport;
  var active = source.subject.active;
  if (!active) {
    return null;
  }
  var axis = source.axis;
  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  var candidates = toDroppableList(droppables).filter(function(droppable2) {
    return droppable2 !== source;
  }).filter(function(droppable2) {
    return droppable2.isEnabled;
  }).filter(function(droppable2) {
    return Boolean(droppable2.subject.active);
  }).filter(function(droppable2) {
    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable2));
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }
    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort(function(a, b) {
    var first = getKnownActive(a)[axis.crossAxisStart];
    var second = getKnownActive(b)[axis.crossAxisStart];
    if (isMovingForward) {
      return first - second;
    }
    return second - first;
  }).filter(function(droppable2, index2, array) {
    return getKnownActive(droppable2)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  var contains = candidates.filter(function(droppable2) {
    var isWithinDroppable = isWithin(getKnownActive(droppable2)[axis.start], getKnownActive(droppable2)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });
  if (contains.length === 1) {
    return contains[0];
  }
  if (contains.length > 1) {
    return contains.sort(function(a, b) {
      return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
    })[0];
  }
  return candidates.sort(function(a, b) {
    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a)));
    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b)));
    if (first !== second) {
      return first - second;
    }
    return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];
  })[0];
};
var getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox.center;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
var getCurrentPageBorderBox = function getCurrentPageBorderBox2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};
var getClosestDraggable = function(_ref2) {
  var pageBorderBoxCenter = _ref2.pageBorderBoxCenter, viewport = _ref2.viewport, destination = _ref2.destination, insideDestination = _ref2.insideDestination, afterCritical = _ref2.afterCritical;
  var sorted = insideDestination.filter(function(draggable2) {
    return isTotallyVisible({
      target: getCurrentPageBorderBox(draggable2, afterCritical),
      destination,
      viewport: viewport.frame,
      withDroppableDisplacement: true
    });
  }).sort(function(a, b) {
    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));
    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));
    if (distanceToA < distanceToB) {
      return -1;
    }
    if (distanceToB < distanceToA) {
      return 1;
    }
    return a.descriptor.index - b.descriptor.index;
  });
  return sorted[0] || null;
};
var getDisplacedBy = memoize_one_esm_default(function getDisplacedBy2(axis, displaceBy) {
  var displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch4(axis.line, displacement)
  };
});
var getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder2(droppable2, placeholderSize, draggables) {
  var axis = droppable2.axis;
  if (droppable2.descriptor.mode === "virtual") {
    return patch4(axis.line, placeholderSize[axis.line]);
  }
  var availableSpace = droppable2.subject.page.contentBox[axis.size];
  var insideDroppable = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var spaceUsed = insideDroppable.reduce(function(sum, dimension) {
    return sum + dimension.client.marginBox[axis.size];
  }, 0);
  var requiredSpace = spaceUsed + placeholderSize[axis.line];
  var needsToGrowBy = requiredSpace - availableSpace;
  if (needsToGrowBy <= 0) {
    return null;
  }
  return patch4(axis.line, needsToGrowBy);
};
var withMaxScroll = function withMaxScroll2(frame, max) {
  return _extends({}, frame, {
    scroll: _extends({}, frame.scroll, {
      max
    })
  });
};
var addPlaceholder = function addPlaceholder2(droppable2, draggable2, draggables) {
  var frame = droppable2.frame;
  !!isHomeOf(draggable2, droppable2) ? true ? invariant2(false, "Should not add placeholder space to home list") : invariant2(false) : void 0;
  !!droppable2.subject.withPlaceholder ? true ? invariant2(false, "Cannot add placeholder size to a subject when it already has one") : invariant2(false) : void 0;
  var placeholderSize = getDisplacedBy(droppable2.axis, draggable2.displaceBy).point;
  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable2, placeholderSize, draggables);
  var added = {
    placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable2.frame ? droppable2.frame.scroll.max : null
  };
  if (!frame) {
    var _subject = getSubject({
      page: droppable2.subject.page,
      withPlaceholder: added,
      axis: droppable2.axis,
      frame: droppable2.frame
    });
    return _extends({}, droppable2, {
      subject: _subject
    });
  }
  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  var newFrame = withMaxScroll(frame, maxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: added,
    axis: droppable2.axis,
    frame: newFrame
  });
  return _extends({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var removePlaceholder = function removePlaceholder2(droppable2) {
  var added = droppable2.subject.withPlaceholder;
  !added ? true ? invariant2(false, "Cannot remove placeholder form subject when there was none") : invariant2(false) : void 0;
  var frame = droppable2.frame;
  if (!frame) {
    var _subject2 = getSubject({
      page: droppable2.subject.page,
      axis: droppable2.axis,
      frame: null,
      withPlaceholder: null
    });
    return _extends({}, droppable2, {
      subject: _subject2
    });
  }
  var oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ? true ? invariant2(false, "Expected droppable with frame to have old max frame scroll when removing placeholder") : invariant2(false) : void 0;
  var newFrame = withMaxScroll(frame, oldMaxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    axis: droppable2.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return _extends({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var moveToNewDroppable = function(_ref2) {
  var previousPageBorderBoxCenter = _ref2.previousPageBorderBoxCenter, moveRelativeTo = _ref2.moveRelativeTo, insideDestination = _ref2.insideDestination, draggable2 = _ref2.draggable, draggables = _ref2.draggables, destination = _ref2.destination, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }
    var proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: "REORDER",
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable2,
      droppable: destination,
      draggables,
      afterCritical
    });
    var withPlaceholder = isHomeOf(draggable2, destination) ? destination : addPlaceholder(destination, draggable2, draggables);
    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable2,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }
  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
  var proposedIndex = function() {
    var relativeTo = moveRelativeTo.descriptor.index;
    if (moveRelativeTo.descriptor.id === draggable2.descriptor.id) {
      return relativeTo;
    }
    if (isGoingBeforeTarget) {
      return relativeTo;
    }
    return relativeTo + 1;
  }();
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
};
var moveCrossAxis = function(_ref2) {
  var isMovingForward = _ref2.isMovingForward, previousPageBorderBoxCenter = _ref2.previousPageBorderBoxCenter, draggable2 = _ref2.draggable, isOver = _ref2.isOver, draggables = _ref2.draggables, droppables = _ref2.droppables, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var destination = getBestCrossAxisDroppable({
    isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables,
    viewport
  });
  if (!destination) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport,
    destination,
    insideDestination,
    afterCritical
  });
  var impact = moveToNewDroppable({
    previousPageBorderBoxCenter,
    destination,
    draggable: draggable2,
    draggables,
    moveRelativeTo,
    insideDestination,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
  return {
    clientSelection,
    impact,
    scrollJumpRequest: null
  };
};
var whatIsDraggedOver = function(impact) {
  var at = impact.at;
  if (!at) {
    return null;
  }
  if (at.type === "REORDER") {
    return at.destination.droppableId;
  }
  return at.combine.droppableId;
};
var getDroppableOver = function getDroppableOver2(impact, droppables) {
  var id = whatIsDraggedOver(impact);
  return id ? droppables[id] : null;
};
var moveInDirection = function(_ref2) {
  var state = _ref2.state, type2 = _ref2.type;
  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);
  var isMainAxisMovementAllowed = Boolean(isActuallyOver);
  var home2 = state.dimensions.droppables[state.critical.droppable.id];
  var isOver = isActuallyOver || home2;
  var direction = isOver.axis.direction;
  var isMovingOnMainAxis = direction === "vertical" && (type2 === "MOVE_UP" || type2 === "MOVE_DOWN") || direction === "horizontal" && (type2 === "MOVE_LEFT" || type2 === "MOVE_RIGHT");
  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }
  var isMovingForward = type2 === "MOVE_DOWN" || type2 === "MOVE_RIGHT";
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  var _state$dimensions = state.dimensions, draggables = _state$dimensions.draggables, droppables = _state$dimensions.droppables;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    destination: isOver,
    draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    isOver,
    draggables,
    droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
};
function isMovementAllowed(state) {
  return state.phase === "DRAGGING" || state.phase === "COLLECTING";
}
function isPositionInFrame(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run(point5) {
    return isWithinVertical(point5.y) && isWithinHorizontal(point5.x);
  };
}
function getHasOverlap(first, second) {
  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
}
function getFurthestAway(_ref2) {
  var pageBorderBox = _ref2.pageBorderBox, draggable2 = _ref2.draggable, candidates = _ref2.candidates;
  var startCenter = draggable2.page.borderBox.center;
  var sorted = candidates.map(function(candidate) {
    var axis = candidate.axis;
    var target = patch4(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort(function(a, b) {
    return b.distance - a.distance;
  });
  return sorted[0] ? sorted[0].id : null;
}
function getDroppableOver$1(_ref2) {
  var pageBorderBox = _ref2.pageBorderBox, draggable2 = _ref2.draggable, droppables = _ref2.droppables;
  var candidates = toDroppableList(droppables).filter(function(item) {
    if (!item.isEnabled) {
      return false;
    }
    var active = item.subject.active;
    if (!active) {
      return false;
    }
    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }
    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }
    var axis = item.axis;
    var childCenter = active.center[axis.crossAxisLine];
    var crossAxisStart = pageBorderBox[axis.crossAxisStart];
    var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    var isStartContained = isContained(crossAxisStart);
    var isEndContained = isContained(crossAxisEnd);
    if (!isStartContained && !isEndContained) {
      return true;
    }
    if (isStartContained) {
      return crossAxisStart < childCenter;
    }
    return crossAxisEnd > childCenter;
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }
  return getFurthestAway({
    pageBorderBox,
    draggable: draggable2,
    candidates
  });
}
var offsetRectByPosition = function offsetRectByPosition2(rect, point5) {
  return getRect(offsetByPosition(rect, point5));
};
var withDroppableScroll = function(droppable2, area) {
  var frame = droppable2.frame;
  if (!frame) {
    return area;
  }
  return offsetRectByPosition(area, frame.scroll.diff.value);
};
function getIsDisplaced(_ref2) {
  var displaced = _ref2.displaced, id = _ref2.id;
  return Boolean(displaced.visible[id] || displaced.invisible[id]);
}
function atIndex(_ref2) {
  var draggable2 = _ref2.draggable, closest3 = _ref2.closest, inHomeList = _ref2.inHomeList;
  if (!closest3) {
    return null;
  }
  if (!inHomeList) {
    return closest3.descriptor.index;
  }
  if (closest3.descriptor.index > draggable2.descriptor.index) {
    return closest3.descriptor.index - 1;
  }
  return closest3.descriptor.index;
}
var getReorderImpact = function(_ref2) {
  var targetRect = _ref2.pageBorderBoxWithDroppableScroll, draggable2 = _ref2.draggable, destination = _ref2.destination, insideDestination = _ref2.insideDestination, last = _ref2.last, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var closest3 = find2(withoutDragging, function(child) {
    var id = child.descriptor.id;
    var childCenter = child.page.borderBox.center[axis.line];
    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: last,
      id
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }
      return targetStart < childCenter - displacement;
    }
    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }
    return targetStart < childCenter;
  });
  var newIndex = atIndex({
    draggable: draggable2,
    closest: closest3,
    inHomeList: isHomeOf(draggable2, destination)
  });
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last,
    displacedBy,
    index: newIndex
  });
};
var combineThresholdDivisor = 4;
var getCombineImpact = function(_ref2) {
  var draggable2 = _ref2.draggable, targetRect = _ref2.pageBorderBoxWithDroppableScroll, previousImpact = _ref2.previousImpact, destination = _ref2.destination, insideDestination = _ref2.insideDestination, afterCritical = _ref2.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var combineWith = find2(withoutDragging, function(child) {
    var id = child.descriptor.id;
    var childRect = child.page.borderBox;
    var childSize = childRect[axis.size];
    var threshold = childSize / combineThresholdDivisor;
    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }
      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }
    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }
    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });
  if (!combineWith) {
    return null;
  }
  var impact = {
    displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
};
var getDragImpact = function(_ref2) {
  var pageOffset = _ref2.pageOffset, draggable2 = _ref2.draggable, draggables = _ref2.draggables, droppables = _ref2.droppables, previousImpact = _ref2.previousImpact, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var pageBorderBox = offsetRectByPosition(draggable2.page.borderBox, pageOffset);
  var destinationId = getDroppableOver$1({
    pageBorderBox,
    draggable: draggable2,
    droppables
  });
  if (!destinationId) {
    return noImpact;
  }
  var destination = droppables[destinationId];
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    previousImpact,
    destination,
    insideDestination,
    afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    destination,
    insideDestination,
    last: previousImpact.displaced,
    viewport,
    afterCritical
  });
};
var patchDroppableMap = function(droppables, updated) {
  var _extends2;
  return _extends({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));
};
var clearUnusedPlaceholder = function clearUnusedPlaceholder2(_ref2) {
  var previousImpact = _ref2.previousImpact, impact = _ref2.impact, droppables = _ref2.droppables;
  var last = whatIsDraggedOver(previousImpact);
  var now2 = whatIsDraggedOver(impact);
  if (!last) {
    return droppables;
  }
  if (last === now2) {
    return droppables;
  }
  var lastDroppable = droppables[last];
  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }
  var updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};
var recomputePlaceholders = function(_ref2) {
  var draggable2 = _ref2.draggable, draggables = _ref2.draggables, droppables = _ref2.droppables, previousImpact = _ref2.previousImpact, impact = _ref2.impact;
  var cleaned = clearUnusedPlaceholder({
    previousImpact,
    impact,
    droppables
  });
  var isOver = whatIsDraggedOver(impact);
  if (!isOver) {
    return cleaned;
  }
  var droppable2 = droppables[isOver];
  if (isHomeOf(draggable2, droppable2)) {
    return cleaned;
  }
  if (droppable2.subject.withPlaceholder) {
    return cleaned;
  }
  var patched = addPlaceholder(droppable2, draggable2, draggables);
  return patchDroppableMap(cleaned, patched);
};
var update = function(_ref2) {
  var state = _ref2.state, forcedClientSelection = _ref2.clientSelection, forcedDimensions = _ref2.dimensions, forcedViewport = _ref2.viewport, forcedImpact = _ref2.impact, scrollJumpRequest = _ref2.scrollJumpRequest;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var clientSelection = forcedClientSelection || state.current.client.selection;
  var offset4 = subtract(clientSelection, state.initial.client.selection);
  var client = {
    offset: offset4,
    selection: clientSelection,
    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset4)
  };
  var page = {
    selection: add(client.selection, viewport.scroll.current),
    borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),
    offset: add(client.offset, viewport.scroll.diff.value)
  };
  var current = {
    client,
    page
  };
  if (state.phase === "COLLECTING") {
    return _extends({
      phase: "COLLECTING"
    }, state, {
      dimensions,
      viewport,
      current
    });
  }
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable2,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport,
    afterCritical: state.afterCritical
  });
  var withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable2,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });
  var result = _extends({}, state, {
    current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  });
  return result;
};
function getDraggables$1(ids, draggables) {
  return ids.map(function(id) {
    return draggables[id];
  });
}
var recompute = function(_ref2) {
  var impact = _ref2.impact, viewport = _ref2.viewport, draggables = _ref2.draggables, destination = _ref2.destination, forceShouldAnimate = _ref2.forceShouldAnimate;
  var last = impact.displaced;
  var afterDragging = getDraggables$1(last.all, draggables);
  var displaced = getDisplacementGroups({
    afterDragging,
    destination,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    forceShouldAnimate,
    last
  });
  return _extends({}, impact, {
    displaced
  });
};
var getClientBorderBoxCenter = function(_ref2) {
  var impact = _ref2.impact, draggable2 = _ref2.draggable, droppable2 = _ref2.droppable, draggables = _ref2.draggables, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    draggables,
    droppable: droppable2,
    afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
};
var refreshSnap = function(_ref2) {
  var state = _ref2.state, forcedDimensions = _ref2.dimensions, forcedViewport = _ref2.viewport;
  !(state.movementMode === "SNAP") ? true ? invariant2(false) : invariant2(false) : void 0;
  var needsVisibilityCheck = state.impact;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var draggable2 = draggables[state.critical.draggable.id];
  var isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ? true ? invariant2(false, "Must be over a destination in SNAP movement mode") : invariant2(false) : void 0;
  var destination = droppables[isOver];
  var impact = recompute({
    impact: needsVisibilityCheck,
    viewport,
    destination,
    draggables
  });
  var clientSelection = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    viewport,
    afterCritical: state.afterCritical
  });
  return update({
    impact,
    clientSelection,
    state,
    dimensions,
    viewport
  });
};
var getHomeLocation = function(descriptor) {
  return {
    index: descriptor.index,
    droppableId: descriptor.droppableId
  };
};
var getLiftEffect = function(_ref2) {
  var draggable2 = _ref2.draggable, home2 = _ref2.home, draggables = _ref2.draggables, viewport = _ref2.viewport;
  var displacedBy = getDisplacedBy(home2.axis, draggable2.displaceBy);
  var insideHome = getDraggablesInsideDroppable(home2.descriptor.id, draggables);
  var rawIndex = insideHome.indexOf(draggable2);
  !(rawIndex !== -1) ? true ? invariant2(false, "Expected draggable to be inside home list") : invariant2(false) : void 0;
  var afterDragging = insideHome.slice(rawIndex + 1);
  var effected = afterDragging.reduce(function(previous2, item) {
    previous2[item.descriptor.id] = true;
    return previous2;
  }, {});
  var afterCritical = {
    inVirtualList: home2.descriptor.mode === "virtual",
    displacedBy,
    effected
  };
  var displaced = getDisplacementGroups({
    afterDragging,
    destination: home2,
    displacedBy,
    last: null,
    viewport: viewport.frame,
    forceShouldAnimate: false
  });
  var impact = {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: getHomeLocation(draggable2.descriptor)
    }
  };
  return {
    impact,
    afterCritical
  };
};
var patchDimensionMap = function(dimensions, updated) {
  return {
    draggables: dimensions.draggables,
    droppables: patchDroppableMap(dimensions.droppables, updated)
  };
};
var start = function start2(key) {
  if (true) {
    {
      return;
    }
  }
};
var finish = function finish2(key) {
  if (true) {
    {
      return;
    }
  }
};
var offsetDraggable = function(_ref2) {
  var draggable2 = _ref2.draggable, offset$1 = _ref2.offset, initialWindowScroll = _ref2.initialWindowScroll;
  var client = offset2(draggable2.client, offset$1);
  var page = withScroll(client, initialWindowScroll);
  var moved = _extends({}, draggable2, {
    placeholder: _extends({}, draggable2.placeholder, {
      client
    }),
    client,
    page
  });
  return moved;
};
var getFrame = function(droppable2) {
  var frame = droppable2.frame;
  !frame ? true ? invariant2(false, "Expected Droppable to have a frame") : invariant2(false) : void 0;
  return frame;
};
var adjustAdditionsForScrollChanges = function(_ref2) {
  var additions = _ref2.additions, updatedDroppables = _ref2.updatedDroppables, viewport = _ref2.viewport;
  var windowScrollChange = viewport.scroll.diff.value;
  return additions.map(function(draggable2) {
    var droppableId = draggable2.descriptor.droppableId;
    var modified = updatedDroppables[droppableId];
    var frame = getFrame(modified);
    var droppableScrollChange = frame.scroll.diff.value;
    var totalChange = add(windowScrollChange, droppableScrollChange);
    var moved = offsetDraggable({
      draggable: draggable2,
      offset: totalChange,
      initialWindowScroll: viewport.scroll.initial
    });
    return moved;
  });
};
var publishWhileDraggingInVirtual = function(_ref2) {
  var state = _ref2.state, published = _ref2.published;
  start();
  var withScrollChange = published.modified.map(function(update2) {
    var existing = state.dimensions.droppables[update2.droppableId];
    var scrolled = scrollDroppable(existing, update2.scroll);
    return scrolled;
  });
  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));
  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));
  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);
  published.removals.forEach(function(id) {
    delete draggables[id];
  });
  var dimensions = {
    droppables,
    draggables
  };
  var wasOverId = whatIsDraggedOver(state.impact);
  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var home2 = dimensions.droppables[state.critical.droppable.id];
  var _getLiftEffect = getLiftEffect({
    draggable: draggable2,
    home: home2,
    draggables,
    viewport: state.viewport
  }), onLiftImpact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  var impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact,
    viewport: state.viewport,
    afterCritical
  });
  finish();
  var draggingState = _extends({
    phase: "DRAGGING"
  }, state, {
    phase: "DRAGGING",
    impact,
    onLiftImpact,
    dimensions,
    afterCritical,
    forceShouldAnimate: false
  });
  if (state.phase === "COLLECTING") {
    return draggingState;
  }
  var dropPending3 = _extends({
    phase: "DROP_PENDING"
  }, draggingState, {
    phase: "DROP_PENDING",
    reason: state.reason,
    isWaiting: false
  });
  return dropPending3;
};
var isSnapping = function isSnapping2(state) {
  return state.movementMode === "SNAP";
};
var postDroppableChange = function postDroppableChange2(state, updated, isEnabledChanging) {
  var dimensions = patchDimensionMap(state.dimensions, updated);
  if (!isSnapping(state) || isEnabledChanging) {
    return update({
      state,
      dimensions
    });
  }
  return refreshSnap({
    state,
    dimensions
  });
};
function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === "SNAP") {
    return _extends({
      phase: "DRAGGING"
    }, state, {
      scrollJumpRequest: null
    });
  }
  return state;
}
var idle = {
  phase: "IDLE",
  completed: null,
  shouldFlush: false
};
var reducer = function(state, action) {
  if (state === void 0) {
    state = idle;
  }
  if (action.type === "FLUSH") {
    return _extends({}, idle, {
      shouldFlush: true
    });
  }
  if (action.type === "INITIAL_PUBLISH") {
    !(state.phase === "IDLE") ? true ? invariant2(false, "INITIAL_PUBLISH must come after a IDLE phase") : invariant2(false) : void 0;
    var _action$payload = action.payload, critical = _action$payload.critical, clientSelection = _action$payload.clientSelection, viewport = _action$payload.viewport, dimensions = _action$payload.dimensions, movementMode = _action$payload.movementMode;
    var draggable2 = dimensions.draggables[critical.draggable.id];
    var home2 = dimensions.droppables[critical.droppable.id];
    var client = {
      selection: clientSelection,
      borderBoxCenter: draggable2.client.borderBox.center,
      offset: origin
    };
    var initial2 = {
      client,
      page: {
        selection: add(client.selection, viewport.scroll.initial),
        borderBoxCenter: add(client.selection, viewport.scroll.initial),
        offset: add(client.selection, viewport.scroll.diff.value)
      }
    };
    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function(item) {
      return !item.isFixedOnPage;
    });
    var _getLiftEffect = getLiftEffect({
      draggable: draggable2,
      home: home2,
      draggables: dimensions.draggables,
      viewport
    }), impact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
    var result = {
      phase: "DRAGGING",
      isDragging: true,
      critical,
      movementMode,
      dimensions,
      initial: initial2,
      current: initial2,
      isWindowScrollAllowed,
      impact,
      afterCritical,
      onLiftImpact: impact,
      viewport,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }
  if (action.type === "COLLECTION_STARTING") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? true ? invariant2(false, "Collection cannot start from phase " + state.phase) : invariant2(false) : void 0;
    var _result = _extends({
      phase: "COLLECTING"
    }, state, {
      phase: "COLLECTING"
    });
    return _result;
  }
  if (action.type === "PUBLISH_WHILE_DRAGGING") {
    !(state.phase === "COLLECTING" || state.phase === "DROP_PENDING") ? true ? invariant2(false, "Unexpected " + action.type + " received in phase " + state.phase) : invariant2(false) : void 0;
    return publishWhileDraggingInVirtual({
      state,
      published: action.payload
    });
  }
  if (action.type === "MOVE") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, action.type + " not permitted in phase " + state.phase) : invariant2(false) : void 0;
    var _clientSelection = action.payload.client;
    if (isEqual2(_clientSelection, state.current.client.selection)) {
      return state;
    }
    return update({
      state,
      clientSelection: _clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }
  if (action.type === "UPDATE_DROPPABLE_SCROLL") {
    if (state.phase === "DROP_PENDING") {
      return removeScrollJumpRequest(state);
    }
    if (state.phase === "COLLECTING") {
      return removeScrollJumpRequest(state);
    }
    !isMovementAllowed(state) ? true ? invariant2(false, action.type + " not permitted in phase " + state.phase) : invariant2(false) : void 0;
    var _action$payload2 = action.payload, id = _action$payload2.id, newScroll = _action$payload2.newScroll;
    var target = state.dimensions.droppables[id];
    if (!target) {
      return state;
    }
    var scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, "Attempting to move in an unsupported phase " + state.phase) : invariant2(false) : void 0;
    var _action$payload3 = action.payload, _id = _action$payload3.id, isEnabled = _action$payload3.isEnabled;
    var _target = state.dimensions.droppables[_id];
    !_target ? true ? invariant2(false, "Cannot find Droppable[id: " + _id + "] to toggle its enabled state") : invariant2(false) : void 0;
    !(_target.isEnabled !== isEnabled) ? true ? invariant2(false, "Trying to set droppable isEnabled to " + String(isEnabled) + "\n      but it is already " + String(_target.isEnabled)) : invariant2(false) : void 0;
    var updated = _extends({}, _target, {
      isEnabled
    });
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, "Attempting to move in an unsupported phase " + state.phase) : invariant2(false) : void 0;
    var _action$payload4 = action.payload, _id2 = _action$payload4.id, isCombineEnabled = _action$payload4.isCombineEnabled;
    var _target2 = state.dimensions.droppables[_id2];
    !_target2 ? true ? invariant2(false, "Cannot find Droppable[id: " + _id2 + "] to toggle its isCombineEnabled state") : invariant2(false) : void 0;
    !(_target2.isCombineEnabled !== isCombineEnabled) ? true ? invariant2(false, "Trying to set droppable isCombineEnabled to " + String(isCombineEnabled) + "\n      but it is already " + String(_target2.isCombineEnabled)) : invariant2(false) : void 0;
    var _updated = _extends({}, _target2, {
      isCombineEnabled
    });
    return postDroppableChange(state, _updated, true);
  }
  if (action.type === "MOVE_BY_WINDOW_SCROLL") {
    if (state.phase === "DROP_PENDING" || state.phase === "DROP_ANIMATING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, "Cannot move by window in phase " + state.phase) : invariant2(false) : void 0;
    !state.isWindowScrollAllowed ? true ? invariant2(false, "Window scrolling is currently not supported for fixed lists") : invariant2(false) : void 0;
    var _newScroll = action.payload.newScroll;
    if (isEqual2(state.viewport.scroll.current, _newScroll)) {
      return removeScrollJumpRequest(state);
    }
    var _viewport = scrollViewport(state.viewport, _newScroll);
    if (isSnapping(state)) {
      return refreshSnap({
        state,
        viewport: _viewport
      });
    }
    return update({
      state,
      viewport: _viewport
    });
  }
  if (action.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!isMovementAllowed(state)) {
      return state;
    }
    var maxScroll = action.payload.maxScroll;
    if (isEqual2(maxScroll, state.viewport.scroll.max)) {
      return state;
    }
    var withMaxScroll3 = _extends({}, state.viewport, {
      scroll: _extends({}, state.viewport.scroll, {
        max: maxScroll
      })
    });
    return _extends({
      phase: "DRAGGING"
    }, state, {
      viewport: withMaxScroll3
    });
  }
  if (action.type === "MOVE_UP" || action.type === "MOVE_DOWN" || action.type === "MOVE_LEFT" || action.type === "MOVE_RIGHT") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? true ? invariant2(false, action.type + " received while not in DRAGGING phase") : invariant2(false) : void 0;
    var _result2 = moveInDirection({
      state,
      type: action.type
    });
    if (!_result2) {
      return state;
    }
    return update({
      state,
      impact: _result2.impact,
      clientSelection: _result2.clientSelection,
      scrollJumpRequest: _result2.scrollJumpRequest
    });
  }
  if (action.type === "DROP_PENDING") {
    var reason = action.payload.reason;
    !(state.phase === "COLLECTING") ? true ? invariant2(false, "Can only move into the DROP_PENDING phase from the COLLECTING phase") : invariant2(false) : void 0;
    var newState = _extends({
      phase: "DROP_PENDING"
    }, state, {
      phase: "DROP_PENDING",
      isWaiting: true,
      reason
    });
    return newState;
  }
  if (action.type === "DROP_ANIMATE") {
    var _action$payload5 = action.payload, completed = _action$payload5.completed, dropDuration = _action$payload5.dropDuration, newHomeClientOffset = _action$payload5.newHomeClientOffset;
    !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? true ? invariant2(false, "Cannot animate drop from phase " + state.phase) : invariant2(false) : void 0;
    var _result3 = {
      phase: "DROP_ANIMATING",
      completed,
      dropDuration,
      newHomeClientOffset,
      dimensions: state.dimensions
    };
    return _result3;
  }
  if (action.type === "DROP_COMPLETE") {
    var _completed = action.payload.completed;
    return {
      phase: "IDLE",
      completed: _completed,
      shouldFlush: false
    };
  }
  return state;
};
var beforeInitialCapture = function beforeInitialCapture2(args) {
  return {
    type: "BEFORE_INITIAL_CAPTURE",
    payload: args
  };
};
var lift = function lift2(args) {
  return {
    type: "LIFT",
    payload: args
  };
};
var initialPublish = function initialPublish2(args) {
  return {
    type: "INITIAL_PUBLISH",
    payload: args
  };
};
var publishWhileDragging = function publishWhileDragging2(args) {
  return {
    type: "PUBLISH_WHILE_DRAGGING",
    payload: args
  };
};
var collectionStarting = function collectionStarting2() {
  return {
    type: "COLLECTION_STARTING",
    payload: null
  };
};
var updateDroppableScroll = function updateDroppableScroll2(args) {
  return {
    type: "UPDATE_DROPPABLE_SCROLL",
    payload: args
  };
};
var updateDroppableIsEnabled = function updateDroppableIsEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_ENABLED",
    payload: args
  };
};
var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
    payload: args
  };
};
var move = function move2(args) {
  return {
    type: "MOVE",
    payload: args
  };
};
var moveByWindowScroll = function moveByWindowScroll2(args) {
  return {
    type: "MOVE_BY_WINDOW_SCROLL",
    payload: args
  };
};
var updateViewportMaxScroll = function updateViewportMaxScroll2(args) {
  return {
    type: "UPDATE_VIEWPORT_MAX_SCROLL",
    payload: args
  };
};
var moveUp = function moveUp2() {
  return {
    type: "MOVE_UP",
    payload: null
  };
};
var moveDown = function moveDown2() {
  return {
    type: "MOVE_DOWN",
    payload: null
  };
};
var moveRight = function moveRight2() {
  return {
    type: "MOVE_RIGHT",
    payload: null
  };
};
var moveLeft = function moveLeft2() {
  return {
    type: "MOVE_LEFT",
    payload: null
  };
};
var flush = function flush2() {
  return {
    type: "FLUSH",
    payload: null
  };
};
var animateDrop = function animateDrop2(args) {
  return {
    type: "DROP_ANIMATE",
    payload: args
  };
};
var completeDrop = function completeDrop2(args) {
  return {
    type: "DROP_COMPLETE",
    payload: args
  };
};
var drop = function drop2(args) {
  return {
    type: "DROP",
    payload: args
  };
};
var dropPending = function dropPending2(args) {
  return {
    type: "DROP_PENDING",
    payload: args
  };
};
var dropAnimationFinished = function dropAnimationFinished2() {
  return {
    type: "DROP_ANIMATION_FINISHED",
    payload: null
  };
};
function checkIndexes(insideDestination) {
  if (insideDestination.length <= 1) {
    return;
  }
  var indexes = insideDestination.map(function(d2) {
    return d2.descriptor.index;
  });
  var errors = {};
  for (var i = 1; i < indexes.length; i++) {
    var current = indexes[i];
    var previous2 = indexes[i - 1];
    if (current !== previous2 + 1) {
      errors[current] = true;
    }
  }
  if (!Object.keys(errors).length) {
    return;
  }
  var formatted = indexes.map(function(index2) {
    var hasError = Boolean(errors[index2]);
    return hasError ? "[\u{1F525}" + index2 + "]" : "" + index2;
  }).join(", ");
  true ? warning2("\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    " + formatted + "\n  ") : void 0;
}
function validateDimensions(critical, dimensions) {
  if (true) {
    var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);
    checkIndexes(insideDestination);
  }
}
var lift$1 = function(marshal) {
  return function(_ref2) {
    var getState = _ref2.getState, dispatch = _ref2.dispatch;
    return function(next) {
      return function(action) {
        if (action.type !== "LIFT") {
          next(action);
          return;
        }
        var _action$payload = action.payload, id = _action$payload.id, clientSelection = _action$payload.clientSelection, movementMode = _action$payload.movementMode;
        var initial2 = getState();
        if (initial2.phase === "DROP_ANIMATING") {
          dispatch(completeDrop({
            completed: initial2.completed
          }));
        }
        !(getState().phase === "IDLE") ? true ? invariant2(false, "Unexpected phase to start a drag") : invariant2(false) : void 0;
        dispatch(flush());
        dispatch(beforeInitialCapture({
          draggableId: id,
          movementMode
        }));
        var scrollOptions = {
          shouldPublishImmediately: movementMode === "SNAP"
        };
        var request = {
          draggableId: id,
          scrollOptions
        };
        var _marshal$startPublish = marshal.startPublishing(request), critical = _marshal$startPublish.critical, dimensions = _marshal$startPublish.dimensions, viewport = _marshal$startPublish.viewport;
        validateDimensions(critical, dimensions);
        dispatch(initialPublish({
          critical,
          dimensions,
          clientSelection,
          movementMode,
          viewport
        }));
      };
    };
  };
};
var style2 = function(marshal) {
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          marshal.dragging();
        }
        if (action.type === "DROP_ANIMATE") {
          marshal.dropping(action.payload.completed.result.reason);
        }
        if (action.type === "FLUSH" || action.type === "DROP_COMPLETE") {
          marshal.resting();
        }
        next(action);
      };
    };
  };
};
var curves = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
};
var combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
var timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
var outOfTheWayTiming = timings.outOfTheWay + "s " + curves.outOfTheWay;
var transitions = {
  fluid: "opacity " + outOfTheWayTiming,
  snap: "transform " + outOfTheWayTiming + ", opacity " + outOfTheWayTiming,
  drop: function drop3(duration2) {
    var timing = duration2 + "s " + curves.drop;
    return "transform " + timing + ", opacity " + timing;
  },
  outOfTheWay: "transform " + outOfTheWayTiming,
  placeholder: "height " + outOfTheWayTiming + ", width " + outOfTheWayTiming + ", margin " + outOfTheWayTiming
};
var moveTo = function moveTo2(offset4) {
  return isEqual2(offset4, origin) ? null : "translate(" + offset4.x + "px, " + offset4.y + "px)";
};
var transforms = {
  moveTo,
  drop: function drop4(offset4, isCombining) {
    var translate = moveTo(offset4);
    if (!translate) {
      return null;
    }
    if (!isCombining) {
      return translate;
    }
    return translate + " scale(" + combine.scale.drop + ")";
  }
};
var minDropTime = timings.minDropTime;
var maxDropTime = timings.maxDropTime;
var dropTimeRange = maxDropTime - minDropTime;
var maxDropTimeAtDistance = 1500;
var cancelDropModifier = 0.6;
var getDropDuration = function(_ref2) {
  var current = _ref2.current, destination = _ref2.destination, reason = _ref2.reason;
  var distance$1 = distance(current, destination);
  if (distance$1 <= 0) {
    return minDropTime;
  }
  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }
  var percentage = distance$1 / maxDropTimeAtDistance;
  var duration2 = minDropTime + dropTimeRange * percentage;
  var withDuration = reason === "CANCEL" ? duration2 * cancelDropModifier : duration2;
  return Number(withDuration.toFixed(2));
};
var getNewHomeClientOffset = function(_ref2) {
  var impact = _ref2.impact, draggable2 = _ref2.draggable, dimensions = _ref2.dimensions, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var droppableId = whatIsDraggedOver(impact);
  var destination = droppableId ? droppables[droppableId] : null;
  var home2 = droppables[draggable2.descriptor.droppableId];
  var newClientCenter = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    draggables,
    afterCritical,
    droppable: destination || home2,
    viewport
  });
  var offset4 = subtract(newClientCenter, draggable2.client.borderBox.center);
  return offset4;
};
var getDropImpact = function(_ref2) {
  var draggables = _ref2.draggables, reason = _ref2.reason, lastImpact = _ref2.lastImpact, home2 = _ref2.home, viewport = _ref2.viewport, onLiftImpact = _ref2.onLiftImpact;
  if (!lastImpact.at || reason !== "DROP") {
    var recomputedHomeImpact = recompute({
      draggables,
      impact: onLiftImpact,
      destination: home2,
      viewport,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }
  if (lastImpact.at.type === "REORDER") {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }
  var withoutMovement = _extends({}, lastImpact, {
    displaced: emptyGroups
  });
  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
};
var drop$1 = function(_ref2) {
  var getState = _ref2.getState, dispatch = _ref2.dispatch;
  return function(next) {
    return function(action) {
      if (action.type !== "DROP") {
        next(action);
        return;
      }
      var state = getState();
      var reason = action.payload.reason;
      if (state.phase === "COLLECTING") {
        dispatch(dropPending({
          reason
        }));
        return;
      }
      if (state.phase === "IDLE") {
        return;
      }
      var isWaitingForDrop = state.phase === "DROP_PENDING" && state.isWaiting;
      !!isWaitingForDrop ? true ? invariant2(false, "A DROP action occurred while DROP_PENDING and still waiting") : invariant2(false) : void 0;
      !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? true ? invariant2(false, "Cannot drop in phase: " + state.phase) : invariant2(false) : void 0;
      var critical = state.critical;
      var dimensions = state.dimensions;
      var draggable2 = dimensions.draggables[state.critical.draggable.id];
      var _getDropImpact = getDropImpact({
        reason,
        lastImpact: state.impact,
        afterCritical: state.afterCritical,
        onLiftImpact: state.onLiftImpact,
        home: state.dimensions.droppables[state.critical.droppable.id],
        viewport: state.viewport,
        draggables: state.dimensions.draggables
      }), impact = _getDropImpact.impact, didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;
      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
      var combine2 = didDropInsideDroppable ? tryGetCombine(impact) : null;
      var source = {
        index: critical.draggable.index,
        droppableId: critical.droppable.id
      };
      var result = {
        draggableId: draggable2.descriptor.id,
        type: draggable2.descriptor.type,
        source,
        reason,
        mode: state.movementMode,
        destination,
        combine: combine2
      };
      var newHomeClientOffset = getNewHomeClientOffset({
        impact,
        draggable: draggable2,
        dimensions,
        viewport: state.viewport,
        afterCritical: state.afterCritical
      });
      var completed = {
        critical: state.critical,
        afterCritical: state.afterCritical,
        result,
        impact
      };
      var isAnimationRequired = !isEqual2(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
      if (!isAnimationRequired) {
        dispatch(completeDrop({
          completed
        }));
        return;
      }
      var dropDuration = getDropDuration({
        current: state.current.client.offset,
        destination: newHomeClientOffset,
        reason
      });
      var args = {
        newHomeClientOffset,
        dropDuration,
        completed
      };
      dispatch(animateDrop(args));
    };
  };
};
var getWindowScroll3 = function() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
function getWindowScrollBinding(update2) {
  return {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn(event) {
      if (event.target !== window && event.target !== window.document) {
        return;
      }
      update2();
    }
  };
}
function getScrollListener(_ref2) {
  var onWindowScroll = _ref2.onWindowScroll;
  function updateScroll() {
    onWindowScroll(getWindowScroll3());
  }
  var scheduled = raf_schd_esm_default(updateScroll);
  var binding = getWindowScrollBinding(scheduled);
  var unbind = noop7;
  function isActive() {
    return unbind !== noop7;
  }
  function start3() {
    !!isActive() ? true ? invariant2(false, "Cannot start scroll listener when already active") : invariant2(false) : void 0;
    unbind = bindEvents(window, [binding]);
  }
  function stop() {
    !isActive() ? true ? invariant2(false, "Cannot stop scroll listener when not active") : invariant2(false) : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop7;
  }
  return {
    start: start3,
    stop,
    isActive
  };
}
var shouldEnd = function shouldEnd2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var scrollListener = function(store) {
  var listener3 = getScrollListener({
    onWindowScroll: function onWindowScroll(newScroll) {
      store.dispatch(moveByWindowScroll({
        newScroll
      }));
    }
  });
  return function(next) {
    return function(action) {
      if (!listener3.isActive() && action.type === "INITIAL_PUBLISH") {
        listener3.start();
      }
      if (listener3.isActive() && shouldEnd(action)) {
        listener3.stop();
      }
      next(action);
    };
  };
};
var getExpiringAnnounce = function(announce) {
  var wasCalled = false;
  var isExpired = false;
  var timeoutId = setTimeout(function() {
    isExpired = true;
  });
  var result = function result2(message) {
    if (wasCalled) {
      true ? warning2("Announcement already made. Not making a second announcement") : void 0;
      return;
    }
    if (isExpired) {
      true ? warning2("\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      ") : void 0;
      return;
    }
    wasCalled = true;
    announce(message);
    clearTimeout(timeoutId);
  };
  result.wasCalled = function() {
    return wasCalled;
  };
  return result;
};
var getAsyncMarshal = function() {
  var entries = [];
  var execute3 = function execute4(timerId) {
    var index2 = findIndex(entries, function(item) {
      return item.timerId === timerId;
    });
    !(index2 !== -1) ? true ? invariant2(false, "Could not find timer") : invariant2(false) : void 0;
    var _entries$splice = entries.splice(index2, 1), entry = _entries$splice[0];
    entry.callback();
  };
  var add3 = function add4(fn) {
    var timerId = setTimeout(function() {
      return execute3(timerId);
    });
    var entry = {
      timerId,
      callback: fn
    };
    entries.push(entry);
  };
  var flush3 = function flush4() {
    if (!entries.length) {
      return;
    }
    var shallow = [].concat(entries);
    entries.length = 0;
    shallow.forEach(function(entry) {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };
  return {
    add: add3,
    flush: flush3
  };
};
var areLocationsEqual = function areLocationsEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.droppableId === second.droppableId && first.index === second.index;
};
var isCombineEqual = function isCombineEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
};
var isCriticalEqual = function isCriticalEqual2(first, second) {
  if (first === second) {
    return true;
  }
  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};
var withTimings = function withTimings2(key, fn) {
  start();
  fn();
  finish();
};
var getDragStart = function getDragStart2(critical, mode) {
  return {
    draggableId: critical.draggable.id,
    type: critical.droppable.type,
    source: {
      droppableId: critical.droppable.id,
      index: critical.draggable.index
    },
    mode
  };
};
var execute = function execute2(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }
  var willExpire = getExpiringAnnounce(announce);
  var provided = {
    announce: willExpire
  };
  responder(data, provided);
  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
};
var getPublisher = function(getResponders, announce) {
  var asyncMarshal = getAsyncMarshal();
  var dragging = null;
  var beforeCapture = function beforeCapture2(draggableId, mode) {
    !!dragging ? true ? invariant2(false, "Cannot fire onBeforeCapture as a drag start has already been published") : invariant2(false) : void 0;
    withTimings("onBeforeCapture", function() {
      var fn = getResponders().onBeforeCapture;
      if (fn) {
        var before = {
          draggableId,
          mode
        };
        fn(before);
      }
    });
  };
  var beforeStart = function beforeStart2(critical, mode) {
    !!dragging ? true ? invariant2(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant2(false) : void 0;
    withTimings("onBeforeDragStart", function() {
      var fn = getResponders().onBeforeDragStart;
      if (fn) {
        fn(getDragStart(critical, mode));
      }
    });
  };
  var start3 = function start4(critical, mode) {
    !!dragging ? true ? invariant2(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant2(false) : void 0;
    var data = getDragStart(critical, mode);
    dragging = {
      mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(function() {
      withTimings("onDragStart", function() {
        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);
      });
    });
  };
  var update2 = function update3(critical, impact) {
    var location3 = tryGetDestination(impact);
    var combine2 = tryGetCombine(impact);
    !dragging ? true ? invariant2(false, "Cannot fire onDragMove when onDragStart has not been called") : invariant2(false) : void 0;
    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }
    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location3);
    if (hasLocationChanged) {
      dragging.lastLocation = location3;
    }
    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine2);
    if (hasGroupingChanged) {
      dragging.lastCombine = combine2;
    }
    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }
    var data = _extends({}, getDragStart(critical, dragging.mode), {
      combine: combine2,
      destination: location3
    });
    asyncMarshal.add(function() {
      withTimings("onDragUpdate", function() {
        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);
      });
    });
  };
  var flush3 = function flush4() {
    !dragging ? true ? invariant2(false, "Can only flush responders while dragging") : invariant2(false) : void 0;
    asyncMarshal.flush();
  };
  var drop5 = function drop6(result) {
    !dragging ? true ? invariant2(false, "Cannot fire onDragEnd when there is no matching onDragStart") : invariant2(false) : void 0;
    dragging = null;
    withTimings("onDragEnd", function() {
      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);
    });
  };
  var abort = function abort2() {
    if (!dragging) {
      return;
    }
    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {
      combine: null,
      destination: null,
      reason: "CANCEL"
    });
    drop5(result);
  };
  return {
    beforeCapture,
    beforeStart,
    start: start3,
    update: update2,
    flush: flush3,
    drop: drop5,
    abort
  };
};
var responders = function(getResponders, announce) {
  var publisher = getPublisher(getResponders, announce);
  return function(store) {
    return function(next) {
      return function(action) {
        if (action.type === "BEFORE_INITIAL_CAPTURE") {
          publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          var critical = action.payload.critical;
          publisher.beforeStart(critical, action.payload.movementMode);
          next(action);
          publisher.start(critical, action.payload.movementMode);
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          var result = action.payload.completed.result;
          publisher.flush();
          next(action);
          publisher.drop(result);
          return;
        }
        next(action);
        if (action.type === "FLUSH") {
          publisher.abort();
          return;
        }
        var state = store.getState();
        if (state.phase === "DRAGGING") {
          publisher.update(state.critical, state.impact);
        }
      };
    };
  };
};
var dropAnimationFinish = function(store) {
  return function(next) {
    return function(action) {
      if (action.type !== "DROP_ANIMATION_FINISHED") {
        next(action);
        return;
      }
      var state = store.getState();
      !(state.phase === "DROP_ANIMATING") ? true ? invariant2(false, "Cannot finish a drop animating when no drop is occurring") : invariant2(false) : void 0;
      store.dispatch(completeDrop({
        completed: state.completed
      }));
    };
  };
};
var dropAnimationFlushOnScroll = function(store) {
  var unbind = null;
  var frameId = null;
  function clear() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }
    if (unbind) {
      unbind();
      unbind = null;
    }
  }
  return function(next) {
    return function(action) {
      if (action.type === "FLUSH" || action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATION_FINISHED") {
        clear();
      }
      next(action);
      if (action.type !== "DROP_ANIMATE") {
        return;
      }
      var binding = {
        eventName: "scroll",
        options: {
          capture: true,
          passive: false,
          once: true
        },
        fn: function flushDropAnimation() {
          var state = store.getState();
          if (state.phase === "DROP_ANIMATING") {
            store.dispatch(dropAnimationFinished());
          }
        }
      };
      frameId = requestAnimationFrame(function() {
        frameId = null;
        unbind = bindEvents(window, [binding]);
      });
    };
  };
};
var dimensionMarshalStopper = function(marshal) {
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "DROP_COMPLETE" || action.type === "FLUSH" || action.type === "DROP_ANIMATE") {
          marshal.stopPublishing();
        }
        next(action);
      };
    };
  };
};
var focus = function(marshal) {
  var isWatching = false;
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          isWatching = true;
          marshal.tryRecordFocus(action.payload.critical.draggable.id);
          next(action);
          marshal.tryRestoreFocusRecorded();
          return;
        }
        next(action);
        if (!isWatching) {
          return;
        }
        if (action.type === "FLUSH") {
          isWatching = false;
          marshal.tryRestoreFocusRecorded();
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          isWatching = false;
          var result = action.payload.completed.result;
          if (result.combine) {
            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
          }
          marshal.tryRestoreFocusRecorded();
        }
      };
    };
  };
};
var shouldStop = function shouldStop2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var autoScroll = function(autoScroller) {
  return function(store) {
    return function(next) {
      return function(action) {
        if (shouldStop(action)) {
          autoScroller.stop();
          next(action);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          next(action);
          var state = store.getState();
          !(state.phase === "DRAGGING") ? true ? invariant2(false, "Expected phase to be DRAGGING after INITIAL_PUBLISH") : invariant2(false) : void 0;
          autoScroller.start(state);
          return;
        }
        next(action);
        autoScroller.scroll(store.getState());
      };
    };
  };
};
var pendingDrop = function(store) {
  return function(next) {
    return function(action) {
      next(action);
      if (action.type !== "PUBLISH_WHILE_DRAGGING") {
        return;
      }
      var postActionState = store.getState();
      if (postActionState.phase !== "DROP_PENDING") {
        return;
      }
      if (postActionState.isWaiting) {
        return;
      }
      store.dispatch(drop({
        reason: postActionState.reason
      }));
    };
  };
};
var composeEnhancers = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
  name: "react-beautiful-dnd"
}) : compose;
var createStore2 = function(_ref2) {
  var dimensionMarshal = _ref2.dimensionMarshal, focusMarshal = _ref2.focusMarshal, styleMarshal = _ref2.styleMarshal, getResponders = _ref2.getResponders, announce = _ref2.announce, autoScroller = _ref2.autoScroller;
  return createStore(reducer, composeEnhancers(applyMiddleware(style2(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));
};
var clean$1 = function clean4() {
  return {
    additions: {},
    removals: {},
    modified: {}
  };
};
function createPublisher(_ref2) {
  var registry = _ref2.registry, callbacks = _ref2.callbacks;
  var staging = clean$1();
  var frameId = null;
  var collect = function collect2() {
    if (frameId) {
      return;
    }
    callbacks.collectionStarting();
    frameId = requestAnimationFrame(function() {
      frameId = null;
      start();
      var _staging = staging, additions = _staging.additions, removals = _staging.removals, modified = _staging.modified;
      var added = Object.keys(additions).map(function(id) {
        return registry.draggable.getById(id).getDimension(origin);
      }).sort(function(a, b) {
        return a.descriptor.index - b.descriptor.index;
      });
      var updated = Object.keys(modified).map(function(id) {
        var entry = registry.droppable.getById(id);
        var scroll3 = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id,
          scroll: scroll3
        };
      });
      var result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging = clean$1();
      finish();
      callbacks.publish(result);
    });
  };
  var add3 = function add4(entry) {
    var id = entry.descriptor.id;
    staging.additions[id] = entry;
    staging.modified[entry.descriptor.droppableId] = true;
    if (staging.removals[id]) {
      delete staging.removals[id];
    }
    collect();
  };
  var remove2 = function remove3(entry) {
    var descriptor = entry.descriptor;
    staging.removals[descriptor.id] = true;
    staging.modified[descriptor.droppableId] = true;
    if (staging.additions[descriptor.id]) {
      delete staging.additions[descriptor.id];
    }
    collect();
  };
  var stop = function stop2() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
    staging = clean$1();
  };
  return {
    add: add3,
    remove: remove2,
    stop
  };
}
var getMaxScroll = function(_ref2) {
  var scrollHeight = _ref2.scrollHeight, scrollWidth = _ref2.scrollWidth, height = _ref2.height, width = _ref2.width;
  var maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width,
    y: height
  });
  var adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};
var getDocumentElement = function() {
  var doc = document.documentElement;
  !doc ? true ? invariant2(false, "Cannot find document.documentElement") : invariant2(false) : void 0;
  return doc;
};
var getMaxWindowScroll = function() {
  var doc = getDocumentElement();
  var maxScroll = getMaxScroll({
    scrollHeight: doc.scrollHeight,
    scrollWidth: doc.scrollWidth,
    width: doc.clientWidth,
    height: doc.clientHeight
  });
  return maxScroll;
};
var getViewport = function() {
  var scroll3 = getWindowScroll3();
  var maxScroll = getMaxWindowScroll();
  var top = scroll3.y;
  var left = scroll3.x;
  var doc = getDocumentElement();
  var width = doc.clientWidth;
  var height = doc.clientHeight;
  var right = left + width;
  var bottom = top + height;
  var frame = getRect({
    top,
    left,
    right,
    bottom
  });
  var viewport = {
    frame,
    scroll: {
      initial: scroll3,
      current: scroll3,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport;
};
var getInitialPublish = function(_ref2) {
  var critical = _ref2.critical, scrollOptions = _ref2.scrollOptions, registry = _ref2.registry;
  start();
  var viewport = getViewport();
  var windowScroll = viewport.scroll.current;
  var home2 = critical.droppable;
  var droppables = registry.droppable.getAllByType(home2.type).map(function(entry) {
    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);
  });
  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function(entry) {
    return entry.getDimension(windowScroll);
  });
  var dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  finish();
  var result = {
    dimensions,
    critical,
    viewport
  };
  return result;
};
function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }
  if (entry.descriptor.type !== dragging.type) {
    return false;
  }
  var home2 = registry.droppable.getById(entry.descriptor.droppableId);
  if (home2.descriptor.mode !== "virtual") {
    true ? warning2("\n      You are attempting to add or remove a Draggable [id: " + entry.descriptor.id + "]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\n    ") : void 0;
    return false;
  }
  return true;
}
var createDimensionMarshal = function(registry, callbacks) {
  var collection = null;
  var publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry
  });
  var updateDroppableIsEnabled3 = function updateDroppableIsEnabled4(id, isEnabled) {
    !registry.droppable.exists(id) ? true ? invariant2(false, "Cannot update is enabled flag of Droppable " + id + " as it is not registered") : invariant2(false) : void 0;
    if (!collection) {
      return;
    }
    callbacks.updateDroppableIsEnabled({
      id,
      isEnabled
    });
  };
  var updateDroppableIsCombineEnabled3 = function updateDroppableIsCombineEnabled4(id, isCombineEnabled) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id) ? true ? invariant2(false, "Cannot update isCombineEnabled flag of Droppable " + id + " as it is not registered") : invariant2(false) : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id,
      isCombineEnabled
    });
  };
  var updateDroppableScroll3 = function updateDroppableScroll4(id, newScroll) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id) ? true ? invariant2(false, "Cannot update the scroll on Droppable " + id + " as it is not registered") : invariant2(false) : void 0;
    callbacks.updateDroppableScroll({
      id,
      newScroll
    });
  };
  var scrollDroppable2 = function scrollDroppable3(id, change) {
    if (!collection) {
      return;
    }
    registry.droppable.getById(id).callbacks.scroll(change);
  };
  var stopPublishing = function stopPublishing2() {
    if (!collection) {
      return;
    }
    publisher.stop();
    var home2 = collection.critical.droppable;
    registry.droppable.getAllByType(home2.type).forEach(function(entry) {
      return entry.callbacks.dragStopped();
    });
    collection.unsubscribe();
    collection = null;
  };
  var subscriber = function subscriber2(event) {
    !collection ? true ? invariant2(false, "Should only be subscribed when a collection is occurring") : invariant2(false) : void 0;
    var dragging = collection.critical.draggable;
    if (event.type === "ADDITION") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }
    if (event.type === "REMOVAL") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };
  var startPublishing = function startPublishing2(request) {
    !!collection ? true ? invariant2(false, "Cannot start capturing critical dimensions as there is already a collection") : invariant2(false) : void 0;
    var entry = registry.draggable.getById(request.draggableId);
    var home2 = registry.droppable.getById(entry.descriptor.droppableId);
    var critical = {
      draggable: entry.descriptor,
      droppable: home2.descriptor
    };
    var unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical,
      unsubscribe
    };
    return getInitialPublish({
      critical,
      registry,
      scrollOptions: request.scrollOptions
    });
  };
  var marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled3,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled3,
    scrollDroppable: scrollDroppable2,
    updateDroppableScroll: updateDroppableScroll3,
    startPublishing,
    stopPublishing
  };
  return marshal;
};
var canStartDrag = function(state, id) {
  if (state.phase === "IDLE") {
    return true;
  }
  if (state.phase !== "DROP_ANIMATING") {
    return false;
  }
  if (state.completed.result.draggableId === id) {
    return false;
  }
  return state.completed.result.reason === "DROP";
};
var scrollWindow = function(change) {
  window.scrollBy(change.x, change.y);
};
var getScrollableDroppables = memoize_one_esm_default(function(droppables) {
  return toDroppableList(droppables).filter(function(droppable2) {
    if (!droppable2.isEnabled) {
      return false;
    }
    if (!droppable2.frame) {
      return false;
    }
    return true;
  });
});
var getScrollableDroppableOver = function getScrollableDroppableOver2(target, droppables) {
  var maybe = find2(getScrollableDroppables(droppables), function(droppable2) {
    !droppable2.frame ? true ? invariant2(false, "Invalid result") : invariant2(false) : void 0;
    return isPositionInFrame(droppable2.frame.pageMarginBox)(target);
  });
  return maybe;
};
var getBestScrollableDroppable = function(_ref2) {
  var center = _ref2.center, destination = _ref2.destination, droppables = _ref2.droppables;
  if (destination) {
    var _dimension = droppables[destination];
    if (!_dimension.frame) {
      return null;
    }
    return _dimension;
  }
  var dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
};
var config2 = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: function ease(percentage) {
    return Math.pow(percentage, 2);
  },
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  }
};
var getDistanceThresholds = function(container, axis) {
  var startScrollingFrom = container[axis.size] * config2.startFromPercentage;
  var maxScrollValueAt = container[axis.size] * config2.maxScrollAtPercentage;
  var thresholds = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds;
};
var getPercentage = function(_ref2) {
  var startOfRange = _ref2.startOfRange, endOfRange = _ref2.endOfRange, current = _ref2.current;
  var range = endOfRange - startOfRange;
  if (range === 0) {
    true ? warning2("\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    ") : void 0;
    return 0;
  }
  var currentInRange = current - startOfRange;
  var percentage = currentInRange / range;
  return percentage;
};
var minScroll = 1;
var getValueFromDistance = function(distanceToEdge, thresholds) {
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return config2.maxPixelScroll;
  }
  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }
  var percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  var scroll3 = config2.maxPixelScroll * config2.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll3);
};
var accelerateAt = config2.durationDampening.accelerateAt;
var stopAt = config2.durationDampening.stopDampeningAt;
var dampenValueByTime = function(proposedScroll, dragStartTime) {
  var startOfRange = dragStartTime;
  var endOfRange = stopAt;
  var now2 = Date.now();
  var runTime = now2 - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  var betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  var scroll3 = proposedScroll * config2.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll3);
};
var getValue = function(_ref2) {
  var distanceToEdge = _ref2.distanceToEdge, thresholds = _ref2.thresholds, dragStartTime = _ref2.dragStartTime, shouldUseTimeDampening = _ref2.shouldUseTimeDampening;
  var scroll3 = getValueFromDistance(distanceToEdge, thresholds);
  if (scroll3 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll3;
  }
  return Math.max(dampenValueByTime(scroll3, dragStartTime), minScroll);
};
var getScrollOnAxis = function(_ref2) {
  var container = _ref2.container, distanceToEdges = _ref2.distanceToEdges, dragStartTime = _ref2.dragStartTime, axis = _ref2.axis, shouldUseTimeDampening = _ref2.shouldUseTimeDampening;
  var thresholds = getDistanceThresholds(container, axis);
  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return getValue({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds,
      dragStartTime,
      shouldUseTimeDampening
    });
  }
  return -1 * getValue({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds,
    dragStartTime,
    shouldUseTimeDampening
  });
};
var adjustForSizeLimits = function(_ref2) {
  var container = _ref2.container, subject = _ref2.subject, proposedScroll = _ref2.proposedScroll;
  var isTooBigVertically = subject.height > container.height;
  var isTooBigHorizontally = subject.width > container.width;
  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }
  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }
  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
};
var clean$2 = apply(function(value) {
  return value === 0 ? 0 : value;
});
var getScroll = function(_ref2) {
  var dragStartTime = _ref2.dragStartTime, container = _ref2.container, subject = _ref2.subject, center = _ref2.center, shouldUseTimeDampening = _ref2.shouldUseTimeDampening;
  var distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  var y = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening
  });
  var x = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening
  });
  var required2 = clean$2({
    x,
    y
  });
  if (isEqual2(required2, origin)) {
    return null;
  }
  var limited = adjustForSizeLimits({
    container,
    subject,
    proposedScroll: required2
  });
  if (!limited) {
    return null;
  }
  return isEqual2(limited, origin) ? null : limited;
};
var smallestSigned = apply(function(value) {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
var getOverlap = function() {
  var getRemainder = function getRemainder2(target, max) {
    if (target < 0) {
      return target;
    }
    if (target > max) {
      return target - max;
    }
    return 0;
  };
  return function(_ref2) {
    var current = _ref2.current, max = _ref2.max, change = _ref2.change;
    var targetScroll = add(current, change);
    var overlap = {
      x: getRemainder(targetScroll.x, max.x),
      y: getRemainder(targetScroll.y, max.y)
    };
    if (isEqual2(overlap, origin)) {
      return null;
    }
    return overlap;
  };
}();
var canPartiallyScroll = function canPartiallyScroll2(_ref2) {
  var rawMax = _ref2.max, current = _ref2.current, change = _ref2.change;
  var max = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  var smallestChange = smallestSigned(change);
  var overlap = getOverlap({
    max,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
var canScrollWindow = function canScrollWindow2(viewport, change) {
  return canPartiallyScroll({
    current: viewport.scroll.current,
    max: viewport.scroll.max,
    change
  });
};
var getWindowOverlap = function getWindowOverlap2(viewport, change) {
  if (!canScrollWindow(viewport, change)) {
    return null;
  }
  var max = viewport.scroll.max;
  var current = viewport.scroll.current;
  return getOverlap({
    current,
    max,
    change
  });
};
var canScrollDroppable = function canScrollDroppable2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return false;
  }
  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getDroppableOverlap = function getDroppableOverlap2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  if (!canScrollDroppable(droppable2, change)) {
    return null;
  }
  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getWindowScrollChange = function(_ref2) {
  var viewport = _ref2.viewport, subject = _ref2.subject, center = _ref2.center, dragStartTime = _ref2.dragStartTime, shouldUseTimeDampening = _ref2.shouldUseTimeDampening;
  var scroll3 = getScroll({
    dragStartTime,
    container: viewport.frame,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollWindow(viewport, scroll3) ? scroll3 : null;
};
var getDroppableScrollChange = function(_ref2) {
  var droppable2 = _ref2.droppable, subject = _ref2.subject, center = _ref2.center, dragStartTime = _ref2.dragStartTime, shouldUseTimeDampening = _ref2.shouldUseTimeDampening;
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  var scroll3 = getScroll({
    dragStartTime,
    container: frame.pageMarginBox,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollDroppable(droppable2, scroll3) ? scroll3 : null;
};
var scroll$1 = function(_ref2) {
  var state = _ref2.state, dragStartTime = _ref2.dragStartTime, shouldUseTimeDampening = _ref2.shouldUseTimeDampening, scrollWindow2 = _ref2.scrollWindow, scrollDroppable2 = _ref2.scrollDroppable;
  var center = state.current.page.borderBoxCenter;
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var subject = draggable2.page.marginBox;
  if (state.isWindowScrollAllowed) {
    var viewport = state.viewport;
    var _change = getWindowScrollChange({
      dragStartTime,
      viewport,
      subject,
      center,
      shouldUseTimeDampening
    });
    if (_change) {
      scrollWindow2(_change);
      return;
    }
  }
  var droppable2 = getBestScrollableDroppable({
    center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });
  if (!droppable2) {
    return;
  }
  var change = getDroppableScrollChange({
    dragStartTime,
    droppable: droppable2,
    subject,
    center,
    shouldUseTimeDampening
  });
  if (change) {
    scrollDroppable2(droppable2.descriptor.id, change);
  }
};
var createFluidScroller = function(_ref2) {
  var scrollWindow2 = _ref2.scrollWindow, scrollDroppable2 = _ref2.scrollDroppable;
  var scheduleWindowScroll = raf_schd_esm_default(scrollWindow2);
  var scheduleDroppableScroll = raf_schd_esm_default(scrollDroppable2);
  var dragging = null;
  var tryScroll = function tryScroll2(state) {
    !dragging ? true ? invariant2(false, "Cannot fluid scroll if not dragging") : invariant2(false) : void 0;
    var _dragging = dragging, shouldUseTimeDampening = _dragging.shouldUseTimeDampening, dragStartTime = _dragging.dragStartTime;
    scroll$1({
      state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime,
      shouldUseTimeDampening
    });
  };
  var start$1 = function start$12(state) {
    start();
    !!dragging ? true ? invariant2(false, "Cannot start auto scrolling when already started") : invariant2(false) : void 0;
    var dragStartTime = Date.now();
    var wasScrollNeeded = false;
    var fakeScrollCallback = function fakeScrollCallback2() {
      wasScrollNeeded = true;
    };
    scroll$1({
      state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback
    });
    dragging = {
      dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    finish();
    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };
  var stop = function stop2() {
    if (!dragging) {
      return;
    }
    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };
  return {
    start: start$1,
    stop,
    scroll: tryScroll
  };
};
var createJumpScroller = function(_ref2) {
  var move3 = _ref2.move, scrollDroppable2 = _ref2.scrollDroppable, scrollWindow2 = _ref2.scrollWindow;
  var moveByOffset = function moveByOffset2(state, offset4) {
    var client = add(state.current.client.selection, offset4);
    move3({
      client
    });
  };
  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan2(droppable2, change) {
    if (!canScrollDroppable(droppable2, change)) {
      return change;
    }
    var overlap = getDroppableOverlap(droppable2, change);
    if (!overlap) {
      scrollDroppable2(droppable2.descriptor.id, change);
      return null;
    }
    var whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable2(droppable2.descriptor.id, whatTheDroppableCanScroll);
    var remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };
  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan2(isWindowScrollAllowed, viewport, change) {
    if (!isWindowScrollAllowed) {
      return change;
    }
    if (!canScrollWindow(viewport, change)) {
      return change;
    }
    var overlap = getWindowOverlap(viewport, change);
    if (!overlap) {
      scrollWindow2(change);
      return null;
    }
    var whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow2(whatTheWindowCanScroll);
    var remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };
  var jumpScroller = function jumpScroller2(state) {
    var request = state.scrollJumpRequest;
    if (!request) {
      return;
    }
    var destination = whatIsDraggedOver(state.impact);
    !destination ? true ? invariant2(false, "Cannot perform a jump scroll when there is no destination") : invariant2(false) : void 0;
    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
    if (!droppableRemainder) {
      return;
    }
    var viewport = state.viewport;
    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
    if (!windowRemainder) {
      return;
    }
    moveByOffset(state, windowRemainder);
  };
  return jumpScroller;
};
var createAutoScroller = function(_ref2) {
  var scrollDroppable2 = _ref2.scrollDroppable, scrollWindow2 = _ref2.scrollWindow, move3 = _ref2.move;
  var fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var jumpScroll = createJumpScroller({
    move: move3,
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var scroll3 = function scroll4(state) {
    if (state.phase !== "DRAGGING") {
      return;
    }
    if (state.movementMode === "FLUID") {
      fluidScroller.scroll(state);
      return;
    }
    if (!state.scrollJumpRequest) {
      return;
    }
    jumpScroll(state);
  };
  var scroller = {
    scroll: scroll3,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
};
var prefix$1 = "data-rbd";
var dragHandle = function() {
  var base2 = prefix$1 + "-drag-handle";
  return {
    base: base2,
    draggableId: base2 + "-draggable-id",
    contextId: base2 + "-context-id"
  };
}();
var draggable = function() {
  var base2 = prefix$1 + "-draggable";
  return {
    base: base2,
    contextId: base2 + "-context-id",
    id: base2 + "-id"
  };
}();
var droppable = function() {
  var base2 = prefix$1 + "-droppable";
  return {
    base: base2,
    contextId: base2 + "-context-id",
    id: base2 + "-id"
  };
}();
var scrollContainer = {
  contextId: prefix$1 + "-scroll-container-context-id"
};
var makeGetSelector = function makeGetSelector2(context) {
  return function(attribute) {
    return "[" + attribute + '="' + context + '"]';
  };
};
var getStyles = function getStyles2(rules, property) {
  return rules.map(function(rule) {
    var value = rule.styles[property];
    if (!value) {
      return "";
    }
    return rule.selector + " { " + value + " }";
  }).join(" ");
};
var noPointerEvents = "pointer-events: none;";
var getStyles$1 = function(contextId) {
  var getSelector2 = makeGetSelector(contextId);
  var dragHandle$1 = function() {
    var grabCursor = "\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";
    return {
      selector: getSelector2(dragHandle.contextId),
      styles: {
        always: "\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  }();
  var draggable$1 = function() {
    var transition = "\n      transition: " + transitions.outOfTheWay + ";\n    ";
    return {
      selector: getSelector2(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  }();
  var droppable$1 = {
    selector: getSelector2(droppable.contextId),
    styles: {
      always: "overflow-anchor: none;"
    }
  };
  var body = {
    selector: "body",
    styles: {
      dragging: "\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "
    }
  };
  var rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles(rules, "always"),
    resting: getStyles(rules, "resting"),
    dragging: getStyles(rules, "dragging"),
    dropAnimating: getStyles(rules, "dropAnimating"),
    userCancel: getStyles(rules, "userCancel")
  };
};
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react23.useLayoutEffect : import_react23.useEffect;
var getHead = function getHead2() {
  var head = document.querySelector("head");
  !head ? true ? invariant2(false, "Cannot find the head to append a style to") : invariant2(false) : void 0;
  return head;
};
var createStyleEl = function createStyleEl2(nonce) {
  var el = document.createElement("style");
  if (nonce) {
    el.setAttribute("nonce", nonce);
  }
  el.type = "text/css";
  return el;
};
function useStyleMarshal(contextId, nonce) {
  var styles2 = useMemo5(function() {
    return getStyles$1(contextId);
  }, [contextId]);
  var alwaysRef = (0, import_react23.useRef)(null);
  var dynamicRef = (0, import_react23.useRef)(null);
  var setDynamicStyle = useCallback(memoize_one_esm_default(function(proposed) {
    var el = dynamicRef.current;
    !el ? true ? invariant2(false, "Cannot set dynamic style element if it is not set") : invariant2(false) : void 0;
    el.textContent = proposed;
  }), []);
  var setAlwaysStyle = useCallback(function(proposed) {
    var el = alwaysRef.current;
    !el ? true ? invariant2(false, "Cannot set dynamic style element if it is not set") : invariant2(false) : void 0;
    el.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect2(function() {
    !(!alwaysRef.current && !dynamicRef.current) ? true ? invariant2(false, "style elements already mounted") : invariant2(false) : void 0;
    var always = createStyleEl(nonce);
    var dynamic = createStyleEl(nonce);
    alwaysRef.current = always;
    dynamicRef.current = dynamic;
    always.setAttribute(prefix$1 + "-always", contextId);
    dynamic.setAttribute(prefix$1 + "-dynamic", contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic);
    setAlwaysStyle(styles2.always);
    setDynamicStyle(styles2.resting);
    return function() {
      var remove2 = function remove3(ref2) {
        var current = ref2.current;
        !current ? true ? invariant2(false, "Cannot unmount ref as it is not set") : invariant2(false) : void 0;
        getHead().removeChild(current);
        ref2.current = null;
      };
      remove2(alwaysRef);
      remove2(dynamicRef);
    };
  }, [nonce, setAlwaysStyle, setDynamicStyle, styles2.always, styles2.resting, contextId]);
  var dragging = useCallback(function() {
    return setDynamicStyle(styles2.dragging);
  }, [setDynamicStyle, styles2.dragging]);
  var dropping = useCallback(function(reason) {
    if (reason === "DROP") {
      setDynamicStyle(styles2.dropAnimating);
      return;
    }
    setDynamicStyle(styles2.userCancel);
  }, [setDynamicStyle, styles2.dropAnimating, styles2.userCancel]);
  var resting = useCallback(function() {
    if (!dynamicRef.current) {
      return;
    }
    setDynamicStyle(styles2.resting);
  }, [setDynamicStyle, styles2.resting]);
  var marshal = useMemo5(function() {
    return {
      dragging,
      dropping,
      resting
    };
  }, [dragging, dropping, resting]);
  return marshal;
}
var getWindowFromEl = function(el) {
  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;
};
function isHtmlElement(el) {
  return el instanceof getWindowFromEl(el).HTMLElement;
}
function findDragHandle(contextId, draggableId) {
  var selector = "[" + dragHandle.contextId + '="' + contextId + '"]';
  var possible = toArray3(document.querySelectorAll(selector));
  if (!possible.length) {
    true ? warning2('Unable to find any drag handles in the context "' + contextId + '"') : void 0;
    return null;
  }
  var handle = find2(possible, function(el) {
    return el.getAttribute(dragHandle.draggableId) === draggableId;
  });
  if (!handle) {
    true ? warning2('Unable to find drag handle with id "' + draggableId + '" as no handle with a matching id was found') : void 0;
    return null;
  }
  if (!isHtmlElement(handle)) {
    true ? warning2("drag handle needs to be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function useFocusMarshal(contextId) {
  var entriesRef = (0, import_react23.useRef)({});
  var recordRef = (0, import_react23.useRef)(null);
  var restoreFocusFrameRef = (0, import_react23.useRef)(null);
  var isMountedRef = (0, import_react23.useRef)(false);
  var register = useCallback(function register2(id, focus2) {
    var entry = {
      id,
      focus: focus2
    };
    entriesRef.current[id] = entry;
    return function unregister() {
      var entries = entriesRef.current;
      var current = entries[id];
      if (current !== entry) {
        delete entries[id];
      }
    };
  }, []);
  var tryGiveFocus = useCallback(function tryGiveFocus2(tryGiveFocusTo) {
    var handle = findDragHandle(contextId, tryGiveFocusTo);
    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  var tryShiftRecord = useCallback(function tryShiftRecord2(previous2, redirectTo) {
    if (recordRef.current === previous2) {
      recordRef.current = redirectTo;
    }
  }, []);
  var tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded2() {
    if (restoreFocusFrameRef.current) {
      return;
    }
    if (!isMountedRef.current) {
      return;
    }
    restoreFocusFrameRef.current = requestAnimationFrame(function() {
      restoreFocusFrameRef.current = null;
      var record = recordRef.current;
      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  var tryRecordFocus = useCallback(function tryRecordFocus2(id) {
    recordRef.current = null;
    var focused = document.activeElement;
    if (!focused) {
      return;
    }
    if (focused.getAttribute(dragHandle.draggableId) !== id) {
      return;
    }
    recordRef.current = id;
  }, []);
  useIsomorphicLayoutEffect2(function() {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      var frameId = restoreFocusFrameRef.current;
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  var marshal = useMemo5(function() {
    return {
      register,
      tryRecordFocus,
      tryRestoreFocusRecorded,
      tryShiftRecord
    };
  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}
function createRegistry() {
  var entries = {
    draggables: {},
    droppables: {}
  };
  var subscribers = [];
  function subscribe(cb) {
    subscribers.push(cb);
    return function unsubscribe() {
      var index2 = subscribers.indexOf(cb);
      if (index2 === -1) {
        return;
      }
      subscribers.splice(index2, 1);
    };
  }
  function notify2(event) {
    if (subscribers.length) {
      subscribers.forEach(function(cb) {
        return cb(event);
      });
    }
  }
  function findDraggableById(id) {
    return entries.draggables[id] || null;
  }
  function getDraggableById(id) {
    var entry = findDraggableById(id);
    !entry ? true ? invariant2(false, "Cannot find draggable entry with id [" + id + "]") : invariant2(false) : void 0;
    return entry;
  }
  var draggableAPI = {
    register: function register(entry) {
      entries.draggables[entry.descriptor.id] = entry;
      notify2({
        type: "ADDITION",
        value: entry
      });
    },
    update: function update2(entry, last) {
      var current = entries.draggables[last.descriptor.id];
      if (!current) {
        return;
      }
      if (current.uniqueId !== entry.uniqueId) {
        return;
      }
      delete entries.draggables[last.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var draggableId = entry.descriptor.id;
      var current = findDraggableById(draggableId);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.draggables[draggableId];
      notify2({
        type: "REMOVAL",
        value: entry
      });
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: function exists2(id) {
      return Boolean(findDraggableById(id));
    },
    getAllByType: function getAllByType(type2) {
      return values(entries.draggables).filter(function(entry) {
        return entry.descriptor.type === type2;
      });
    }
  };
  function findDroppableById(id) {
    return entries.droppables[id] || null;
  }
  function getDroppableById(id) {
    var entry = findDroppableById(id);
    !entry ? true ? invariant2(false, "Cannot find droppable entry with id [" + id + "]") : invariant2(false) : void 0;
    return entry;
  }
  var droppableAPI = {
    register: function register(entry) {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var current = findDroppableById(entry.descriptor.id);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: function exists2(id) {
      return Boolean(findDroppableById(id));
    },
    getAllByType: function getAllByType(type2) {
      return values(entries.droppables).filter(function(entry) {
        return entry.descriptor.type === type2;
      });
    }
  };
  function clean5() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }
  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe,
    clean: clean5
  };
}
function useRegistry() {
  var registry = useMemo5(createRegistry, []);
  (0, import_react23.useEffect)(function() {
    return function unmount() {
      requestAnimationFrame(registry.clean);
    };
  }, [registry]);
  return registry;
}
var StoreContext = import_react23.default.createContext(null);
var getBodyElement = function() {
  var body = document.body;
  !body ? true ? invariant2(false, "Cannot find document.body") : invariant2(false) : void 0;
  return body;
};
var visuallyHidden = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
var getId = function getId2(contextId) {
  return "rbd-announcement-" + contextId;
};
function useAnnouncer(contextId) {
  var id = useMemo5(function() {
    return getId(contextId);
  }, [contextId]);
  var ref2 = (0, import_react23.useRef)(null);
  (0, import_react23.useEffect)(function setup() {
    var el = document.createElement("div");
    ref2.current = el;
    el.id = id;
    el.setAttribute("aria-live", "assertive");
    el.setAttribute("aria-atomic", "true");
    _extends(el.style, visuallyHidden);
    getBodyElement().appendChild(el);
    return function cleanup() {
      setTimeout(function remove2() {
        var body = getBodyElement();
        if (body.contains(el)) {
          body.removeChild(el);
        }
        if (el === ref2.current) {
          ref2.current = null;
        }
      });
    };
  }, [id]);
  var announce = useCallback(function(message) {
    var el = ref2.current;
    if (el) {
      el.textContent = message;
      return;
    }
    true ? warning2('\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      "' + message + '"\n    ') : void 0;
  }, []);
  return announce;
}
var count = 0;
var defaults3 = {
  separator: "::"
};
function useUniqueId(prefix3, options) {
  if (options === void 0) {
    options = defaults3;
  }
  return useMemo5(function() {
    return "" + prefix3 + options.separator + count++;
  }, [options.separator, prefix3]);
}
function getElementId(_ref2) {
  var contextId = _ref2.contextId, uniqueId = _ref2.uniqueId;
  return "rbd-hidden-text-" + contextId + "-" + uniqueId;
}
function useHiddenTextElement(_ref2) {
  var contextId = _ref2.contextId, text6 = _ref2.text;
  var uniqueId = useUniqueId("hidden-text", {
    separator: "-"
  });
  var id = useMemo5(function() {
    return getElementId({
      contextId,
      uniqueId
    });
  }, [uniqueId, contextId]);
  (0, import_react23.useEffect)(function mount() {
    var el = document.createElement("div");
    el.id = id;
    el.textContent = text6;
    el.style.display = "none";
    getBodyElement().appendChild(el);
    return function unmount() {
      var body = getBodyElement();
      if (body.contains(el)) {
        body.removeChild(el);
      }
    };
  }, [id, text6]);
  return id;
}
var AppContext2 = import_react23.default.createContext(null);
var peerDependencies = {
  react: "^16.8.5 || ^17.0.0 || ^18.0.0",
  "react-dom": "^16.8.5 || ^17.0.0 || ^18.0.0"
};
var semver = /(\d+)\.(\d+)\.(\d+)/;
var getVersion = function getVersion2(value) {
  var result = semver.exec(value);
  !(result != null) ? true ? invariant2(false, "Unable to parse React version " + value) : invariant2(false) : void 0;
  var major = Number(result[1]);
  var minor = Number(result[2]);
  var patch6 = Number(result[3]);
  return {
    major,
    minor,
    patch: patch6,
    raw: value
  };
};
var isSatisfied = function isSatisfied2(expected, actual) {
  if (actual.major > expected.major) {
    return true;
  }
  if (actual.major < expected.major) {
    return false;
  }
  if (actual.minor > expected.minor) {
    return true;
  }
  if (actual.minor < expected.minor) {
    return false;
  }
  return actual.patch >= expected.patch;
};
var checkReactVersion = function(peerDepValue, actualValue) {
  var peerDep = getVersion(peerDepValue);
  var actual = getVersion(actualValue);
  if (isSatisfied(peerDep, actual)) {
    return;
  }
  true ? warning2("\n    React version: [" + actual.raw + "]\n    does not satisfy expected peer dependency version: [" + peerDep.raw + "]\n\n    This can result in run time bugs, and even fatal crashes\n  ") : void 0;
};
var suffix = "\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\n";
var checkDoctype = function(doc) {
  var doctype2 = doc.doctype;
  if (!doctype2) {
    true ? warning2("\n      No <!doctype html> found.\n\n      " + suffix + "\n    ") : void 0;
    return;
  }
  if (doctype2.name.toLowerCase() !== "html") {
    true ? warning2("\n      Unexpected <!doctype> found: (" + doctype2.name + ")\n\n      " + suffix + "\n    ") : void 0;
  }
  if (doctype2.publicId !== "") {
    true ? warning2("\n      Unexpected <!doctype> publicId found: (" + doctype2.publicId + ")\n      A html5 doctype does not have a publicId\n\n      " + suffix + "\n    ") : void 0;
  }
};
function useDev(useHook) {
  if (true) {
    useHook();
  }
}
function useDevSetupWarning(fn, inputs) {
  useDev(function() {
    (0, import_react23.useEffect)(function() {
      try {
        fn();
      } catch (e2) {
        error("\n          A setup problem was encountered.\n\n          > " + e2.message + "\n        ");
      }
    }, inputs);
  });
}
function useStartupValidation() {
  useDevSetupWarning(function() {
    checkReactVersion(peerDependencies.react, import_react23.default.version);
    checkDoctype(document);
  }, []);
}
function usePrevious2(current) {
  var ref2 = (0, import_react23.useRef)(current);
  (0, import_react23.useEffect)(function() {
    ref2.current = current;
  });
  return ref2;
}
function create3() {
  var lock = null;
  function isClaimed() {
    return Boolean(lock);
  }
  function isActive(value) {
    return value === lock;
  }
  function claim(abandon) {
    !!lock ? true ? invariant2(false, "Cannot claim lock as it is already claimed") : invariant2(false) : void 0;
    var newLock = {
      abandon
    };
    lock = newLock;
    return newLock;
  }
  function release() {
    !lock ? true ? invariant2(false, "Cannot release lock when there is no lock") : invariant2(false) : void 0;
    lock = null;
  }
  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }
  return {
    isClaimed,
    isActive,
    claim,
    release,
    tryAbandon
  };
}
var tab2 = 9;
var enter = 13;
var escape2 = 27;
var space2 = 32;
var pageUp = 33;
var pageDown = 34;
var end3 = 35;
var home = 36;
var arrowLeft = 37;
var arrowUp = 38;
var arrowRight = 39;
var arrowDown = 40;
var _preventedKeys;
var preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab2] = true, _preventedKeys);
var preventStandardKeyEvents = function(event) {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
};
var supportedEventName = function() {
  var base2 = "visibilitychange";
  if (typeof document === "undefined") {
    return base2;
  }
  var candidates = [base2, "ms" + base2, "webkit" + base2, "moz" + base2, "o" + base2];
  var supported = find2(candidates, function(eventName) {
    return "on" + eventName in document;
  });
  return supported || base2;
}();
var primaryButton = 0;
var sloppyClickThreshold = 5;
function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}
var idle$1 = {
  type: "IDLE"
};
function getCaptureBindings(_ref2) {
  var cancel = _ref2.cancel, completed = _ref2.completed, getPhase = _ref2.getPhase, setPhase = _ref2.setPhase;
  return [{
    eventName: "mousemove",
    fn: function fn(event) {
      var button = event.button, clientX = event.clientX, clientY = event.clientY;
      if (button !== primaryButton) {
        return;
      }
      var point5 = {
        x: clientX,
        y: clientY
      };
      var phase = getPhase();
      if (phase.type === "DRAGGING") {
        event.preventDefault();
        phase.actions.move(point5);
        return;
      }
      !(phase.type === "PENDING") ? true ? invariant2(false, "Cannot be IDLE") : invariant2(false) : void 0;
      var pending = phase.point;
      if (!isSloppyClickThresholdExceeded(pending, point5)) {
        return;
      }
      event.preventDefault();
      var actions = phase.actions.fluidLift(point5);
      setPhase({
        type: "DRAGGING",
        actions
      });
    }
  }, {
    eventName: "mouseup",
    fn: function fn(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "mousedown",
    fn: function fn(event) {
      if (getPhase().type === "DRAGGING") {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: "keydown",
    fn: function fn(event) {
      var phase = getPhase();
      if (phase.type === "PENDING") {
        cancel();
        return;
      }
      if (event.keyCode === escape2) {
        event.preventDefault();
        cancel();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn() {
      if (getPhase().type === "PENDING") {
        cancel();
      }
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: function fn(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? true ? invariant2(false, "Unexpected phase") : invariant2(false) : void 0;
      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useMouseSensor(api2) {
  var phaseRef = (0, import_react23.useRef)(idle$1);
  var unbindEventsRef = (0, import_react23.useRef)(noop7);
  var startCaptureBinding = useMemo5(function() {
    return {
      eventName: "mousedown",
      fn: function onMouseDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.button !== primaryButton) {
          return;
        }
        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
          return;
        }
        var draggableId = api2.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions = api2.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions) {
          return;
        }
        event.preventDefault();
        var point5 = {
          x: event.clientX,
          y: event.clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point5);
      }
    };
  }, [api2]);
  var preventForcePressBinding = useMemo5(function() {
    return {
      eventName: "webkitmouseforcewillbegin",
      fn: function fn(event) {
        if (event.defaultPrevented) {
          return;
        }
        var id = api2.findClosestDraggableId(event);
        if (!id) {
          return;
        }
        var options = api2.findOptionsForDraggable(id);
        if (!options) {
          return;
        }
        if (options.shouldRespectForcePress) {
          return;
        }
        if (!api2.canGetLock(id)) {
          return;
        }
        event.preventDefault();
      }
    };
  }, [api2]);
  var listenForCapture = useCallback(function listenForCapture2() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
  }, [preventForcePressBinding, startCaptureBinding]);
  var stop = useCallback(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  var cancel = useCallback(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var bindings = getCaptureBindings({
      cancel,
      completed: stop,
      getPhase: function getPhase() {
        return phaseRef.current;
      },
      setPhase: function setPhase(phase) {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options);
  }, [cancel, stop]);
  var startPendingDrag = useCallback(function startPendingDrag2(actions, point5) {
    !(phaseRef.current.type === "IDLE") ? true ? invariant2(false, "Expected to move from IDLE to PENDING drag") : invariant2(false) : void 0;
    phaseRef.current = {
      type: "PENDING",
      point: point5,
      actions
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect2(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var _scrollJumpKeys;
function noop$12() {
}
var scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end3] = true, _scrollJumpKeys);
function getDraggingBindings(actions, stop) {
  function cancel() {
    stop();
    actions.cancel();
  }
  function drop5() {
    stop();
    actions.drop();
  }
  return [{
    eventName: "keydown",
    fn: function fn(event) {
      if (event.keyCode === escape2) {
        event.preventDefault();
        cancel();
        return;
      }
      if (event.keyCode === space2) {
        event.preventDefault();
        drop5();
        return;
      }
      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions.moveDown();
        return;
      }
      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions.moveUp();
        return;
      }
      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions.moveRight();
        return;
      }
      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions.moveLeft();
        return;
      }
      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "mousedown",
    fn: cancel
  }, {
    eventName: "mouseup",
    fn: cancel
  }, {
    eventName: "click",
    fn: cancel
  }, {
    eventName: "touchstart",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "wheel",
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useKeyboardSensor(api2) {
  var unbindEventsRef = (0, import_react23.useRef)(noop$12);
  var startCaptureBinding = useMemo5(function() {
    return {
      eventName: "keydown",
      fn: function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.keyCode !== space2) {
          return;
        }
        var draggableId = api2.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var preDrag = api2.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!preDrag) {
          return;
        }
        event.preventDefault();
        var isCapturing = true;
        var actions = preDrag.snapLift();
        unbindEventsRef.current();
        function stop() {
          !isCapturing ? true ? invariant2(false, "Cannot stop capturing a keyboard drag when not capturing") : invariant2(false) : void 0;
          isCapturing = false;
          unbindEventsRef.current();
          listenForCapture();
        }
        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
          capture: true,
          passive: false
        });
      }
    };
  }, [api2]);
  var listenForCapture = useCallback(function tryStartCapture() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect2(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var idle$2 = {
  type: "IDLE"
};
var timeForLongPress = 120;
var forcePressThreshold = 0.15;
function getWindowBindings(_ref2) {
  var cancel = _ref2.cancel, getPhase = _ref2.getPhase;
  return [{
    eventName: "orientationchange",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "contextmenu",
    fn: function fn(event) {
      event.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: function fn(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      if (event.keyCode === escape2) {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function getHandleBindings(_ref2) {
  var cancel = _ref2.cancel, completed = _ref2.completed, getPhase = _ref2.getPhase;
  return [{
    eventName: "touchmove",
    options: {
      capture: false
    },
    fn: function fn(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      phase.hasMoved = true;
      var _event$touches$ = event.touches[0], clientX = _event$touches$.clientX, clientY = _event$touches$.clientY;
      var point5 = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point5);
    }
  }, {
    eventName: "touchend",
    fn: function fn(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "touchcancel",
    fn: function fn(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      cancel();
    }
  }, {
    eventName: "touchforcechange",
    fn: function fn(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? true ? invariant2(false) : invariant2(false) : void 0;
      var touch = event.touches[0];
      if (!touch) {
        return;
      }
      var isForcePress = touch.force >= forcePressThreshold;
      if (!isForcePress) {
        return;
      }
      var shouldRespect = phase.actions.shouldRespectForcePress();
      if (phase.type === "PENDING") {
        if (shouldRespect) {
          cancel();
        }
        return;
      }
      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useTouchSensor(api2) {
  var phaseRef = (0, import_react23.useRef)(idle$2);
  var unbindEventsRef = (0, import_react23.useRef)(noop7);
  var getPhase = useCallback(function getPhase2() {
    return phaseRef.current;
  }, []);
  var setPhase = useCallback(function setPhase2(phase) {
    phaseRef.current = phase;
  }, []);
  var startCaptureBinding = useMemo5(function() {
    return {
      eventName: "touchstart",
      fn: function onTouchStart(event) {
        if (event.defaultPrevented) {
          return;
        }
        var draggableId = api2.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions = api2.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions) {
          return;
        }
        var touch = event.touches[0];
        var clientX = touch.clientX, clientY = touch.clientY;
        var point5 = {
          x: clientX,
          y: clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point5);
      }
    };
  }, [api2]);
  var listenForCapture = useCallback(function listenForCapture2() {
    var options = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  var stop = useCallback(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    if (current.type === "PENDING") {
      clearTimeout(current.longPressTimerId);
    }
    setPhase(idle$2);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  var cancel = useCallback(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var args = {
      cancel,
      completed: stop,
      getPhase
    };
    var unbindTarget = bindEvents(window, getHandleBindings(args), options);
    var unbindWindow = bindEvents(window, getWindowBindings(args), options);
    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  var startDragging = useCallback(function startDragging2() {
    var phase = getPhase();
    !(phase.type === "PENDING") ? true ? invariant2(false, "Cannot start dragging from phase " + phase.type) : invariant2(false) : void 0;
    var actions = phase.actions.fluidLift(phase.point);
    setPhase({
      type: "DRAGGING",
      actions,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  var startPendingDrag = useCallback(function startPendingDrag2(actions, point5) {
    !(getPhase().type === "IDLE") ? true ? invariant2(false, "Expected to move from IDLE to PENDING drag") : invariant2(false) : void 0;
    var longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: "PENDING",
      point: point5,
      actions,
      longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect2(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      var phase = getPhase();
      if (phase.type === "PENDING") {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle$2);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect2(function webkitHack() {
    var unbind = bindEvents(window, [{
      eventName: "touchmove",
      fn: function fn() {
      },
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}
function useValidateSensorHooks(sensorHooks) {
  useDev(function() {
    var previousRef = usePrevious2(sensorHooks);
    useDevSetupWarning(function() {
      !(previousRef.current.length === sensorHooks.length) ? true ? invariant2(false, "Cannot change the amount of sensor hooks after mounting") : invariant2(false) : void 0;
    });
  });
}
var interactiveTagNames = {
  input: true,
  button: true,
  textarea: true,
  select: true,
  option: true,
  optgroup: true,
  video: true,
  audio: true
};
function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }
  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);
  if (hasAnInteractiveTag) {
    return true;
  }
  var attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent) {
    return false;
  }
  return isAnInteractiveElement(parent, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  var target = event.target;
  if (!isHtmlElement(target)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}
var getBorderBoxCenterPosition = function(el) {
  return getRect(el.getBoundingClientRect()).center;
};
function isElement(el) {
  return el instanceof getWindowFromEl(el).Element;
}
var supportedMatchesName = function() {
  var base2 = "matches";
  if (typeof document === "undefined") {
    return base2;
  }
  var candidates = [base2, "msMatchesSelector", "webkitMatchesSelector"];
  var value = find2(candidates, function(name) {
    return name in Element.prototype;
  });
  return value || base2;
}();
function closestPonyfill(el, selector) {
  if (el == null) {
    return null;
  }
  if (el[supportedMatchesName](selector)) {
    return el;
  }
  return closestPonyfill(el.parentElement, selector);
}
function closest$1(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  return closestPonyfill(el, selector);
}
function getSelector(contextId) {
  return "[" + dragHandle.contextId + '="' + contextId + '"]';
}
function findClosestDragHandleFromEvent(contextId, event) {
  var target = event.target;
  if (!isElement(target)) {
    true ? warning2("event.target must be a Element") : void 0;
    return null;
  }
  var selector = getSelector(contextId);
  var handle = closest$1(target, selector);
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    true ? warning2("drag handle must be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function tryGetClosestDraggableIdFromEvent(contextId, event) {
  var handle = findClosestDragHandleFromEvent(contextId, event);
  if (!handle) {
    return null;
  }
  return handle.getAttribute(dragHandle.draggableId);
}
function findDraggable(contextId, draggableId) {
  var selector = "[" + draggable.contextId + '="' + contextId + '"]';
  var possible = toArray3(document.querySelectorAll(selector));
  var draggable$1 = find2(possible, function(el) {
    return el.getAttribute(draggable.id) === draggableId;
  });
  if (!draggable$1) {
    return null;
  }
  if (!isHtmlElement(draggable$1)) {
    true ? warning2("Draggable element is not a HTMLElement") : void 0;
    return null;
  }
  return draggable$1;
}
function preventDefault(event) {
  event.preventDefault();
}
function _isActive(_ref2) {
  var expected = _ref2.expected, phase = _ref2.phase, isLockActive = _ref2.isLockActive, shouldWarn = _ref2.shouldWarn;
  if (!isLockActive()) {
    if (shouldWarn) {
      true ? warning2("\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      ") : void 0;
    }
    return false;
  }
  if (expected !== phase) {
    if (shouldWarn) {
      true ? warning2("\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: " + expected + "\n        You called an action from outdated phase: " + phase + "\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      ") : void 0;
    }
    return false;
  }
  return true;
}
function canStart(_ref2) {
  var lockAPI = _ref2.lockAPI, store = _ref2.store, registry = _ref2.registry, draggableId = _ref2.draggableId;
  if (lockAPI.isClaimed()) {
    return false;
  }
  var entry = registry.draggable.findById(draggableId);
  if (!entry) {
    true ? warning2("Unable to find draggable with id: " + draggableId) : void 0;
    return false;
  }
  if (!entry.options.isEnabled) {
    return false;
  }
  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }
  return true;
}
function tryStart(_ref3) {
  var lockAPI = _ref3.lockAPI, contextId = _ref3.contextId, store = _ref3.store, registry = _ref3.registry, draggableId = _ref3.draggableId, forceSensorStop = _ref3.forceSensorStop, sourceEvent = _ref3.sourceEvent;
  var shouldStart = canStart({
    lockAPI,
    store,
    registry,
    draggableId
  });
  if (!shouldStart) {
    return null;
  }
  var entry = registry.draggable.getById(draggableId);
  var el = findDraggable(contextId, entry.descriptor.id);
  if (!el) {
    true ? warning2("Unable to find draggable element with id: " + draggableId) : void 0;
    return null;
  }
  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
    return null;
  }
  var lock = lockAPI.claim(forceSensorStop || noop7);
  var phase = "PRE_DRAG";
  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }
  function isLockActive() {
    return lockAPI.isActive(lock);
  }
  function tryDispatch(expected, getAction) {
    if (_isActive({
      expected,
      phase,
      isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }
  var tryDispatchWhenDragging = tryDispatch.bind(null, "DRAGGING");
  function lift$12(args) {
    function completed() {
      lockAPI.release();
      phase = "COMPLETED";
    }
    if (phase !== "PRE_DRAG") {
      completed();
      !(phase === "PRE_DRAG") ? true ? invariant2(false, "Cannot lift in phase " + phase) : invariant2(false) : void 0;
    }
    store.dispatch(lift(args.liftActionArgs));
    phase = "DRAGGING";
    function finish3(reason, options) {
      if (options === void 0) {
        options = {
          shouldBlockNextClick: false
        };
      }
      args.cleanup();
      if (options.shouldBlockNextClick) {
        var unbind = bindEvents(window, [{
          eventName: "click",
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }
      completed();
      store.dispatch(drop({
        reason
      }));
    }
    return _extends({
      isActive: function isActive() {
        return _isActive({
          expected: "DRAGGING",
          phase,
          isLockActive,
          shouldWarn: false
        });
      },
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: function drop5(options) {
        return finish3("DROP", options);
      },
      cancel: function cancel(options) {
        return finish3("CANCEL", options);
      }
    }, args.actions);
  }
  function fluidLift(clientSelection) {
    var move$1 = raf_schd_esm_default(function(client) {
      tryDispatchWhenDragging(function() {
        return move({
          client
        });
      });
    });
    var api2 = lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection,
        movementMode: "FLUID"
      },
      cleanup: function cleanup() {
        return move$1.cancel();
      },
      actions: {
        move: move$1
      }
    });
    return _extends({}, api2, {
      move: move$1
    });
  }
  function snapLift() {
    var actions = {
      moveUp: function moveUp$1() {
        return tryDispatchWhenDragging(moveUp);
      },
      moveRight: function moveRight$1() {
        return tryDispatchWhenDragging(moveRight);
      },
      moveDown: function moveDown$1() {
        return tryDispatchWhenDragging(moveDown);
      },
      moveLeft: function moveLeft$1() {
        return tryDispatchWhenDragging(moveLeft);
      }
    };
    return lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el),
        movementMode: "SNAP"
      },
      cleanup: noop7,
      actions
    });
  }
  function abortPreDrag() {
    var shouldRelease = _isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: true
    });
    if (shouldRelease) {
      lockAPI.release();
    }
  }
  var preDrag = {
    isActive: function isActive() {
      return _isActive({
        expected: "PRE_DRAG",
        phase,
        isLockActive,
        shouldWarn: false
      });
    },
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift,
    snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}
var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal(_ref4) {
  var contextId = _ref4.contextId, store = _ref4.store, registry = _ref4.registry, customSensors = _ref4.customSensors, enableDefaultSensors = _ref4.enableDefaultSensors;
  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);
  var lockAPI = (0, import_react23.useState)(function() {
    return create3();
  })[0];
  var tryAbandonLock = useCallback(function tryAbandonLock2(previous2, current) {
    if (previous2.isDragging && !current.isDragging) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect2(function listenToStore() {
    var previous2 = store.getState();
    var unsubscribe = store.subscribe(function() {
      var current = store.getState();
      tryAbandonLock(previous2, current);
      previous2 = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect2(function() {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  var canGetLock = useCallback(function(draggableId) {
    return canStart({
      lockAPI,
      registry,
      store,
      draggableId
    });
  }, [lockAPI, registry, store]);
  var tryGetLock = useCallback(function(draggableId, forceStop, options) {
    return tryStart({
      lockAPI,
      registry,
      contextId,
      store,
      draggableId,
      forceSensorStop: forceStop,
      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
    });
  }, [contextId, lockAPI, registry, store]);
  var findClosestDraggableId = useCallback(function(event) {
    return tryGetClosestDraggableIdFromEvent(contextId, event);
  }, [contextId]);
  var findOptionsForDraggable = useCallback(function(id) {
    var entry = registry.draggable.findById(id);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  var tryReleaseLock = useCallback(function tryReleaseLock2() {
    if (!lockAPI.isClaimed()) {
      return;
    }
    lockAPI.tryAbandon();
    if (store.getState().phase !== "IDLE") {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  var isLockClaimed = useCallback(lockAPI.isClaimed, [lockAPI]);
  var api2 = useMemo5(function() {
    return {
      canGetLock,
      tryGetLock,
      findClosestDraggableId,
      findOptionsForDraggable,
      tryReleaseLock,
      isLockClaimed
    };
  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  useValidateSensorHooks(useSensors);
  for (var i = 0; i < useSensors.length; i++) {
    useSensors[i](api2);
  }
}
var createResponders = function createResponders2(props) {
  return {
    onBeforeCapture: props.onBeforeCapture,
    onBeforeDragStart: props.onBeforeDragStart,
    onDragStart: props.onDragStart,
    onDragEnd: props.onDragEnd,
    onDragUpdate: props.onDragUpdate
  };
};
function getStore(lazyRef) {
  !lazyRef.current ? true ? invariant2(false, "Could not find store from lazy ref") : invariant2(false) : void 0;
  return lazyRef.current;
}
function App4(props) {
  var contextId = props.contextId, setCallbacks = props.setCallbacks, sensors = props.sensors, nonce = props.nonce, dragHandleUsageInstructions2 = props.dragHandleUsageInstructions;
  var lazyStoreRef = (0, import_react23.useRef)(null);
  useStartupValidation();
  var lastPropsRef = usePrevious2(props);
  var getResponders = useCallback(function() {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  var announce = useAnnouncer(contextId);
  var dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions2
  });
  var styleMarshal = useStyleMarshal(contextId, nonce);
  var lazyDispatch = useCallback(function(action) {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  var marshalCallbacks = useMemo5(function() {
    return bindActionCreators({
      publishWhileDragging,
      updateDroppableScroll,
      updateDroppableIsEnabled,
      updateDroppableIsCombineEnabled,
      collectionStarting
    }, lazyDispatch);
  }, [lazyDispatch]);
  var registry = useRegistry();
  var dimensionMarshal = useMemo5(function() {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  var autoScroller = useMemo5(function() {
    return createAutoScroller(_extends({
      scrollWindow,
      scrollDroppable: dimensionMarshal.scrollDroppable
    }, bindActionCreators({
      move
    }, lazyDispatch)));
  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);
  var focusMarshal = useFocusMarshal(contextId);
  var store = useMemo5(function() {
    return createStore2({
      announce,
      autoScroller,
      dimensionMarshal,
      focusMarshal,
      getResponders,
      styleMarshal
    });
  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
  if (true) {
    if (lazyStoreRef.current && lazyStoreRef.current !== store) {
      true ? warning2("unexpected store change") : void 0;
    }
  }
  lazyStoreRef.current = store;
  var tryResetStore = useCallback(function() {
    var current = getStore(lazyStoreRef);
    var state = current.getState();
    if (state.phase !== "IDLE") {
      current.dispatch(flush());
    }
  }, []);
  var isDragging = useCallback(function() {
    var state = getStore(lazyStoreRef).getState();
    return state.isDragging || state.phase === "DROP_ANIMATING";
  }, []);
  var appCallbacks = useMemo5(function() {
    return {
      isDragging,
      tryAbort: tryResetStore
    };
  }, [isDragging, tryResetStore]);
  setCallbacks(appCallbacks);
  var getCanLift = useCallback(function(id) {
    return canStartDrag(getStore(lazyStoreRef).getState(), id);
  }, []);
  var getIsMovementAllowed = useCallback(function() {
    return isMovementAllowed(getStore(lazyStoreRef).getState());
  }, []);
  var appContext = useMemo5(function() {
    return {
      marshal: dimensionMarshal,
      focus: focusMarshal,
      contextId,
      canLift: getCanLift,
      isMovementAllowed: getIsMovementAllowed,
      dragHandleUsageInstructionsId,
      registry
    };
  }, [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors,
    enableDefaultSensors: props.enableDefaultSensors !== false
  });
  (0, import_react23.useEffect)(function() {
    return tryResetStore;
  }, [tryResetStore]);
  return import_react23.default.createElement(AppContext2.Provider, {
    value: appContext
  }, import_react23.default.createElement(Provider_default, {
    context: StoreContext,
    store
  }, props.children));
}
var count$1 = 0;
function useInstanceCount() {
  return useMemo5(function() {
    return "" + count$1++;
  }, []);
}
function DragDropContext(props) {
  var contextId = useInstanceCount();
  var dragHandleUsageInstructions2 = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return import_react23.default.createElement(ErrorBoundary, null, function(setCallbacks) {
    return import_react23.default.createElement(App4, {
      nonce: props.nonce,
      contextId,
      setCallbacks,
      dragHandleUsageInstructions: dragHandleUsageInstructions2,
      enableDefaultSensors: props.enableDefaultSensors,
      sensors: props.sensors,
      onBeforeCapture: props.onBeforeCapture,
      onBeforeDragStart: props.onBeforeDragStart,
      onDragStart: props.onDragStart,
      onDragUpdate: props.onDragUpdate,
      onDragEnd: props.onDragEnd
    }, props.children);
  });
}
var isEqual$1 = function isEqual4(base2) {
  return function(value) {
    return base2 === value;
  };
};
var isScroll = isEqual$1("scroll");
var isAuto = isEqual$1("auto");
var isVisible$1 = isEqual$1("visible");
var isEither = function isEither2(overflow, fn) {
  return fn(overflow.overflowX) || fn(overflow.overflowY);
};
var isBoth = function isBoth2(overflow, fn) {
  return fn(overflow.overflowX) && fn(overflow.overflowY);
};
var isElementScrollable = function isElementScrollable2(el) {
  var style3 = window.getComputedStyle(el);
  var overflow = {
    overflowX: style3.overflowX,
    overflowY: style3.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};
var isBodyScrollable = function isBodyScrollable2() {
  if (false) {
    return false;
  }
  var body = getBodyElement();
  var html4 = document.documentElement;
  !html4 ? true ? invariant2(false) : invariant2(false) : void 0;
  if (!isElementScrollable(body)) {
    return false;
  }
  var htmlStyle = window.getComputedStyle(html4);
  var htmlOverflow = {
    overflowX: htmlStyle.overflowX,
    overflowY: htmlStyle.overflowY
  };
  if (isBoth(htmlOverflow, isVisible$1)) {
    return false;
  }
  true ? warning2("\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\n  ") : void 0;
  return false;
};
var getClosestScrollable = function getClosestScrollable2(el) {
  if (el == null) {
    return null;
  }
  if (el === document.body) {
    return isBodyScrollable() ? el : null;
  }
  if (el === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el)) {
    return getClosestScrollable2(el.parentElement);
  }
  return el;
};
var checkForNestedScrollContainers = function(scrollable) {
  if (!scrollable) {
    return;
  }
  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);
  if (!anotherScrollParent) {
    return;
  }
  true ? warning2("\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  ") : void 0;
};
var getScroll$1 = function(el) {
  return {
    x: el.scrollLeft,
    y: el.scrollTop
  };
};
var getIsFixed = function getIsFixed2(el) {
  if (!el) {
    return false;
  }
  var style3 = window.getComputedStyle(el);
  if (style3.position === "fixed") {
    return true;
  }
  return getIsFixed2(el.parentElement);
};
var getEnv = function(start3) {
  var closestScrollable = getClosestScrollable(start3);
  var isFixedOnPage = getIsFixed(start3);
  return {
    closestScrollable,
    isFixedOnPage
  };
};
var getDroppableDimension = function(_ref2) {
  var descriptor = _ref2.descriptor, isEnabled = _ref2.isEnabled, isCombineEnabled = _ref2.isCombineEnabled, isFixedOnPage = _ref2.isFixedOnPage, direction = _ref2.direction, client = _ref2.client, page = _ref2.page, closest3 = _ref2.closest;
  var frame = function() {
    if (!closest3) {
      return null;
    }
    var scrollSize = closest3.scrollSize, frameClient = closest3.client;
    var maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest3.page.marginBox,
      frameClient,
      scrollSize,
      shouldClipSubject: closest3.shouldClipSubject,
      scroll: {
        initial: closest3.scroll,
        current: closest3.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  }();
  var axis = direction === "vertical" ? vertical : horizontal;
  var subject = getSubject({
    page,
    withPlaceholder: null,
    axis,
    frame
  });
  var dimension = {
    descriptor,
    isCombineEnabled,
    isFixedOnPage,
    axis,
    isEnabled,
    client,
    page,
    frame,
    subject
  };
  return dimension;
};
var getClient = function getClient2(targetRef, closestScrollable) {
  var base2 = getBox(targetRef);
  if (!closestScrollable) {
    return base2;
  }
  if (targetRef !== closestScrollable) {
    return base2;
  }
  var top = base2.paddingBox.top - closestScrollable.scrollTop;
  var left = base2.paddingBox.left - closestScrollable.scrollLeft;
  var bottom = top + closestScrollable.scrollHeight;
  var right = left + closestScrollable.scrollWidth;
  var paddingBox = {
    top,
    right,
    bottom,
    left
  };
  var borderBox = expand(paddingBox, base2.border);
  var client = createBox({
    borderBox,
    margin: base2.margin,
    border: base2.border,
    padding: base2.padding
  });
  return client;
};
var getDimension = function(_ref2) {
  var ref2 = _ref2.ref, descriptor = _ref2.descriptor, env = _ref2.env, windowScroll = _ref2.windowScroll, direction = _ref2.direction, isDropDisabled = _ref2.isDropDisabled, isCombineEnabled = _ref2.isCombineEnabled, shouldClipSubject = _ref2.shouldClipSubject;
  var closestScrollable = env.closestScrollable;
  var client = getClient(ref2, closestScrollable);
  var page = withScroll(client, windowScroll);
  var closest3 = function() {
    if (!closestScrollable) {
      return null;
    }
    var frameClient = getBox(closestScrollable);
    var scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: withScroll(frameClient, windowScroll),
      scroll: getScroll$1(closestScrollable),
      scrollSize,
      shouldClipSubject
    };
  }();
  var dimension = getDroppableDimension({
    descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled,
    isFixedOnPage: env.isFixedOnPage,
    direction,
    client,
    page,
    closest: closest3
  });
  return dimension;
};
var immediate = {
  passive: false
};
var delayed = {
  passive: true
};
var getListenerOptions = function(options) {
  return options.shouldPublishImmediately ? immediate : delayed;
};
function useRequiredContext(Context) {
  var result = (0, import_react23.useContext)(Context);
  !result ? true ? invariant2(false, "Could not find required context") : invariant2(false) : void 0;
  return result;
}
var getClosestScrollableFromDrag = function getClosestScrollableFromDrag2(dragging) {
  return dragging && dragging.env.closestScrollable || null;
};
function useDroppablePublisher(args) {
  var whileDraggingRef = (0, import_react23.useRef)(null);
  var appContext = useRequiredContext(AppContext2);
  var uniqueId = useUniqueId("droppable");
  var registry = appContext.registry, marshal = appContext.marshal;
  var previousRef = usePrevious2(args);
  var descriptor = useMemo5(function() {
    return {
      id: args.droppableId,
      type: args.type,
      mode: args.mode
    };
  }, [args.droppableId, args.mode, args.type]);
  var publishedDescriptorRef = (0, import_react23.useRef)(descriptor);
  var memoizedUpdateScroll = useMemo5(function() {
    return memoize_one_esm_default(function(x, y) {
      !whileDraggingRef.current ? true ? invariant2(false, "Can only update scroll when dragging") : invariant2(false) : void 0;
      var scroll4 = {
        x,
        y
      };
      marshal.updateDroppableScroll(descriptor.id, scroll4);
    });
  }, [descriptor.id, marshal]);
  var getClosestScroll = useCallback(function() {
    var dragging = whileDraggingRef.current;
    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }
    return getScroll$1(dragging.env.closestScrollable);
  }, []);
  var updateScroll = useCallback(function() {
    var scroll4 = getClosestScroll();
    memoizedUpdateScroll(scroll4.x, scroll4.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  var scheduleScrollUpdate = useMemo5(function() {
    return raf_schd_esm_default(updateScroll);
  }, [updateScroll]);
  var onClosestScroll = useCallback(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? true ? invariant2(false, "Could not find scroll options while scrolling") : invariant2(false) : void 0;
    var options = dragging.scrollOptions;
    if (options.shouldPublishImmediately) {
      updateScroll();
      return;
    }
    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  var getDimensionAndWatchScroll = useCallback(function(windowScroll, options) {
    !!whileDraggingRef.current ? true ? invariant2(false, "Cannot collect a droppable while a drag is occurring") : invariant2(false) : void 0;
    var previous2 = previousRef.current;
    var ref2 = previous2.getDroppableRef();
    !ref2 ? true ? invariant2(false, "Cannot collect without a droppable ref") : invariant2(false) : void 0;
    var env = getEnv(ref2);
    var dragging = {
      ref: ref2,
      descriptor,
      env,
      scrollOptions: options
    };
    whileDraggingRef.current = dragging;
    var dimension = getDimension({
      ref: ref2,
      descriptor,
      env,
      windowScroll,
      direction: previous2.direction,
      isDropDisabled: previous2.isDropDisabled,
      isCombineEnabled: previous2.isCombineEnabled,
      shouldClipSubject: !previous2.ignoreContainerClipping
    });
    var scrollable = env.closestScrollable;
    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
      if (true) {
        checkForNestedScrollContainers(scrollable);
      }
    }
    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  var getScrollWhileDragging = useCallback(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? true ? invariant2(false, "Can only recollect Droppable client for Droppables that have a scroll container") : invariant2(false) : void 0;
    return getScroll$1(closest3);
  }, []);
  var dragStopped = useCallback(function() {
    var dragging = whileDraggingRef.current;
    !dragging ? true ? invariant2(false, "Cannot stop drag when no active drag") : invariant2(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;
    if (!closest3) {
      return;
    }
    scheduleScrollUpdate.cancel();
    closest3.removeAttribute(scrollContainer.contextId);
    closest3.removeEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  var scroll3 = useCallback(function(change) {
    var dragging = whileDraggingRef.current;
    !dragging ? true ? invariant2(false, "Cannot scroll when there is no drag") : invariant2(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !closest3 ? true ? invariant2(false, "Cannot scroll a droppable with no closest scrollable") : invariant2(false) : void 0;
    closest3.scrollTop += change.y;
    closest3.scrollLeft += change.x;
  }, []);
  var callbacks = useMemo5(function() {
    return {
      getDimensionAndWatchScroll,
      getScrollWhileDragging,
      dragStopped,
      scroll: scroll3
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll3]);
  var entry = useMemo5(function() {
    return {
      uniqueId,
      descriptor,
      callbacks
    };
  }, [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect2(function() {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return function() {
      if (whileDraggingRef.current) {
        true ? warning2("Unsupported: changing the droppableId or type of a Droppable during a drag") : void 0;
        dragStopped();
      }
      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect2(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect2(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}
function noop$22() {
}
var empty = {
  width: 0,
  height: 0,
  margin: noSpacing2
};
var getSize = function getSize2(_ref2) {
  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount, placeholder2 = _ref2.placeholder, animate = _ref2.animate;
  if (isAnimatingOpenOnMount) {
    return empty;
  }
  if (animate === "close") {
    return empty;
  }
  return {
    height: placeholder2.client.borderBox.height,
    width: placeholder2.client.borderBox.width,
    margin: placeholder2.client.margin
  };
};
var getStyle = function getStyle2(_ref2) {
  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount, placeholder2 = _ref2.placeholder, animate = _ref2.animate;
  var size = getSize({
    isAnimatingOpenOnMount,
    placeholder: placeholder2,
    animate
  });
  return {
    display: placeholder2.display,
    boxSizing: "border-box",
    width: size.width,
    height: size.height,
    marginTop: size.margin.top,
    marginRight: size.margin.right,
    marginBottom: size.margin.bottom,
    marginLeft: size.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: animate !== "none" ? transitions.placeholder : null
  };
};
function Placeholder(props) {
  var animateOpenTimerRef = (0, import_react23.useRef)(null);
  var tryClearAnimateOpenTimer = useCallback(function() {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  var animate = props.animate, onTransitionEnd = props.onTransitionEnd, onClose = props.onClose, contextId = props.contextId;
  var _useState = (0, import_react23.useState)(props.animate === "open"), isAnimatingOpenOnMount = _useState[0], setIsAnimatingOpenOnMount = _useState[1];
  (0, import_react23.useEffect)(function() {
    if (!isAnimatingOpenOnMount) {
      return noop$22;
    }
    if (animate !== "open") {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop$22;
    }
    if (animateOpenTimerRef.current) {
      return noop$22;
    }
    animateOpenTimerRef.current = setTimeout(function() {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  var onSizeChangeEnd = useCallback(function(event) {
    if (event.propertyName !== "height") {
      return;
    }
    onTransitionEnd();
    if (animate === "close") {
      onClose();
    }
  }, [animate, onClose, onTransitionEnd]);
  var style3 = getStyle({
    isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder
  });
  return import_react23.default.createElement(props.placeholder.tagName, {
    style: style3,
    "data-rbd-placeholder-context-id": contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef
  });
}
var Placeholder$1 = import_react23.default.memo(Placeholder);
var DroppableContext = import_react23.default.createContext(null);
function checkIsValidInnerRef(el) {
  !(el && isHtmlElement(el)) ? true ? invariant2(false, "\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\n  ") : invariant2(false) : void 0;
}
function isBoolean2(value) {
  return typeof value === "boolean";
}
function runChecks(args, checks2) {
  checks2.forEach(function(check) {
    return check(args);
  });
}
var shared = [function required(_ref2) {
  var props = _ref2.props;
  !props.droppableId ? true ? invariant2(false, "A Droppable requires a droppableId prop") : invariant2(false) : void 0;
  !(typeof props.droppableId === "string") ? true ? invariant2(false, "A Droppable requires a [string] droppableId. Provided: [" + typeof props.droppableId + "]") : invariant2(false) : void 0;
}, function _boolean(_ref2) {
  var props = _ref2.props;
  !isBoolean2(props.isDropDisabled) ? true ? invariant2(false, "isDropDisabled must be a boolean") : invariant2(false) : void 0;
  !isBoolean2(props.isCombineEnabled) ? true ? invariant2(false, "isCombineEnabled must be a boolean") : invariant2(false) : void 0;
  !isBoolean2(props.ignoreContainerClipping) ? true ? invariant2(false, "ignoreContainerClipping must be a boolean") : invariant2(false) : void 0;
}, function ref(_ref3) {
  var getDroppableRef = _ref3.getDroppableRef;
  checkIsValidInnerRef(getDroppableRef());
}];
var standard = [function placeholder(_ref4) {
  var props = _ref4.props, getPlaceholderRef = _ref4.getPlaceholderRef;
  if (!props.placeholder) {
    return;
  }
  var ref2 = getPlaceholderRef();
  if (ref2) {
    return;
  }
  true ? warning2('\n      Droppable setup issue [droppableId: "' + props.droppableId + '"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\n    ') : void 0;
}];
var virtual = [function hasClone(_ref5) {
  var props = _ref5.props;
  !props.renderClone ? true ? invariant2(false, "Must provide a clone render function (renderClone) for virtual lists") : invariant2(false) : void 0;
}, function hasNoPlaceholder(_ref6) {
  var getPlaceholderRef = _ref6.getPlaceholderRef;
  !!getPlaceholderRef() ? true ? invariant2(false, "Expected virtual list to not have a placeholder") : invariant2(false) : void 0;
}];
function useValidation(args) {
  useDevSetupWarning(function() {
    runChecks(args, shared);
    if (args.props.mode === "standard") {
      runChecks(args, standard);
    }
    if (args.props.mode === "virtual") {
      runChecks(args, virtual);
    }
  });
}
var AnimateInOut = function(_React$PureComponent) {
  _inheritsLoose(AnimateInOut2, _React$PureComponent);
  function AnimateInOut2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {
      isVisible: Boolean(_this.props.on),
      data: _this.props.on,
      animate: _this.props.shouldAnimate && _this.props.on ? "open" : "none"
    };
    _this.onClose = function() {
      if (_this.state.animate !== "close") {
        return;
      }
      _this.setState({
        isVisible: false
      });
    };
    return _this;
  }
  AnimateInOut2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: "none"
      };
    }
    if (props.on) {
      return {
        isVisible: true,
        data: props.on,
        animate: "open"
      };
    }
    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: "close"
      };
    }
    return {
      isVisible: false,
      animate: "close",
      data: null
    };
  };
  var _proto = AnimateInOut2.prototype;
  _proto.render = function render3() {
    if (!this.state.isVisible) {
      return null;
    }
    var provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  };
  return AnimateInOut2;
}(import_react23.default.PureComponent);
var zIndexOptions = {
  dragging: 5e3,
  dropAnimating: 4500
};
var getDraggingTransition = function getDraggingTransition2(shouldAnimateDragMovement, dropping) {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }
  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }
  return transitions.fluid;
};
var getDraggingOpacity = function getDraggingOpacity2(isCombining, isDropAnimating) {
  if (!isCombining) {
    return null;
  }
  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};
var getShouldDraggingAnimate = function getShouldDraggingAnimate2(dragging) {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }
  return dragging.mode === "SNAP";
};
function getDraggingStyle(dragging) {
  var dimension = dragging.dimension;
  var box = dimension.client;
  var offset4 = dragging.offset, combineWith = dragging.combineWith, dropping = dragging.dropping;
  var isCombining = Boolean(combineWith);
  var shouldAnimate = getShouldDraggingAnimate(dragging);
  var isDropAnimating = Boolean(dropping);
  var transform = isDropAnimating ? transforms.drop(offset4, isCombining) : transforms.moveTo(offset4);
  var style3 = {
    position: "fixed",
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: "border-box",
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: "none"
  };
  return style3;
}
function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? null : "none"
  };
}
function getStyle$1(mapped) {
  return mapped.type === "DRAGGING" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}
function getDimension$1(descriptor, el, windowScroll) {
  if (windowScroll === void 0) {
    windowScroll = origin;
  }
  var computedStyles = window.getComputedStyle(el);
  var borderBox = el.getBoundingClientRect();
  var client = calculateBox(borderBox, computedStyles);
  var page = withScroll(client, windowScroll);
  var placeholder2 = {
    client,
    tagName: el.tagName.toLowerCase(),
    display: computedStyles.display
  };
  var displaceBy = {
    x: client.marginBox.width,
    y: client.marginBox.height
  };
  var dimension = {
    descriptor,
    placeholder: placeholder2,
    displaceBy,
    client,
    page
  };
  return dimension;
}
function useDraggablePublisher(args) {
  var uniqueId = useUniqueId("draggable");
  var descriptor = args.descriptor, registry = args.registry, getDraggableRef = args.getDraggableRef, canDragInteractiveElements = args.canDragInteractiveElements, shouldRespectForcePress = args.shouldRespectForcePress, isEnabled = args.isEnabled;
  var options = useMemo5(function() {
    return {
      canDragInteractiveElements,
      shouldRespectForcePress,
      isEnabled
    };
  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
  var getDimension2 = useCallback(function(windowScroll) {
    var el = getDraggableRef();
    !el ? true ? invariant2(false, "Cannot get dimension when no ref is set") : invariant2(false) : void 0;
    return getDimension$1(descriptor, el, windowScroll);
  }, [descriptor, getDraggableRef]);
  var entry = useMemo5(function() {
    return {
      uniqueId,
      descriptor,
      options,
      getDimension: getDimension2
    };
  }, [descriptor, getDimension2, options, uniqueId]);
  var publishedRef = (0, import_react23.useRef)(entry);
  var isFirstPublishRef = (0, import_react23.useRef)(true);
  useIsomorphicLayoutEffect2(function() {
    registry.draggable.register(publishedRef.current);
    return function() {
      return registry.draggable.unregister(publishedRef.current);
    };
  }, [registry.draggable]);
  useIsomorphicLayoutEffect2(function() {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }
    var last = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last);
  }, [entry, registry.draggable]);
}
function useValidation$1(props, contextId, getRef) {
  useDevSetupWarning(function() {
    function prefix3(id2) {
      return "Draggable[id: " + id2 + "]: ";
    }
    var id = props.draggableId;
    !id ? true ? invariant2(false, "Draggable requires a draggableId") : invariant2(false) : void 0;
    !(typeof id === "string") ? true ? invariant2(false, "Draggable requires a [string] draggableId.\n      Provided: [type: " + typeof id + "] (value: " + id + ")") : invariant2(false) : void 0;
    !isInteger2(props.index) ? true ? invariant2(false, prefix3(id) + " requires an integer index prop") : invariant2(false) : void 0;
    if (props.mapped.type === "DRAGGING") {
      return;
    }
    checkIsValidInnerRef(getRef());
    if (props.isEnabled) {
      !findDragHandle(contextId, id) ? true ? invariant2(false, prefix3(id) + " Unable to find drag handle") : invariant2(false) : void 0;
    }
  });
}
function useClonePropValidation(isClone) {
  useDev(function() {
    var initialRef = (0, import_react23.useRef)(isClone);
    useDevSetupWarning(function() {
      !(isClone === initialRef.current) ? true ? invariant2(false, "Draggable isClone prop value changed during component life") : invariant2(false) : void 0;
    }, [isClone]);
  });
}
function preventHtml5Dnd(event) {
  event.preventDefault();
}
function Draggable(props) {
  var ref2 = (0, import_react23.useRef)(null);
  var setRef = useCallback(function(el) {
    ref2.current = el;
  }, []);
  var getRef = useCallback(function() {
    return ref2.current;
  }, []);
  var _useRequiredContext = useRequiredContext(AppContext2), contextId = _useRequiredContext.contextId, dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId, registry = _useRequiredContext.registry;
  var _useRequiredContext2 = useRequiredContext(DroppableContext), type2 = _useRequiredContext2.type, droppableId = _useRequiredContext2.droppableId;
  var descriptor = useMemo5(function() {
    return {
      id: props.draggableId,
      index: props.index,
      type: type2,
      droppableId
    };
  }, [props.draggableId, props.index, type2, droppableId]);
  var children = props.children, draggableId = props.draggableId, isEnabled = props.isEnabled, shouldRespectForcePress = props.shouldRespectForcePress, canDragInteractiveElements = props.canDragInteractiveElements, isClone = props.isClone, mapped = props.mapped, dropAnimationFinishedAction = props.dropAnimationFinished;
  useValidation$1(props, contextId, getRef);
  useClonePropValidation(isClone);
  if (!isClone) {
    var forPublisher = useMemo5(function() {
      return {
        descriptor,
        registry,
        getDraggableRef: getRef,
        canDragInteractiveElements,
        shouldRespectForcePress,
        isEnabled
      };
    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
    useDraggablePublisher(forPublisher);
  }
  var dragHandleProps = useMemo5(function() {
    return isEnabled ? {
      tabIndex: 0,
      role: "button",
      "aria-describedby": dragHandleUsageInstructionsId,
      "data-rbd-drag-handle-draggable-id": draggableId,
      "data-rbd-drag-handle-context-id": contextId,
      draggable: false,
      onDragStart: preventHtml5Dnd
    } : null;
  }, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
  var onMoveEnd = useCallback(function(event) {
    if (mapped.type !== "DRAGGING") {
      return;
    }
    if (!mapped.dropping) {
      return;
    }
    if (event.propertyName !== "transform") {
      return;
    }
    dropAnimationFinishedAction();
  }, [dropAnimationFinishedAction, mapped]);
  var provided = useMemo5(function() {
    var style3 = getStyle$1(mapped);
    var onTransitionEnd = mapped.type === "DRAGGING" && mapped.dropping ? onMoveEnd : null;
    var result = {
      innerRef: setRef,
      draggableProps: {
        "data-rbd-draggable-context-id": contextId,
        "data-rbd-draggable-id": draggableId,
        style: style3,
        onTransitionEnd
      },
      dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);
  var rubric = useMemo5(function() {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return children(provided, mapped.snapshot, rubric);
}
var isStrictEqual = function(a, b) {
  return a === b;
};
var whatIsDraggedOverFromResult = function(result) {
  var combine2 = result.combine, destination = result.destination;
  if (destination) {
    return destination.droppableId;
  }
  if (combine2) {
    return combine2.droppableId;
  }
  return null;
};
var getCombineWithFromResult = function getCombineWithFromResult2(result) {
  return result.combine ? result.combine.draggableId : null;
};
var getCombineWithFromImpact = function getCombineWithFromImpact2(impact) {
  return impact.at && impact.at.type === "COMBINE" ? impact.at.combine.draggableId : null;
};
function getDraggableSelector() {
  var memoizedOffset = memoize_one_esm_default(function(x, y) {
    return {
      x,
      y
    };
  });
  var getMemoizedSnapshot = memoize_one_esm_default(function(mode, isClone, draggingOver, combineWith, dropping) {
    return {
      isDragging: true,
      isClone,
      isDropAnimating: Boolean(dropping),
      dropAnimation: dropping,
      mode,
      draggingOver,
      combineWith,
      combineTargetFor: null
    };
  });
  var getMemoizedProps = memoize_one_esm_default(function(offset4, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
    return {
      mapped: {
        type: "DRAGGING",
        dropping: null,
        draggingOver,
        combineWith,
        mode,
        offset: offset4,
        dimension,
        forceShouldAnimate,
        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
      }
    };
  });
  var selector = function selector2(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }
      var offset4 = state.current.client.offset;
      var dimension = state.dimensions.draggables[ownProps.draggableId];
      var draggingOver = whatIsDraggedOver(state.impact);
      var combineWith = getCombineWithFromImpact(state.impact);
      var forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset4.x, offset4.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }
      var isClone = ownProps.isClone;
      var _dimension = state.dimensions.draggables[ownProps.draggableId];
      var result = completed.result;
      var mode = result.mode;
      var _draggingOver = whatIsDraggedOverFromResult(result);
      var _combineWith = getCombineWithFromResult(result);
      var duration2 = state.dropDuration;
      var dropping = {
        duration: duration2,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: _combineWith ? combine.opacity.drop : null,
        scale: _combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: state.newHomeClientOffset,
          dimension: _dimension,
          dropping,
          draggingOver: _draggingOver,
          combineWith: _combineWith,
          mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)
        }
      };
    }
    return null;
  };
  return selector;
}
function getSecondarySnapshot(combineTargetFor) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor,
    combineWith: null
  };
}
var atRest = {
  mapped: {
    type: "SECONDARY",
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};
function getSecondarySelector() {
  var memoizedOffset = memoize_one_esm_default(function(x, y) {
    return {
      x,
      y
    };
  });
  var getMemoizedSnapshot = memoize_one_esm_default(getSecondarySnapshot);
  var getMemoizedProps = memoize_one_esm_default(function(offset4, combineTargetFor, shouldAnimateDisplacement) {
    if (combineTargetFor === void 0) {
      combineTargetFor = null;
    }
    return {
      mapped: {
        type: "SECONDARY",
        offset: offset4,
        combineTargetFor,
        shouldAnimateDisplacement,
        snapshot: getMemoizedSnapshot(combineTargetFor)
      }
    };
  });
  var getFallback = function getFallback2(combineTargetFor) {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };
  var getProps = function getProps2(ownId, draggingId, impact, afterCritical) {
    var visualDisplacement = impact.displaced.visible[ownId];
    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    var combine2 = tryGetCombine(impact);
    var combineTargetFor = combine2 && combine2.draggableId === ownId ? draggingId : null;
    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }
      if (impact.displaced.invisible[ownId]) {
        return null;
      }
      var change = negate(afterCritical.displacedBy.point);
      var _offset = memoizedOffset(change.x, change.y);
      return getMemoizedProps(_offset, combineTargetFor, true);
    }
    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }
    var displaceBy = impact.displacedBy.point;
    var offset4 = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset4, combineTargetFor, visualDisplacement.shouldAnimate);
  };
  var selector = function selector2(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }
    return null;
  };
  return selector;
}
var makeMapStateToProps = function makeMapStateToProps2() {
  var draggingSelector = getDraggableSelector();
  var secondarySelector = getSecondarySelector();
  var selector = function selector2(state, ownProps) {
    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  };
  return selector;
};
var mapDispatchToProps = {
  dropAnimationFinished
};
var ConnectedDraggable = connect_default(makeMapStateToProps, mapDispatchToProps, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Draggable);
function PrivateDraggable(props) {
  var droppableContext = useRequiredContext(DroppableContext);
  var isUsingCloneFor = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }
  return import_react23.default.createElement(ConnectedDraggable, props);
}
function PublicDraggable(props) {
  var isEnabled = typeof props.isDragDisabled === "boolean" ? !props.isDragDisabled : true;
  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
  return import_react23.default.createElement(PrivateDraggable, _extends({}, props, {
    isClone: false,
    isEnabled,
    canDragInteractiveElements,
    shouldRespectForcePress
  }));
}
function Droppable(props) {
  var appContext = (0, import_react23.useContext)(AppContext2);
  !appContext ? true ? invariant2(false, "Could not find app context") : invariant2(false) : void 0;
  var contextId = appContext.contextId, isMovementAllowed2 = appContext.isMovementAllowed;
  var droppableRef = (0, import_react23.useRef)(null);
  var placeholderRef = (0, import_react23.useRef)(null);
  var children = props.children, droppableId = props.droppableId, type2 = props.type, mode = props.mode, direction = props.direction, ignoreContainerClipping = props.ignoreContainerClipping, isDropDisabled = props.isDropDisabled, isCombineEnabled = props.isCombineEnabled, snapshot = props.snapshot, useClone = props.useClone, updateViewportMaxScroll3 = props.updateViewportMaxScroll, getContainerForClone = props.getContainerForClone;
  var getDroppableRef = useCallback(function() {
    return droppableRef.current;
  }, []);
  var setDroppableRef = useCallback(function(value) {
    droppableRef.current = value;
  }, []);
  var getPlaceholderRef = useCallback(function() {
    return placeholderRef.current;
  }, []);
  var setPlaceholderRef = useCallback(function(value) {
    placeholderRef.current = value;
  }, []);
  useValidation({
    props,
    getDroppableRef,
    getPlaceholderRef
  });
  var onPlaceholderTransitionEnd = useCallback(function() {
    if (isMovementAllowed2()) {
      updateViewportMaxScroll3({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed2, updateViewportMaxScroll3]);
  useDroppablePublisher({
    droppableId,
    type: type2,
    mode,
    direction,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef
  });
  var placeholder2 = import_react23.default.createElement(AnimateInOut, {
    on: props.placeholder,
    shouldAnimate: props.shouldAnimatePlaceholder
  }, function(_ref2) {
    var onClose = _ref2.onClose, data = _ref2.data, animate = _ref2.animate;
    return import_react23.default.createElement(Placeholder$1, {
      placeholder: data,
      onClose,
      innerRef: setPlaceholderRef,
      animate,
      contextId,
      onTransitionEnd: onPlaceholderTransitionEnd
    });
  });
  var provided = useMemo5(function() {
    return {
      innerRef: setDroppableRef,
      placeholder: placeholder2,
      droppableProps: {
        "data-rbd-droppable-id": droppableId,
        "data-rbd-droppable-context-id": contextId
      }
    };
  }, [contextId, droppableId, placeholder2, setDroppableRef]);
  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  var droppableContext = useMemo5(function() {
    return {
      droppableId,
      type: type2,
      isUsingCloneFor
    };
  }, [droppableId, isUsingCloneFor, type2]);
  function getClone() {
    if (!useClone) {
      return null;
    }
    var dragging = useClone.dragging, render3 = useClone.render;
    var node2 = import_react23.default.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, function(draggableProvided, draggableSnapshot) {
      return render3(draggableProvided, draggableSnapshot, dragging);
    });
    return import_react_dom2.default.createPortal(node2, getContainerForClone());
  }
  return import_react23.default.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
}
var isMatchingType = function isMatchingType2(type2, critical) {
  return type2 === critical.droppable.type;
};
var getDraggable = function getDraggable2(critical, dimensions) {
  return dimensions.draggables[critical.draggable.id];
};
var makeMapStateToProps$1 = function makeMapStateToProps3() {
  var idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };
  var idleWithoutAnimation = _extends({}, idleWithAnimation, {
    shouldAnimatePlaceholder: false
  });
  var getDraggableRubric = memoize_one_esm_default(function(descriptor) {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  });
  var getMapProps = memoize_one_esm_default(function(id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {
    var draggableId = dragging.descriptor.id;
    var isHome = dragging.descriptor.droppableId === id;
    if (isHome) {
      var useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      var _snapshot = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: _snapshot,
        useClone
      };
    }
    if (!isEnabled) {
      return idleWithoutAnimation;
    }
    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }
    var snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot,
      useClone: null
    };
  });
  var selector = function selector2(state, ownProps) {
    var id = ownProps.droppableId;
    var type2 = ownProps.type;
    var isEnabled = !ownProps.isDropDisabled;
    var renderClone = ownProps.renderClone;
    if (state.isDragging) {
      var critical = state.critical;
      if (!isMatchingType(type2, critical)) {
        return idleWithoutAnimation;
      }
      var dragging = getDraggable(critical, state.dimensions);
      var isDraggingOver = whatIsDraggedOver(state.impact) === id;
      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (!isMatchingType(type2, completed.critical)) {
        return idleWithoutAnimation;
      }
      var _dragging = getDraggable(completed.critical, state.dimensions);
      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);
    }
    if (state.phase === "IDLE" && state.completed && !state.shouldFlush) {
      var _completed = state.completed;
      if (!isMatchingType(type2, _completed.critical)) {
        return idleWithoutAnimation;
      }
      var wasOver = whatIsDraggedOver(_completed.impact) === id;
      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === "COMBINE");
      var isHome = _completed.critical.droppable.id === id;
      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }
      if (isHome) {
        return idleWithAnimation;
      }
      return idleWithoutAnimation;
    }
    return idleWithoutAnimation;
  };
  return selector;
};
var mapDispatchToProps$1 = {
  updateViewportMaxScroll
};
function getBody() {
  !document.body ? true ? invariant2(false, "document.body is not ready") : invariant2(false) : void 0;
  return document.body;
}
var defaultProps = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
var ConnectedDroppable = connect_default(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Droppable);
ConnectedDroppable.defaultProps = defaultProps;

// src/components/analyser/SceneAnalyserComponent.tsx
var React78 = __toESM(require_react());
function SceneAnalyserComponent({ element: element4 }) {
  var _a, _b, _c, _d, _e;
  const { t: t2 } = useTranslation();
  const sceneAnalyser = ServiceFactory.createSceneAnalyserService();
  const analysis = sceneAnalyser.analyseSession(element4);
  if (analysis === void 0)
    return null;
  const getLineColor = (value) => {
    if (value >= -100 && value <= -50 || value >= 50 && value <= 100)
      return "bg-[--text-error]";
    if (value >= -49 && value <= -25 || value >= 25 && value <= 49)
      return "bg-[--text-warning]";
    return "bg-[--text-success]";
  };
  const getTextColor = (value) => {
    if (value < 50)
      return "text-[--text-error]";
    if (value < 75)
      return "text-[--text-warning]";
    return "text-[--text-success]";
  };
  const LineIndicator = ({ value }) => /* @__PURE__ */ React78.createElement("div", {
    className: "w-full flex bg-opacity-100 items-center h-[2px] bg-[--background-modifier-border] relative"
  }, /* @__PURE__ */ React78.createElement("div", {
    className: `h-[2px] ${getLineColor(value)} transition-width duration-300 absolute left-1/2`,
    style: {
      width: `${Math.abs(value) / 2}%`,
      transform: value < 0 ? `translateX(-100%)` : `translateX(0)`
    }
  }));
  function getContext(value) {
    if (value > 50)
      return "positiveerror";
    if (value > 25)
      return "positivewarnign";
    if (value < -50)
      return "negativeerror";
    if (value < -25)
      return "negativewarning";
    return void 0;
  }
  function secondsToHHMM(duration2) {
    const minutesDuration = Math.floor(duration2 / 60);
    const hours = Math.floor(minutesDuration / 60);
    const minutes = minutesDuration % 60;
    return `${String(hours)}h ${String(minutes).padStart(2, "0")}'`;
  }
  return /* @__PURE__ */ React78.createElement("div", {
    className: "w-full mt-3"
  }, /* @__PURE__ */ React78.createElement("h2", null, t2("analyser.sceneanalyser")), /* @__PURE__ */ React78.createElement("div", {
    className: `text-center w-full mb-3 !font-extralight text-5xl ${getTextColor(analysis.score)}`
  }, ((_a = analysis.score) == null ? void 0 : _a.toString()) + "%"), /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-3 mb-2 text-center"
  }, t2("analyser.expectedduration"), ": ", /* @__PURE__ */ React78.createElement("span", {
    className: "font-bold"
  }, secondsToHHMM(analysis.expectedDuration))), /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-3 mb-2 text-center"
  }, t2("analyser.activity"), ": ", ((_b = analysis.activity) == null ? void 0 : _b.toString()) + "%"), /* @__PURE__ */ React78.createElement(LineIndicator, {
    value: analysis.activity
  }), getContext(analysis.activity) !== void 0 && /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-0 mb-2 text-center text-xs"
  }, t2("analyser.saactivity", { context: getContext(analysis.activity) })), /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-3 mb-2 text-center"
  }, t2("analyser.excitement"), ": ", ((_c = analysis.excitement) == null ? void 0 : _c.toString()) + "%"), /* @__PURE__ */ React78.createElement(LineIndicator, {
    value: analysis.excitement
  }), getContext(analysis.excitement) && /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-0 mb-2 text-center text-xs"
  }, t2("sanalyser.aexcitement", { context: getContext(analysis.excitement) })), /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-3 mb-2 text-center"
  }, t2("analyser.interest"), ": ", ((_d = analysis.interest) == null ? void 0 : _d.toString()) + "%"), /* @__PURE__ */ React78.createElement(LineIndicator, {
    value: analysis.interest
  }), getContext(analysis.interest) && /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-0 mb-2 text-center text-xs"
  }, t2("analyser.sainterest", { context: getContext(analysis.interest) })), /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-3 mb-2 text-center"
  }, t2("analyser.variety"), ": ", ((_e = analysis.variety) == null ? void 0 : _e.toString()) + "%"), /* @__PURE__ */ React78.createElement(LineIndicator, {
    value: analysis.variety
  }), getContext(analysis.variety) && /* @__PURE__ */ React78.createElement("div", {
    className: "w-full !mt-0 mb-2 text-center text-xs"
  }, t2("savariety", { context: getContext(analysis.variety) })));
}

// src/components/hierarchies/ChildDefaultComponent.tsx
var React79 = __toESM(require_react());
function ChildDefaultComponent({
  element: element4,
  isInPopover
}) {
  const api2 = useApi();
  const app = useApp();
  function saveAttribute(attributeName, value) {
    if (attributeName === "name") {
      const lastIndexOfName = element4.path.lastIndexOf(element4.name);
      const newPath = element4.path.substring(0, lastIndexOfName) + value + ".md";
      return app.vault.rename(element4.file, newPath);
    }
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    return codeblockService.updateCodeblockData(attributeName, value);
  }
  return /* @__PURE__ */ React79.createElement("div", {
    className: "flex items-center w-full hover:bg-[--background-primary-alt] border-b border-b-[--background-modifier-border] text-sm group"
  }, !isInPopover && /* @__PURE__ */ React79.createElement("div", {
    className: "col-span-1 max-w-[12px] w-[12px] mr-1 pt-1 items-center invisible group-hover:visible"
  }, /* @__PURE__ */ React79.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "none",
    className: ""
  }, /* @__PURE__ */ React79.createElement("path", {
    d: "M8.5 7C9.60457 7 10.5 6.10457 10.5 5C10.5 3.89543 9.60457 3 8.5 3C7.39543 3 6.5 3.89543 6.5 5C6.5 6.10457 7.39543 7 8.5 7Z",
    fill: "#666666"
  }), /* @__PURE__ */ React79.createElement("path", {
    d: "M15.5 7C16.6046 7 17.5 6.10457 17.5 5C17.5 3.89543 16.6046 3 15.5 3C14.3954 3 13.5 3.89543 13.5 5C13.5 6.10457 14.3954 7 15.5 7Z",
    fill: "#666666"
  }), /* @__PURE__ */ React79.createElement("path", {
    d: "M10.5 12C10.5 13.1046 9.60457 14 8.5 14C7.39543 14 6.5 13.1046 6.5 12C6.5 10.8954 7.39543 10 8.5 10C9.60457 10 10.5 10.8954 10.5 12Z",
    fill: "#666666"
  }), /* @__PURE__ */ React79.createElement("path", {
    d: "M15.5 14C16.6046 14 17.5 13.1046 17.5 12C17.5 10.8954 16.6046 10 15.5 10C14.3954 10 13.5 10.8954 13.5 12C13.5 13.1046 14.3954 14 15.5 14Z",
    fill: "#666666"
  }), /* @__PURE__ */ React79.createElement("path", {
    d: "M10.5 19C10.5 20.1046 9.60457 21 8.5 21C7.39543 21 6.5 20.1046 6.5 19C6.5 17.8954 7.39543 17 8.5 17C9.60457 17 10.5 17.8954 10.5 19Z",
    fill: "#666666"
  }), /* @__PURE__ */ React79.createElement("path", {
    d: "M15.5 21C16.6046 21 17.5 20.1046 17.5 19C17.5 17.8954 16.6046 17 15.5 17C14.3954 17 13.5 17.8954 13.5 19C13.5 20.1046 14.3954 21 15.5 21Z",
    fill: "#666666"
  }))), /* @__PURE__ */ React79.createElement("div", {
    className: "col-span-1 max-w-[20px] w-[20px] align-middle items-center"
  }, /* @__PURE__ */ React79.createElement("a", {
    href: element4.file.name,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, element4.positionInParent)), isInPopover ? /* @__PURE__ */ React79.createElement("div", {
    className: "flex w-full items-center"
  }, /* @__PURE__ */ React79.createElement("div", null, /* @__PURE__ */ React79.createElement("a", {
    href: element4.file.name,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, element4.name))) : /* @__PURE__ */ React79.createElement("div", {
    className: "grid grid-cols-10 w-full pt-1 pb-1 items-center"
  }, /* @__PURE__ */ React79.createElement("div", {
    className: "col-span-2 pr-1"
  }, /* @__PURE__ */ React79.createElement("input", {
    type: "text",
    onBlur: (e2) => {
      saveAttribute("name" /* Name */, e2.target.value);
    },
    className: "w-full !border !border-transparent group-hover:!border-[--background-modifier-border] h-5 focus:!border-[--background-modifier-border] focus:!shadow-none",
    defaultValue: element4.name
  }))));
}

// src/components/hierarchies/ChildDefaultHeadersComponent.tsx
var React80 = __toESM(require_react());
function ChildDefaultHeadersComponent({ isInPopover }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React80.createElement("div", {
    className: "flex w-full border-b border-b-[--background-modifier-border] pb-1 mb-1"
  }, /* @__PURE__ */ React80.createElement("div", {
    className: "flex"
  }, !isInPopover && /* @__PURE__ */ React80.createElement("div", {
    className: "col-span-1 max-w-[12px] w-[12px] mr-1"
  }), /* @__PURE__ */ React80.createElement("div", {
    className: "col-span-1 max-w-[20px] w-[20px] font-bold"
  }, "#")), /* @__PURE__ */ React80.createElement("div", {
    className: "grid grid-cols-1 gap-2 w-full"
  }, /* @__PURE__ */ React80.createElement("div", {
    className: "font-bold"
  }, t2("name"))));
}

// src/components/hierarchies/ChildSceneComponent.tsx
var React81 = __toESM(require_react());
function ChildSceneComponent({
  element: element4,
  isInPopover
}) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [showTooltip, setShowTooltip] = React81.useState(false);
  const [isEditing, setIsEditing] = React81.useState(false);
  function saveAttribute(attributeName, value) {
    if (attributeName === "name") {
      const lastIndexOfName = element4.path.lastIndexOf(element4.name);
      const newPath = element4.path.substring(0, lastIndexOfName) + value + ".md";
      return app.vault.rename(element4.file, newPath);
    }
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    return codeblockService.updateCodeblockData(attributeName, value);
  }
  let duration2 = void 0;
  if (showTooltip) {
    const sceneAnalyser = new SceneAnalyserService(api2);
    duration2 = sceneAnalyser.getExpectedDuration(element4.campaign, (_a = element4.attribute("scenetype" /* SceneType */)) == null ? void 0 : _a.value);
  }
  function secondsToMMSS(duration3) {
    const minutes = Math.floor(duration3 / 60);
    const seconds = duration3 % 60;
    return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
  }
  return /* @__PURE__ */ React81.createElement("div", {
    className: "flex items-center w-full hover:bg-[--background-primary-alt] border-b border-b-[--background-modifier-border] text-sm group"
  }, /* @__PURE__ */ React81.createElement("div", {
    className: "flex"
  }, !isInPopover && /* @__PURE__ */ React81.createElement("div", {
    className: "col-span-1 max-w-[12px] w-[12px] mr-1 pt-1 items-center invisible group-hover:visible"
  }, /* @__PURE__ */ React81.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "none",
    className: ""
  }, /* @__PURE__ */ React81.createElement("path", {
    d: "M8.5 7C9.60457 7 10.5 6.10457 10.5 5C10.5 3.89543 9.60457 3 8.5 3C7.39543 3 6.5 3.89543 6.5 5C6.5 6.10457 7.39543 7 8.5 7Z",
    fill: "#666666"
  }), /* @__PURE__ */ React81.createElement("path", {
    d: "M15.5 7C16.6046 7 17.5 6.10457 17.5 5C17.5 3.89543 16.6046 3 15.5 3C14.3954 3 13.5 3.89543 13.5 5C13.5 6.10457 14.3954 7 15.5 7Z",
    fill: "#666666"
  }), /* @__PURE__ */ React81.createElement("path", {
    d: "M10.5 12C10.5 13.1046 9.60457 14 8.5 14C7.39543 14 6.5 13.1046 6.5 12C6.5 10.8954 7.39543 10 8.5 10C9.60457 10 10.5 10.8954 10.5 12Z",
    fill: "#666666"
  }), /* @__PURE__ */ React81.createElement("path", {
    d: "M15.5 14C16.6046 14 17.5 13.1046 17.5 12C17.5 10.8954 16.6046 10 15.5 10C14.3954 10 13.5 10.8954 13.5 12C13.5 13.1046 14.3954 14 15.5 14Z",
    fill: "#666666"
  }), /* @__PURE__ */ React81.createElement("path", {
    d: "M10.5 19C10.5 20.1046 9.60457 21 8.5 21C7.39543 21 6.5 20.1046 6.5 19C6.5 17.8954 7.39543 17 8.5 17C9.60457 17 10.5 17.8954 10.5 19Z",
    fill: "#666666"
  }), /* @__PURE__ */ React81.createElement("path", {
    d: "M15.5 21C16.6046 21 17.5 20.1046 17.5 19C17.5 17.8954 16.6046 17 15.5 17C14.3954 17 13.5 17.8954 13.5 19C13.5 20.1046 14.3954 21 15.5 21Z",
    fill: "#666666"
  }))), /* @__PURE__ */ React81.createElement("div", {
    className: "col-span-1 max-w-[20px] w-[20px] align-middle items-center"
  }, /* @__PURE__ */ React81.createElement("a", {
    href: element4.file.name,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, element4.positionInParent))), isInPopover ? /* @__PURE__ */ React81.createElement("div", {
    className: "flex w-full items-center"
  }, /* @__PURE__ */ React81.createElement("div", null, /* @__PURE__ */ React81.createElement("a", {
    href: element4.file.name,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, element4.name))) : /* @__PURE__ */ React81.createElement("div", {
    className: "grid grid-cols-12 w-full pt-1 pb-1 items-start"
  }, /* @__PURE__ */ React81.createElement("div", {
    className: "col-span-2 pr-1"
  }, /* @__PURE__ */ React81.createElement("input", {
    type: "text",
    onBlur: (e2) => {
      saveAttribute("name" /* Name */, e2.target.value);
    },
    className: "w-full !border !border-transparent group-hover:!border-[--background-modifier-border] h-5 focus:!border-[--background-modifier-border] focus:!shadow-none",
    defaultValue: element4.name
  })), /* @__PURE__ */ React81.createElement("div", {
    className: "pr-1"
  }, /* @__PURE__ */ React81.createElement("select", {
    defaultValue: (_b = element4.attribute("storycirclestage" /* StoryCircleStage */)) == null ? void 0 : _b.value,
    onChange: (e2) => saveAttribute("storycirclestage" /* StoryCircleStage */, e2.target.value),
    className: "selectBorder w-full \n								!border !border-transparent group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border]\n								h-7 pl-1 \n								focus:!shadow-none !shadow-none\n								bg-transparent group-hover:bg-[--background-modifier-form-field]\n								"
  }, /* @__PURE__ */ React81.createElement("option", {
    value: ""
  }), Object.entries(StoryCircleStage).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => /* @__PURE__ */ React81.createElement("option", {
    key,
    value: index2
  }, key)))), /* @__PURE__ */ React81.createElement("div", {
    className: "col-span-5 pr-1"
  }, isEditing ? /* @__PURE__ */ React81.createElement(MarkdownEditorComponent, {
    initialValue: (_d = (_c = element4.attribute("description" /* Description */)) == null ? void 0 : _c.value) != null ? _d : "",
    campaignPath: element4.campaignPath,
    className: "!p-1 m-0 border rounded-md border-transparent group-hover:!border-solid group-hover:!border-[--background-modifier-border] bg-transparent group-hover:bg-[--background-modifier-form-field]",
    onBlur: (value) => {
      saveAttribute("description" /* Description */, value);
    },
    forceFocus: true
  }) : /* @__PURE__ */ React81.createElement("div", {
    className: "cursor-pointer",
    onClick: () => setIsEditing(true)
  }, /* @__PURE__ */ React81.createElement(MarkdownComponent, {
    className: "min-h-[30px] w-full border rounded-md border-transparent group-hover:!border-solid group-hover:!border-[--background-modifier-border] bg-transparent group-hover:bg-[--background-modifier-form-field]",
    value: (_f = (_e = element4.attribute("description" /* Description */)) == null ? void 0 : _e.value) != null ? _f : ""
  }))), /* @__PURE__ */ React81.createElement("div", {
    className: "col-span-2 pr-1"
  }, /* @__PURE__ */ React81.createElement("select", {
    defaultValue: (_g = element4.attribute("scenetype" /* SceneType */)) == null ? void 0 : _g.value,
    onChange: (e2) => saveAttribute("scenetype" /* SceneType */, e2.target.value),
    className: "selectBorder w-full \n								!border !border-transparent group-hover:!border-[--background-modifier-border] focus:!border-[--background-modifier-border]\n								h-7 pl-1 \n								focus:!shadow-none !shadow-none\n								bg-transparent group-hover:bg-[--background-modifier-form-field]\n								"
  }, /* @__PURE__ */ React81.createElement("option", {
    value: ""
  }), Object.entries(SceneType).filter(([key]) => isNaN(Number(key))).map(([key, index2]) => {
    const isActive = isSceneActive(SceneType[key]);
    return /* @__PURE__ */ React81.createElement("option", {
      key,
      value: index2
    }, key + " " + (isActive ? t2("attributes.active") : ""));
  }))), /* @__PURE__ */ React81.createElement("div", {
    className: "flex justify-center"
  }, /* @__PURE__ */ React81.createElement("div", null, /* @__PURE__ */ React81.createElement("input", {
    type: "checkbox",
    className: "",
    defaultChecked: ((_h = element4.attribute("externalactions" /* ExternalActions */)) == null ? void 0 : _h.value) === true,
    onChange: (e2) => saveAttribute("externalactions" /* ExternalActions */, e2.target.checked)
  }))), /* @__PURE__ */ React81.createElement("div", {
    className: "relative flex justify-center opacity-0 group-hover:opacity-100 cursor-help !text-[--text-muted] hover:!text-[text-normal]",
    onMouseEnter: () => setShowTooltip(true),
    onMouseLeave: () => setShowTooltip(false)
  }, /* @__PURE__ */ React81.createElement("span", {
    className: " "
  }, "?"), showTooltip && /* @__PURE__ */ React81.createElement("div", {
    className: "absolute z-10 w-64 p-2 mt-2 text-xs bg-[--background-secondary] rounded shadow-lg",
    style: { top: "-40px", left: "50%", transform: "translateX(-50%)" }
  }, t2("analyser.expectedduration"), ": ", secondsToMMSS(duration2)))));
}

// src/components/hierarchies/ChildSceneHeadersComponent.tsx
var React82 = __toESM(require_react());
function ChildSceneHeadersComponent({ isInPopover }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React82.createElement("div", {
    className: "flex w-full border-b border-b-[--background-modifier-border] pb-1  text-sm"
  }, /* @__PURE__ */ React82.createElement("div", {
    className: "flex"
  }, !isInPopover && /* @__PURE__ */ React82.createElement("div", {
    className: "col-span-1 max-w-[12px] w-[12px] mr-1"
  }), /* @__PURE__ */ React82.createElement("div", {
    className: "col-span-1 max-w-[20px] w-[20px] font-bold"
  }, "#")), isInPopover ? /* @__PURE__ */ React82.createElement("div", {
    className: "w-full"
  }, /* @__PURE__ */ React82.createElement("div", {
    className: "font-bold"
  }, t2("name"))) : /* @__PURE__ */ React82.createElement("div", {
    className: "grid grid-cols-12 gap-2 w-full"
  }, /* @__PURE__ */ React82.createElement("div", {
    className: "font-bold col-span-2"
  }, t2("name")), /* @__PURE__ */ React82.createElement("div", {
    className: "font-bold"
  }, t2("attributes.stage")), /* @__PURE__ */ React82.createElement("div", {
    className: "font-bold col-span-5"
  }, t2("attributes.description")), /* @__PURE__ */ React82.createElement("div", {
    className: "font-bold col-span-2"
  }, t2("attributes.scenetype")), /* @__PURE__ */ React82.createElement("div", {
    className: "font-bold"
  }, t2("attributes.externalactions")), /* @__PURE__ */ React82.createElement("div", null)));
}

// src/components/hierarchies/ChildSessionComponent.tsx
var React83 = __toESM(require_react());
var import_react_flatpickr2 = __toESM(require_build());
function ChildSessionComponent({
  element: element4,
  isInPopover
}) {
  const api2 = useApi();
  const date2 = element4.attribute("sessiondate" /* SessionDate */);
  const app = useApp();
  function saveAttribute(attributeName, value) {
    if (attributeName === "name") {
      const lastIndexOfName = element4.path.lastIndexOf(element4.name);
      const newPath = element4.path.substring(0, lastIndexOfName) + value + ".md";
      return app.vault.rename(element4.file, newPath);
    }
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    return codeblockService.updateCodeblockData(attributeName, value);
  }
  return /* @__PURE__ */ React83.createElement("div", {
    className: "flex items-center w-full hover:bg-[--background-primary-alt] border-b border-b-[--background-modifier-border] text-sm group"
  }, /* @__PURE__ */ React83.createElement("div", {
    className: "flex"
  }, !isInPopover && /* @__PURE__ */ React83.createElement("div", {
    className: "col-span-1 max-w-[12px] w-[12px] mr-1 pt-1 items-center invisible group-hover:visible"
  }, /* @__PURE__ */ React83.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "none",
    className: ""
  }, /* @__PURE__ */ React83.createElement("path", {
    d: "M8.5 7C9.60457 7 10.5 6.10457 10.5 5C10.5 3.89543 9.60457 3 8.5 3C7.39543 3 6.5 3.89543 6.5 5C6.5 6.10457 7.39543 7 8.5 7Z",
    fill: "#666666"
  }), /* @__PURE__ */ React83.createElement("path", {
    d: "M15.5 7C16.6046 7 17.5 6.10457 17.5 5C17.5 3.89543 16.6046 3 15.5 3C14.3954 3 13.5 3.89543 13.5 5C13.5 6.10457 14.3954 7 15.5 7Z",
    fill: "#666666"
  }), /* @__PURE__ */ React83.createElement("path", {
    d: "M10.5 12C10.5 13.1046 9.60457 14 8.5 14C7.39543 14 6.5 13.1046 6.5 12C6.5 10.8954 7.39543 10 8.5 10C9.60457 10 10.5 10.8954 10.5 12Z",
    fill: "#666666"
  }), /* @__PURE__ */ React83.createElement("path", {
    d: "M15.5 14C16.6046 14 17.5 13.1046 17.5 12C17.5 10.8954 16.6046 10 15.5 10C14.3954 10 13.5 10.8954 13.5 12C13.5 13.1046 14.3954 14 15.5 14Z",
    fill: "#666666"
  }), /* @__PURE__ */ React83.createElement("path", {
    d: "M10.5 19C10.5 20.1046 9.60457 21 8.5 21C7.39543 21 6.5 20.1046 6.5 19C6.5 17.8954 7.39543 17 8.5 17C9.60457 17 10.5 17.8954 10.5 19Z",
    fill: "#666666"
  }), /* @__PURE__ */ React83.createElement("path", {
    d: "M15.5 21C16.6046 21 17.5 20.1046 17.5 19C17.5 17.8954 16.6046 17 15.5 17C14.3954 17 13.5 17.8954 13.5 19C13.5 20.1046 14.3954 21 15.5 21Z",
    fill: "#666666"
  }))), /* @__PURE__ */ React83.createElement("div", {
    className: "col-span-1 max-w-[20px] w-[20px] align-middle items-center"
  }, /* @__PURE__ */ React83.createElement("a", {
    href: element4.file.name,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, element4.positionInParent))), isInPopover ? /* @__PURE__ */ React83.createElement("div", {
    className: "flex w-full items-center"
  }, /* @__PURE__ */ React83.createElement("div", null, /* @__PURE__ */ React83.createElement("a", {
    href: element4.file.name,
    className: "internal-link !no-underline cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover]"
  }, element4.name))) : /* @__PURE__ */ React83.createElement("div", {
    className: "grid grid-cols-5 w-full pt-1 pb-1 items-center"
  }, /* @__PURE__ */ React83.createElement("div", {
    className: "col-span-4 pr-1"
  }, /* @__PURE__ */ React83.createElement("input", {
    type: "text",
    onBlur: (e2) => {
      saveAttribute("name" /* Name */, e2.target.value);
    },
    className: "w-full !border !border-transparent group-hover:!border-[--background-modifier-border] h-5 focus:!border-[--background-modifier-border] focus:!shadow-none",
    defaultValue: element4.name
  })), /* @__PURE__ */ React83.createElement("div", {
    className: "pr-1"
  }, /* @__PURE__ */ React83.createElement(import_react_flatpickr2.default, {
    value: date2.value,
    className: "w-full !border !border-transparent group-hover:!border-[--background-modifier-border] h-5 focus:!border-[--background-modifier-border] focus:!shadow-none",
    options: { dateFormat: "Y-m-d", altInput: true, altFormat: "D, M j, Y" },
    onChange: (selectedDates, currentDate) => {
      saveAttribute("sessiondate" /* SessionDate */, currentDate);
    }
  }))));
}

// src/components/hierarchies/ChildSessionHeadersComponent.tsx
var React84 = __toESM(require_react());
function ChildSessionHeadersComponent({ isInPopover }) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React84.createElement("div", {
    className: "flex w-full border-b border-b-[--background-modifier-border] pb-1 mb-1"
  }, /* @__PURE__ */ React84.createElement("div", {
    className: "flex"
  }, !isInPopover && /* @__PURE__ */ React84.createElement("div", {
    className: "col-span-1 max-w-[12px] w-[12px] mr-1"
  }), /* @__PURE__ */ React84.createElement("div", {
    className: "col-span-1 max-w-[20px] w-[20px] font-bold"
  }, "#")), isInPopover ? /* @__PURE__ */ React84.createElement("div", {
    className: "w-full"
  }, /* @__PURE__ */ React84.createElement("div", {
    className: "font-bold"
  }, t2("name"))) : /* @__PURE__ */ React84.createElement("div", {
    className: "grid grid-cols-5 gap-2 w-full"
  }, /* @__PURE__ */ React84.createElement("div", {
    className: "font-bold col-span-4"
  }, t2("name")), /* @__PURE__ */ React84.createElement("div", {
    className: "font-bold"
  }, t2("attributes.sessiondate"))));
}

// src/components/hierarchies/NewChildComponent.tsx
var React85 = __toESM(require_react());

// src/services/FileCreationService.ts
var import_obsidian4 = require("obsidian");
var path3 = require("path");
var FileCreationService = class {
  constructor(_app, _api, _type, _name, system, _campaignPath, _parentPath, positionInParent, attributes3, relationships, _template) {
    this._app = _app;
    this._api = _api;
    this._type = _type;
    this._name = _name;
    this._campaignPath = _campaignPath;
    this._parentPath = _parentPath;
    this._template = _template;
    __publicField(this, "_rpgManagerCodeBlock");
    __publicField(this, "_codeblock");
    __publicField(this, "_campaign");
    var _a;
    const id = {
      type: this._type
    };
    if (system !== void 0 && system !== 0 /* Agnostic */)
      id.system = 0 /* Agnostic */;
    if (this._campaignPath !== void 0)
      id.campaign = this._campaignPath;
    if (this._parentPath !== void 0)
      id.parent = this._parentPath;
    if (positionInParent !== void 0)
      id.positionInParent = positionInParent;
    if (this._campaignPath !== void 0) {
      this._campaign = this._api.get(this._campaignPath);
      if (this._campaign !== void 0)
        system = (_a = this._campaign.system) != null ? _a : 0 /* Agnostic */;
    }
    this._codeblock = {
      id
    };
    if (attributes3 !== void 0) {
      this._codeblock.data = {};
      attributes3.forEach((attribute) => {
        if (attribute.value)
          this._codeblock.data[attribute.name] = attribute.value;
      });
    }
    if (relationships !== void 0) {
      this._codeblock.relationships = [];
      relationships.forEach((relationship) => {
        this._codeblock.relationships.push({
          type: relationship.type,
          path: relationship.path
        });
      });
    }
    this._codeblock.tasks = [
      {
        id: v4_default(),
        priority: 1,
        name: instance.t("tasks.complete", { context: this._type }),
        description: instance.t("tasks.complete", { context: this._type }) + " " + this._name,
        type: "creation" /* Creation */,
        status: "proposed" /* Proposed */
      }
    ];
    const yamlService = new YamlService();
    this._rpgManagerCodeBlock = "\n```RpgManager4\n";
    this._rpgManagerCodeBlock += yamlService.stringify(this._codeblock);
    this._rpgManagerCodeBlock += "```\n";
  }
  create(open) {
    return __async(this, null, function* () {
      let content3 = this._rpgManagerCodeBlock;
      if (this._template !== void 0) {
        const templateFile = this._app.vault.getAbstractFileByPath(this._template);
        const templateContent = yield this._app.vault.read(templateFile);
        content3 = templateContent.replace("```RpgManager4```", content3).replace("```RpgManager4\n```", content3);
      }
      const fileName = yield this._generateFilePath();
      const newFile = yield this._app.vault.create(fileName, content3);
      const currentLeaf = this._app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      const leaf = this._app.workspace.getLeaf(currentLeaf != null);
      if (open === true)
        yield leaf.openFile(newFile);
      else
        leaf.detach();
      return newFile;
    });
  }
  createInCurrentFile(file) {
    return __async(this, null, function* () {
      const codeblockService = new RpgManagerCodeblockService(this._app, this._api, file);
      return codeblockService.addCodeBlock(this._codeblock);
    });
  }
  _generateFilePath() {
    return __async(this, null, function* () {
      let pathSeparator;
      try {
        pathSeparator = path3.sep;
      } catch (e2) {
        pathSeparator = "/";
      }
      let response = this._api.settings.automaticMove ? "Campaigns" : "";
      if (this._type === "campaign" /* Campaign */) {
        response += pathSeparator + this._name;
        this._createFolder(response);
        return response + pathSeparator + this._name + ".md";
      } else if (this._campaignPath !== void 0 && this._api.settings.automaticMove === false) {
        const campaign = this._api.get(this._campaignPath);
        return campaign.file.parent.path + pathSeparator + this._name + ".md";
      } else if (this._campaignPath === void 0) {
        response = "Assets";
      } else {
        response += pathSeparator + this._campaign.name;
      }
      const parent = this._parentPath !== void 0 ? this._api.get(this._parentPath) : void 0;
      switch (this._type) {
        case "adventure" /* Adventure */:
          response += pathSeparator + "01. Adventures" + pathSeparator + this._name;
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "chapter" /* Chapter */:
          response += pathSeparator + "01. Adventures" + pathSeparator + parent.name + pathSeparator + "Chapters";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "session" /* Session */:
          response += pathSeparator + "02. Sessions" + pathSeparator + this._name;
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "scene" /* Scene */:
          response += pathSeparator + "02. Sessions" + pathSeparator + parent.name + pathSeparator + "Scenes";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "nonplayercharacter" /* NonPlayerCharacter */:
          response += pathSeparator + "03. Non Player Characters";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "event" /* Event */:
          response += pathSeparator + "04. Events";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "location" /* Location */:
          response += pathSeparator + "05. Locations";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "faction" /* Faction */:
          response += pathSeparator + "06. Factions";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "clue" /* Clue */:
          response += pathSeparator + "07. Clues";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "playercharacter" /* PlayerCharacter */:
          response += pathSeparator + "08. Player Characters";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "subplot" /* Subplot */:
          response += pathSeparator + "09. Subplots";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "object" /* Object */:
          response += pathSeparator + "10. Objects";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
        case "monster" /* Monster */:
          response += pathSeparator + "11. Monsters";
          this._createFolder(response);
          response += pathSeparator + this._name + ".md";
          break;
      }
      return response;
    });
  }
  _createFolder(fileName) {
    return __async(this, null, function* () {
      const fileOrFolder = this._app.vault.getAbstractFileByPath(fileName);
      if (fileOrFolder == null) {
        try {
          yield this._app.vault.createFolder(fileName);
        } catch (e2) {
        }
      }
    });
  }
};

// src/components/hierarchies/NewChildComponent.tsx
function NewChildComponent({
  parent,
  type: type2,
  handleFileAdded
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [fileName, setFileName] = React85.useState("");
  const inputRef = React85.useRef(null);
  React85.useEffect(() => {
    var _a;
    (_a = inputRef.current) == null ? void 0 : _a.focus();
  }, []);
  function handleKeyDown(event) {
    if (event.key === "Enter") {
      handleCreateNewChild();
    }
  }
  function handleCreateNewChild() {
    return __async(this, null, function* () {
      if (fileName === "")
        return;
      const children = api2.get(void 0, parent.campaign, type2, parent);
      const positionInParent = children.length === 0 ? 1 : Math.max(...children.map((element4) => element4.positionInParent)) + 1;
      const fileCreator = new FileCreationService(app, api2, type2, fileName, parent.type === "campaign" /* Campaign */ ? parent.system : parent.campaign.system, parent.type === "campaign" /* Campaign */ ? parent.path : parent.campaign.path, parent.path, positionInParent);
      fileCreator.create(false).then(() => {
        handleFileAdded();
      });
    });
  }
  return /* @__PURE__ */ React85.createElement("div", {
    className: "flex w-full border-b border-b-[--background-modifier-border] pb-1 mb-1 pt-1"
  }, /* @__PURE__ */ React85.createElement("div", {
    className: "flex"
  }, /* @__PURE__ */ React85.createElement("div", {
    className: "col-span-1 max-w-[36px] w-[36px]"
  }), /* @__PURE__ */ React85.createElement("div", {
    className: "pr-1"
  }, /* @__PURE__ */ React85.createElement("input", {
    ref: inputRef,
    onKeyDown: handleKeyDown,
    type: "text",
    onChange: (e2) => setFileName(e2.target.value),
    className: "w-full !border !border-[--background-modifier-border] h-5 focus:!border-[--background-modifier-border] focus:!shadow-none",
    defaultValue: fileName,
    onBlur: handleCreateNewChild
  }))), /* @__PURE__ */ React85.createElement("div", {
    className: "flex justify-end w-full text-sm"
  }, /* @__PURE__ */ React85.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 mr-3",
    onClick: handleFileAdded
  }, t2("buttons.cancel")), /* @__PURE__ */ React85.createElement("button", {
    className: "rpgm-primary pl-3 pr-3",
    onClick: handleCreateNewChild
  }, t2("create.add", { context: type2 }))));
}

// src/components/hierarchies/HierarchyComponent.tsx
function HierarchyComponent({
  element: element4,
  type: type2,
  isInPopover,
  isDraggable
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [newChild, setNewChild] = React86.useState(false);
  const children = api2.get(void 0, type2 === "campaign" /* Campaign */ ? element4 : element4.campaign, type2, element4);
  children.sort((a, b) => a.positionInParent - b.positionInParent);
  function handleOnDragEnd(result) {
    if (!result.destination)
      return;
    const reorderedChildren = Array.from(children);
    const [reorderedItem] = reorderedChildren.splice(result.source.index, 1);
    reorderedChildren.splice(result.destination.index, 0, reorderedItem);
    reorderedChildren.map((element5, index2) => {
      const codeblockService = new RpgManagerCodeblockService(app, api2, element5.file);
      codeblockService.updateCodeblockId("positionInParent", index2 + 1);
    });
  }
  function getChildComponent(child) {
    switch (child.type) {
      case "session" /* Session */:
        return /* @__PURE__ */ React86.createElement(ChildSessionComponent, {
          key: child.path,
          element: child,
          isInPopover
        });
      case "scene" /* Scene */:
        return /* @__PURE__ */ React86.createElement(ChildSceneComponent, {
          key: child.path,
          element: child,
          isInPopover
        });
      default:
        return /* @__PURE__ */ React86.createElement(ChildDefaultComponent, {
          key: child.path,
          element: child,
          isInPopover
        });
    }
  }
  function getHeaderComponent() {
    switch (type2) {
      case "session" /* Session */:
        return /* @__PURE__ */ React86.createElement(ChildSessionHeadersComponent, {
          isInPopover
        });
      case "scene" /* Scene */:
        return /* @__PURE__ */ React86.createElement(ChildSceneHeadersComponent, {
          isInPopover
        });
      default:
        return /* @__PURE__ */ React86.createElement(ChildDefaultHeadersComponent, {
          isInPopover
        });
    }
  }
  function handleCreate() {
    setNewChild(true);
  }
  function handleFileAdded() {
    setNewChild(false);
  }
  if (!isDraggable) {
    return /* @__PURE__ */ React86.createElement("div", {
      className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
    }, /* @__PURE__ */ React86.createElement("h2", null, t2("elements." + type2, { count: 2 })), /* @__PURE__ */ React86.createElement(React86.Fragment, null, getHeaderComponent(), children.map((child, index2) => getChildComponent(child)), newChild && !isInPopover && /* @__PURE__ */ React86.createElement(NewChildComponent, {
      key: Date.now(),
      parent: element4,
      type: type2,
      handleFileAdded
    }), !isInPopover && !newChild && /* @__PURE__ */ React86.createElement("div", {
      className: "flex justify-end w-full text-sm mt-3"
    }, /* @__PURE__ */ React86.createElement("button", {
      className: "rpgm-secondary pl-3 pr-3",
      onClick: () => handleCreate()
    }, t2("create.new", { context: type2 }))), !isInPopover && type2 === "scene" /* Scene */ && /* @__PURE__ */ React86.createElement(SceneAnalyserComponent, {
      element: element4
    })));
  }
  return /* @__PURE__ */ React86.createElement("div", {
    key: element4.path + "draggable",
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React86.createElement("h2", null, t2("elements." + type2, { count: 2 })), /* @__PURE__ */ React86.createElement(React86.Fragment, null, getHeaderComponent(), /* @__PURE__ */ React86.createElement(DragDropContext, {
    onDragEnd: handleOnDragEnd
  }, /* @__PURE__ */ React86.createElement(ConnectedDroppable, {
    droppableId: element4.path + "list",
    renderClone: (provided, snapshot, rubric) => /* @__PURE__ */ React86.createElement("div", __spreadProps(__spreadValues(__spreadValues({
      ref: provided.innerRef
    }, provided.draggableProps), provided.dragHandleProps), {
      style: provided.draggableProps.style
    }), getChildComponent(children[rubric.source.index]))
  }, (provided) => /* @__PURE__ */ React86.createElement("div", __spreadProps(__spreadValues({}, provided.droppableProps), {
    ref: provided.innerRef
  }), children.map((child, index2) => /* @__PURE__ */ React86.createElement(PublicDraggable, {
    key: child.path,
    draggableId: child.path,
    index: index2
  }, (provided2, snapshot) => {
    return /* @__PURE__ */ React86.createElement("div", __spreadProps(__spreadValues(__spreadValues({
      ref: provided2.innerRef
    }, provided2.draggableProps), provided2.dragHandleProps), {
      style: __spreadProps(__spreadValues({}, provided2.draggableProps.style), {
        zIndex: snapshot.isDragging ? 9999 : "auto"
      })
    }), getChildComponent(child));
  })), provided.placeholder))), newChild && !isInPopover && /* @__PURE__ */ React86.createElement(NewChildComponent, {
    key: Date.now(),
    parent: element4,
    type: type2,
    handleFileAdded
  }), !isInPopover && !newChild && /* @__PURE__ */ React86.createElement("div", {
    className: "flex justify-end w-full text-sm mt-3"
  }, /* @__PURE__ */ React86.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3",
    onClick: () => handleCreate()
  }, t2("create.new", { context: type2 }))), !isInPopover && type2 === "scene" /* Scene */ && api2.settings.useSceneAnalyser && /* @__PURE__ */ React86.createElement(SceneAnalyserComponent, {
    element: element4
  })));
}

// src/components/elements/SessionComponent.tsx
function SessionComponent({
  element: element4,
  isInPopover
}) {
  const storyCircle = element4.attribute("StoryCircle" /* StoryCircle */);
  const kishotenketsu2 = element4.attribute("kishotenketsu" /* Kishotenketsu */);
  const conflict2 = element4.attribute("conflict" /* Conflict */);
  return /* @__PURE__ */ React87.createElement(React87.Fragment, null, /* @__PURE__ */ React87.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React87.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.images.length > 0 && /* @__PURE__ */ React87.createElement("div", {
    className: "max-h-32 h-32 overflow-hidden"
  }, /* @__PURE__ */ React87.createElement(ImageComponent, {
    element: element4,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React87.createElement("div", {
    className: `grid grid-cols-1 sm:grid-cols-1 lg:grid-cols-5 gap-3 !mb-3}`
  }, /* @__PURE__ */ React87.createElement("div", {
    className: `col-span-5 sm:col-span-1 lg:col-span-5`
  }, /* @__PURE__ */ React87.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 !mb-3"
  }, /* @__PURE__ */ React87.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  }), /* @__PURE__ */ React87.createElement(ParentAttributeComponent, {
    element: element4,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React87.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), conflict2 && conflict2.isSet && /* @__PURE__ */ React87.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React87.createElement(ConflictComponent, {
    element: element4,
    attribute: conflict2,
    isEditable: !isInPopover
  })), kishotenketsu2 && kishotenketsu2.isSet && /* @__PURE__ */ React87.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React87.createElement(KishotenketsuComponent, {
    element: element4,
    attribute: kishotenketsu2,
    isEditable: !isInPopover
  })), storyCircle && storyCircle.isSet && /* @__PURE__ */ React87.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React87.createElement(StoryCircleAttributeComponent, {
    element: element4,
    attribute: storyCircle,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React87.createElement(HierarchyComponent, {
    key: element4.path + !isInPopover,
    element: element4,
    isInPopover,
    type: "scene" /* Scene */,
    isDraggable: !isInPopover
  }), element4.images.length > 1 && /* @__PURE__ */ React87.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React87.createElement(ImageCarouselComponent, {
    element: element4
  })), !isInPopover && /* @__PURE__ */ React87.createElement(TasksContainerComponent, {
    element: element4
  }), isInPopover === false && element4.relationships.length > 0 && /* @__PURE__ */ React87.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 m-3"
  }, /* @__PURE__ */ React87.createElement(RelationshipsComponent, {
    element: element4
  }))));
}

// src/components/elements/SubplotComponent.tsx
var React88 = __toESM(require_react());
function SubplotComponent({
  element: element4,
  isInPopover
}) {
  const storyCircle = element4.attribute("StoryCircle" /* StoryCircle */);
  return /* @__PURE__ */ React88.createElement(React88.Fragment, null, /* @__PURE__ */ React88.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React88.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.images.length > 0 && /* @__PURE__ */ React88.createElement("div", {
    className: "max-h-32 h-32 overflow-hidden"
  }, /* @__PURE__ */ React88.createElement(ImageComponent, {
    element: element4,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React88.createElement("div", {
    className: `grid grid-cols-1 sm:grid-cols-1 lg:grid-cols-5 gap-3 !mb-3}`
  }, /* @__PURE__ */ React88.createElement("div", {
    className: `col-span-5 sm:col-span-1 lg:col-span-5`
  }, /* @__PURE__ */ React88.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 !mb-3"
  }, /* @__PURE__ */ React88.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  })), /* @__PURE__ */ React88.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), storyCircle && storyCircle.isSet && /* @__PURE__ */ React88.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React88.createElement(StoryCircleAttributeComponent, {
    element: element4,
    attribute: storyCircle,
    isEditable: !isInPopover
  })), element4.images.length > 1 && /* @__PURE__ */ React88.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React88.createElement(ImageCarouselComponent, {
    element: element4
  })), !isInPopover && /* @__PURE__ */ React88.createElement(TasksContainerComponent, {
    element: element4
  }), isInPopover === false && element4.relationships.length > 0 && /* @__PURE__ */ React88.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React88.createElement(RelationshipsComponent, {
    element: element4
  }))));
}

// src/components/elements/AdventureComponent.tsx
var React89 = __toESM(require_react());
function AdventureComponent({
  element: element4,
  isInPopover
}) {
  const storyCircle = element4.attribute("StoryCircle" /* StoryCircle */);
  const kishotenketsu2 = element4.attribute("kishotenketsu" /* Kishotenketsu */);
  const conflict2 = element4.attribute("conflict" /* Conflict */);
  return /* @__PURE__ */ React89.createElement(React89.Fragment, null, /* @__PURE__ */ React89.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React89.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.images.length > 0 && /* @__PURE__ */ React89.createElement(BannerComponent, {
    image: element4.images[0]
  }), /* @__PURE__ */ React89.createElement("div", {
    className: `grid grid-cols-1 sm:grid-cols-1 lg:grid-cols-5 gap-3 !mb-3}`
  }, /* @__PURE__ */ React89.createElement("div", {
    className: `${isInPopover ? "col-span-5 sm:col-span-1 lg:col-span-5" : "col-span-5 sm:col-span-1 lg:col-span-5"}`
  }, /* @__PURE__ */ React89.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 !mb-3"
  }, /* @__PURE__ */ React89.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  })), /* @__PURE__ */ React89.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), element4.images.length > 1 && /* @__PURE__ */ React89.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React89.createElement(ImageCarouselComponent, {
    element: element4
  })), conflict2 && conflict2.isSet && /* @__PURE__ */ React89.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React89.createElement(ConflictComponent, {
    element: element4,
    attribute: conflict2,
    isEditable: !isInPopover
  })), kishotenketsu2 && kishotenketsu2.isSet && /* @__PURE__ */ React89.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React89.createElement(KishotenketsuComponent, {
    element: element4,
    attribute: kishotenketsu2,
    isEditable: !isInPopover
  })), storyCircle && storyCircle.isSet && /* @__PURE__ */ React89.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React89.createElement(StoryCircleAttributeComponent, {
    element: element4,
    attribute: storyCircle,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React89.createElement(HierarchyComponent, {
    key: element4.path + !isInPopover,
    element: element4,
    isInPopover,
    type: "chapter" /* Chapter */,
    isDraggable: !isInPopover
  }), !isInPopover && /* @__PURE__ */ React89.createElement(TasksContainerComponent, {
    element: element4
  }), isInPopover === false && element4.relationships.length > 0 && /* @__PURE__ */ React89.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React89.createElement(RelationshipsComponent, {
    element: element4
  }))));
}

// src/components/elements/CampaignComponent.tsx
var React90 = __toESM(require_react());
function CampaignComponent({
  element: element4,
  isInPopover
}) {
  const storyCircle = element4.attribute("StoryCircle" /* StoryCircle */);
  return /* @__PURE__ */ React90.createElement(React90.Fragment, null, /* @__PURE__ */ React90.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React90.createElement(HeaderComponent, {
    element: element4,
    isInPopover
  }), element4.images.length > 0 && /* @__PURE__ */ React90.createElement(BannerComponent, {
    image: element4.images[0]
  }), /* @__PURE__ */ React90.createElement("div", {
    className: `grid grid-cols-1 sm:grid-cols-1 lg:grid-cols-5 gap-3 !mb-3}`
  }, /* @__PURE__ */ React90.createElement("div", {
    className: `col-span-5`
  }, /* @__PURE__ */ React90.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 !mb-3"
  }, /* @__PURE__ */ React90.createElement(DescriptionAttributeComponent, {
    element: element4,
    attribute: element4.attribute("description" /* Description */),
    isEditable: !isInPopover
  })), /* @__PURE__ */ React90.createElement(AttributeListComponent, {
    element: element4,
    isEditable: !isInPopover
  }))), storyCircle && storyCircle.isSet && /* @__PURE__ */ React90.createElement("div", {
    className: "col-span-1 sm:col-span-1 lg:col-span-6"
  }, /* @__PURE__ */ React90.createElement(StoryCircleAttributeComponent, {
    element: element4,
    attribute: storyCircle,
    isEditable: !isInPopover
  })), /* @__PURE__ */ React90.createElement(HierarchyComponent, {
    key: element4.path + "adventure" /* Adventure */ + !isInPopover,
    element: element4,
    isInPopover,
    type: "adventure" /* Adventure */,
    isDraggable: !isInPopover
  }), /* @__PURE__ */ React90.createElement(HierarchyComponent, {
    key: element4.path + "session" /* Session */ + !isInPopover,
    element: element4,
    isInPopover,
    type: "session" /* Session */,
    isDraggable: !isInPopover
  }), element4.images.length > 1 && /* @__PURE__ */ React90.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3"
  }, /* @__PURE__ */ React90.createElement(ImageCarouselComponent, {
    element: element4
  })), !isInPopover && /* @__PURE__ */ React90.createElement(TasksContainerComponent, {
    element: element4
  })));
}

// src/components/elements/NonPlayerCharacterComponent.tsx
var React91 = __toESM(require_react());
function NonPlayerCharacterComponent({
  element: element4,
  isInPopover
}) {
  return /* @__PURE__ */ React91.createElement(React91.Fragment, null, /* @__PURE__ */ React91.createElement("div", {
    className: "space-y-3 p-3 bg-[--background-primary-alt] border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React91.createElement(MainV1Component, {
    element: element4,
    isInPopover
  })));
}

// src/components/system/agnostic/index.ts
var agnosticComponents = /* @__PURE__ */ new Map([
  ["campaign" /* Campaign */, CampaignComponent],
  ["adventure" /* Adventure */, AdventureComponent],
  ["chapter" /* Chapter */, ChapterComponent],
  ["session" /* Session */, SessionComponent],
  ["scene" /* Scene */, SceneComponent],
  ["nonplayercharacter" /* NonPlayerCharacter */, NonPlayerCharacterComponent],
  ["event" /* Event */, EventComponent],
  ["location" /* Location */, LocationComponent],
  ["faction" /* Faction */, FactionComponent],
  ["clue" /* Clue */, ClueComponent],
  ["playercharacter" /* PlayerCharacter */, PlayerCharacterComponent],
  ["subplot" /* Subplot */, SubplotComponent],
  ["object" /* Object */, ObjectComponent],
  ["monster" /* Monster */, MonsterComponent]
]);

// src/controllers/Controller.ts
var Controller = class extends import_obsidian5.MarkdownRenderChild {
  constructor(_app, _api, _path, container, source) {
    super(container);
    this._app = _app;
    this._api = _api;
    this._path = _path;
    __publicField(this, "_components", /* @__PURE__ */ new Map([
      [0 /* Agnostic */, agnosticComponents]
    ]));
    __publicField(this, "_root");
    __publicField(this, "_source", {});
    __publicField(this, "_element");
    this._source = (0, import_obsidian5.parseYaml)(source);
    this._root = (0, import_client2.createRoot)(this.containerEl);
    this.registerEvent(this._app.workspace.on("rpgmanager:refresh-views", this._render.bind(this)));
  }
  _render() {
    var _a;
    if (this._element === void 0)
      this._element = this._api.get(this._path);
    if (!this._element || this._root === void 0)
      return;
    this._path = this._element.path;
    const component = (_a = this._components.get(this._element.system)) == null ? void 0 : _a.get(this._element.type);
    if (!component)
      return;
    let isInPopover = false;
    setTimeout(() => {
      let currentElement = this.containerEl;
      while (currentElement) {
        if (currentElement.classList.contains("popover")) {
          isInPopover = true;
          break;
        }
        currentElement = currentElement.parentElement;
      }
      const elementComponent = (0, import_react24.createElement)(component, {
        element: this._element,
        isInPopover,
        key: this._element.version.toString()
      });
      const reactComponent = (0, import_react24.createElement)(AppContext.Provider, { value: this._app }, (0, import_react24.createElement)(ApiContext.Provider, { value: this._api }, elementComponent));
      this._root.render(reactComponent);
    }, 0);
  }
  onload() {
    super.onload();
    this._render();
  }
};

// src/controllers/ModalCreationController.ts
var import_obsidian6 = require("obsidian");
var import_react26 = __toESM(require_react());
var import_client3 = __toESM(require_client());

// src/components/creation/CreationComponent.tsx
var React122 = __toESM(require_react());

// src/contexts/WizardContext.tsx
var React93 = __toESM(require_react());
var WizardContext = React93.createContext(void 0);

// src/hooks/useWizard.ts
var import_react25 = __toESM(require_react());
var useWizard = () => {
  return import_react25.default.useContext(WizardContext);
};

// src/components/wizards/chapters/ChapterWizardComponent.tsx
var React100 = __toESM(require_react());

// src/components/wizards/WizardNavigatorComponent.tsx
var React95 = __toESM(require_react());
function WizardNavigatorComponent({
  steps,
  step,
  setStep
}) {
  return /* @__PURE__ */ React95.createElement(React95.Fragment, null, /* @__PURE__ */ React95.createElement("ul", {
    className: "!p-0 !m-0 !mt-3 !mb-3"
  }, steps.map((stepComponent, index2) => {
    return /* @__PURE__ */ React95.createElement("li", {
      key: index2,
      className: `${stepComponent.errors !== void 0 && stepComponent.errors.length > 0 ? "text-[--text-error]" : step > index2 ? "text-[--text-normal]" : "text-[--text-muted]"} hover:text-[--text-accent] cursor-pointer`,
      onClick: () => {
        setStep(index2 + 1);
      }
    }, stepComponent.name);
  })));
}

// src/components/wizards/chapters/steps/ChapterWizardCluesComponent.tsx
var React96 = __toESM(require_react());
function ChapterWizardCluesComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay,
  errors
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const wizardData = useWizard();
  const [chapterClues, setChapterClues] = React96.useState(wizardData.clues.length > 0 ? wizardData.clues : [{ id: v4_default(), cluePath: "" }]);
  const handleInputChange = (index2, field, value, isExistingClue) => {
    var _a, _b;
    const updatedClues = [...chapterClues];
    if (field === "cluePath" || field === "clueName" || field === "description")
      updatedClues[index2][field] = value;
    if (isExistingClue !== void 0) {
      updatedClues[index2].isExistingClue = isExistingClue;
      if (isExistingClue === true) {
        updatedClues[index2].clueName = (_b = (_a = api2.get(updatedClues[index2].cluePath)) == null ? void 0 : _a.name) != null ? _b : "";
      } else {
        updatedClues[index2].cluePath = void 0;
      }
    }
    const isClueEmpty = (clue) => !clue.clueName && !clue.description;
    if (index2 === chapterClues.length - 1) {
      updatedClues.push({ id: v4_default(), clueName: "" });
    }
    const cleanedClues = updatedClues.filter((clue, idx) => idx === updatedClues.length - 1 || !isClueEmpty(clue));
    setChapterClues(cleanedClues);
    wizardData.clues = cleanedClues;
  };
  const removeExisting = (index2) => {
    const updatedClues = [...chapterClues];
    updatedClues[index2].clueName = void 0;
    handleInputChange(index2, "cluePath", "", false);
  };
  const setExistingClue = (cluePath, params) => {
    cluePath = HelperService.extractPath(cluePath);
    handleInputChange(params.index, "cluePath", cluePath, true);
  };
  const selectExistingClue = (clueIndex) => {
    new NewRelationshipController(app, api2, void 0, campaignPath, ["clue" /* Clue */], setExistingClue, {
      index: clueIndex
    }).open();
  };
  let error2 = void 0;
  if (errors !== void 0 && errors.length > 0) {
    error2 = t2("wizards.errors");
    errors.forEach((singleError) => error2 += "\n- " + singleError);
  }
  return /* @__PURE__ */ React96.createElement(React96.Fragment, null, /* @__PURE__ */ React96.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("elements.clue", { count: 2 })), error2 && /* @__PURE__ */ React96.createElement("div", {
    className: "!mt-3 !mb-3 text-[--text-error]"
  }, /* @__PURE__ */ React96.createElement(MarkdownComponent, {
    value: error2
  })), /* @__PURE__ */ React96.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ React96.createElement("div", {
    className: "grid grid-cols-2 space-x-4"
  }, /* @__PURE__ */ React96.createElement("div", {
    className: "w-full font-bold"
  }, t2("elements.clue", { count: 1 })), /* @__PURE__ */ React96.createElement("div", {
    className: "w-full font-bold"
  }, t2("wizards.chapter.cluesdescription"))), chapterClues.map((clue, index2) => {
    var _a;
    return /* @__PURE__ */ React96.createElement("div", {
      key: clue.id,
      className: `grid grid-cols-2 p-3 min-h-[4rem] ${index2 % 2 === 0 ? "bg-[--background-primary-alt]" : "bg-[--background-primary]"}`
    }, /* @__PURE__ */ React96.createElement("div", {
      className: `w-full relative group ${clue.isExistingClue && "col-span-2"}`
    }, clue.isExistingClue ? /* @__PURE__ */ React96.createElement(React96.Fragment, null, /* @__PURE__ */ React96.createElement("div", null, (_a = clue.clueName) != null ? _a : ""), /* @__PURE__ */ React96.createElement("span", {
      className: "text-xs cursor-pointer bottom-0 opacity-0 group-hover:opacity-100 hover:text-[--text-accent-hover]",
      onClick: () => removeExisting(index2)
    }, t2("wizards.chapter.removeexistingclue"))) : /* @__PURE__ */ React96.createElement(React96.Fragment, null, /* @__PURE__ */ React96.createElement("input", {
      key: clue.id,
      type: "text",
      className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md",
      value: clue.clueName || "",
      onChange: (e2) => handleInputChange(index2, "clueName", e2.target.value)
    }), /* @__PURE__ */ React96.createElement("span", {
      className: "text-xs cursor-pointer bottom-0 opacity-0 group-hover:opacity-100 hover:text-[--text-accent-hover]",
      onClick: () => selectExistingClue(index2)
    }, t2("wizards.chapter.selectexistingclue")))), !clue.isExistingClue && /* @__PURE__ */ React96.createElement("div", {
      className: "w-full ml-3"
    }, /* @__PURE__ */ React96.createElement(MarkdownEditorComponent, {
      campaignPath,
      initialValue: clue.description,
      onChange: (value) => handleInputChange(index2, "description", value),
      className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] active:border-[--background-modifier-border-hover] active:shadow-none rounded-md"
    })));
  })));
}

// src/components/wizards/chapters/steps/ChapterWizardDescriptionComponent.tsx
var React97 = __toESM(require_react());
function ChapterWizardDescriptionComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay,
  errors
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const updateDescription = (value) => {
    wizardData.description = value;
  };
  let error2 = void 0;
  if (errors !== void 0 && errors.length > 0) {
    error2 = t2("wizards.errors");
    errors.forEach((singleError) => error2 += "\n- " + singleError);
  }
  return /* @__PURE__ */ React97.createElement(React97.Fragment, null, /* @__PURE__ */ React97.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.description")), /* @__PURE__ */ React97.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React97.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.description", { context: "description", name })
  })), error2 && /* @__PURE__ */ React97.createElement("div", {
    className: "!mt-3 !mb-3 text-[--text-error]"
  }, /* @__PURE__ */ React97.createElement(MarkdownComponent, {
    value: error2
  })), /* @__PURE__ */ React97.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React97.createElement(MarkdownEditorComponent, {
    initialValue: wizardData.description,
    campaignPath,
    onChange: updateDescription,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })));
}

// src/components/wizards/chapters/steps/ChapterWizardDestinationComponent.tsx
var React98 = __toESM(require_react());
function DestinationTypeComponent({
  type: type2,
  destinationType,
  setDestinationType
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React98.createElement("div", {
    key: type2,
    className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
    onClick: () => setDestinationType(type2)
  }, /* @__PURE__ */ React98.createElement("div", {
    className: "flext min-w[50px] w-[50px] items-center justify-center"
  }, destinationType === type2 && /* @__PURE__ */ React98.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "30",
    height: "30",
    fill: "currentColor",
    viewBox: "0 0 16 16"
  }, /* @__PURE__ */ React98.createElement("path", {
    d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
  }))), /* @__PURE__ */ React98.createElement("div", null, /* @__PURE__ */ React98.createElement("h4", null, t2("elements." + type2, { count: 1 })), /* @__PURE__ */ React98.createElement("small", null, /* @__PURE__ */ React98.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.destinationtype", { context: type2 })
  }))));
}
function DestinationElementTypeComponent({
  isElement: isElement2,
  setIsExistingDestination
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React98.createElement(React98.Fragment, null, /* @__PURE__ */ React98.createElement("div", {
    key: 0,
    className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
    onClick: () => setIsExistingDestination(true)
  }, /* @__PURE__ */ React98.createElement("div", {
    className: "flext min-w[50px] w-[50px] items-center justify-center"
  }, isElement2 === true && /* @__PURE__ */ React98.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "30",
    height: "30",
    fill: "currentColor",
    viewBox: "0 0 16 16"
  }, /* @__PURE__ */ React98.createElement("path", {
    d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
  }))), /* @__PURE__ */ React98.createElement("div", null, /* @__PURE__ */ React98.createElement("h4", null, t2("wizards.chapter.destinationelementtype", { context: "existing" })), /* @__PURE__ */ React98.createElement("small", null, /* @__PURE__ */ React98.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.destinationelementtypedescription", { context: "existing" })
  })))), /* @__PURE__ */ React98.createElement("div", {
    key: 1,
    className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
    onClick: () => setIsExistingDestination(false)
  }, /* @__PURE__ */ React98.createElement("div", {
    className: "flext min-w[50px] w-[50px] items-center justify-center"
  }, isElement2 === false && /* @__PURE__ */ React98.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "30",
    height: "30",
    fill: "currentColor",
    viewBox: "0 0 16 16"
  }, /* @__PURE__ */ React98.createElement("path", {
    d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
  }))), /* @__PURE__ */ React98.createElement("div", null, /* @__PURE__ */ React98.createElement("h4", null, t2("wizards.chapter.destinationelementtype", { context: "new" })), /* @__PURE__ */ React98.createElement("small", null, /* @__PURE__ */ React98.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.destinationelementtypedescription", { context: "new" })
  })))));
}
function ChapterWizardDestinationComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay,
  errors
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const wizardData = useWizard();
  const [destinationType, setDestinationType] = React98.useState(wizardData.destinationType);
  const [destinationName, setDestinationName] = React98.useState((_a = wizardData.destinationName) != null ? _a : "");
  const [destinationElementPath, setDestinationElementPath] = React98.useState(wizardData.destinationElement);
  const [destinationElement, setDestinationElement] = React98.useState(wizardData.destinationElement ? api2.get(wizardData.destinationElement) : void 0);
  const [isExistingDestination, setIsExistingDestination] = React98.useState(wizardData.destinationElement !== void 0 ? true : wizardData.destinationName !== void 0 ? false : void 0);
  const onSetIsExistingDestination = (isExistingDestination2) => {
    setIsExistingDestination(isExistingDestination2);
    if (isExistingDestination2) {
      const selector = new NewRelationshipController(app, api2, void 0, campaignPath, [destinationType], onSetDestinationElement);
      selector.open();
    }
  };
  const onSetDestinationType = (destinationType2) => {
    setDestinationType(destinationType2);
    wizardData.destinationType = destinationType2;
    if (destinationElement !== void 0) {
      setDestinationElement(void 0);
      wizardData.destinationElement = void 0;
      setIsExistingDestination(void 0);
    }
  };
  const onSetDestinationName = (destinationName2) => {
    setDestinationName(destinationName2);
    setDestinationElement(void 0);
    setDestinationElementPath(void 0);
    wizardData.destinationName = destinationName2;
    wizardData.destinationElement = void 0;
  };
  const onSetDestinationElement = (path4) => {
    path4 = HelperService.extractPath(path4);
    const element4 = api2.get(path4);
    if (element4 !== void 0) {
      setDestinationElementPath(path4);
      setDestinationElement(element4);
      setDestinationName(void 0);
      wizardData.destinationElement = path4;
      wizardData.destinationName = void 0;
    }
  };
  let error2 = void 0;
  if (errors !== void 0 && errors.length > 0) {
    error2 = t2("wizards.errors");
    errors.forEach((singleError) => error2 += "\n- " + singleError);
  }
  return /* @__PURE__ */ React98.createElement(React98.Fragment, null, /* @__PURE__ */ React98.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.destinationtitle")), /* @__PURE__ */ React98.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React98.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.destination", { name })
  })), error2 && /* @__PURE__ */ React98.createElement("div", {
    className: "!mt-3 !mb-3 text-[--text-error]"
  }, /* @__PURE__ */ React98.createElement(MarkdownComponent, {
    value: error2
  })), /* @__PURE__ */ React98.createElement("div", {
    className: "grid grid-cols-2"
  }, /* @__PURE__ */ React98.createElement(DestinationTypeComponent, {
    key: "adventure" /* Adventure */,
    type: "adventure" /* Adventure */,
    destinationType,
    setDestinationType: onSetDestinationType
  }), /* @__PURE__ */ React98.createElement(DestinationTypeComponent, {
    key: "chapter" /* Chapter */,
    type: "chapter" /* Chapter */,
    destinationType,
    setDestinationType: onSetDestinationType
  })), destinationType !== void 0 && /* @__PURE__ */ React98.createElement(React98.Fragment, null, /* @__PURE__ */ React98.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.destinationelementtype")), /* @__PURE__ */ React98.createElement("div", {
    className: "grid grid-cols-2"
  }, /* @__PURE__ */ React98.createElement(DestinationElementTypeComponent, {
    isElement: isExistingDestination,
    setIsExistingDestination: onSetIsExistingDestination
  })), isExistingDestination === void 0 ? /* @__PURE__ */ React98.createElement(React98.Fragment, null) : isExistingDestination ? /* @__PURE__ */ React98.createElement(React98.Fragment, null, /* @__PURE__ */ React98.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.destinationelement", { context: "existing" })), /* @__PURE__ */ React98.createElement("div", {
    className: "ml-3"
  }, destinationElementPath && destinationElement && destinationElement.name)) : /* @__PURE__ */ React98.createElement(React98.Fragment, null, /* @__PURE__ */ React98.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.destinationelement", { context: "new" })), /* @__PURE__ */ React98.createElement("input", {
    type: "text",
    defaultValue: destinationName,
    onChange: (e2) => onSetDestinationName(e2.target.value),
    className: "ml-3"
  }))));
}

// src/components/wizards/chapters/steps/ChapterWizardTargetComponent.tsx
var React99 = __toESM(require_react());
function TargetTypeComponent({
  type: type2,
  targetType,
  setTargetType
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React99.createElement("div", {
    key: type2,
    className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
    onClick: () => setTargetType(type2)
  }, /* @__PURE__ */ React99.createElement("div", {
    className: "flext min-w[50px] w-[50px] items-center justify-center"
  }, targetType === type2 && /* @__PURE__ */ React99.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "30",
    height: "30",
    fill: "currentColor",
    viewBox: "0 0 16 16"
  }, /* @__PURE__ */ React99.createElement("path", {
    d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
  }))), /* @__PURE__ */ React99.createElement("div", null, /* @__PURE__ */ React99.createElement("h4", null, t2("elements." + type2, { count: 1 })), /* @__PURE__ */ React99.createElement("small", null, /* @__PURE__ */ React99.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.targettype", { context: type2 })
  }))));
}
function TargetElementTypeComponent({
  isElement: isElement2,
  setIsExistingTarget
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React99.createElement(React99.Fragment, null, /* @__PURE__ */ React99.createElement("div", {
    key: 0,
    className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
    onClick: () => setIsExistingTarget(true)
  }, /* @__PURE__ */ React99.createElement("div", {
    className: "flext min-w[50px] w-[50px] items-center justify-center"
  }, isElement2 === true && /* @__PURE__ */ React99.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "30",
    height: "30",
    fill: "currentColor",
    viewBox: "0 0 16 16"
  }, /* @__PURE__ */ React99.createElement("path", {
    d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
  }))), /* @__PURE__ */ React99.createElement("div", null, /* @__PURE__ */ React99.createElement("h4", null, t2("wizards.chapter.targetelementtype", { context: "existing" })), /* @__PURE__ */ React99.createElement("small", null, /* @__PURE__ */ React99.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.targetelementtypedescription", { context: "existing" })
  })))), /* @__PURE__ */ React99.createElement("div", {
    key: 1,
    className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
    onClick: () => setIsExistingTarget(false)
  }, /* @__PURE__ */ React99.createElement("div", {
    className: "flext min-w[50px] w-[50px] items-center justify-center"
  }, isElement2 === false && /* @__PURE__ */ React99.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "30",
    height: "30",
    fill: "currentColor",
    viewBox: "0 0 16 16"
  }, /* @__PURE__ */ React99.createElement("path", {
    d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
  }))), /* @__PURE__ */ React99.createElement("div", null, /* @__PURE__ */ React99.createElement("h4", null, t2("wizards.chapter.targetelementtype", { context: "new" })), /* @__PURE__ */ React99.createElement("small", null, /* @__PURE__ */ React99.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.targetelementtypedescription", { context: "new" })
  })))));
}
function ChapterWizardTargetComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay,
  errors
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const wizardData = useWizard();
  const [targetType, setTargetType] = React99.useState(wizardData.targetType);
  const [targetName, setTargetName] = React99.useState((_a = wizardData.targetName) != null ? _a : "");
  const [targetElementPath, setTargetElementPath] = React99.useState(wizardData.targetElement);
  const [targetElement, setTargetElement] = React99.useState(wizardData.targetElement ? api2.get(wizardData.targetElement) : void 0);
  const [isExistingTarget, setIsExistingTarget] = React99.useState(wizardData.targetElement !== void 0 ? true : wizardData.targetName !== void 0 ? false : void 0);
  const onSetIsExistingTarget = (isExistingTarget2) => {
    setIsExistingTarget(isExistingTarget2);
    if (isExistingTarget2) {
      const selector = new NewRelationshipController(app, api2, void 0, campaignPath, [targetType], onSetTargetElement);
      selector.open();
    }
  };
  const onSetTargetType = (targetType2) => {
    setTargetType(targetType2);
    wizardData.targetType = targetType2;
    if (targetElement !== void 0) {
      setTargetElement(void 0);
      wizardData.targetElement = void 0;
      setIsExistingTarget(void 0);
    }
  };
  const onSetTargetName = (targetName2) => {
    setTargetName(targetName2);
    setTargetElement(void 0);
    setTargetElementPath(void 0);
    wizardData.targetName = targetName2;
    wizardData.targetElement = void 0;
  };
  const updateDescription = (value) => {
    wizardData.targetDescription = value;
  };
  const onSetTargetElement = (path4) => {
    path4 = HelperService.extractPath(path4);
    const element4 = api2.get(path4);
    if (element4 !== void 0) {
      setTargetElementPath(path4);
      setTargetElement(element4);
      setTargetName(void 0);
      wizardData.targetElement = path4;
      wizardData.targetName = void 0;
    }
  };
  let error2 = void 0;
  if (errors !== void 0 && errors.length > 0) {
    error2 = t2("wizards.errors");
    errors.forEach((singleError) => error2 += "\n- " + singleError);
  }
  return /* @__PURE__ */ React99.createElement(React99.Fragment, null, /* @__PURE__ */ React99.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.targettitle")), /* @__PURE__ */ React99.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React99.createElement(MarkdownComponent, {
    value: t2("wizards.chapter.target", { name })
  })), error2 && /* @__PURE__ */ React99.createElement("div", {
    className: "!mt-3 !mb-3 text-[--text-error]"
  }, /* @__PURE__ */ React99.createElement(MarkdownComponent, {
    value: error2
  })), /* @__PURE__ */ React99.createElement("div", {
    className: "grid grid-cols-2"
  }, /* @__PURE__ */ React99.createElement(TargetTypeComponent, {
    key: "event" /* Event */,
    type: "event" /* Event */,
    targetType,
    setTargetType: onSetTargetType
  }), /* @__PURE__ */ React99.createElement(TargetTypeComponent, {
    key: "location" /* Location */,
    type: "location" /* Location */,
    targetType,
    setTargetType: onSetTargetType
  })), targetType !== void 0 && /* @__PURE__ */ React99.createElement(React99.Fragment, null, /* @__PURE__ */ React99.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.targetelementtype")), /* @__PURE__ */ React99.createElement("div", {
    className: "grid grid-cols-2"
  }, /* @__PURE__ */ React99.createElement(TargetElementTypeComponent, {
    isElement: isExistingTarget,
    setIsExistingTarget: onSetIsExistingTarget
  })), isExistingTarget === void 0 ? /* @__PURE__ */ React99.createElement(React99.Fragment, null) : isExistingTarget ? /* @__PURE__ */ React99.createElement(React99.Fragment, null, /* @__PURE__ */ React99.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.targetelement", { context: "existing" })), /* @__PURE__ */ React99.createElement("div", {
    className: "ml-3"
  }, targetElementPath && targetElement && targetElement.name)) : /* @__PURE__ */ React99.createElement(React99.Fragment, null, /* @__PURE__ */ React99.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.targetelement", { context: "new" })), /* @__PURE__ */ React99.createElement("input", {
    type: "text",
    defaultValue: targetName,
    onChange: (e2) => onSetTargetName(e2.target.value),
    className: "ml-3"
  }), /* @__PURE__ */ React99.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("wizards.chapter.targetelementdescription")), /* @__PURE__ */ React99.createElement("div", {
    className: "ml-3"
  }, /* @__PURE__ */ React99.createElement(MarkdownEditorComponent, {
    initialValue: wizardData.targetDescription,
    campaignPath,
    onChange: updateDescription,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })))));
}

// src/components/wizards/chapters/ChapterWizardComponent.tsx
var stepComponents = [
  { name: "Description", component: ChapterWizardDescriptionComponent },
  { name: "Destination", component: ChapterWizardDestinationComponent },
  { name: "Target", component: ChapterWizardTargetComponent },
  { name: "Clues", component: ChapterWizardCluesComponent }
];
function ChapterWizardComponent({
  element: element4,
  name,
  campaign,
  close,
  returnData
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const wizardData = useWizard();
  if (campaign === void 0 && element4 !== void 0)
    campaign = element4.campaign;
  const [validation, setValidation] = React100.useState(1e4);
  const [showOverlay, setShowOverlay] = React100.useState(false);
  const [step, setStep] = React100.useState(1);
  const [steps, setSteps] = React100.useState(stepComponents);
  if (Object.keys(wizardData).length === 0) {
    wizardData.description = (_a = element4 == null ? void 0 : element4.attribute("description" /* Description */)) == null ? void 0 : _a.value;
    wizardData.destinationType = void 0;
    wizardData.destinationName = void 0;
    wizardData.destinationElement = void 0;
    wizardData.tagetType = void 0;
    wizardData.targetName = void 0;
    wizardData.targetElement = void 0;
    wizardData.targetDescription = "";
    wizardData.clues = [];
  }
  const updateStep = (newStep) => {
    setStep(newStep);
  };
  const setError = (step2, error2) => {
    stepComponents[step2].errors = stepComponents[step2].errors || [];
    stepComponents[step2].errors.push(t2(error2));
  };
  const save = () => __async(this, null, function* () {
    stepComponents[1].errors = void 0;
    stepComponents[2].errors = void 0;
    if (!wizardData.targetType)
      setError(2, "wizards.chapter.errors.missingtargettype");
    if (!wizardData.targetElement && !wizardData.targetName)
      setError(2, "wizards.chapter.errors.missingtargetname");
    if (wizardData.destinationType && !wizardData.destinationElement && !wizardData.destinationName)
      setError(1, "wizards.chapter.errors.missingdestination");
    setSteps(stepComponents);
    const hasStep1Errors = !!stepComponents[1].errors;
    const hasStep2Errors = !!stepComponents[2].errors;
    if (hasStep1Errors || hasStep2Errors) {
      setValidation((prev) => prev + 1);
      setStep(hasStep1Errors ? 2 : 3);
      return;
    }
    let destinationFile = void 0;
    let finalClues = [];
    let targetFile = void 0;
    if (wizardData.destinationType !== void 0) {
      if (wizardData.destinationElement) {
        const destination = api2.get(wizardData.destinationElement);
        destinationFile = destination.path;
      } else {
        let positionInParent;
        if (wizardData.destinationElement === "adventure" /* Adventure */) {
          positionInParent = HelperService.getPositionInParent(api2.get(void 0, campaign, "adventure" /* Adventure */));
        } else {
          positionInParent = HelperService.getPositionInParent(api2.get(void 0, campaign, "chapter" /* Chapter */, element4.parent));
        }
        const fileCreationService = new FileCreationService(app, api2, wizardData.destinationType, wizardData.destinationName, campaign.system, element4.campaignPath, wizardData.destinationElement === "adventure" /* Adventure */ ? element4.campaignPath : element4.parentPath, positionInParent);
        const file = yield fileCreationService.create(false);
        destinationFile = file.path;
      }
    }
    if (wizardData.clues !== void 0 && wizardData.clues.length > 0) {
      let clues = wizardData.clues;
      clues = clues.filter((clue) => clue.clueName !== "");
      finalClues = yield Promise.all(clues.map((clue) => __async(this, null, function* () {
        if (clue.isExistingClue || clue.cluePath)
          return clue.cluePath;
        const fileCreationService = new FileCreationService(app, api2, "clue" /* Clue */, clue.clueName, campaign.system, element4.campaignPath, void 0, void 0, [{ name: "description" /* Description */, value: clue.description }]);
        const file = yield fileCreationService.create(false);
        return file.path;
      })));
    }
    if (wizardData.targetElement !== void 0) {
      targetFile = wizardData.targetElement;
    } else {
      const relationships = [];
      finalClues.forEach((clue) => {
        relationships.push({ type: "bidirectional" /* Bidirectional */, path: clue, isInContent: false });
      });
      const fileCreationService = new FileCreationService(app, api2, wizardData.targetType, wizardData.targetName, campaign.system, element4.campaignPath, void 0, void 0, [{ name: "description" /* Description */, value: wizardData.targetDescription }], relationships);
      const file = yield fileCreationService.create(false);
      targetFile = file.path;
    }
    const majorClues = [];
    finalClues.forEach((clue) => {
      majorClues.push({ clue: "[[" + clue + "]]", description: void 0, destination: "[[" + destinationFile + "]]" });
    });
    const data = {
      data: {
        ["description" /* Description */]: wizardData.description,
        ["majorclues" /* MajorClues */]: majorClues
      },
      relationships: [{ type: "bidirectional" /* Bidirectional */, path: targetFile, isInContent: false }]
    };
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    yield codeblockService.update(data);
    close();
  });
  const CurrentStepComponent = steps[step - 1];
  let campaignPath;
  if (element4 !== void 0) {
    campaignPath = (element4 == null ? void 0 : element4.type) === "campaign" /* Campaign */ ? element4 == null ? void 0 : element4.path : element4.campaignPath;
  } else {
    campaignPath = campaign == null ? void 0 : campaign.path;
  }
  return /* @__PURE__ */ React100.createElement("div", {
    className: "relative"
  }, showOverlay && /* @__PURE__ */ React100.createElement(ChatGptOverlay, {
    type: "chapter" /* Chapter */
  }), /* @__PURE__ */ React100.createElement("h2", {
    className: "!text-2xl !font-extralight border-b border-b-[--background-modifier-border]"
  }, t2("wizards.chapter.title")), /* @__PURE__ */ React100.createElement("div", {
    className: "grid grid-cols-5 border-b border-b-[--background-modifier-border]"
  }, /* @__PURE__ */ React100.createElement("div", {
    className: "col-span-1 border-r border-r-[--background-modifier-border]"
  }, /* @__PURE__ */ React100.createElement(WizardNavigatorComponent, {
    key: step + validation,
    steps: stepComponents,
    step,
    setStep
  })), /* @__PURE__ */ React100.createElement("div", {
    className: "p-3 col-span-4"
  }, /* @__PURE__ */ React100.createElement(CurrentStepComponent.component, {
    key: step + validation,
    name: element4 ? element4 == null ? void 0 : element4.name : name,
    chatGpt: void 0,
    campaignPath,
    setOverlay: setShowOverlay,
    errors: CurrentStepComponent.errors
  }))), /* @__PURE__ */ React100.createElement("div", {
    className: "flex justify-end pt-5"
  }, /* @__PURE__ */ React100.createElement("button", {
    className: "rpgm-danger pl-3 pr-3 mr-6",
    onClick: () => close()
  }, t2("buttons.cancel")), /* @__PURE__ */ React100.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 ml-3 disabled:text-[--text-faint]",
    onClick: () => updateStep(step - 1),
    disabled: step === 1
  }, t2("buttons.previous")), /* @__PURE__ */ React100.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 ml-3 disabled:text-[--text-faint]",
    onClick: () => updateStep(step + 1),
    disabled: step === stepComponents.length
  }, t2("buttons.next")), /* @__PURE__ */ React100.createElement("button", {
    className: "rpgm-primary pl-3 pr-3 ml-3 mr-5",
    onClick: () => save()
  }, t2("buttons.create"))));
}

// src/components/wizards/npcs/NonPlayerCharacterWizardComponent.tsx
var React115 = __toESM(require_react());

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardArcStepComponent.tsx
var React101 = __toESM(require_react());
function NonPlayerCharacterWizardArcStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [arcType, setArcType] = React101.useState(wizardData.arc);
  const setArc = (arc2) => {
    setArcType(arc2);
    wizardData.arc = arc2;
  };
  const arcs = [
    {
      type: 1 /* Positive */,
      name: t2("arc.arc", { context: 1 /* Positive */ }),
      description: t2("arc.description", { context: 1 /* Positive */ }),
      selected: arcType === 1 /* Positive */
    },
    {
      type: 2 /* Disillusionment */,
      name: t2("arc.arc", { context: 2 /* Disillusionment */ }),
      description: t2("arc.description", { context: 2 /* Disillusionment */ }),
      selected: arcType === 2 /* Disillusionment */
    },
    {
      type: 3 /* Fall */,
      name: t2("arc.arc", { context: 3 /* Fall */ }),
      description: t2("arc.description", { context: 3 /* Fall */ }),
      selected: arcType === 3 /* Fall */
    },
    {
      type: 4 /* Corruption */,
      name: t2("arc.arc", { context: 4 /* Corruption */ }),
      description: t2("arc.description", { context: 4 /* Corruption */ }),
      selected: arcType === 4 /* Corruption */
    },
    {
      type: 5 /* Flat */,
      name: t2("arc.arc", { context: 5 /* Flat */ }),
      description: t2("arc.description", { context: 5 /* Flat */ }),
      selected: arcType === 5 /* Flat */
    }
  ];
  return /* @__PURE__ */ React101.createElement(React101.Fragment, null, /* @__PURE__ */ React101.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.arc")), /* @__PURE__ */ React101.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React101.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "arc", name })
  })), /* @__PURE__ */ React101.createElement("div", {
    className: ""
  }, arcs.map((arc2, index2) => {
    return /* @__PURE__ */ React101.createElement("div", {
      key: index2,
      className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
      onClick: () => setArc(arc2.type)
    }, /* @__PURE__ */ React101.createElement("div", {
      className: "flext min-w[50px] w-[50px] items-center justify-center"
    }, arc2.selected && /* @__PURE__ */ React101.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "30",
      height: "30",
      fill: "currentColor",
      viewBox: "0 0 16 16"
    }, /* @__PURE__ */ React101.createElement("path", {
      d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
    }))), /* @__PURE__ */ React101.createElement("div", null, /* @__PURE__ */ React101.createElement("h4", null, arc2.name), /* @__PURE__ */ React101.createElement("small", null, /* @__PURE__ */ React101.createElement(MarkdownComponent, {
      value: arc2.description
    }))));
  })));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardBehaviourStepComponent.tsx
var React103 = __toESM(require_react());

// src/components/chatgpt/ChatGptSuggestionComponent.tsx
var React102 = __toESM(require_react());
function ChatGptSuggestionComponent({
  generateSuggestions,
  applySuggestions
}) {
  const { t: t2 } = useTranslation();
  const [suggestions, setSuggestions] = React102.useState(void 0);
  const selectSuggestion = (suggestion) => {
    applySuggestions(suggestion);
  };
  const requestSuggestions = () => __async(this, null, function* () {
    setSuggestions(void 0);
    const providedSuggestions = yield generateSuggestions();
    setSuggestions(providedSuggestions);
  });
  return /* @__PURE__ */ React102.createElement("div", {
    className: "!mt-3 p-3 grid grid-cols-1 rounded-lg border border-[--background-modifier-border]"
  }, /* @__PURE__ */ React102.createElement("div", null, /* @__PURE__ */ React102.createElement("button", {
    className: "rpgm-secondary !m-0",
    onClick: requestSuggestions
  }, t2("chatgpt.generate"))), suggestions && /* @__PURE__ */ React102.createElement(React102.Fragment, null, suggestions.map((suggestion, index2) => {
    return /* @__PURE__ */ React102.createElement("div", {
      key: index2,
      className: "rounded-lg border border-[--background-modifier-border] m-2 p-1 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
      onClick: () => selectSuggestion(suggestion)
    }, suggestion);
  })));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardBehaviourStepComponent.tsx
function NonPlayerCharacterWizardBehaviourStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React103.useState(Date.now());
  const [behaviour2, setBehaviour] = React103.useState(wizardData.behaviour);
  const updateBehaviour = (value) => {
    wizardData.behaviour = value;
    setBehaviour(value);
  };
  const applySuggestion = (suggestion) => {
    const updatedBehaviour = behaviour2 ? `${behaviour2}
${suggestion}` : suggestion;
    updateBehaviour(updatedBehaviour);
    setKey(Date.now());
  };
  function generateSuggestions() {
    return __async(this, null, function* () {
      try {
        setOverlay(true);
        return chatGpt.getBehaviour().then((values2) => {
          setOverlay(false);
          return values2;
        });
      } catch (error2) {
        console.error("Failed to fetch behaviour:", error2);
      }
    });
  }
  return /* @__PURE__ */ React103.createElement(React103.Fragment, null, /* @__PURE__ */ React103.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.behaviour")), /* @__PURE__ */ React103.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React103.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "behaviour", name })
  })), /* @__PURE__ */ React103.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React103.createElement(MarkdownEditorComponent, {
    key,
    initialValue: behaviour2,
    campaignPath,
    onChange: updateBehaviour,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), chatGpt && /* @__PURE__ */ React103.createElement(ChatGptSuggestionComponent, {
    generateSuggestions,
    applySuggestions: applySuggestion
  }));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardBeliefsStepComponent.tsx
var React104 = __toESM(require_react());
function NonPlayerCharacterWizardBeliefsStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React104.useState(Date.now());
  const [beliefs2, setBeliefs] = React104.useState(wizardData.beliefs);
  const updateBeliefs = (value) => {
    wizardData.beliefs = value;
    setBeliefs(value);
  };
  const applySuggestion = (suggestion) => {
    const updatedBeliefs = beliefs2 ? `${beliefs2}
${suggestion}` : suggestion;
    updateBeliefs(updatedBeliefs);
    setKey(Date.now());
  };
  function generateSuggestions() {
    return __async(this, null, function* () {
      try {
        setOverlay(true);
        return chatGpt.getBeliefs().then((values2) => {
          setOverlay(false);
          return values2;
        });
      } catch (error2) {
        console.error("Failed to fetch beliefs:", error2);
      }
    });
  }
  return /* @__PURE__ */ React104.createElement(React104.Fragment, null, /* @__PURE__ */ React104.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.beliefs")), /* @__PURE__ */ React104.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React104.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "beliefs", name })
  })), /* @__PURE__ */ React104.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React104.createElement(MarkdownEditorComponent, {
    key,
    initialValue: beliefs2,
    campaignPath,
    onChange: updateBeliefs,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), chatGpt && /* @__PURE__ */ React104.createElement(ChatGptSuggestionComponent, {
    generateSuggestions,
    applySuggestions: applySuggestion
  }));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardDescriptionStepComponent.tsx
var React105 = __toESM(require_react());
function NonPlayerCharacterWizardDescriptionStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const updateDescription = (value) => {
    wizardData.description = value;
  };
  return /* @__PURE__ */ React105.createElement(React105.Fragment, null, /* @__PURE__ */ React105.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.description")), /* @__PURE__ */ React105.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React105.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "description", name })
  })), /* @__PURE__ */ React105.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React105.createElement(MarkdownEditorComponent, {
    initialValue: wizardData.description,
    campaignPath,
    onChange: updateDescription,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardGhostStepComponent.tsx
var React106 = __toESM(require_react());
function NonPlayerCharacterWizardGhostStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React106.useState(Date.now());
  const [ghost2, setGhost] = React106.useState(wizardData.ghost);
  const updateGhost = (value) => {
    wizardData.ghost = value;
    setGhost(value);
  };
  const applySuggestion = (suggestion) => {
    const updatedGhost = ghost2 ? `${ghost2}
${suggestion}` : suggestion;
    updateGhost(updatedGhost);
    setKey(Date.now());
  };
  function generateSuggestions() {
    return __async(this, null, function* () {
      try {
        setOverlay(true);
        return chatGpt.getGhost().then((value) => {
          setOverlay(false);
          return value;
        });
      } catch (error2) {
        console.error("Failed to fetch behaviour:", error2);
      }
    });
  }
  return /* @__PURE__ */ React106.createElement(React106.Fragment, null, /* @__PURE__ */ React106.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.ghost")), /* @__PURE__ */ React106.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React106.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "ghost", name })
  })), /* @__PURE__ */ React106.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React106.createElement(MarkdownEditorComponent, {
    key,
    initialValue: ghost2,
    campaignPath,
    onChange: updateGhost,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), chatGpt && /* @__PURE__ */ React106.createElement(ChatGptSuggestionComponent, {
    generateSuggestions,
    applySuggestions: applySuggestion
  }));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardLieStepComponent.tsx
var React107 = __toESM(require_react());
function NonPlayerCharacterWizardLieStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React107.useState(Date.now());
  const [lie2, setLie] = React107.useState(wizardData.lie);
  const updateLie = (value) => {
    wizardData.lie = value;
    setLie(value);
  };
  const applySuggestion = (suggestion) => {
    const updatedLie = lie2 ? `${lie2}
${suggestion}` : suggestion;
    updateLie(updatedLie);
    setKey(Date.now());
  };
  function generateSuggestions() {
    return __async(this, null, function* () {
      try {
        setOverlay(true);
        return chatGpt.getLie().then((value) => {
          setOverlay(false);
          return value;
        });
      } catch (error2) {
        console.error("Failed to fetch behaviour:", error2);
      }
    });
  }
  return /* @__PURE__ */ React107.createElement(React107.Fragment, null, /* @__PURE__ */ React107.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.lie")), /* @__PURE__ */ React107.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React107.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "lie", name })
  })), /* @__PURE__ */ React107.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React107.createElement(MarkdownEditorComponent, {
    key,
    initialValue: lie2,
    campaignPath,
    onChange: updateLie,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), chatGpt && /* @__PURE__ */ React107.createElement(ChatGptSuggestionComponent, {
    generateSuggestions,
    applySuggestions: applySuggestion
  }));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardNeedStepComponent.tsx
var React108 = __toESM(require_react());
function NonPlayerCharacterWizardNeedStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React108.useState(Date.now());
  const [need2, setNeed] = React108.useState(wizardData.need);
  const updateNeed = (value) => {
    wizardData.need = value;
    setNeed(value);
  };
  const applySuggestion = (suggestion) => {
    const updatedNeed = need2 ? `${need2}
${suggestion}` : suggestion;
    updateNeed(updatedNeed);
    setKey(Date.now());
  };
  function generateSuggestions() {
    return __async(this, null, function* () {
      try {
        setOverlay(true);
        return chatGpt.getNeed().then((value) => {
          setOverlay(false);
          return value;
        });
      } catch (error2) {
        console.error("Failed to fetch behaviour:", error2);
      }
    });
  }
  return /* @__PURE__ */ React108.createElement(React108.Fragment, null, /* @__PURE__ */ React108.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.need")), /* @__PURE__ */ React108.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React108.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "need", name })
  })), /* @__PURE__ */ React108.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React108.createElement(MarkdownEditorComponent, {
    key,
    initialValue: need2,
    campaignPath,
    onChange: updateNeed,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), chatGpt && /* @__PURE__ */ React108.createElement(ChatGptSuggestionComponent, {
    generateSuggestions,
    applySuggestions: applySuggestion
  }));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardOccupationStepComponent.tsx
var React109 = __toESM(require_react());
function NonPlayerCharacterWizardOccupationStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [occupation2, setOccupation] = React109.useState(wizardData.occupation);
  const updateOccupation = (value) => {
    wizardData.occupation = value;
    setOccupation(value);
  };
  return /* @__PURE__ */ React109.createElement(React109.Fragment, null, /* @__PURE__ */ React109.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.occupation")), /* @__PURE__ */ React109.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React109.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "occupation", name })
  })), /* @__PURE__ */ React109.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React109.createElement(TextInputComponent, {
    initialValue: occupation2,
    campaignPath,
    onChange: updateOccupation,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardOppositionStepComponent.tsx
var React110 = __toESM(require_react());
function NonPlayerCharacterWizardOppositionStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React110.useState(Date.now());
  const [opposition2, setOpposition] = React110.useState(wizardData.opposition);
  const updateOpposition = (value) => {
    wizardData.opposition = value;
    setOpposition(value);
  };
  const applySuggestion = (suggestion) => {
    const updatedOpposition = opposition2 ? `${opposition2}
${suggestion}` : suggestion;
    updateOpposition(updatedOpposition);
    setKey(Date.now());
  };
  function generateSuggestions() {
    return __async(this, null, function* () {
      try {
        setOverlay(true);
        return chatGpt.getOpposition().then((value) => {
          setOverlay(false);
          return value;
        });
      } catch (error2) {
        console.error("Failed to fetch behaviour:", error2);
      }
    });
  }
  return /* @__PURE__ */ React110.createElement(React110.Fragment, null, /* @__PURE__ */ React110.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.opposition")), /* @__PURE__ */ React110.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React110.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "opposition", name })
  }), wizardData.want !== void 0 && /* @__PURE__ */ React110.createElement(React110.Fragment, null, /* @__PURE__ */ React110.createElement("br", null), /* @__PURE__ */ React110.createElement("small", null, name, " wants to:", /* @__PURE__ */ React110.createElement(MarkdownComponent, {
    value: wizardData.want
  })))), /* @__PURE__ */ React110.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React110.createElement(MarkdownEditorComponent, {
    key,
    initialValue: opposition2,
    campaignPath,
    onChange: updateOpposition,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), chatGpt && /* @__PURE__ */ React110.createElement(ChatGptSuggestionComponent, {
    generateSuggestions,
    applySuggestions: applySuggestion
  }));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardStakeStepComponent.tsx
var React111 = __toESM(require_react());
function NonPlayerCharacterWizardStakeStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [stake2, setStake] = React111.useState((_a = wizardData.stake) != null ? _a : 0);
  const [widthPercentage, setWidthPercentage] = React111.useState(stake2 / 10 * 100);
  React111.useEffect(() => {
    setWidthPercentage(stake2 / 10 * 100);
  }, [stake2]);
  const handleMouseOver = (event) => {
    const rect = event.currentTarget.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const newWidthPercentage = x / rect.width * 100;
    setWidthPercentage(newWidthPercentage);
  };
  const updateStake = () => {
    const newValue = Math.round(widthPercentage / 100 * 10);
    wizardData.stake = newValue;
    setStake(newValue);
  };
  return /* @__PURE__ */ React111.createElement(React111.Fragment, null, /* @__PURE__ */ React111.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.stake")), /* @__PURE__ */ React111.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React111.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "stake", name })
  })), /* @__PURE__ */ React111.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React111.createElement("div", {
    className: "w-full mt-3 cursor-pointer"
  }, /* @__PURE__ */ React111.createElement("div", {
    className: "relative mr-3 h-2 bg-[--background-primary-alt] rounded-full",
    onMouseMove: handleMouseOver,
    onClick: updateStake
  }, /* @__PURE__ */ React111.createElement("div", {
    style: { width: `${widthPercentage}%` },
    className: "absolute h-2 bg-[--text-accent] rounded-full"
  })), /* @__PURE__ */ React111.createElement("div", {
    className: "text-xs text-[--text-faint] text-center"
  }, Math.round(widthPercentage / 100 * 10)))));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardStrengthsAndWeaknessesStepComponent.tsx
var React112 = __toESM(require_react());
function NonPlayerCharacterWizardStrengthsAndWeaknessesStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React112.useState(Date.now());
  const [retrievingStrengthsSuggestions, setRetrievingStrengthsSuggestions] = React112.useState(false);
  const [retrievingWeaknessesSuggestions, setRetrievingWeaknessesSuggestions] = React112.useState(false);
  const [strengths2, setStrengths] = React112.useState(wizardData.strengths);
  const [weaknesses2, setWeaknesses] = React112.useState(wizardData.weaknesses);
  const requestStrengthsSuggestions = () => __async(this, null, function* () {
    setRetrievingStrengthsSuggestions(true);
    try {
      setOverlay(true);
      const suggestedStrengths = yield chatGpt.getStrenghts().then((value) => {
        setOverlay(false);
        return value;
      });
      let strengthValue = 0;
      for (const strength of suggestedStrengths) {
        const normalizedStrength = strength.charAt(0).toUpperCase() + strength.slice(1).toLowerCase();
        if (StrengthType[normalizedStrength] !== void 0)
          strengthValue |= StrengthType[normalizedStrength];
      }
      wizardData.strengths = strengthValue;
      setStrengths(strengthValue);
    } catch (error2) {
      console.error("Failed to fetch behaviour:", error2);
    }
    setKey(Date.now());
    setRetrievingStrengthsSuggestions(false);
  });
  const requestWeaknessesSuggestions = () => __async(this, null, function* () {
    setRetrievingWeaknessesSuggestions(true);
    try {
      setOverlay(true);
      const suggestedWeaknesses = yield chatGpt.getWeaknesses().then((value) => {
        setOverlay(false);
        return value;
      });
      let weaknessValue = 0;
      for (const weakness of suggestedWeaknesses) {
        const normalizedWeakness = weakness.charAt(0).toUpperCase() + weakness.slice(1).toLowerCase();
        if (WeaknessType[normalizedWeakness] !== void 0)
          weaknessValue |= WeaknessType[normalizedWeakness];
      }
      wizardData.weaknesses = weaknessValue;
      setWeaknesses(weaknessValue);
    } catch (error2) {
      console.error("Failed to fetch behaviour:", error2);
    }
    setKey(Date.now());
    setRetrievingWeaknessesSuggestions(false);
  });
  const updateStrengths = (strengths3) => {
    wizardData.strengths = wizardData.strengths ^ strengths3;
    setStrengths(wizardData.strengths);
  };
  const updateWeaknesses = (weaknesses3) => {
    wizardData.weaknesses = wizardData.weaknesses ^ weaknesses3;
    setWeaknesses(wizardData.weaknesses);
  };
  return /* @__PURE__ */ React112.createElement(React112.Fragment, null, /* @__PURE__ */ React112.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.strengths")), /* @__PURE__ */ React112.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React112.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "strengths", name })
  })), /* @__PURE__ */ React112.createElement("div", {
    className: "!mb-5"
  }, /* @__PURE__ */ React112.createElement(StrengthsComponent, {
    key,
    initialValue: strengths2,
    propagateValue: updateStrengths
  })), chatGpt && /* @__PURE__ */ React112.createElement("div", {
    className: "!mt-3 grid grid-cols-1"
  }, /* @__PURE__ */ React112.createElement("div", {
    className: "!mb-3"
  }, /* @__PURE__ */ React112.createElement("button", {
    className: "rpgm-secondary",
    onClick: requestStrengthsSuggestions,
    disabled: retrievingStrengthsSuggestions
  }, t2("chatgpt.generate"))), retrievingStrengthsSuggestions && /* @__PURE__ */ React112.createElement("div", {
    className: "p-3 rounded-lg border border-[--background-modifier-border]"
  }, t2("chatgpt.messages", { returnObjects: true })[0])), /* @__PURE__ */ React112.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.weaknesses")), /* @__PURE__ */ React112.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React112.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "weaknesses", name })
  })), /* @__PURE__ */ React112.createElement("div", null, /* @__PURE__ */ React112.createElement(WeaknessesComponent, {
    key,
    initialValue: weaknesses2,
    propagateValue: updateWeaknesses
  })), chatGpt && /* @__PURE__ */ React112.createElement("div", {
    className: "!mt-3 grid grid-cols-1"
  }, /* @__PURE__ */ React112.createElement("div", {
    className: "!mb-3"
  }, /* @__PURE__ */ React112.createElement("button", {
    className: "rpgm-secondary",
    onClick: requestWeaknessesSuggestions,
    disabled: retrievingWeaknessesSuggestions
  }, t2("chatgpt.generate"))), retrievingWeaknessesSuggestions && /* @__PURE__ */ React112.createElement("div", {
    className: "p-3 rounded-lg border border-[--background-modifier-border]"
  }, t2("chatgpt.messages", { returnObjects: true })[0])));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardTypeStepComponent.tsx
var React113 = __toESM(require_react());
function NonPlayerCharacterWizardTypeStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [characterType, setCharacterType] = React113.useState(wizardData.nonplayercharactertype);
  const setType = (type2) => {
    wizardData.nonplayercharactertype = type2;
    setCharacterType(type2);
  };
  const types = [
    {
      type: "main" /* Main */,
      name: t2("npctype.npctype", { context: "main" /* Main */ }),
      description: t2("npctype.description", { context: "main" /* Main */ }),
      selected: characterType === "main" /* Main */
    },
    {
      type: "supporting" /* Supporting */,
      name: t2("npctype.npctype", { context: "supporting" /* Supporting */ }),
      description: t2("npctype.description", { context: "supporting" /* Supporting */ }),
      selected: characterType === "supporting" /* Supporting */
    },
    {
      type: "extra" /* Extra */,
      name: t2("npctype.npctype", { context: "extra" /* Extra */ }),
      description: t2("npctype.description", { context: "extra" /* Extra */ }),
      selected: characterType === "extra" /* Extra */
    }
  ];
  return /* @__PURE__ */ React113.createElement(React113.Fragment, null, /* @__PURE__ */ React113.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.nonplayercharactertype")), /* @__PURE__ */ React113.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React113.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "type", name })
  })), /* @__PURE__ */ React113.createElement("div", {
    className: ""
  }, types.map((type2, index2) => {
    return /* @__PURE__ */ React113.createElement("div", {
      key: index2,
      className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
      onClick: () => setType(type2.type)
    }, /* @__PURE__ */ React113.createElement("div", {
      className: "flext min-w[50px] w-[50px] items-center justify-center"
    }, type2.selected && /* @__PURE__ */ React113.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "30",
      height: "30",
      fill: "currentColor",
      viewBox: "0 0 16 16"
    }, /* @__PURE__ */ React113.createElement("path", {
      d: "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"
    }))), /* @__PURE__ */ React113.createElement("div", null, /* @__PURE__ */ React113.createElement("h4", null, type2.name), /* @__PURE__ */ React113.createElement("small", null, /* @__PURE__ */ React113.createElement(MarkdownComponent, {
      value: type2.description
    }))));
  })));
}

// src/components/wizards/npcs/steps/NonPlayerCharacterWizardWantStepComponent.tsx
var React114 = __toESM(require_react());
function NonPlayerCharacterWizardWantStepComponent({
  name,
  campaignPath,
  chatGpt,
  setOverlay
}) {
  const { t: t2 } = useTranslation();
  const wizardData = useWizard();
  const [key, setKey] = React114.useState(Date.now());
  const [want2, setWant] = React114.useState(wizardData.want);
  const updateWant = (value) => {
    wizardData.want = value;
    setWant(value);
  };
  const applySuggestion = (suggestion) => {
    const updatedWant = want2 ? `${want2}
${suggestion}` : suggestion;
    updateWant(updatedWant);
    setKey(Date.now());
  };
  function generateSuggestions() {
    return __async(this, null, function* () {
      try {
        setOverlay(true);
        return chatGpt.getWant().then((value) => {
          setOverlay(false);
          return value;
        });
      } catch (error2) {
        console.error("Failed to fetch behaviour:", error2);
      }
    });
  }
  return /* @__PURE__ */ React114.createElement(React114.Fragment, null, /* @__PURE__ */ React114.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("attributes.want")), /* @__PURE__ */ React114.createElement("div", {
    className: "!mt-3 !mb-3"
  }, /* @__PURE__ */ React114.createElement(MarkdownComponent, {
    value: t2("wizards.npc.description", { context: "want", name })
  })), /* @__PURE__ */ React114.createElement("div", {
    className: ""
  }, /* @__PURE__ */ React114.createElement(MarkdownEditorComponent, {
    key,
    initialValue: want2,
    campaignPath,
    onChange: updateWant,
    className: "w-full resize-none overflow-y-hidden border border-[--background-modifier-border] rounded-md"
  })), chatGpt && /* @__PURE__ */ React114.createElement(ChatGptSuggestionComponent, {
    generateSuggestions,
    applySuggestions: applySuggestion
  }));
}

// src/components/wizards/npcs/NonPlayerCharacterWizardComponent.tsx
var initialStepComponents = [
  { name: "Type", component: NonPlayerCharacterWizardTypeStepComponent },
  { name: "Description", component: NonPlayerCharacterWizardDescriptionStepComponent }
];
var stepComponents2 = [
  { name: "Type", component: NonPlayerCharacterWizardTypeStepComponent },
  { name: "Description", component: NonPlayerCharacterWizardDescriptionStepComponent },
  { name: "Occupation", component: NonPlayerCharacterWizardOccupationStepComponent },
  { name: "Character Arc", component: NonPlayerCharacterWizardArcStepComponent },
  { name: "Beliefs", component: NonPlayerCharacterWizardBeliefsStepComponent, chatGptId: "beliefs" },
  { name: "Ghost", component: NonPlayerCharacterWizardGhostStepComponent, chatGptId: "ghost" },
  { name: "Lie", component: NonPlayerCharacterWizardLieStepComponent, chatGptId: "lie" },
  { name: "Need", component: NonPlayerCharacterWizardNeedStepComponent, chatGptId: "need" },
  {
    name: "Strengths and Weaknesses",
    component: NonPlayerCharacterWizardStrengthsAndWeaknessesStepComponent,
    chatGptId: "sw"
  },
  { name: "Behaviour", component: NonPlayerCharacterWizardBehaviourStepComponent, chatGptId: "behaviour" },
  { name: "Want", component: NonPlayerCharacterWizardWantStepComponent, chatGptId: "want" },
  { name: "Stake", component: NonPlayerCharacterWizardStakeStepComponent },
  { name: "Opposition", component: NonPlayerCharacterWizardOppositionStepComponent, chatGptId: "opposition" }
];
var minimalStepComponents = [
  { name: "Type", component: NonPlayerCharacterWizardTypeStepComponent },
  { name: "Description", component: NonPlayerCharacterWizardDescriptionStepComponent },
  { name: "Occupation", component: NonPlayerCharacterWizardOccupationStepComponent },
  {
    name: "Strengths and Weaknesses",
    component: NonPlayerCharacterWizardStrengthsAndWeaknessesStepComponent,
    chatGptId: "sw"
  },
  { name: "Behaviour", component: NonPlayerCharacterWizardBehaviourStepComponent, chatGptId: "behaviour" },
  { name: "Want", component: NonPlayerCharacterWizardWantStepComponent, chatGptId: "want" },
  { name: "Stake", component: NonPlayerCharacterWizardStakeStepComponent }
];
function NonPlayerCharacterWizardComponent({
  element: element4,
  name,
  campaign,
  close,
  returnData
}) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const { t: t2 } = useTranslation();
  const [stepsType, setStepsType] = React115.useState(initialStepComponents);
  const [showOverlay, setShowOverlay] = React115.useState(false);
  const api2 = useApi();
  const app = useApp();
  const wizardData = useWizard();
  const chatGpt = React115.useRef(void 0);
  const createAutomatically = () => __async(this, null, function* () {
    if (chatGpt.current === void 0)
      return;
    setShowOverlay(true);
    for (let index2 = 0; index2 < stepsType.length; index2++) {
      const step2 = stepsType[index2];
      if (step2.chatGptId !== void 0 && wizardData[step2.chatGptId] === void 0) {
        let responses = [];
        switch (step2.chatGptId) {
          case "want":
            responses = yield chatGpt.current.getWant();
            if (responses.length > 0) {
              wizardData.want = responses[0];
              chatGpt.current.want = responses[0];
            }
            break;
          case "beliefs":
            responses = yield chatGpt.current.getBeliefs();
            if (responses.length > 0) {
              wizardData.beliefs = responses[0];
              chatGpt.current.beliefs = responses[0];
            }
            break;
          case "ghost":
            responses = yield chatGpt.current.getGhost();
            if (responses.length > 0) {
              wizardData.ghost = responses[0];
              chatGpt.current.ghost = responses[0];
            }
            break;
          case "lie":
            responses = yield chatGpt.current.getLie();
            if (responses.length > 0) {
              wizardData.lie = responses[0];
              chatGpt.current.lie = responses[0];
            }
            break;
          case "need":
            responses = yield chatGpt.current.getNeed();
            if (responses.length > 0) {
              wizardData.need = responses[0];
              chatGpt.current.need = responses[0];
            }
            break;
          case "behaviour":
            responses = yield chatGpt.current.getBehaviour();
            if (responses.length > 0) {
              wizardData.behaviour = responses[0];
              chatGpt.current.behaviour = responses[0];
            }
            break;
          case "opposition":
            responses = yield chatGpt.current.getOpposition();
            if (responses.length > 0) {
              wizardData.opposition = responses[0];
              chatGpt.current.opposition = responses[0];
            }
            break;
          case "sw":
            responses = yield chatGpt.current.getStrenghts();
            if (responses.length > 0) {
              let strengthValue = 0;
              for (const strength of responses) {
                const normalizedStrength = strength.charAt(0).toUpperCase() + strength.slice(1).toLowerCase();
                if (StrengthType[normalizedStrength] !== void 0)
                  strengthValue |= StrengthType[normalizedStrength];
              }
              wizardData.strengths = strengthValue;
              setStrengthsValue();
            }
            responses = yield chatGpt.current.getWeaknesses();
            if (responses.length > 0) {
              let weaknessValue = 0;
              for (const weakness of responses) {
                const normalizedWeakness = weakness.charAt(0).toUpperCase() + weakness.slice(1).toLowerCase();
                if (WeaknessType[normalizedWeakness] !== void 0)
                  weaknessValue |= WeaknessType[normalizedWeakness];
              }
              wizardData.weaknesses = weaknessValue;
              setWeaknessesValue();
            }
            break;
        }
      }
    }
    save();
  });
  const setStrengthsValue = () => {
    const strengths2 = [];
    Object.entries(StrengthType).filter(([key]) => isNaN(Number(key))).map(([key, currentStrength]) => {
      const strengthValue = currentStrength;
      if ((wizardData.strengths & strengthValue) === strengthValue) {
        strengths2.push(key);
      }
    });
    chatGpt.current.strengths = strengths2.join(", ");
  };
  const setWeaknessesValue = () => {
    const weaknesses2 = [];
    Object.entries(WeaknessType).filter(([key]) => isNaN(Number(key))).map(([key, currentWeakness]) => {
      const weaknessValue = currentWeakness;
      if ((wizardData.weaknesses & weaknessValue) === weaknessValue) {
        weaknesses2.push(key);
      }
    });
    chatGpt.current.weaknesses = weaknesses2.join(", ");
  };
  if (api2.settings.chatGptKey !== void 0 && api2.settings.chatGptKey !== "" && !chatGpt.current) {
    chatGpt.current = new ChatGptNonPlayerCharacterModel(api2, (_a = element4 == null ? void 0 : element4.campaign) != null ? _a : campaign, (_b = element4 == null ? void 0 : element4.name) != null ? _b : name);
  }
  const setCurrentChatGPT = () => {
    if (wizardData.description !== void 0)
      chatGpt.current.description = wizardData.description;
    if (wizardData.occupation !== void 0)
      chatGpt.current.occupation = wizardData.occupation;
    if (wizardData.arc !== void 0)
      chatGpt.current.characterArc = wizardData.arc;
    if (wizardData.beliefs !== void 0)
      chatGpt.current.beliefs = wizardData.beliefs;
    if (wizardData.ghost !== void 0)
      chatGpt.current.ghost = wizardData.ghost;
    if (wizardData.lie !== void 0)
      chatGpt.current.lie = wizardData.lie;
    if (wizardData.need !== void 0)
      chatGpt.current.need = wizardData.need;
    if (wizardData.strengths !== void 0)
      setStrengthsValue();
    if (wizardData.weaknesses !== void 0)
      setWeaknessesValue();
    if (wizardData.behaviour !== void 0)
      chatGpt.current.behaviour = wizardData.behaviour;
    if (wizardData.want !== void 0)
      chatGpt.current.want = wizardData.want;
    if (wizardData.opposition !== void 0)
      chatGpt.current.opposition = wizardData.opposition;
  };
  if (Object.keys(wizardData).length === 0) {
    wizardData.nonplayercharactertype = (_c = element4 == null ? void 0 : element4.attribute("nonplayercharactertype" /* NonPlayerCharacterType */)) == null ? void 0 : _c.value;
    wizardData.description = (_d = element4 == null ? void 0 : element4.attribute("description" /* Description */)) == null ? void 0 : _d.value;
    wizardData.occupation = (_e = element4 == null ? void 0 : element4.attribute("occupation" /* Occupation */)) == null ? void 0 : _e.value;
    wizardData.arc = (_f = element4 == null ? void 0 : element4.attribute("arc" /* Arc */)) == null ? void 0 : _f.value;
    wizardData.ghost = (_g = element4 == null ? void 0 : element4.attribute("ghost" /* Ghost */)) == null ? void 0 : _g.value;
    wizardData.lie = (_h = element4 == null ? void 0 : element4.attribute("lie" /* Lie */)) == null ? void 0 : _h.value;
    wizardData.need = (_i = element4 == null ? void 0 : element4.attribute("need" /* Need */)) == null ? void 0 : _i.value;
    wizardData.want = (_j = element4 == null ? void 0 : element4.attribute("want" /* Want */)) == null ? void 0 : _j.value;
    wizardData.opposition = (_k = element4 == null ? void 0 : element4.attribute("opposition" /* Opposition */)) == null ? void 0 : _k.value;
    wizardData.strengths = (_l = element4 == null ? void 0 : element4.attribute("strengths" /* Strengths */)) == null ? void 0 : _l.value;
    wizardData.weaknesses = (_m = element4 == null ? void 0 : element4.attribute("weaknesses" /* Weaknesses */)) == null ? void 0 : _m.value;
    wizardData.beliefs = (_n = element4 == null ? void 0 : element4.attribute("beliefs" /* Beliefs */)) == null ? void 0 : _n.value;
    wizardData.behaviour = (_o = element4 == null ? void 0 : element4.attribute("behaviour" /* Behaviour */)) == null ? void 0 : _o.value;
    wizardData.stake = (_p = element4 == null ? void 0 : element4.attribute("stake" /* Stake */)) == null ? void 0 : _p.value;
    if (chatGpt.current !== void 0)
      setCurrentChatGPT();
  }
  const [step, setStep] = React115.useState(1);
  const updateStep = (newStep) => {
    if (api2.settings.chatGptKey !== void 0 && api2.settings.chatGptKey !== "") {
      setCurrentChatGPT();
    }
    if (step === 1) {
      if (wizardData.nonplayercharactertype === "extra" /* Extra */) {
        setStepsType(minimalStepComponents);
      } else {
        setStepsType(stepComponents2);
      }
    }
    if ((newStep === 6 || newStep === 7) && (wizardData.arc === 5 /* Flat */ || wizardData.arc === 4 /* Corruption */)) {
      if (step > newStep) {
        newStep = 5;
      } else {
        newStep = 8;
      }
    }
    setStep(newStep);
  };
  const CurrentStepComponent = stepsType[step - 1];
  const save = () => {
    const attributes3 = Object.entries(wizardData).map(([name2, value]) => ({
      name: name2,
      value
    }));
    if (returnData !== void 0) {
      returnData(attributes3);
    } else {
      const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
      codeblockService.updateCodeblockDataList(attributes3);
      close();
    }
  };
  let campaignPath;
  if (element4 !== void 0) {
    campaignPath = (element4 == null ? void 0 : element4.type) === "campaign" /* Campaign */ ? element4 == null ? void 0 : element4.path : element4.campaignPath;
  } else {
    campaignPath = campaign == null ? void 0 : campaign.path;
  }
  return /* @__PURE__ */ React115.createElement("div", {
    className: "relative"
  }, showOverlay && /* @__PURE__ */ React115.createElement(ChatGptOverlay, {
    type: "nonplayercharacter" /* NonPlayerCharacter */
  }), /* @__PURE__ */ React115.createElement("h2", {
    className: "!text-2xl !font-extralight border-b border-b-[--background-modifier-border]"
  }, t2("wizards.npc.title")), /* @__PURE__ */ React115.createElement("div", {
    className: "grid grid-cols-5 border-b border-b-[--background-modifier-border]"
  }, /* @__PURE__ */ React115.createElement("div", {
    className: "col-span-1 border-r border-r-[--background-modifier-border]"
  }, WizardNavigatorComponent({ steps: stepsType, step, setStep })), /* @__PURE__ */ React115.createElement("div", {
    className: "p-3 col-span-4"
  }, /* @__PURE__ */ React115.createElement(CurrentStepComponent.component, {
    key: step,
    name: element4 ? element4 == null ? void 0 : element4.name : name,
    chatGpt: chatGpt.current,
    campaignPath,
    setOverlay: setShowOverlay
  }))), /* @__PURE__ */ React115.createElement("div", {
    className: "flex justify-end pt-5"
  }, /* @__PURE__ */ React115.createElement("button", {
    className: "rpgm-danger pl-3 pr-3 mr-6",
    onClick: () => close()
  }, t2("buttons.cancel")), api2.settings.chatGptKey !== void 0 && api2.settings.chatGptKey !== "" && chatGpt.current && step > 2 && /* @__PURE__ */ React115.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 mr-6",
    onClick: () => createAutomatically()
  }, t2("wizards.npc.create")), /* @__PURE__ */ React115.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 ml-3 disabled:text-[--text-faint]",
    onClick: () => updateStep(step - 1),
    disabled: step === 1
  }, t2("buttons.previous")), /* @__PURE__ */ React115.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 ml-3 disabled:text-[--text-faint]",
    onClick: () => updateStep(step + 1),
    disabled: step === stepsType.length
  }, t2("buttons.next")), /* @__PURE__ */ React115.createElement("button", {
    className: "rpgm-primary pl-3 pr-3 ml-3 mr-5",
    onClick: () => save()
  }, t2("buttons.create"))));
}

// src/components/creation/CreationBaseComponent.tsx
var React121 = __toESM(require_react());

// src/components/creation/AdventureSelectionComponent.tsx
var React116 = __toESM(require_react());
function AdventureSelectionComponent({
  adventures,
  setAdventurePath
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React116.createElement("div", {
    className: "max-w-md mb-3"
  }, /* @__PURE__ */ React116.createElement("div", null, t2("adventure", { count: 1 })), /* @__PURE__ */ React116.createElement("div", null, /* @__PURE__ */ React116.createElement("select", {
    onChange: (e2) => setAdventurePath(e2.target.value),
    className: "w-full"
  }, adventures.length > 1 && /* @__PURE__ */ React116.createElement("option", {
    value: ""
  }), adventures.map((adventure) => /* @__PURE__ */ React116.createElement("option", {
    key: adventure.path,
    value: adventure.path
  }, adventure.name)))));
}

// src/components/creation/CampaignSelectionComponent.tsx
var React117 = __toESM(require_react());
function CampaignSelectionComponent({
  campaigns,
  setAsGlobal,
  setCampaign,
  setSystem
}) {
  const { t: t2 } = useTranslation();
  const setSelectedCampaign = (campaignPath) => {
    const campaign = campaigns.find((campaign2) => campaign2.path === campaignPath);
    if (campaign === void 0)
      return;
    setCampaign(campaignPath);
    setSystem(campaign.system);
  };
  return /* @__PURE__ */ React117.createElement("div", {
    className: "max-w-md mb-3"
  }, /* @__PURE__ */ React117.createElement("div", {
    className: "font-bold"
  }, t2("create.select", { context: "campaign" /* Campaign */ })), /* @__PURE__ */ React117.createElement("select", {
    onChange: (e2) => setSelectedCampaign(e2.target.value),
    className: "w-full"
  }, campaigns.length > 1 && /* @__PURE__ */ React117.createElement("option", {
    value: ""
  }), campaigns.map((campaign) => /* @__PURE__ */ React117.createElement("option", {
    key: campaign.path,
    value: campaign.path
  }, campaign.name))), setAsGlobal !== void 0 && /* @__PURE__ */ React117.createElement(React117.Fragment, null, /* @__PURE__ */ React117.createElement("label", {
    key: "global",
    className: "block"
  }, /* @__PURE__ */ React117.createElement("input", {
    type: "checkbox",
    onChange: (e2) => setAsGlobal(e2.target.checked)
  }), t2("global_description"))));
}

// src/components/creation/CreationTypeSelectionComponent.tsx
var React118 = __toESM(require_react());
function CreationTypeSelectionComponent({
  setType
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React118.createElement(React118.Fragment, null, /* @__PURE__ */ React118.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("create.new", { context: "element" })), /* @__PURE__ */ React118.createElement("div", {
    className: "!mt-3 !mb-3"
  }, t2("create.select", { context: "type" })), /* @__PURE__ */ React118.createElement("div", {
    className: ""
  }, Object.keys(ElementType).map((type2, index2) => {
    return /* @__PURE__ */ React118.createElement("div", {
      key: index2,
      className: "flex items-center rounded-lg border border-[--background-modifier-border] m-4 p-4 hover:bg-[--background-primary-alt] bg-transparent cursor-pointer",
      onClick: () => setType(type2)
    }, /* @__PURE__ */ React118.createElement("div", null, /* @__PURE__ */ React118.createElement("h4", null, type2)));
  })));
}

// src/components/creation/SessionSelectionComponent.tsx
var React119 = __toESM(require_react());
function SessionSelectionComponent({
  sessions,
  setSessionPath
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ React119.createElement("div", {
    className: "max-w-md mb-3"
  }, /* @__PURE__ */ React119.createElement("div", null, t2("session", { count: 1 })), /* @__PURE__ */ React119.createElement("div", null, /* @__PURE__ */ React119.createElement("select", {
    onChange: (e2) => setSessionPath(e2.target.value),
    className: "w-full"
  }, sessions.length > 1 && /* @__PURE__ */ React119.createElement("option", {
    value: ""
  }), sessions.map((session) => /* @__PURE__ */ React119.createElement("option", {
    key: session.path,
    value: session.path
  }, session.name)))));
}

// src/components/creation/TemplateSelectionComponent.tsx
var React120 = __toESM(require_react());
function TemplateSelectionComponent({
  setTemplate
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  if (!api2.settings.templatesFolder)
    return null;
  const templates = app.vault.getFiles().filter((file) => file.parent.path === api2.settings.templatesFolder && file.extension === "md");
  if (templates.length === 0)
    return null;
  return /* @__PURE__ */ React120.createElement("div", {
    className: "max-w-md mb-3"
  }, /* @__PURE__ */ React120.createElement("div", {
    className: "font-bold"
  }, t2("create.select", { context: "template" })), /* @__PURE__ */ React120.createElement("select", {
    onChange: (e2) => setTemplate(e2.target.value),
    className: "w-full"
  }, /* @__PURE__ */ React120.createElement("option", {
    value: ""
  }), templates.map((template) => /* @__PURE__ */ React120.createElement("option", {
    key: template.path,
    value: template.path
  }, template.basename))));
}

// src/components/creation/CreationBaseComponent.tsx
function CreationBaseComponent({
  initialType,
  currentNote,
  setId,
  hasWizard,
  closeModal
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const [global2, setGlobal] = React121.useState(false);
  const [type2, setType] = React121.useState(initialType);
  const [campaignPath, setCampaignPath] = React121.useState();
  const [parentPath, setParentPath] = React121.useState(void 0);
  const [positionInParent, setPositionInParent] = React121.useState(void 0);
  const [name, setName] = React121.useState(void 0);
  const [error2, setError] = React121.useState(void 0);
  const [system, setSystem] = React121.useState(void 0);
  const [template, setTemplate] = React121.useState(void 0);
  let campaigns = [];
  let campaign = void 0;
  let adventures = [];
  let adventure = void 0;
  let sessions = [];
  let session = void 0;
  if (currentNote !== void 0 && name === void 0) {
    setName(currentNote.basename);
  }
  if (type2 !== void 0) {
    if (type2 !== "campaign" /* Campaign */) {
      campaigns = api2.get(void 0, void 0, "campaign" /* Campaign */);
      if (campaigns.length === 0 && !global2)
        return /* @__PURE__ */ React121.createElement("div", null, t2("errors.must", { context: "campaign" }));
      if (campaigns.length === 1) {
        campaign = campaigns[0];
        if (!campaignPath) {
          setCampaignPath(campaign.path);
          setSystem(campaign.system);
        }
      }
      if (campaignPath !== void 0)
        campaign = campaigns.find((campaign2) => campaign2.path === campaignPath);
      if (type2 === "adventure" /* Adventure */ || type2 === "session" /* Session */) {
        if (parentPath === void 0 && campaign !== void 0)
          setParentPath(campaign.path);
        if (positionInParent === void 0) {
          setPositionInParent(HelperService.getPositionInParent(api2.get(void 0, campaign, type2)));
        }
      }
      if (type2 === "scene" /* Scene */) {
        sessions = api2.get(void 0, campaign, "session" /* Session */, campaign);
        if (sessions.length === 0)
          return /* @__PURE__ */ React121.createElement("div", null, t2("errors.must", { context: "session" }));
        if (sessions.length === 1) {
          session = sessions[0];
        } else if (parentPath !== void 0) {
          session = sessions.find((session2) => session2.path === parentPath);
        }
        if (session !== void 0) {
          if (parentPath === void 0)
            setParentPath(session.path);
          if (positionInParent === void 0) {
            setPositionInParent(HelperService.getPositionInParent(api2.get(void 0, campaign, "session" /* Session */, session)));
          }
        }
      }
      if (type2 === "chapter" /* Chapter */) {
        adventures = api2.get(void 0, campaign, "adventure" /* Adventure */, campaign);
        if (adventures.length === 0)
          return /* @__PURE__ */ React121.createElement("div", null, t2("errors.must", { context: "adventure" }));
        if (adventures.length === 1) {
          adventure = adventures[0];
        } else if (parentPath !== void 0) {
          adventure = adventures.find((adventure2) => adventure2.path === parentPath);
        }
        if (adventure !== void 0) {
          if (parentPath === void 0)
            setParentPath(adventure.path);
          if (positionInParent === void 0) {
            setPositionInParent(HelperService.getPositionInParent(api2.get(void 0, campaign, type2, adventure)));
          }
        }
      }
    }
  }
  const createElement133 = (launchWizard) => __async(this, null, function* () {
    let e2 = "";
    if (type2 !== "campaign" /* Campaign */ && campaignPath === void 0 && !global2)
      e2 += "You must select a campaign";
    if (name === void 0 || name === "")
      e2 += "You must enter a name";
    if ((type2 === "adventure" /* Adventure */ || type2 === "session" /* Session */) && parentPath === void 0)
      e2 += "You must select a campaign";
    if (type2 === "scene" /* Scene */ && parentPath === void 0)
      e2 += "You must select a session";
    if (type2 === "chapter" /* Chapter */ && parentPath === void 0)
      e2 += "You must select an adventure";
    if (e2 !== "") {
      setError(e2);
      return;
    }
    setId(launchWizard, type2, name, system, global2 ? void 0 : campaignPath, parentPath, positionInParent, template);
  });
  const inputRef = React121.useRef(null);
  React121.useEffect(() => {
    var _a;
    if (type2 !== void 0) {
      (_a = inputRef.current) == null ? void 0 : _a.focus();
    }
  }, [type2]);
  function handleKeyDown(event) {
    if (event.key === "Enter") {
      createElement133(hasWizard);
    }
  }
  return /* @__PURE__ */ React121.createElement(React121.Fragment, null, /* @__PURE__ */ React121.createElement("h2", {
    className: "!text-2xl !font-extralight border-b border-b-[--background-modifier-border]"
  }, t2("create.new", { context: type2 })), /* @__PURE__ */ React121.createElement("div", {
    className: "grid grid-cols-5 border-b border-b-[--background-modifier-border]"
  }, /* @__PURE__ */ React121.createElement("div", {
    className: "col-span-1 border-r border-r-[--background-modifier-border]"
  }, /* @__PURE__ */ React121.createElement("ul", {
    className: "!p-0 !m-0 !mt-3"
  }, /* @__PURE__ */ React121.createElement("li", {
    className: "text-[--text-normal]"
  }, t2("elements.element", { count: 1 })))), /* @__PURE__ */ React121.createElement("div", {
    className: "p-3 col-span-4"
  }, error2 && /* @__PURE__ */ React121.createElement("div", null, error2), type2 === void 0 ? /* @__PURE__ */ React121.createElement(CreationTypeSelectionComponent, {
    setType
  }) : /* @__PURE__ */ React121.createElement(TemplateSelectionComponent, {
    setTemplate
  }), type2 !== void 0 && type2 !== "campaign" /* Campaign */ && /* @__PURE__ */ React121.createElement(CampaignSelectionComponent, {
    campaigns,
    setCampaign: setCampaignPath,
    setAsGlobal: ![
      "campaign" /* Campaign */,
      "adventure" /* Adventure */,
      "chapter" /* Chapter */,
      "session" /* Session */,
      "scene" /* Scene */
    ].contains(type2) ? setGlobal : void 0,
    setSystem
  }), type2 !== void 0 && type2 === "scene" /* Scene */ && /* @__PURE__ */ React121.createElement(SessionSelectionComponent, {
    sessions,
    setSessionPath: setParentPath
  }), type2 !== void 0 && type2 === "chapter" /* Chapter */ && /* @__PURE__ */ React121.createElement(AdventureSelectionComponent, {
    adventures,
    setAdventurePath: setParentPath
  }), type2 !== void 0 && /* @__PURE__ */ React121.createElement("div", {
    className: "max-w-md"
  }, /* @__PURE__ */ React121.createElement("div", {
    className: "font-bold"
  }, t2("name")), /* @__PURE__ */ React121.createElement("input", {
    onKeyDown: handleKeyDown,
    ref: inputRef,
    type: "text",
    defaultValue: name != null ? name : "",
    placeholder: t2("name"),
    onChange: (e2) => setName(e2.target.value),
    className: "w-full"
  }), error2 && /* @__PURE__ */ React121.createElement("div", null, error2)))), /* @__PURE__ */ React121.createElement("div", {
    className: "flex justify-end pt-5"
  }, /* @__PURE__ */ React121.createElement("button", {
    className: "rpgm-secondary pl-3 pr-3 mr-6",
    onClick: closeModal
  }, t2("buttons.cancel")), hasWizard && /* @__PURE__ */ React121.createElement("button", {
    className: "rpgm-primary pl-3 pr-3 ml-3",
    onClick: () => createElement133(true)
  }, t2("buttons.launchwizard")), /* @__PURE__ */ React121.createElement("button", {
    className: "rpgm-primary pl-3 pr-3 ml-3 mr-5",
    onClick: () => createElement133(false)
  }, t2("buttons.create"))));
}

// src/components/creation/CreationComponent.tsx
function CreationComponent({
  type: type2,
  currentNote,
  controller,
  close
}) {
  const api2 = useApi();
  const app = useApp();
  const [inWizard, setInWizard] = React122.useState(false);
  const [selectedType, setSelectedType] = React122.useState(type2);
  const [name, setName] = React122.useState(void 0);
  const [system, setSystem] = React122.useState(void 0);
  const [campaignPath, setCampaignPath] = React122.useState(void 0);
  const [parentPath, setParentPath] = React122.useState(void 0);
  const [positionInParent, setPositionInParent] = React122.useState(void 0);
  const [template, setTemplate] = React122.useState(void 0);
  function setId(launchWizard, passedType, passedName, passedSystem, passedCampaignPath, passedParentPath, passedPositionInParent, passedTemplate) {
    return __async(this, null, function* () {
      if (launchWizard) {
        setSelectedType(passedType);
        setName(passedName);
        setSystem(passedSystem);
        setCampaignPath(passedCampaignPath);
        if (passedParentPath)
          setParentPath(passedParentPath);
        if (passedPositionInParent)
          setPositionInParent(passedPositionInParent);
        if (passedTemplate)
          setTemplate(passedTemplate);
        setInWizard(true);
      } else {
        create4(void 0, passedType, passedName, passedSystem, passedCampaignPath, passedParentPath, passedPositionInParent, passedTemplate);
      }
    });
  }
  function setData(attributes3) {
    return __async(this, null, function* () {
      create4(attributes3);
    });
  }
  function create4(attributes3, passedType, passedName, passedSystem, passedCampaignPath, passedParentPath, passedPositionInParent, passedTemplate) {
    return __async(this, null, function* () {
      const fileCreator = new FileCreationService(app, api2, passedType != null ? passedType : selectedType, passedName != null ? passedName : name, passedSystem != null ? passedSystem : system, passedCampaignPath != null ? passedCampaignPath : campaignPath, passedParentPath != null ? passedParentPath : parentPath, passedPositionInParent != null ? passedPositionInParent : positionInParent, attributes3, void 0, passedTemplate != null ? passedTemplate : template);
      if (currentNote !== void 0) {
        fileCreator.createInCurrentFile(currentNote).then((newFile) => {
          controller.close();
        });
      } else {
        fileCreator.create(true).then((newFile) => {
          controller.close();
        });
      }
    });
  }
  let wizardTypeComponent = void 0;
  switch (selectedType) {
    case "chapter" /* Chapter */:
      wizardTypeComponent = React122.createElement(ChapterWizardComponent, {
        element: void 0,
        name,
        campaign: api2.get(campaignPath),
        close: void 0,
        returnData: setData
      });
      break;
    case "nonplayercharacter" /* NonPlayerCharacter */:
      wizardTypeComponent = React122.createElement(NonPlayerCharacterWizardComponent, {
        element: void 0,
        name,
        campaign: api2.get(campaignPath),
        close: void 0,
        returnData: setData
      });
      break;
  }
  const wizardComponent = wizardTypeComponent !== void 0 ? React122.createElement(WizardContext.Provider, { value: {} }, wizardTypeComponent) : void 0;
  if (inWizard && wizardComponent !== void 0) {
    return wizardComponent;
  }
  return /* @__PURE__ */ React122.createElement(CreationBaseComponent, {
    initialType: selectedType,
    currentNote,
    setId,
    hasWizard: wizardComponent !== void 0,
    closeModal: close
  });
}

// src/controllers/ModalCreationController.ts
var ModalCreationController = class extends import_obsidian6.Modal {
  constructor(_app, _api, _type, _addToCurrentNote = false) {
    super(_app);
    this._app = _app;
    this._api = _api;
    this._type = _type;
    this._addToCurrentNote = _addToCurrentNote;
    this.scope = new import_obsidian6.Scope();
    this.scope.register([], "Escape", (evt) => {
      evt.preventDefault();
    });
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    const root3 = (0, import_client3.createRoot)(contentEl);
    this.modalEl.style.width = "var(--modal-max-width)";
    let file = void 0;
    if (this._addToCurrentNote)
      file = this._app.workspace.getActiveFile();
    const creationComponent = (0, import_react26.createElement)(CreationComponent, {
      type: this._type,
      currentNote: file,
      controller: this,
      close: this.close.bind(this)
    });
    const reactComponent = (0, import_react26.createElement)(AppContext.Provider, { value: this._app }, (0, import_react26.createElement)(ApiContext.Provider, { value: this._api }, creationComponent));
    root3.render(reactComponent);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    super.onClose();
  }
};

// src/services/PluginServices.ts
var PluginServices = class {
  static createView(app) {
    return __async(this, null, function* () {
      app.workspace.detachLeavesOfType("rpg-manager-options");
      yield app.workspace.getRightLeaf(false).setViewState({
        type: "rpg-manager-options",
        active: true
      });
      const leaf = app.workspace.getLeavesOfType("rpg-manager-options")[0];
      const view = leaf.view;
      app.workspace.revealLeaf(leaf);
      view.render();
    });
  }
  static registerProcessors(app, rpgm) {
    return __async(this, null, function* () {
      rpgm.registerMarkdownCodeBlockProcessor("RpgManager4", (source, el, ctx) => __async(this, null, function* () {
        ctx.addChild(new Controller(app, rpgm, ctx.sourcePath, el, source));
      }));
    });
  }
  static registerEvents(app, rpgm, database) {
    return __async(this, null, function* () {
      app.workspace.on("active-leaf-change", (leaf) => {
        app.workspace.trigger("rpgmanager:refresh-option-view");
        if (TimerService.runningScene === void 0)
          return;
        let sceneFound = false;
        app.workspace.iterateAllLeaves((leaf2) => {
          var _a;
          if (leaf2.view instanceof import_obsidian7.MarkdownView) {
            const file = (_a = leaf2.view) == null ? void 0 : _a.file;
            if (file !== void 0 && file.path === TimerService.runningScene)
              sceneFound = true;
          }
        });
        if (!sceneFound)
          TimerService.endTimer(app, rpgm);
      });
      rpgm.registerEvent(app.metadataCache.on("resolve", (file) => {
        const element4 = rpgm.get(file.path);
        if (element4 === void 0 || Array.isArray(element4)) {
          DatabaseFactory.add(app, rpgm, database, file).then((elements) => {
            database = elements;
            ElementFactory.updateFileRelationships(app, rpgm, file, database);
            app.workspace.trigger("rpgmanager:refresh-views");
          });
        } else {
          DatabaseFactory.update(app, rpgm, database, element4).then(() => {
            ElementFactory.updateFileRelationships(app, rpgm, file, database);
            const { editor, cursorPosition, scrollInfo } = EditorPositionService.getEditorPositions(file.path) || {};
            if (editor && cursorPosition && scrollInfo) {
              editor.scrollTo(scrollInfo.left, scrollInfo.top);
              EditorPositionService.clearEditorPosition(file.path);
            }
            app.workspace.trigger("rpgmanager:refresh-views");
          });
        }
      }));
      rpgm.registerEvent(app.vault.on("rename", (file, oldPath) => {
        const element4 = rpgm.get(file.path);
        if (element4 === void 0 || Array.isArray(element4))
          return;
        DatabaseFactory.rename(app, rpgm, database, element4, oldPath).then(() => {
          element4.touch();
          app.workspace.trigger("rpgmanager:refresh-views");
        });
      }));
      rpgm.registerEvent(app.vault.on("delete", (file) => {
        database = database.filter((element4) => element4.path !== file.path);
      }));
      rpgm.registerEvent(app.workspace.on("file-open", (file) => {
        app.workspace.trigger("rpgmanager:refresh-views");
      }));
    });
  }
  static registerCommands(app, rpgm) {
    return __async(this, null, function* () {
      rpgm.addCommand({
        id: "rpg-manager-create-select",
        name: instance.t("create.new", { context: "element" }),
        callback: () => {
          new ModalCreationController(app, rpgm).open();
        }
      });
      rpgm.addCommand({
        id: "rpg-manager-create-in-select",
        name: instance.t("create.in", { context: "element" }),
        callback: () => {
          new ModalCreationController(app, rpgm, void 0, true).open();
        }
      });
      Object.keys(ElementType).filter((v) => isNaN(Number(v))).forEach((type2, index2) => {
        rpgm.addCommand({
          id: "rpg-manager-create-" + type2.toLowerCase(),
          name: instance.t("create.new", { context: type2.toLowerCase() }),
          callback: () => {
            new ModalCreationController(app, rpgm, ElementType[type2]).open();
          }
        });
        rpgm.addCommand({
          id: "rpg-manager-create-in-" + type2.toLowerCase(),
          name: instance.t("create.in", { context: type2.toLowerCase() }),
          callback: () => {
            new ModalCreationController(app, rpgm, ElementType[type2], true).open();
          }
        });
      });
    });
  }
};

// src/services/UpdaterService/CustomAttributesUpdater.ts
var CustomAttribtuesUpdater = class {
  static update(app, api2) {
    return __async(this, null, function* () {
      const campaigns = api2.get().filter((element4) => element4.type === "campaign" /* Campaign */);
      if (campaigns.length === 0)
        return;
      const campaignFiles = campaigns.map((campaign) => campaign.file);
      const customAttributesContainerPromises = campaignFiles.map((campaignFile) => __async(this, null, function* () {
        const codeblockService = new RpgManagerCodeblockService(app, api2, campaignFile);
        const codeblock = yield codeblockService.readCodeblock();
        if (!codeblock)
          return void 0;
        if (!codeblock.attributes || codeblock.attributes.length === 0)
          return void 0;
        return codeblock.attributes.map((customAttribute) => {
          return __spreadProps(__spreadValues({}, customAttribute), { isCustom: true });
        });
      }));
      const customAttributesContainer = yield Promise.all(customAttributesContainerPromises);
      const customAttributes = customAttributesContainer.flat().filter(Boolean);
      if (customAttributes.length === 0)
        return;
      api2.settings = __spreadValues(__spreadValues({}, api2.settings), { customAttributes });
      yield api2.saveData(api2.settings);
      campaignFiles.map((campaignFile) => __async(this, null, function* () {
        const codeblockService = new RpgManagerCodeblockService(app, api2, campaignFile);
        const codeblock = yield codeblockService.readCodeblock();
        if (!codeblock)
          return;
        if (!codeblock.attributes || codeblock.attributes.length === 0)
          return;
        codeblockService.deleteAttributes();
      }));
    });
  }
};

// src/services/UpdaterService/views/UpdaterView.ts
var import_obsidian9 = require("obsidian");
var import_react27 = __toESM(require_react());
var import_client4 = __toESM(require_client());

// src/services/UpdaterService/components/UpdaterComponent.tsx
var React123 = __toESM(require_react());

// src/services/UpdaterService/UpdaterService.ts
var import_obsidian8 = require("obsidian");
var UpdaterService = class {
  constructor(_app, _updateView) {
    this._app = _app;
    this._updateView = _updateView;
    __publicField(this, "_total", 0);
    __publicField(this, "_current", 0);
    __publicField(this, "_elementsMap");
    __publicField(this, "_newElements");
    this._elementsMap = /* @__PURE__ */ new Map();
    this._newElements = /* @__PURE__ */ new Map();
  }
  updateVault() {
    return __async(this, null, function* () {
      const allFiles = this._app.vault.getFiles();
      this._total = allFiles.length;
      this._updateView(this._total, this._current, "Reading files...");
      yield Promise.all(allFiles.map((file) => __async(this, null, function* () {
        this._current++;
        this._updateView(this._total, this._current, "Reading files...");
        yield this._readCodeblocks(file);
      })));
      this._total = this._elementsMap.size;
      this._current = 0;
      this._updateView(this._total, this._current, "Converting RPG Manager Elements...");
      yield Promise.all(Array.from(this._elementsMap.entries()).map((value) => __async(this, null, function* () {
        this._current++;
        this._updateView(this._total, this._current, "Converting RPG Manager Elements...");
        const codeblock = {
          id: this._convertId(value[0], value[1]),
          data: this._convertData(value[0], value[1]),
          relationships: this._convertRelationships(value[0], value[1]),
          images: this._convertImages(value[0], value[1])
        };
        if (codeblock.images.length === 0)
          delete codeblock.images;
        if (codeblock.relationships.length === 0)
          delete codeblock.relationships;
        this._newElements.set(value[1].file, codeblock);
      })));
      this._current = 0;
      this._updateView(this._total, this._current, "Updating files...");
      yield Promise.all(Array.from(this._newElements.entries()).map((value) => __async(this, null, function* () {
        yield this._replaceCodeblock(value[0], value[1]);
        this._current++;
        return this._updateView(this._total, this._current, "Updating files...");
      })));
    });
  }
  _convertId(id, data) {
    const type2 = this._getType(data.metadata.ID.type);
    const idData = {
      type: type2
    };
    if (type2 !== "campaign" /* Campaign */) {
      const campaignData = this._elementsMap.get(data.metadata.ID.campaignId);
      if (type2 === "adventure" /* Adventure */ || type2 === "session" /* Session */ || type2 === "chapter" /* Chapter */) {
        const parentData = this._elementsMap.get(data.metadata.ID.parentId);
        if (parentData !== void 0) {
          idData.parent = parentData.file.path;
          idData.positionInParent = data.metadata.ID.positionInParent;
        }
      } else if (type2 === "scene" /* Scene */) {
        let parentData;
        if (data.metadata.data.data.sessionId !== void 0)
          parentData = this._elementsMap.get(data.metadata.data.data.sessionId);
        if (data.metadata.data.data.positionInSession !== void 0)
          idData.positionInParent = data.metadata.data.data.positionInSession;
        if (parentData === void 0)
          parentData = this._elementsMap.get(data.metadata.ID.parentId);
        if (parentData !== void 0) {
          idData.parent = parentData.file.path;
          if (idData.positionInParent === void 0)
            idData.positionInParent = data.metadata.ID.positionInParent;
        }
      }
      if (campaignData !== void 0)
        idData.campaign = campaignData.file.path;
    }
    return idData;
  }
  _convertData(id, data) {
    var _a, _b, _c, _d;
    const response = {};
    const oldData = data.metadata.data.data;
    for (const key in oldData) {
      if (oldData.hasOwnProperty(key) && oldData[key]) {
        switch (key.toLocaleLowerCase()) {
          case "synopsis":
            if (response.description === void 0) {
              response.description = oldData[key];
            } else {
              response.description = oldData[key] + "\n\n" + response.description;
            }
            break;
          case "irl":
            response.sessiondate = oldData[key];
            break;
          case "abtstage":
            response.abtstage = oldData[key].toLowerCase();
            break;
          case "date":
            response.date = oldData[key];
            break;
          case "duration":
            response.duration = oldData[key];
            break;
          case "action":
            response.action = oldData[key];
            break;
          case "isactedupon":
            response.externalactions = oldData[key];
            break;
          case "scenetype":
            response.scenetype = oldData[key];
            break;
          case "storycirclestage":
            response.storycirclestage = oldData[key].toLowerCase();
            break;
          case "trigger":
            if (response.description === void 0) {
              response.description = oldData[key];
            } else {
              response.description += "\n\n" + oldData[key];
            }
            break;
          case "dob":
            response.dob = oldData[key];
            break;
          case "death":
            response.dod = oldData[key];
            break;
          case "pronoun":
            response.pronoun = oldData[key];
            break;
          case "address":
            response.address = oldData[key];
            break;
          case "targetduration":
            response.targetDuration = oldData[key];
            break;
          case "images":
          case "sessionid":
          case "durations":
          case "positioninsession":
          case "completed":
          case "complete":
            break;
          default:
            response["FromV3-" + key] = oldData[key];
            break;
        }
      }
    }
    if (((_a = data.metadata.data) == null ? void 0 : _a.plot) !== void 0 && ((_b = data.metadata.data.plot) == null ? void 0 : _b.storycircle) !== void 0) {
      const storycircle2 = data.metadata.data.plot.storycircle;
      if (storycircle2.you || storycircle2.need || storycircle2.go || storycircle2.search || storycircle2.find || storycircle2.take || storycircle2.return || storycircle2.change)
        response.storycircle = data.metadata.data.plot.storycircle;
    }
    if (((_c = data.metadata.data) == null ? void 0 : _c.plot) !== void 0 && ((_d = data.metadata.data.plot) == null ? void 0 : _d.abt) !== void 0) {
      const abt = data.metadata.data.plot.abt;
      if (abt.need || abt.and || abt.but || abt.therefore) {
        if (response.description === void 0)
          response.description = "";
        response.description += "\n\nNeed: " + abt.need;
        response.description += "\n\nAnd: " + abt.and;
        response.description += "\n\nBut: " + abt.but;
        response.description += "\n\nTherefore: " + abt.therefore;
      }
    }
    return response;
  }
  _convertImages(id, data) {
    var _a, _b;
    const response = [];
    const images = (_b = (_a = data.metadata.data) == null ? void 0 : _a.data) == null ? void 0 : _b.images;
    if (images === void 0 || !Array.isArray(images) || images.length === 0)
      return response;
    images.forEach((image2) => {
      const newImage = {
        path: image2.path
      };
      if (image2.description !== void 0)
        newImage.description = image2.description;
      response.push(newImage);
    });
    return response;
  }
  _convertRelationships(id, data) {
    var _a;
    const response = [];
    const relationships = (_a = data.metadata.data) == null ? void 0 : _a.relationships;
    if (relationships === void 0 || !Array.isArray(relationships) || relationships.length === 0)
      return response;
    relationships.forEach((relationship) => {
      const newRelationship = {
        path: relationship.path,
        type: relationship.type
      };
      if (relationship.description)
        newRelationship.description = relationship.description;
      response.push(newRelationship);
    });
    return response;
  }
  _getType(typeId) {
    switch (typeId) {
      case 1:
        return "campaign" /* Campaign */;
      case 2:
        return "adventure" /* Adventure */;
      case 4:
        return "chapter" /* Chapter */;
      case 8:
        return "scene" /* Scene */;
      case 16:
        return "session" /* Session */;
      case 32:
        return "playercharacter" /* PlayerCharacter */;
      case 64:
        return "nonplayercharacter" /* NonPlayerCharacter */;
      case 128:
        return "location" /* Location */;
      case 256:
        return "event" /* Event */;
      case 512:
        return "clue" /* Clue */;
      case 1024:
        return "faction" /* Faction */;
      case 4096:
        return "subplot" /* Subplot */;
    }
  }
  _replaceCodeblock(file, codeblock) {
    return __async(this, null, function* () {
      const metadata = this._app.metadataCache.getFileCache(file);
      if (metadata === null || metadata.sections == void 0 || metadata.sections.length === 0)
        return;
      let content3 = yield this._app.vault.read(file);
      const lines = content3.split("\n");
      let codeblockData = void 0;
      const yamlService = new YamlService();
      for (let index2 = 0; index2 < metadata.sections.length; index2++) {
        codeblockData = metadata.sections[index2];
        let type2 = "";
        if (codeblockData !== void 0 && (lines[codeblockData.position.start.line] === "```RpgManagerData" || lines[codeblockData.position.start.line] === "```RpgManagerID" || lines[codeblockData.position.start.line] === "```RpgManager")) {
          switch (lines[codeblockData.position.start.line]) {
            case "```RpgManagerData":
              type2 = "data";
              break;
            case "```RpgManagerID":
              type2 = "ID";
              break;
            case "```RpgManager":
              type2 = "codeblock";
              break;
          }
          let codeblockContent = "";
          for (let lineIndex = codeblockData.position.start.line + 1; lineIndex < codeblockData.position.end.line; lineIndex++) {
            codeblockContent += lines[lineIndex] + "\n";
          }
          if (codeblockContent !== void 0) {
            switch (type2) {
              case "data":
                content3 = content3.replace("```RpgManagerData\n" + codeblockContent, "\n```RpgManager4\n" + yamlService.stringify(codeblock));
                break;
              case "ID":
                content3 = content3.replace("```RpgManagerID\n" + codeblockContent + "```\n", "");
                content3 = content3.replace("```RpgManagerID\n" + codeblockContent + "```", "");
                break;
              case "codeblock":
                content3 = content3.replace("```RpgManager\n" + codeblockContent + "```\n", "");
                content3 = content3.replace("```RpgManager\n" + codeblockContent + "```", "");
                break;
            }
          }
          content3 = content3.replace(/\[\[.*?\|\]\]\n/g, "");
          content3 = content3.replace(/\[\[.*?\|\]\]/g, "");
        }
      }
      yield this._app.vault.modify(file, content3);
    });
  }
  _readCodeblocks(file) {
    return __async(this, null, function* () {
      var _a;
      const metadata = this._app.metadataCache.getFileCache(file);
      if (metadata === null || metadata.sections == void 0 || metadata.sections.length === 0)
        return;
      const content3 = yield this._app.vault.read(file);
      const lines = content3.split("\n");
      let codeblockContent = void 0;
      let codeblockData = void 0;
      const data = {
        file,
        metadata: {
          ID: {},
          data: {}
        }
      };
      let id = void 0;
      for (let index2 = 0; index2 < metadata.sections.length; index2++) {
        codeblockData = metadata.sections[index2];
        let type2 = void 0;
        if (codeblockData !== void 0 && (lines[codeblockData.position.start.line] === "```RpgManagerData" || lines[codeblockData.position.start.line] === "```RpgManagerID")) {
          type2 = lines[codeblockData.position.start.line] === "```RpgManagerData" ? "data" : "ID";
          codeblockContent = "";
          for (let lineIndex = codeblockData.position.start.line + 1; lineIndex < codeblockData.position.end.line; lineIndex++) {
            if (type2 === "ID" && lines[lineIndex].trim().startsWith("id:")) {
              id = lines[lineIndex].trim().split(":")[1].trim().replaceAll('"', "");
            }
            codeblockContent += lines[lineIndex] + "\n";
          }
          if (codeblockContent !== void 0) {
            data.metadata[type2] = (_a = yield (0, import_obsidian8.parseYaml)(codeblockContent)) != null ? _a : {};
          }
        }
      }
      if (id !== void 0) {
        this._elementsMap.set(id, data);
      }
    });
  }
};

// src/services/UpdaterService/components/UpdaterComponent.tsx
function Upgrading() {
  const api2 = useApi();
  const app = useApp();
  const [total, setTotal] = React123.useState(0);
  const [processed, setProcessed] = React123.useState(0);
  const [process2, setProcess] = React123.useState(void 0);
  const [message, setMessage] = React123.useState(void 0);
  const updateViewRef = React123.useRef();
  updateViewRef.current = (total2, processed2, process3) => {
    setTotal(total2);
    setProcessed(processed2);
    setProcess(process3);
  };
  React123.useEffect(() => {
    const updateView = (total2, processed2, process3) => {
      var _a;
      (_a = updateViewRef.current) == null ? void 0 : _a.call(updateViewRef, total2, processed2, process3);
    };
    const updater = new UpdaterService(app, updateView);
    updater.updateVault().then(() => {
      const settings = {
        chatGptKey: void 0,
        templatesFolder: api2.settings.templateFolder,
        assetsFolder: api2.settings.imagesFolder,
        automaticMove: false,
        useSceneAnalyser: true,
        version: api2.version,
        customAttributes: [],
        forceFullWidth: false
      };
      api2.saveData(settings);
      setTotal(void 0);
      setProcessed(void 0);
      setProcess(void 0);
      setMessage("**Upgrade completed**.\n\nObsidian is currently re-indexing your vault.\n\nPlease wait a minute then restart Obsidian to enjoy the new RPG Manager!");
    });
  }, []);
  return /* @__PURE__ */ React123.createElement("div", null, total && /* @__PURE__ */ React123.createElement("div", null, "total: ", total), processed && /* @__PURE__ */ React123.createElement("div", null, "processed: ", processed), process2 && /* @__PURE__ */ React123.createElement("div", null, "process: ", process2), message && /* @__PURE__ */ React123.createElement("div", null, /* @__PURE__ */ React123.createElement(MarkdownComponent, {
    value: message
  })));
}
function UpdaterComponent() {
  const [upgrading, setUpgrading] = React123.useState(false);
  return /* @__PURE__ */ React123.createElement("div", {
    className: "relative"
  }, /* @__PURE__ */ React123.createElement("div", {
    className: "flex flex-col m-3"
  }, /* @__PURE__ */ React123.createElement("h1", {
    className: "text-[--text-error] text-4xl font-bold mt-3 mb-3"
  }, "RPG Manager WARNING!"), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "RPG Manager has been updated to ", /* @__PURE__ */ React123.createElement("strong", null, "Version 4.0"), " that is ", /* @__PURE__ */ React123.createElement("strong", null, "incompatible"), " with the version previously installed in your vault!"), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "Previous versions are not supported any longer"), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "Currently, your campaigns have been disabled."), /* @__PURE__ */ React123.createElement("h2", {
    className: "text-3xl mt-3 mb-3"
  }, "What can you do?"), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "Currently you have two options to proceed:"), /* @__PURE__ */ React123.createElement("ol", {
    className: "list-decimal list-inside"
  }, /* @__PURE__ */ React123.createElement("li", null, "Revert to Version 3"), /* @__PURE__ */ React123.createElement("li", null, "Upgrade your campaigns to Version 4")), /* @__PURE__ */ React123.createElement("h3", {
    className: "text-2xl mt-3 mb-3"
  }, "Revert to Version 3"), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "Reverting RPG Manager to version 3 is possible through the BRAT plugin. If you decide to go down this route, you will be able to use RPG Manager as always. You will not receive any further updates, but your campaigns will work and look as they always have."), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "If you decide to revert to Version 3, you will have to:"), /* @__PURE__ */ React123.createElement("ol", {
    className: "list-decimal list-inside"
  }, /* @__PURE__ */ React123.createElement("li", null, /* @__PURE__ */ React123.createElement("strong", null, "Install BRAT"), ': To install the BRAT plugin, open "', /* @__PURE__ */ React123.createElement("em", null, "Obsidian Preferences"), '"", head to "', /* @__PURE__ */ React123.createElement("em", null, "Community Plugins"), '" and click "', /* @__PURE__ */ React123.createElement("em", null, "Browse"), '". Search for "', /* @__PURE__ */ React123.createElement("em", null, "Obsidian42 - BRAT"), '", install it and enable it.'), /* @__PURE__ */ React123.createElement("li", null, /* @__PURE__ */ React123.createElement("strong", null, "Add Beta plugin with frozen version"), ': Once BRAT is installed and active, go in the Obsidian42 - BRAT Options and click the button "', /* @__PURE__ */ React123.createElement("em", null, "Add Beta plugin with frozen version"), '".'), /* @__PURE__ */ React123.createElement("li", null, /* @__PURE__ */ React123.createElement("strong", null, "Add version 3.4.5 of RPG Manager"), ': In the field "', /* @__PURE__ */ React123.createElement("em", null, "Github repository for beta plugin"), '" add "', /* @__PURE__ */ React123.createElement("strong", null, "carlonicora/obsidian-rpg-manager"), '" and in the field "', /* @__PURE__ */ React123.createElement("em", null, "Specify the release version tag"), '" add "', /* @__PURE__ */ React123.createElement("strong", null, "3.4.5"), '".'), /* @__PURE__ */ React123.createElement("li", null, /* @__PURE__ */ React123.createElement("strong", null, "Restart Obsidian"))), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "This procedure will install Version 3.4.5 of RPG Manager and will instruct Obsidian not to upgrade to version 4."), /* @__PURE__ */ React123.createElement("p", null, "If, in the future, you'd like to upgrade to Version 4, Open the BRAT Settings and remove RPG Manager from the plugins. Go on the Community Plugins and upgrade RPG Manager."), /* @__PURE__ */ React123.createElement("h3", {
    className: "text-2xl mt-3 mb-3"
  }, "Upgrade your campaigns to Version 4"), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "Upgrading your campaigns to Version 4 of RPG Manager will align your campaigns to the new RPG Manager, you will have access to the new data strucure and user interface; however, you will have to run through the update process for your data. The update process may change some of the information in your campaigns, and it is never a bug-free solution."), /* @__PURE__ */ React123.createElement("p", null, /* @__PURE__ */ React123.createElement("em", null, "Please keep in mind that RPG Manager comes as-is, with no guarantee of bug-free upgrade proces. Upgrade at your own risk, especially if you skip #1")), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "If you decide to upgrade your campaigns, you will have to:"), /* @__PURE__ */ React123.createElement("ol", {
    className: "list-decimal list-inside"
  }, /* @__PURE__ */ React123.createElement("li", null, /* @__PURE__ */ React123.createElement("strong", null, "Backup your current vault"), ": Please keep in mind this is a vital step to avoid any data loss. Just go in your filesystem and make a copy of your current vault. If anything go south, you can restore your backup!"), /* @__PURE__ */ React123.createElement("li", null, "Start the upgrade process by clicking on the ", /* @__PURE__ */ React123.createElement("strong", null, "Upgrade"), " button below")), /* @__PURE__ */ React123.createElement("p", {
    className: "mt-2 mb-2"
  }, "The process might take some time to complete, depending on the size of your vault. Once completed, you will have to restart Obsidian for your campaigns to be loaded."), /* @__PURE__ */ React123.createElement("button", {
    className: "rpgm-danger",
    onClick: () => setUpgrading(true)
  }, "I am ready! I have backed up my vault! upgrade my vault to Version 4")), upgrading && /* @__PURE__ */ React123.createElement(React123.Fragment, null, /* @__PURE__ */ React123.createElement("div", {
    className: "fixed inset-0 bg-gray-900 bg-opacity-75"
  }), /* @__PURE__ */ React123.createElement("div", {
    className: "fixed inset-0 flex justify-center items-center"
  }, /* @__PURE__ */ React123.createElement("div", {
    className: "bg-white p-10 rounded-lg"
  }, /* @__PURE__ */ React123.createElement(Upgrading, null)))));
}

// src/services/UpdaterService/views/UpdaterView.ts
var UpdaterView = class extends import_obsidian9.ItemView {
  constructor(_app, _api, leaf) {
    super(leaf);
    this._app = _app;
    this._api = _api;
    __publicField(this, "viewType", "rpg-manager-updater");
    __publicField(this, "displayText", "Update RPG Manager");
    __publicField(this, "icon", "d20");
    __publicField(this, "_element");
    __publicField(this, "_root");
    this._root = (0, import_client4.createRoot)(this.contentEl);
  }
  getViewType() {
    return this.viewType;
  }
  onResize() {
    super.onResize();
    this.render();
  }
  getDisplayText() {
    return this.displayText;
  }
  onOpen() {
    return __async(this, null, function* () {
      this.render();
    });
  }
  render() {
    return __async(this, null, function* () {
      const elementComponent = (0, import_react27.createElement)(UpdaterComponent);
      const reactComponent = (0, import_react27.createElement)(AppContext.Provider, { value: this._app }, (0, import_react27.createElement)(ApiContext.Provider, { value: this._api }, elementComponent));
      this._root.render(reactComponent);
    });
  }
};

// src/services/taskService/TaskService.ts
var taskService = class {
  constructor(database) {
    __publicField(this, "_database", []);
    if (database !== void 0)
      this._database = database;
  }
  getAll(notAlreadyMentionedIn) {
    const response = [];
    if (this._database === void 0)
      return response;
    this._database.forEach((element4) => {
      response.push(...element4.tasks);
    });
    if (notAlreadyMentionedIn !== void 0)
      return response.filter((task) => task.mentionedIn === void 0 || !task.mentionedIn.contains(notAlreadyMentionedIn.path) && task.element.path !== notAlreadyMentionedIn.path);
    return response;
  }
  getByStatus(status, notAlreadyMentionedIn) {
    return this.getAll(notAlreadyMentionedIn).filter((task) => task.status === status);
  }
  getByElement(element4) {
    return this.getAll().filter((task) => task.element.path === element4.path);
  }
  getCompletedIn(element4) {
    return this.getAll().filter((task) => {
      var _a;
      return ((_a = task.completedIn) == null ? void 0 : _a.path) === element4.path;
    });
  }
  getMentionedIn(element4) {
    return this.getAll().filter((task) => task.mentionedIn !== void 0 && task.mentionedIn.contains(element4.path));
  }
};

// src/settings/RpgManagerSettings.ts
var import_obsidian10 = require("obsidian");
var rpgManagerDefaultSettings = {
  chatGptKey: void 0,
  templatesFolder: void 0,
  assetsFolder: void 0,
  automaticMove: false,
  useSceneAnalyser: true,
  version: "0.0.0",
  customAttributes: [],
  forceFullWidth: true
};
var RpgManagerSettings = class extends import_obsidian10.PluginSettingTab {
  constructor(_app, _plugin) {
    super(_app, _plugin);
    this._app = _app;
    this._plugin = _plugin;
    __publicField(this, "_folderMap");
    const { containerEl } = this;
    this.containerEl = containerEl;
  }
  saveSettings(changed) {
    return __async(this, null, function* () {
      this._plugin.settings = __spreadValues(__spreadValues({}, this._plugin.settings), changed);
      yield this._plugin.saveData(this._plugin.settings);
      this._app.workspace.trigger("rpgmanager:refresh-views");
    });
  }
  display() {
    this._createFolderMap();
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Rpg Manager Settings" });
    const mainDesc = containerEl.createEl("p");
    mainDesc.addClass("mb-3");
    mainDesc.appendText("For help or support, refer to ");
    mainDesc.appendChild(createEl("a", {
      text: "github",
      href: "https://github.com/carlonicora/obsidian-rpg-manager"
    }));
    mainDesc.appendText(" or join the ");
    mainDesc.appendChild(createEl("a", {
      text: "discord support thread",
      href: "https://discord.com/channels/686053708261228577/1022806716343144518"
    }));
    containerEl.createEl("h3", { text: "Main Options" });
    new import_obsidian10.Setting(containerEl).setName("Templates Folder").setDesc("To use custom templates, select the folder that contains them.").addDropdown((dropdown) => {
      dropdown.addOption("", "");
      this._folderMap.forEach((value, display) => {
        dropdown.addOption(value, display);
      });
      dropdown.setValue(this._plugin.settings.templatesFolder);
      dropdown.onChange((value) => __async(this, null, function* () {
        yield this.saveSettings({ templatesFolder: value });
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Keep Element Organised").setDesc("Automatically move new elements in subfolders of their campaign.").addToggle((toggle) => {
      toggle.setValue(this._plugin.settings.automaticMove).onChange((value) => __async(this, null, function* () {
        yield this.saveSettings({ automaticMove: value });
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Force Full Width").setDesc("Force the markdown editor to use the full width of the screen. This might clash with some themes.").addToggle((toggle) => {
      toggle.setValue(this._plugin.settings.forceFullWidth).onChange((value) => __async(this, null, function* () {
        yield this.saveSettings({ forceFullWidth: value });
        if (value === true)
          document.body.classList.add("rpgm-toggle-full-width-styles");
        else
          document.body.classList.remove("rpgm-toggle-full-width-styles");
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Image and Assets Folder").setDesc("Select the folder that contains the assets.").addDropdown((dropdown) => {
      dropdown.addOption("", "");
      this._folderMap.forEach((value, display) => {
        dropdown.addOption(value, display);
      });
      dropdown.setValue(this._plugin.settings.assetsFolder);
      dropdown.onChange((value) => __async(this, null, function* () {
        yield this.saveSettings({ assetsFolder: value });
      }));
    });
    new import_obsidian10.Setting(containerEl).setName("Scene Analyser").setDesc("Show the tool that helps you create balanced sessions.").addToggle((toggle) => {
      toggle.setValue(this._plugin.settings.useSceneAnalyser).onChange((value) => __async(this, null, function* () {
        yield this.saveSettings({ useSceneAnalyser: value });
      }));
    });
    containerEl.createEl("h3", { text: "ChatGPT", cls: "mt-3" });
    const ChatGPT = containerEl.createEl("p");
    ChatGPT.appendText("Set up all the add-ons for the plugin. ");
    const ChatGPTWarning = containerEl.createEl("p");
    ChatGPTWarning.appendChild(createEl("span", {
      text: "Please note: ChatGPT is a paid service, you need to have a key to use it. Also, some data from your vault will be sent to OpenAI.",
      cls: "text-[--text-warning]"
    }));
    new import_obsidian10.Setting(containerEl).setName("OpenAI Key").setDesc("Insert your OpenAI key here.").addText((text6) => text6.setPlaceholder("").setValue(this._plugin.settings.chatGptKey).onChange((value) => __async(this, null, function* () {
      yield this.saveSettings({ chatGptKey: value });
    })));
  }
  _createFolderMap(parent = void 0, indent = 0) {
    let folderList = [];
    if (parent != void 0) {
      folderList = parent.children.filter((file) => file instanceof import_obsidian10.TFolder);
    } else {
      this._folderMap = /* @__PURE__ */ new Map();
      folderList = this.app.vault.getRoot().children.filter((file) => file instanceof import_obsidian10.TFolder);
    }
    folderList.forEach((folder) => {
      if (folder.name !== "Campaigns") {
        this._folderMap.set(folder.path, folder.path);
        this._createFolderMap(folder, indent + 1);
      }
    });
  }
};

// src/components/options/OptionContainerComponent.tsx
var React133 = __toESM(require_react());

// src/components/creation/NewElementComponent.tsx
var React124 = __toESM(require_react());
function NewElementComponent({
  element: element4,
  file
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  return /* @__PURE__ */ React124.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 col-span-1 text-xs mb-3"
  }, file && !element4 && /* @__PURE__ */ React124.createElement("div", {
    className: "mb-3"
  }, /* @__PURE__ */ React124.createElement("h3", {
    className: "!mb-1 !text-xl !font-extralight mt-0"
  }, t2("create.in_title")), Object.values(ElementType).filter((v) => isNaN(Number(v))).map((type2, index2) => /* @__PURE__ */ React124.createElement("div", {
    className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] list-disc list-inside pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
    key: index2,
    onClick: () => new ModalCreationController(app, api2, type2, true).open()
  }, t2("elements." + type2, { count: 1 })))), /* @__PURE__ */ React124.createElement("h3", {
    className: "!mb-1 !text-xl !font-extralight mt-0"
  }, t2("create.title")), Object.values(ElementType).filter((v) => isNaN(Number(v))).map((type2, index2) => /* @__PURE__ */ React124.createElement("div", {
    className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] list-disc list-inside pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
    key: index2,
    onClick: () => new ModalCreationController(app, api2, type2).open()
  }, t2("elements." + type2, { count: 1 }))));
}

// src/components/options/OptionsViewComponent.tsx
var React132 = __toESM(require_react());

// src/controllers/CustomAttributesController.ts
var import_obsidian11 = require("obsidian");
var import_react28 = __toESM(require_react());
var import_client5 = __toESM(require_client());

// src/components/custom/CustomAttributesComponent.tsx
var React127 = __toESM(require_react());

// src/components/custom/CustomAttributeComponent.tsx
var React125 = __toESM(require_react());
function CustomAttributeComponent({
  attribute,
  onSaveAttribute
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const [name, setName] = React125.useState((attribute == null ? void 0 : attribute.customName) || "");
  const [type2, setType] = React125.useState(attribute == null ? void 0 : attribute.type);
  const [options, setOptions] = React125.useState((attribute == null ? void 0 : attribute.options) ? [...attribute.options, ""] : [""]);
  const [customTypes, setCustomTypes] = React125.useState((_a = attribute == null ? void 0 : attribute.customTypes) != null ? _a : []);
  const [errors, setErrors] = React125.useState({});
  const [canBeDeleted] = React125.useState(() => {
    if (!attribute)
      return false;
    return !api2.get().some((element4) => {
      var _a2;
      return ((_a2 = element4.attribute(attribute.id)) == null ? void 0 : _a2.isSet) === true;
    });
  });
  const handleCustomTypeChange = (value, checked) => {
    if (checked && !(customTypes == null ? void 0 : customTypes.includes(value))) {
      setCustomTypes((prev) => [...prev || [], value]);
    } else if (!checked) {
      setCustomTypes((prev) => (prev || []).filter((item) => item !== value));
    }
  };
  const handleOptionChange = (index2, value) => {
    const updatedOptions = [...options || []];
    updatedOptions[index2] = value;
    setOptions(updatedOptions);
    if (index2 === updatedOptions.length - 1 && value !== "") {
      setOptions([...updatedOptions, ""]);
    }
  };
  const validate = () => {
    const newErrors = {};
    if (!name)
      newErrors.name = "Name is required.";
    if (!type2)
      newErrors.type = "Type is required.";
    if (type2 === "Select" /* Select */) {
      const validOptions = options == null ? void 0 : options.filter((option) => option.trim() !== "");
      if (!validOptions || validOptions.length === 0)
        newErrors.options = "At least one valid option is required.";
    }
    if (!customTypes || customTypes.length === 0)
      newErrors.customTypes = "At least one element type must be selected.";
    if (name.includes('"') || name.includes("\\"))
      newErrors.name = "Double quotes or back slashes are not allowed.";
    if (options.some((option) => option.includes('"') || option.includes("\\")))
      newErrors.options = "Double quotes or back slashes are not allowed in options.";
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  const handleDelete = () => __async(this, null, function* () {
    var _a2, _b;
    const id = (_a2 = attribute == null ? void 0 : attribute.id) != null ? _a2 : "_" + (name == null ? void 0 : name.replace(/[^a-zA-Z0-9]/g, "").toLowerCase());
    const customAttributes = (_b = api2.settings.customAttributes) != null ? _b : [];
    const existingIndex = customAttributes.findIndex((attribute2) => attribute2.id === id);
    if (existingIndex !== -1) {
      customAttributes.splice(existingIndex, 1);
      api2.settings = __spreadProps(__spreadValues({}, api2.settings), { customAttributes });
      yield api2.saveData(api2.settings);
      onSaveAttribute();
    }
  });
  const handleSave = () => __async(this, null, function* () {
    var _a2, _b;
    if (!validate())
      return;
    const id = (_a2 = attribute == null ? void 0 : attribute.id) != null ? _a2 : "_" + (name == null ? void 0 : name.replace(/[^a-zA-Z0-9]/g, "").toLowerCase());
    const updatedAttribute = {
      customName: name,
      type: type2,
      id,
      isCustom: true
    };
    if (type2 === "Select" /* Select */) {
      const filteredOptions = options == null ? void 0 : options.filter((option) => option !== "");
      if (filteredOptions && filteredOptions.length) {
        updatedAttribute.options = filteredOptions;
      }
    }
    if (customTypes && customTypes.length) {
      updatedAttribute.customTypes = customTypes;
    }
    const customAttributes = (_b = api2.settings.customAttributes) != null ? _b : [];
    const existingIndex = customAttributes.findIndex((attribute2) => attribute2.id === updatedAttribute.id);
    if (existingIndex === -1) {
      customAttributes.push(updatedAttribute);
    } else {
      customAttributes[existingIndex] = updatedAttribute;
    }
    api2.settings = __spreadProps(__spreadValues({}, api2.settings), { customAttributes });
    yield api2.saveData(api2.settings);
    onSaveAttribute();
  });
  return /* @__PURE__ */ React125.createElement("div", {
    className: "w-full"
  }, /* @__PURE__ */ React125.createElement("h3", null, name !== "" ? name : "New Custom Attribute"), /* @__PURE__ */ React125.createElement("div", {
    className: `grid ${type2 === "Select" /* Select */ ? "grid-cols-3" : "grid-cols-2"} gap-4`
  }, /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("div", {
    className: "font-bold"
  }, t2("customattributes.name")), /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("input", {
    type: "text",
    value: name,
    onChange: (e2) => setName(e2.target.value)
  }), errors.name && /* @__PURE__ */ React125.createElement("div", {
    className: "text-[--text-error] text-sm"
  }, errors.name))), /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("div", {
    className: "font-bold"
  }, t2("customattributes.type")), /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("select", {
    defaultValue: type2,
    onChange: (e2) => setType(e2.target.value)
  }, /* @__PURE__ */ React125.createElement("option", null), /* @__PURE__ */ React125.createElement("option", {
    value: "Text" /* Text */
  }, t2("customattributes.text")), /* @__PURE__ */ React125.createElement("option", {
    value: "Number" /* Number */
  }, t2("customattributes.number")), /* @__PURE__ */ React125.createElement("option", {
    value: "Select" /* Select */
  }, t2("customattributes.option")), /* @__PURE__ */ React125.createElement("option", {
    value: "Boolean" /* Boolean */
  }, t2("customattributes.checkbox")), /* @__PURE__ */ React125.createElement("option", {
    value: "LongText" /* LongText */
  }, t2("customattributes.longtext")), /* @__PURE__ */ React125.createElement("option", {
    value: "Date" /* Date */
  }, t2("customattributes.date")), /* @__PURE__ */ React125.createElement("option", {
    value: "Link" /* Link */
  }, t2("customattributes.link"))), errors.type && /* @__PURE__ */ React125.createElement("div", {
    className: "text-[--text-error] text-sm"
  }, errors.type)))), type2 === "Select" /* Select */ && /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("div", {
    className: "font-bold"
  }, t2("customattributes.options")), /* @__PURE__ */ React125.createElement("div", null, (options || []).map((option, index2) => /* @__PURE__ */ React125.createElement("input", {
    key: index2,
    type: "text",
    value: option,
    onChange: (e2) => handleOptionChange(index2, e2.target.value),
    className: "mb-2"
  }))), errors.options && /* @__PURE__ */ React125.createElement("div", {
    className: "text-[--text-error] text-sm"
  }, errors.options))), /* @__PURE__ */ React125.createElement("div", null, /* @__PURE__ */ React125.createElement("div", {
    className: "font-bold"
  }, t2("customattributes.availableon")), /* @__PURE__ */ React125.createElement("div", null, Object.values(ElementType).map((type3) => /* @__PURE__ */ React125.createElement("label", {
    key: type3,
    className: "block"
  }, /* @__PURE__ */ React125.createElement("input", {
    type: "checkbox",
    checked: (customTypes == null ? void 0 : customTypes.includes(type3)) || false,
    onChange: (e2) => handleCustomTypeChange(type3, e2.target.checked)
  }), t2(`elements.${type3}`, { count: 2 })))), errors.customTypes && /* @__PURE__ */ React125.createElement("div", {
    className: "text-[--text-error] text-sm"
  }, errors.customTypes))), /* @__PURE__ */ React125.createElement("div", {
    className: "flex w-full justify-end"
  }, canBeDeleted === true ? /* @__PURE__ */ React125.createElement("button", {
    className: "rpgm-danger",
    onClick: handleDelete
  }, t2("buttons.delete")) : /* @__PURE__ */ React125.createElement("button", {
    className: "text-[--text-faint] cursor-not-allowed",
    disabled: true,
    title: t2("customattributes.cantdelete")
  }, t2("buttons.delete")), /* @__PURE__ */ React125.createElement("button", {
    className: "rpgm-primary",
    onClick: handleSave
  }, t2("buttons.save"))));
}

// src/components/custom/CustomAttributeListComponent.tsx
var React126 = __toESM(require_react());
function CustomAttributeListComponent({
  element: element4,
  setAttribute,
  setNewAttribute
}) {
  var _a;
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  let customAttributes = (_a = api2.settings.customAttributes) != null ? _a : [];
  customAttributes = customAttributes.filter((customAttribute) => customAttribute.customTypes.contains(element4.type));
  return /* @__PURE__ */ React126.createElement(React126.Fragment, null, /* @__PURE__ */ React126.createElement("ul", {
    className: "!p-0 !m-0 !mt-3 !mb-3"
  }, customAttributes.map((attribute, index2) => {
    var _a2;
    return /* @__PURE__ */ React126.createElement("li", {
      key: index2,
      className: "text-[--text-normal] hover:text-[--text-accent] cursor-pointer",
      onClick: () => {
        setAttribute(attribute);
      }
    }, (_a2 = attribute.customName) != null ? _a2 : attribute.id);
  })), /* @__PURE__ */ React126.createElement("button", {
    className: "rpgm-secondary !ml-0 mb-3 mt-3",
    onClick: () => setNewAttribute(true)
  }, t2("buttons.newattribute")));
}

// src/components/custom/CustomAttributesComponent.tsx
function CustomAttributesComponent({ element: element4 }) {
  const { t: t2 } = useTranslation();
  const app = useApp();
  const [attribute, setAttribute] = React127.useState(void 0);
  const [newAttribute, setNewAttribute] = React127.useState(false);
  const handleSetAttribute = (newAttribute2) => {
    setAttribute(newAttribute2);
    setNewAttribute(false);
  };
  const handleSetNewAttribute = () => {
    setAttribute(void 0);
    setNewAttribute(true);
  };
  const reset = () => {
    setTimeout(() => {
      setAttribute(void 0);
      setNewAttribute(false);
      app.workspace.trigger("rpgmanager:refresh-option-view");
    }, 500);
  };
  let content3 = void 0;
  if (attribute) {
    content3 = /* @__PURE__ */ React127.createElement(CustomAttributeComponent, {
      key: attribute.id,
      attribute,
      onSaveAttribute: reset
    });
  }
  if (newAttribute) {
    content3 = /* @__PURE__ */ React127.createElement(CustomAttributeComponent, {
      onSaveAttribute: reset
    });
  }
  return /* @__PURE__ */ React127.createElement(React127.Fragment, null, /* @__PURE__ */ React127.createElement("h2", {
    className: "!text-2xl !font-extralight border-b border-b-[--background-modifier-border]"
  }, t2("attributes.custom")), /* @__PURE__ */ React127.createElement("div", {
    className: "grid grid-cols-5 border-b border-b-[--background-modifier-border]"
  }, /* @__PURE__ */ React127.createElement("div", {
    className: "col-span-1 border-r border-r-[--background-modifier-border]"
  }, /* @__PURE__ */ React127.createElement(CustomAttributeListComponent, {
    element: element4,
    setAttribute: handleSetAttribute,
    setNewAttribute: handleSetNewAttribute
  })), /* @__PURE__ */ React127.createElement("div", {
    className: "p-3 col-span-4"
  }, attribute || newAttribute ? /* @__PURE__ */ React127.createElement(React127.Fragment, null, content3) : /* @__PURE__ */ React127.createElement("div", null, /* @__PURE__ */ React127.createElement("h3", {
    className: "!p-0 !text-xl !font-extralight"
  }, t2("customattributes.your")), /* @__PURE__ */ React127.createElement("div", null, /* @__PURE__ */ React127.createElement(MarkdownComponent, {
    value: t2("customattributes.describe")
  }))))));
}

// src/controllers/CustomAttributesController.ts
var CustomAttributesController = class extends import_obsidian11.Modal {
  constructor(_app, _api, _element) {
    super(_app);
    this._app = _app;
    this._api = _api;
    this._element = _element;
    this.scope = new import_obsidian11.Scope();
    this.scope.register([], "Escape", (evt) => {
      evt.preventDefault();
    });
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    const root3 = (0, import_client5.createRoot)(contentEl);
    this.modalEl.style.width = "var(--modal-max-width)";
    const creationComponent = (0, import_react28.createElement)(CustomAttributesComponent, {
      element: this._element
    });
    const reactComponent = (0, import_react28.createElement)(AppContext.Provider, { value: this._app }, (0, import_react28.createElement)(ApiContext.Provider, { value: this._api }, creationComponent));
    root3.render(reactComponent);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    super.onClose();
  }
};

// src/controllers/GalleryController.ts
var import_obsidian12 = require("obsidian");
var import_react29 = __toESM(require_react());
var import_client6 = __toESM(require_client());

// src/components/gallery/GalleryComponent.tsx
var React131 = __toESM(require_react());

// src/components/gallery/BrowseImagesComponent.tsx
var React128 = __toESM(require_react());
function BrowseImagesComponent({
  element: element4,
  selectImage
}) {
  const api2 = useApi();
  const app = useApp();
  const [searchTerm, setSearchTerm] = React128.useState("");
  let allImages = app.vault.getAllLoadedFiles();
  if (api2.settings.assetsFolder !== void 0 && api2.settings.assetsFolder !== "") {
    allImages = allImages.filter((file) => {
      var _a;
      return file.path.startsWith((_a = api2.settings.assetsFolder) != null ? _a : "Assets");
    });
  }
  allImages = allImages.filter((file) => file.extension === "png" || file.extension === "jpg" || file.extension === "jpeg" || file.extension === "webp");
  if (searchTerm !== "") {
    allImages = allImages.filter((file) => file.path.toLowerCase().includes(searchTerm.toLowerCase()));
  }
  const handleAddExistingImage = (image2) => __async(this, null, function* () {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    codeblockService.addImage(image2.path, "").then(() => {
      selectImage();
    });
  });
  return /* @__PURE__ */ React128.createElement("div", {
    className: "mt-3"
  }, /* @__PURE__ */ React128.createElement("div", {
    className: "grid mb-3 grid-cols-1 md:grid-cols-4 items-center justify-center"
  }, /* @__PURE__ */ React128.createElement("div", {
    className: "col-span-1"
  }, /* @__PURE__ */ React128.createElement("a", {
    href: "#",
    className: "!no-underline cursor-pointer text-[--text-normal] hover:text-[--text-accent-hover]",
    onClick: selectImage
  }, "<back")), /* @__PURE__ */ React128.createElement("div", {
    className: "col-span-3 w-full"
  }, /* @__PURE__ */ React128.createElement("input", {
    type: "text",
    className: "w-full",
    placeholder: "Search",
    onChange: (e2) => setSearchTerm(e2.target.value)
  }))), /* @__PURE__ */ React128.createElement("div", {
    className: "grid grid-cols-4 justify-center gap-3"
  }, allImages.map((imageFile, index2) => {
    var _a;
    let path4;
    if (api2.settings.assetsFolder !== void 0 && api2.settings.assetsFolder !== "" && imageFile.path.startsWith(api2.settings.assetsFolder)) {
      path4 = imageFile.path.substring(((_a = api2.settings.assetsFolder) != null ? _a : "Assets").length + 1);
    } else {
      path4 = imageFile.path;
    }
    if (path4.length === 0)
      return null;
    const imageData = { path: path4 };
    const image2 = ImageService.createImage(app, api2, imageData);
    if (!image2)
      return null;
    return /* @__PURE__ */ React128.createElement("div", {
      key: index2,
      className: "flex justify-center relative",
      onClick: () => handleAddExistingImage(image2)
    }, /* @__PURE__ */ React128.createElement("div", {
      className: "w-full relative pb-[100%]"
    }, /* @__PURE__ */ React128.createElement("div", {
      className: "absolute top-0 left-0 w-full h-full overflow-hidden rounded-lg"
    }, /* @__PURE__ */ React128.createElement("img", {
      src: image2.src,
      alt: image2.caption,
      className: "w-full h-auto object-contain !cursor-pointer"
    }))));
  })));
}

// src/components/gallery/CurrentImagesComponent.tsx
var React129 = __toESM(require_react());
function CurrentImagesComponent({
  element: element4,
  setCurrentImage
}) {
  return /* @__PURE__ */ React129.createElement("div", {
    className: "flex flex-wrap justify-center"
  }, element4.images.map((image2, index2) => /* @__PURE__ */ React129.createElement("div", {
    key: index2,
    className: "m-1 w-48 h-48 overflow-hidden cursor-pointer",
    onClick: () => setCurrentImage(image2)
  }, /* @__PURE__ */ React129.createElement("img", {
    src: image2.src,
    alt: image2.caption,
    className: "w-full h-auto object-contain !cursor-pointer rounded-lg"
  }))));
}

// src/components/gallery/SingleImageComponent.tsx
var React130 = __toESM(require_react());
function SingleImageComponent({
  element: element4,
  image: image2,
  resetCurrentImage
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [caption, setCaption] = React130.useState(image2.caption);
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  const saveCaption = () => {
    codeblockService.updateImage(image2.path, caption).then(() => {
      resetCurrentImage();
    });
  };
  const deleteImage = () => {
    codeblockService.removeImage(image2.path).then(() => {
      resetCurrentImage();
    });
  };
  return /* @__PURE__ */ React130.createElement("div", {
    className: "mt-3"
  }, /* @__PURE__ */ React130.createElement("div", null, /* @__PURE__ */ React130.createElement("a", {
    href: "#",
    className: "!no-underline cursor-pointer text-[--text-normal] hover:text-[--text-accent-hover]",
    onClick: resetCurrentImage
  }, "< back")), /* @__PURE__ */ React130.createElement("div", {
    className: "flex items-start"
  }, /* @__PURE__ */ React130.createElement("div", {
    className: "flex items-start justify-start w-[350px] h-[350px]"
  }, /* @__PURE__ */ React130.createElement("img", {
    src: image2.src,
    alt: caption,
    className: "w-full h-auto object-contain rounded-lg"
  })), /* @__PURE__ */ React130.createElement("div", {
    className: "ml-3 w-full"
  }, /* @__PURE__ */ React130.createElement("div", null, /* @__PURE__ */ React130.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("gallery.caption")), /* @__PURE__ */ React130.createElement("div", {
    className: "w-full"
  }, /* @__PURE__ */ React130.createElement(MarkdownEditorComponent, {
    initialValue: caption,
    onChange: setCaption,
    campaignPath: element4.type === "campaign" /* Campaign */ ? element4.path : element4.campaignPath,
    className: "w-full"
  })), /* @__PURE__ */ React130.createElement("div", {
    className: "flex w-full justify-end"
  }, /* @__PURE__ */ React130.createElement("button", {
    className: "rpgm-danger",
    onClick: deleteImage
  }, t2("buttons.delete")), /* @__PURE__ */ React130.createElement("button", {
    className: "rpgm-primary",
    onClick: saveCaption
  }, t2("buttons.save")))))));
}

// src/components/gallery/GalleryComponent.tsx
function GalleryComponent({ element: element4 }) {
  const { t: t2 } = useTranslation();
  const app = useApp();
  const [currentImage, setCurrentImage] = React131.useState(void 0);
  const [browseImages, setBrowseImages] = React131.useState(false);
  const [key, setKey] = React131.useState(Date.now());
  const api2 = useApi();
  const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
  const fileUpload = new FileUploadService(app, api2);
  const refresh = () => {
    setKey(Date.now());
    setBrowseImages(false);
  };
  const resetCurrentImage = () => {
    setTimeout(() => {
      refresh();
    }, 500);
    setCurrentImage(void 0);
  };
  const handleDragOver = (event) => {
    event.preventDefault();
  };
  const handleFileDrop = (event) => {
    event.preventDefault();
    fileUpload.uploadFileList(element4, event.dataTransfer.files).then(() => {
      setTimeout(() => {
        refresh();
      }, 500);
    });
  };
  const handleFileSelect = (event) => {
    fileUpload.uploadFileList(element4, event.target.files).then(() => {
      setTimeout(() => {
        refresh();
      }, 500);
    });
  };
  const handleImageUrlChange = (event) => __async(this, null, function* () {
    var _a;
    try {
      const response = yield fetch(event.target.value, {
        method: "HEAD"
      });
      if ((_a = response.headers.get("Content-Type")) == null ? void 0 : _a.startsWith("image/")) {
        codeblockService.addImage(event.target.value, "").then(() => {
          setTimeout(() => {
            refresh();
          }, 500);
        });
      }
    } catch (error2) {
    }
  });
  let content3;
  if (currentImage !== void 0) {
    content3 = /* @__PURE__ */ React131.createElement(SingleImageComponent, {
      key,
      element: element4,
      image: currentImage,
      resetCurrentImage
    });
  } else if (browseImages === true) {
    content3 = /* @__PURE__ */ React131.createElement(BrowseImagesComponent, {
      key,
      element: element4,
      selectImage: resetCurrentImage
    });
  } else {
    content3 = /* @__PURE__ */ React131.createElement(CurrentImagesComponent, {
      key,
      element: element4,
      setCurrentImage
    });
  }
  return /* @__PURE__ */ React131.createElement("div", {
    key
  }, /* @__PURE__ */ React131.createElement("div", {
    className: "flex justify-center items-center"
  }, /* @__PURE__ */ React131.createElement("h2", {
    className: "!text-2xl !font-extralight"
  }, t2("gallery.title"))), /* @__PURE__ */ React131.createElement("div", {
    className: "border-2 p-4"
  }, /* @__PURE__ */ React131.createElement("div", {
    className: "grid grid-cols-4 space-x-4"
  }, /* @__PURE__ */ React131.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ React131.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("gallery.drag")), /* @__PURE__ */ React131.createElement("div", {
    className: "border-2 border-dashed p-4 cursor-pointer flex-1",
    onDrop: handleFileDrop,
    onDragOver: handleDragOver
  }, t2("gallery.dragdrop"))), /* @__PURE__ */ React131.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ React131.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("gallery.upload")), /* @__PURE__ */ React131.createElement("input", {
    type: "file",
    onChange: handleFileSelect,
    accept: "image/*"
  })), /* @__PURE__ */ React131.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ React131.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("gallery.link")), /* @__PURE__ */ React131.createElement("input", {
    type: "text",
    onChange: handleImageUrlChange,
    className: "border-2 p-2 w-full",
    placeholder: "Enter image url"
  })), /* @__PURE__ */ React131.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ React131.createElement("h3", {
    className: "!text-xl !font-extralight"
  }, t2("gallery.browse")), /* @__PURE__ */ React131.createElement("button", {
    className: "rpgm-secondary",
    onClick: () => setBrowseImages(true)
  }, t2("gallery.browselocal"))))), /* @__PURE__ */ React131.createElement("div", null, content3));
}

// src/controllers/GalleryController.ts
var GalleryController = class extends import_obsidian12.Modal {
  constructor(_app, _api, _element) {
    super(_app);
    this._app = _app;
    this._api = _api;
    this._element = _element;
    this.scope = new import_obsidian12.Scope();
    this.scope.register([], "Escape", (evt) => {
      evt.preventDefault();
    });
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    const root3 = (0, import_client6.createRoot)(contentEl);
    this.modalEl.style.width = "var(--modal-max-width)";
    const creationComponent = (0, import_react29.createElement)(GalleryComponent, {
      element: this._element,
      key: this._element.version
    });
    const reactComponent = (0, import_react29.createElement)(AppContext.Provider, { value: this._app }, (0, import_react29.createElement)(ApiContext.Provider, { value: this._api }, creationComponent));
    root3.render(reactComponent);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    super.onClose();
  }
};

// src/controllers/WizardController.ts
var import_obsidian13 = require("obsidian");
var import_react30 = __toESM(require_react());
var import_client7 = __toESM(require_client());
var WizardController = class extends import_obsidian13.Modal {
  constructor(_app, _api, _element) {
    super(_app);
    this._app = _app;
    this._api = _api;
    this._element = _element;
    this.scope = new import_obsidian13.Scope();
    this.scope.register([], "Escape", (evt) => {
      evt.preventDefault();
    });
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    contentEl.empty();
    const root3 = (0, import_client7.createRoot)(contentEl);
    this.modalEl.style.width = "var(--modal-max-width)";
    let wizardComponent;
    if (this._element.type === "nonplayercharacter" /* NonPlayerCharacter */) {
      wizardComponent = (0, import_react30.createElement)(NonPlayerCharacterWizardComponent, {
        element: this._element,
        close: this.close.bind(this)
      });
    } else if (this._element.type === "chapter" /* Chapter */) {
      wizardComponent = (0, import_react30.createElement)(ChapterWizardComponent, {
        element: this._element,
        close: this.close.bind(this)
      });
    }
    const wizardProvider = (0, import_react30.createElement)(WizardContext.Provider, { value: {} }, wizardComponent);
    const reactComponent = (0, import_react30.createElement)(AppContext.Provider, { value: this._app }, (0, import_react30.createElement)(ApiContext.Provider, { value: this._api }, wizardProvider));
    root3.render(reactComponent);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    super.onClose();
  }
};

// src/components/options/OptionsViewComponent.tsx
function OptionsViewComponent({ element: element4 }) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const [isDragging, setIsDragging] = React132.useState(false);
  React132.useEffect(() => {
    let dragCounter = 0;
    const handleWindowDragEnter = (event) => {
      event.preventDefault();
      dragCounter++;
      setIsDragging(true);
    };
    const handleWindowDragLeave = () => {
      dragCounter--;
      if (dragCounter === 0) {
        setIsDragging(false);
      }
    };
    const handleWindowDrop = (event) => {
      event.preventDefault();
      dragCounter = 0;
      setIsDragging(false);
    };
    window.addEventListener("dragenter", handleWindowDragEnter);
    window.addEventListener("dragleave", handleWindowDragLeave);
    window.addEventListener("drop", handleWindowDrop);
    return () => {
      window.removeEventListener("dragenter", handleWindowDragEnter);
      window.removeEventListener("dragleave", handleWindowDragLeave);
      window.removeEventListener("drop", handleWindowDrop);
    };
  }, []);
  const openWizard = () => {
    const wizard = new WizardController(app, api2, element4);
    wizard.open();
  };
  const addRelationship = () => {
    const relationshipModal = new NewRelationshipController(app, api2, element4);
    relationshipModal.open();
  };
  const openGallery = () => {
    const galleryModal = new GalleryController(app, api2, element4);
    galleryModal.open();
  };
  const createCustomAttribute = () => {
    const customAttributeController = new CustomAttributesController(app, api2, element4);
    customAttributeController.open();
  };
  let hasWizard = false;
  switch (element4.type) {
    case "nonplayercharacter" /* NonPlayerCharacter */:
    case "chapter" /* Chapter */:
      hasWizard = true;
      break;
  }
  const availableAttributes = element4.attributes.filter((attribute) => !attribute.isSet);
  const addAttribute = (attribute) => () => {
    const codeblockService = new RpgManagerCodeblockService(app, api2, element4.file);
    let value = "";
    switch (attribute.type) {
      case "StoryCircle" /* StoryCircle */:
        value = {
          you: "",
          need: "",
          go: "",
          search: "",
          find: "",
          take: "",
          return: "",
          change: ""
        };
        break;
      case "Kishotenketsu" /* Kishotenketsu */:
        value = {
          ki: "",
          sho: "",
          ten: "",
          ketsu: ""
        };
        break;
      case "MajorClues" /* MajorClues */:
        value = [];
        break;
      case "Conflict" /* Conflict */:
        value = {
          status: "planned"
        };
        break;
    }
    codeblockService.updateCodeblockData(attribute.id, value);
  };
  const handleDragOver = (event) => {
    event.preventDefault();
  };
  const handleFileDrop = (event) => {
    event.preventDefault();
    setIsDragging(false);
    const fileUpload = new FileUploadService(app, api2);
    fileUpload.uploadFileList(element4, event.dataTransfer.files);
  };
  return /* @__PURE__ */ React132.createElement(React132.Fragment, null, /* @__PURE__ */ React132.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 col-span-1 text-xs mb-3"
  }, /* @__PURE__ */ React132.createElement("h3", {
    className: "!text-xl !font-extralight !mb-1 mt-0"
  }, t2("options.option", { count: 2 })), hasWizard && /* @__PURE__ */ React132.createElement("div", {
    className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] list-disc list-inside pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
    onClick: openWizard
  }, t2("options.wizard")), element4.type !== "campaign" /* Campaign */ && /* @__PURE__ */ React132.createElement("div", {
    className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] list-disc list-inside pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
    onClick: addRelationship
  }, t2("create.add", { context: "relationship" })), /* @__PURE__ */ React132.createElement("div", {
    className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] list-disc list-inside pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
    onClick: createCustomAttribute
  }, t2("attributes.custom")), /* @__PURE__ */ React132.createElement("div", {
    className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] list-disc list-inside pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
    onClick: openGallery
  }, t2("gallery.title")), isDragging && /* @__PURE__ */ React132.createElement("div", {
    className: "border-2 border-dashed p-4 cursor-pointer flex-1",
    onDrop: handleFileDrop,
    onDragOver: handleDragOver
  }, t2("gallery.dragdrop"))), /* @__PURE__ */ React132.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 col-span-1 text-xs mb-1"
  }, /* @__PURE__ */ React132.createElement("h3", {
    className: "!text-xl !font-extralight !mb-1 mt-0"
  }, t2("attributes.attribute", { count: 2 })), availableAttributes.filter((attribute) => attribute.id !== "description" /* Description */ && attribute.id !== "duration" /* Duration */).map((attribute, index2) => {
    var _a;
    return /* @__PURE__ */ React132.createElement("div", {
      className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] list-disc list-inside pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
      key: index2,
      onClick: addAttribute(attribute)
    }, attribute.isCustom === true ? (_a = attribute.customName) != null ? _a : attribute.id.substring(1) : t2("attributes." + attribute.id));
  })));
}

// src/components/options/OptionContainerComponent.tsx
function OptionContainerComponent({
  element: element4,
  file
}) {
  const { t: t2 } = useTranslation();
  const api2 = useApi();
  const app = useApp();
  const showReadme = () => {
    app.workspace.detachLeavesOfType("rpg-manager-readme");
    app.workspace.getLeaf(true).setViewState({
      type: "rpg-manager-readme",
      active: true
    });
  };
  return /* @__PURE__ */ React133.createElement("div", {
    className: "flex flex-col min-h-screen pb-16"
  }, element4 && /* @__PURE__ */ React133.createElement("div", {
    className: "mb-3"
  }, /* @__PURE__ */ React133.createElement("h1", {
    className: "text-xl !font-bold mb-3"
  }, element4.name), /* @__PURE__ */ React133.createElement(OptionsViewComponent, {
    element: element4
  })), /* @__PURE__ */ React133.createElement(NewElementComponent, {
    element: element4,
    file
  }), /* @__PURE__ */ React133.createElement("div", {
    className: "rounded-lg border border-[--background-modifier-border] bg-[--background-primary] p-3 col-span-1 text-xs"
  }, /* @__PURE__ */ React133.createElement("div", {
    className: "cursor-pointer text-[--text-accent] hover:text-[--text-accent-hover] pl-2 pr-2 pt-1 pb-1 border border-transparent hover:bg-[--background-primary-alt] hover:border-[--background-modifier-border] rounded-lg",
    onClick: showReadme
  }, t2("documentation")), /* @__PURE__ */ React133.createElement("div", {
    className: "absolute bottom-8 left-0 right-0 pr-3 text-right text-[--text-faint] text-xs"
  }, "RPG Manager" + api2.version)));
}

// src/views/OptionsView.ts
var import_obsidian14 = require("obsidian");
var import_react31 = __toESM(require_react());
var import_client8 = __toESM(require_client());
var OptionView = class extends import_obsidian14.ItemView {
  constructor(_app, _api, leaf) {
    super(leaf);
    this._app = _app;
    this._api = _api;
    __publicField(this, "viewType", "rpg-manager-options");
    __publicField(this, "displayText", "RPG Manager");
    __publicField(this, "icon", "d20");
    __publicField(this, "_element");
    __publicField(this, "_root");
    this._root = (0, import_client8.createRoot)(this.contentEl);
    this.registerEvent(_app.workspace.on("rpgmanager:refresh-option-view", this.render.bind(this)));
    this.registerEvent(_app.workspace.on("rpgmanager:refresh-views", this.render.bind(this)));
  }
  getViewType() {
    return this.viewType;
  }
  onResize() {
    super.onResize();
    this.render();
  }
  getDisplayText() {
    return this.displayText;
  }
  onOpen() {
    return __async(this, null, function* () {
      this.render();
    });
  }
  render() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      this._element = void 0;
      const file = this.app.workspace.getActiveFile();
      if (file != void 0)
        this._element = this._api.get(file.path);
      const elementComponent = (0, import_react31.createElement)(OptionContainerComponent, {
        element: this._element,
        file: file != null ? file : void 0,
        key: (_c = (_a = this._element) == null ? void 0 : _a.path) != null ? _c : "" + ((_b = this._element) == null ? void 0 : _b.version.toString())
      });
      const reactComponent = (0, import_react31.createElement)(AppContext.Provider, { value: this._app }, (0, import_react31.createElement)(ApiContext.Provider, { value: this._api }, elementComponent));
      this._root.render(reactComponent);
    });
  }
};

// src/views/ReadmeView.ts
var import_obsidian15 = require("obsidian");
var import_react32 = __toESM(require_react());
var import_client9 = __toESM(require_client());
var ReadmeView = class extends import_obsidian15.ItemView {
  constructor(_app, _api, leaf) {
    super(leaf);
    this._app = _app;
    this._api = _api;
    __publicField(this, "viewType", "rpg-manager-readme");
    __publicField(this, "displayText", "RPG Manager Documentation");
    __publicField(this, "icon", "d20");
    __publicField(this, "_element");
    __publicField(this, "_root");
    this._root = (0, import_client9.createRoot)(this.contentEl);
  }
  getViewType() {
    return this.viewType;
  }
  onResize() {
    super.onResize();
    this.render();
  }
  getDisplayText() {
    return this.displayText;
  }
  onOpen() {
    return __async(this, null, function* () {
      this.render();
    });
  }
  render() {
    return __async(this, null, function* () {
      const readmeUrl = "https://raw.githubusercontent.com/carlonicora/obsidian-rpg-manager/master/README.md";
      const response = yield fetch(readmeUrl);
      const readmeContent = yield response.text();
      const elementComponent = (0, import_react32.createElement)(MarkdownComponent, {
        value: readmeContent
      });
      const reactComponent = (0, import_react32.createElement)(AppContext.Provider, { value: this._app }, (0, import_react32.createElement)(ApiContext.Provider, { value: this._api }, elementComponent));
      this._root.render(reactComponent);
    });
  }
};

// src/main.ts
var RpgManager = class extends import_obsidian16.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "_database");
    __publicField(this, "_taskService");
    __publicField(this, "settings");
  }
  get version() {
    return this.manifest.version;
  }
  get(path4, campaign, type2, parent) {
    if (this._database === void 0)
      return void 0;
    if (!path4 && !campaign && !parent) {
      let all7 = [];
      if (campaign === void 0) {
        all7 = this._database.filter((element4) => element4.campaign === void 0);
      } else if (campaign === null) {
        all7 = this._database;
      }
      if (!type2)
        return all7;
      return all7.filter((element4) => element4.campaign === void 0 && element4.type === type2);
    }
    const matchesPath = (element4) => path4 === void 0 || element4.path === path4;
    const matchesCampaign = (element4) => campaign === void 0 || element4.path === campaign.path || element4.campaignPath === campaign.path;
    if (path4 !== void 0)
      return this._database.find(matchesPath);
    if (path4 === void 0 && type2 === void 0 && parent === void 0) {
      return this._database.filter(matchesCampaign);
    }
    const matchesType = (element4) => type2 === void 0 || element4.type === type2;
    const matchesParent = (element4) => parent === void 0 || element4.parentPath === parent.path;
    const isMatchingElement = (element4) => matchesCampaign(element4) && matchesPath(element4) && matchesType(element4) && matchesParent(element4);
    return this._database.filter(isMatchingElement);
  }
  get tasks() {
    return this._taskService;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      (0, import_obsidian16.addIcon)("d20", '<g cx="50" cy="50" r="50" fill="currentColor" g transform="translate(0.000000,0.000000) scale(0.018)" stroke="none"><path d="M1940 4358 l-612 -753 616 -3 c339 -1 893 -1 1232 0 l616 3 -612 753 c-337 413 -616 752 -620 752 -4 0 -283 -339 -620 -752z"/><path d="M1180 4389 c-399 -231 -731 -424 -739 -428 -9 -6 3 -17 40 -38 30 -17 152 -87 271 -156 l217 -126 476 585 c261 321 471 584 467 583 -4 0 -333 -189 -732 -420z"/><path d="M3676 4225 c457 -562 477 -585 498 -572 11 8 133 78 269 157 l249 143 -29 17 c-62 39 -1453 840 -1458 840 -2 0 210 -263 471 -585z"/><path d="M281 2833 c0 -472 4 -849 8 -838 24 58 520 1362 523 1373 3 12 -168 116 -474 291 l-58 32 1 -858z"/><path d="M4571 3536 c-145 -84 -264 -156 -264 -160 -1 -4 118 -320 263 -701 l265 -694 3 430 c1 237 1 621 0 854 l-3 424 -264 -153z"/><path d="M1272 3290 c7 -20 1283 -2229 1288 -2229 5 0 1281 2209 1288 2229 2 7 -451 10 -1288 10 -837 0 -1290 -3 -1288 -10z"/><path d="M1025 3079 c-2 -8 -158 -416 -345 -906 -187 -491 -340 -897 -340 -903 0 -5 4 -10 8 -10 5 0 415 -65 913 -145 497 -80 928 -149 957 -154 l52 -8 -23 41 c-85 150 -1202 2083 -1208 2090 -5 6 -10 3 -14 -5z"/><path d="M3470 2028 c-337 -585 -614 -1066 -616 -1069 -2 -3 7 -4 19 -2 12 2 445 71 962 154 517 82 941 152 943 154 3 2 -1 19 -7 37 -33 93 -675 1774 -681 1781 -4 4 -283 -471 -620 -1055z"/><path d="M955 842 c17 -11 336 -196 710 -412 374 -216 695 -401 713 -412 l32 -20 0 314 0 314 -707 113 c-390 62 -724 115 -743 118 l-35 5 30 -20z"/><path d="M3428 741 l-718 -116 0 -313 0 -314 33 20 c17 11 347 201 732 422 385 222 704 407 710 412 16 14 -22 8 -757 -111z"/></g>');
      this.registerView("rpg-manager-options", (leaf) => new OptionView(this.app, this, leaf));
      this.registerView("rpg-manager-readme", (leaf) => new ReadmeView(this.app, this, leaf));
      this.registerView("rpg-manager-updater", (leaf) => new UpdaterView(this.app, this, leaf));
      this.addRibbonIcon("d20", "RPG Manager", () => {
        PluginServices.createView(this.app);
      });
      this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, rpgManagerDefaultSettings, yield this.loadData());
    });
  }
  onunload() {
    super.onunload();
    this.app.workspace.detachLeavesOfType("rpg-manager-readme");
  }
  onLayoutReady() {
    return __async(this, null, function* () {
      InternationalisationService.loadSettings();
      if (this.settings.previousVersion !== void 0) {
        this.app.workspace.getLeaf(true).setViewState({
          type: "rpg-manager-updater",
          active: true
        });
        return;
      }
      DatabaseFactory.create(this.app, this).then((database) => {
        this._database = database;
        ServiceFactory.initialise(this.app, this);
        this._taskService = new taskService(this._database);
        console.info("RpgManager " + this.manifest.version + " loaded");
        if (this.settings.forceFullWidth === true)
          document.body.classList.add("rpgm-toggle-full-width-styles");
        PluginServices.registerEvents(this.app, this, this._database);
        this.app.workspace.trigger("rpgmanager:refresh-views");
        (window["RpgManagerAPI"] = this) && this.register(() => delete window["RpgManagerAPI"]);
        this.app.workspace.detachLeavesOfType("rpg-manager-updater");
        this.app.workspace.detachLeavesOfType("rpg-manager-readme");
        CustomAttribtuesUpdater.update(this.app, this);
        if (this.settings.version !== this.manifest.version) {
          this.settings = __spreadProps(__spreadValues({}, this.settings), { version: this.manifest.version });
          this.saveData(this.settings);
          this.app.workspace.getLeaf(true).setViewState({
            type: "rpg-manager-readme",
            active: true
          });
        }
      });
      PluginServices.registerProcessors(this.app, this);
      PluginServices.registerCommands(this.app, this);
      this.addSettingTab(new RpgManagerSettings(this.app, this));
    });
  }
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* flatpickr v4.6.13, @license MIT */
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* nosourcemap */