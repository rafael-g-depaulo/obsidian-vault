trabalhos escrito:
- definir problema
- trabalhos relacionados/estado da arte

precisa de estatísticos:
- é uma boa fazer um negócio mais qualitativo (nota de 1 a 5)

precisa de um questionário? ele é pra avaliar se conseguimos chegar no resultado esperado



  
///////////////////////////////////////////////////////////////////////

// routes.ts

//----------- import Brand, type_brand_key, SegmentKinds, ConcreteSegment, CompilePath, Component, EnsureLiteral, EnsureFromUnion,

export type Routes<RouteTree extends unknown[]> = Brand<

typeof type_brand_key,

RouteTree

> &

Record<ConcretePaths<RouteTree>, Component> & { path: PathFunc<RouteTree> };

  

type NewRouteTree<

OldRouteTree extends unknown[],

PathName extends EnsureLiteral<PathName>,

Opts extends SegmentKindOpts

> = ExtractRouteTree<PathFuncReturnByOpts<Opts, OldRouteTree, PathName>>;

  

const makePathFunc =

<RouteTree extends unknown[] = []>(context: RouteTree) =>

<PathName extends EnsureLiteral<PathName>, Options extends SegmentKindOpts>(

path: PathName,

opts: Options = {} as Options

): PathFuncReturnByOpts<Options, RouteTree, PathName> => {

const routeTree = {

...context,

} as NewRouteTree<RouteTree, PathName, Options>;

  

const pathFunc = makePathFunc(context);

  

const concreteRoutes: Record<

ConcretePaths<NewRouteTree<RouteTree, PathName, Options>>,

Component

> = {};

  

const newRoutes = {

[type_brand_key]: routeTree,

path: pathFunc,

...concreteRoutes,

// explicit conversion below needed to ensure proper typing

} as unknown as PathFuncReturnByOpts<Options, RouteTree, PathName>;

  

// concrete route

if ("component" in opts) {

return { ...newRoutes, ["asd"]: opts.component };

}

  

return newRoutes;

};

  

const path = makePathFunc<[]>([]);

const component = () => <></>;

  

const routes = path("/asdasd", { component }).path("/123", {

children: path("/new", { component }).path("/old", { component }),

});

  

console.log(routes);

  

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

console.log("!!!!!!!!!!!!!!!!!!!!!!!!!")

//const C = () => <>aa</>

//const asdasd = path("/asdasd", { component: C, children: path("/asddasd", { component: C }) }).path("/irmao")

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

////////////////////////////////// isso aqui pra frente é pra outras coisas, ignora

export type IfConcretePath<

SegmentPath extends string[],

Kind extends EnsureFromUnion<Kind, SegmentKinds>

> =

// if child concrete

ConcreteSegment extends Kind ? CompilePath<SegmentPath> : never;

  

export type ConcretePathsDict<ConcretePaths extends string> = Record<

ConcretePaths,

Component

>;

  

type ConcretePaths<

RouteTree,

AccumulatePath extends string[] = []

> = unknown extends RouteTree

? never // maybe this line is unecessary

: RouteTree extends []

? never

: RouteTree extends [infer Route, ...infer RestTree]

? Route extends [

infer ChildName extends string,

infer ChildKind extends string,

infer GrandChildren

]

? ChildName extends EnsureLiteral<ChildName>

? ChildKind extends EnsureFromUnion<ChildKind, SegmentKinds>

? // this segment

| IfConcretePath<[...AccumulatePath, ChildName], ChildKind>

// recur on siblins

| ConcretePaths<RestTree, AccumulatePath>

// recur on children

| ConcretePaths<GrandChildren, [...AccumulatePath, ChildName]>

: never

: never

: never

: never;

  

type aaaaa = Routes<[]>;

  

// TODO: add state, push and replace functionality

  

export type RouteIndexParamsKeys<RoutePath extends EnsureLiteral<RoutePath>> =

// index parent

RoutePath extends `/:${infer IndexSegName}/${infer Rest}`

? IndexSegName | RouteIndexParamsKeys<`/${Rest}`>

: // non-index parent

RoutePath extends `/${infer _SegName}/${infer Rest}`

? RouteIndexParamsKeys<`/${Rest}`>

: // index leaf

RoutePath extends `/:${infer IndexSegName}`

? IndexSegName

: // non-index leaf

RoutePath extends `/${infer _SegName}`

? never

: never;

  

type RouteIndexParams<RoutePath extends EnsureLiteral<RoutePath>> = Record<

RouteIndexParamsKeys<RoutePath>,

string

>;

  

type DistributeAndCombine<T extends EnsureLiteral<T>> = T extends any

? { to: T } & (keyof RouteIndexParams<T> extends never

? {}

: { params: RouteIndexParams<T> })

: never;

  

type LinkProps<ConcretePaths extends EnsureLiteral<ConcretePaths>> =

DistributeAndCombine<ConcretePaths>;

  

export const makeLink =

<UserRoutes>(routes: UserRoutes) =>

({ to }: LinkProps<ConcretePaths<UserRoutes>>) => {

return <></>;

};

///////////////////////////////////////////////////////////////////////

  

// TODO: only test path once, not tree

export type IfIndexedPath<

SegmentPath extends string[],

AccPath extends string[] = []

> = [] extends SegmentPath

? never

: SegmentPath extends [

infer Segment extends string,

...infer Rest extends string[]

]

? Segment extends `/:${infer _Index}`

? CompilePath<[...AccPath, ...SegmentPath]>

: IfIndexedPath<Rest, [...AccPath, Segment]>

: never;

  

type aaaa = IfIndexedPath<["/asdasd", "/:ffffff", "/vdfhgtew"]>;

// ^?

  

type IndexedPaths<

RouteTree extends unknown[],

AccumulatePath extends string[] = []

> =

// unknown extends RouteTree ? never : // maybe this line is unecessary

RouteTree extends []

? never

: RouteTree extends [infer Route, ...infer RestTree]

? Route extends [

infer ChildName extends string,

infer ChildKind extends string,

infer GrandChildren extends unknown[]

]

? ChildName extends EnsureLiteral<ChildName>

? ChildKind extends EnsureFromUnion<ChildKind, SegmentKinds>

? // this segment

| IfIndexedPath<[...AccumulatePath, ChildName]>

// recur on siblins

| IndexedPaths<RestTree, AccumulatePath>

// recur on children

| IndexedPaths<GrandChildren, [...AccumulatePath, ChildName]>

: never

: never

: never

: never;

  

type RouteParams<T extends EnsureLiteral<T>> = T extends any

? RouteIndexParams<T>

: {};

//T extends any ? { [key in RouteIndexParamsKeys<T>]: string } : {}

type ASD = RouteParams<

"/asdasd/:teste" | "/asdasd/55555/:fff" | "/asdasd/55555/:fff/oi"

>;

// ^?

const x: ASD = {

fff: "",

};

  

export const makeUseRouteParams =

<UserRoutes>(routes: UserRoutes) =>

<

IndexedRoute extends IndexedPaths<

ExtractRouteTree<UserRoutes>

> = IndexedPaths<ExtractRouteTree<UserRoutes>>

>(

route?: IndexedRoute

): RouteIndexParams<IndexedRoute> => {

return "" as any;

};

  

/* const test: PathFunc = (() => {}) as any;

const a = test("/asdasd", {

component: () => <></>,

children: test("/55555", {

children: test("/:fff", {

component: () => <></>,

children: test("/oi", {

component: () => <></>,

}),

}),

}).path("/:teste", { component: () => <></> }),

});

// ^?

type teste = IndexedPaths<ExtractRouteTree<typeof a>>;

// ^?

  

const useRouteParams = makeUseRouteParams(a);

// ^?

const aa = useRouteParams("/asdasd/55555/:fff/oi");

// ^?

  

aa.fff;

*/