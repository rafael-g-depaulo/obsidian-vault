## Situação 2: Extrair as informações de tipo sem duplicação de código.

Como vimos na situação 1, foi achado uma forma simples de representar as informações de tipo necessária para atingir o objetivo principal da biblioteca. O próximo passo é explorar a parte da API onde recebemos essas informações do usuário. A informação de tipos necessária em compile time e de valores necessária em runtime, em typescript, são definidas separadamente. 

### Contextualização: tipos em typescript
Já temos uma ideia geral da API da biblioteca como uma função que recebe a informação da árvore de rotas em algum formado, e retorna um objeto que pode ser usado para criar as ferramentas necessárias para fazer o roteamento e navegação no app. Para que esse objeto tenha o tipo correto que desejamos que valide corretamente as rotas como definidas, essa função deve receber as duas informações


Encontramos aqui um grande desafio por conta da premissa da biblioteca que o usuário não deve precisar definir a mesma informação duas vezes.



### Porquê não aceitar duplicação de código na configuração das rotas?

Inicialmente, a ideia de simplificar a API da biblioteca e pedir que o usuário insira separadamente as informações de tipo e de implementação é atraente, dado que ela aparentemente reduz a complexidade de implementação.  Essa abordagem resultaria em algo como:

```ts
import { createRoutes, type RouteType } from "ragic"

// definição do tipo das rotas
type Routes = [
	"/",
	[
		["/home", []],
		["/blog", [
			["/:blog_id", []],
		]],
		["/about", [
			["/us", []]
		]],
	]
]

const routes: RouteType<Routes> = createRoutes({
    path: "/",
    children: [
        { path: "/home" },
        { path: "/blog", children: [
            { path: "/:blog_id" },
        ]},
        { path: "/about", children: [
            { path: "/us", children: [] }
        ]},
    ]
})
```
.

O primeiro e mais óbvio problema com essa abordagem é o quanto ela afeta negativamente a DX, e fica no caminho do desenvolvedor. O segundo é que apesar de parecer mais simples de implementar que uma solução que use inferência de tipo, o esforço e complexidade de garantir a concordância das informações de tipo e valor da árvore de rotas é comparável com o de construir uma implementação com inferência de tipo, o que reduz consideravelmente o apelo dessa abordagem. Um terceiro problema que foi descoberto empiricamente é que bugs na lógica de tipos são mais fáceis de passar despercebidos na abordagem com duplicação do que na de inferência.

### Contextualização: Inferência de tipos em TS

